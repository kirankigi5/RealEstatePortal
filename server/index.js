var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __glob = (map) => (path9) => {
  var fn = map[path9];
  if (fn) return fn();
  throw new Error("Module not found in bundle: " + path9);
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require4() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/rollup/dist/native.js
var require_native = __commonJS({
  "node_modules/rollup/dist/native.js"(exports2, module) {
    var { existsSync: existsSync2 } = __require("node:fs");
    var path9 = __require("node:path");
    var { platform: platform2, arch: arch2, report } = __require("node:process");
    var isMusl = () => !report.getReport().header.glibcVersionRuntime;
    var bindingsByPlatformAndArch = {
      android: {
        arm: { base: "android-arm-eabi" },
        arm64: { base: "android-arm64" }
      },
      darwin: {
        arm64: { base: "darwin-arm64" },
        x64: { base: "darwin-x64" }
      },
      freebsd: {
        arm64: { base: "freebsd-arm64" },
        x64: { base: "freebsd-x64" }
      },
      linux: {
        arm: { base: "linux-arm-gnueabihf", musl: "linux-arm-musleabihf" },
        arm64: { base: "linux-arm64-gnu", musl: "linux-arm64-musl" },
        ppc64: { base: "linux-powerpc64le-gnu", musl: null },
        riscv64: { base: "linux-riscv64-gnu", musl: null },
        s390x: { base: "linux-s390x-gnu", musl: null },
        x64: { base: "linux-x64-gnu", musl: "linux-x64-musl" }
      },
      win32: {
        arm64: { base: "win32-arm64-msvc" },
        ia32: { base: "win32-ia32-msvc" },
        x64: { base: "win32-x64-msvc" }
      }
    };
    var msvcLinkFilenameByArch = {
      arm64: "vc_redist.arm64.exe",
      ia32: "vc_redist.x86.exe",
      x64: "vc_redist.x64.exe"
    };
    var packageBase = getPackageBase();
    var localName = `./rollup.${packageBase}.node`;
    var requireWithFriendlyError = (id3) => {
      try {
        return __require(id3);
      } catch (error) {
        if (platform2 === "win32" && error instanceof Error && error.code === "ERR_DLOPEN_FAILED" && error.message.includes("The specified module could not be found")) {
          const msvcDownloadLink = `https://aka.ms/vs/17/release/${msvcLinkFilenameByArch[arch2]}`;
          throw new Error(
            `Failed to load module ${id3}. Required DLL was not found. This error usually happens when Microsoft Visual C++ Redistributable is not installed. You can download it from ${msvcDownloadLink}`,
            { cause: error }
          );
        }
        throw new Error(
          `Cannot find module ${id3}. npm has a bug related to optional dependencies (https://github.com/npm/cli/issues/4828). Please try \`npm i\` again after removing both package-lock.json and node_modules directory.`,
          { cause: error }
        );
      }
    };
    var { parse: parse6, parseAsync: parseAsync2, xxhashBase64Url, xxhashBase36, xxhashBase16 } = requireWithFriendlyError(
      existsSync2(path9.join(__dirname, localName)) ? localName : `@rollup/rollup-${packageBase}`
    );
    function getPackageBase() {
      const imported = bindingsByPlatformAndArch[platform2]?.[arch2];
      if (!imported) {
        throwUnsupportedError(false);
      }
      if ("musl" in imported && isMusl()) {
        return imported.musl || throwUnsupportedError(true);
      }
      return imported.base;
    }
    function throwUnsupportedError(isMusl2) {
      throw new Error(
        `Your current platform "${platform2}${isMusl2 ? " (musl)" : ""}" and architecture "${arch2}" combination is not yet supported by the native Rollup build. Please use the WASM build "@rollup/wasm-node" instead.

The following platform-architecture combinations are supported:
${Object.entries(bindingsByPlatformAndArch).flatMap(
          ([platformName, architectures]) => Object.entries(architectures).flatMap(([architectureName, { musl }]) => {
            const name2 = `${platformName}-${architectureName}`;
            return musl ? [name2, `${name2} (musl)`] : [name2];
          })
        ).join("\n")}

If this is important to you, please consider supporting Rollup to make a native build for your platform and architecture available.`
      );
    }
    module.exports.parse = parse6;
    module.exports.parseAsync = parseAsync2;
    module.exports.xxhashBase64Url = xxhashBase64Url;
    module.exports.xxhashBase36 = xxhashBase36;
    module.exports.xxhashBase16 = xxhashBase16;
  }
});

// node_modules/rollup/dist/es/shared/parseAst.js
var import_native, BLANK, EMPTY_OBJECT, EMPTY_ARRAY, EMPTY_SET, LOGLEVEL_SILENT, LOGLEVEL_WARN, LOGLEVEL_INFO, LOGLEVEL_DEBUG, logLevelPriority, symbolAugmented;
var init_parseAst = __esm({
  "node_modules/rollup/dist/es/shared/parseAst.js"() {
    import_native = __toESM(require_native(), 1);
    BLANK = Object.freeze(/* @__PURE__ */ Object.create(null));
    EMPTY_OBJECT = Object.freeze({});
    EMPTY_ARRAY = Object.freeze([]);
    EMPTY_SET = Object.freeze(new class extends Set {
      add() {
        throw new Error("Cannot add to empty set");
      }
    }());
    LOGLEVEL_SILENT = "silent";
    LOGLEVEL_WARN = "warn";
    LOGLEVEL_INFO = "info";
    LOGLEVEL_DEBUG = "debug";
    logLevelPriority = {
      [LOGLEVEL_DEBUG]: 0,
      [LOGLEVEL_INFO]: 1,
      [LOGLEVEL_SILENT]: 3,
      [LOGLEVEL_WARN]: 2
    };
    symbolAugmented = Symbol("augmented");
  }
});

// node_modules/rollup/dist/es/parseAst.js
var import_native2;
var init_parseAst2 = __esm({
  "node_modules/rollup/dist/es/parseAst.js"() {
    import_native2 = __toESM(require_native(), 1);
    init_parseAst();
  }
});

// node_modules/vite/node_modules/esbuild/lib/main.js
var require_main = __commonJS({
  "node_modules/vite/node_modules/esbuild/lib/main.js"(exports2, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name2 in all)
        __defProp2(target, name2, { get: all[name2], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var node_exports2 = {};
    __export2(node_exports2, {
      analyzeMetafile: () => analyzeMetafile,
      analyzeMetafileSync: () => analyzeMetafileSync,
      build: () => build3,
      buildSync: () => buildSync,
      context: () => context,
      default: () => node_default,
      formatMessages: () => formatMessages2,
      formatMessagesSync: () => formatMessagesSync,
      initialize: () => initialize,
      stop: () => stop,
      transform: () => transform3,
      transformSync: () => transformSync,
      version: () => version4
    });
    module.exports = __toCommonJS(node_exports2);
    function encodePacket(packet) {
      let visit2 = (value2) => {
        if (value2 === null) {
          bb.write8(0);
        } else if (typeof value2 === "boolean") {
          bb.write8(1);
          bb.write8(+value2);
        } else if (typeof value2 === "number") {
          bb.write8(2);
          bb.write32(value2 | 0);
        } else if (typeof value2 === "string") {
          bb.write8(3);
          bb.write(encodeUTF8(value2));
        } else if (value2 instanceof Uint8Array) {
          bb.write8(4);
          bb.write(value2);
        } else if (value2 instanceof Array) {
          bb.write8(5);
          bb.write32(value2.length);
          for (let item of value2) {
            visit2(item);
          }
        } else {
          let keys = Object.keys(value2);
          bb.write8(6);
          bb.write32(keys.length);
          for (let key of keys) {
            bb.write(encodeUTF8(key));
            visit2(value2[key]);
          }
        }
      };
      let bb = new ByteBuffer();
      bb.write32(0);
      bb.write32(packet.id << 1 | +!packet.isRequest);
      visit2(packet.value);
      writeUInt32LE(bb.buf, bb.len - 4, 0);
      return bb.buf.subarray(0, bb.len);
    }
    function decodePacket(bytes) {
      let visit2 = () => {
        switch (bb.read8()) {
          case 0:
            return null;
          case 1:
            return !!bb.read8();
          case 2:
            return bb.read32();
          case 3:
            return decodeUTF8(bb.read());
          case 4:
            return bb.read();
          case 5: {
            let count = bb.read32();
            let value22 = [];
            for (let i = 0; i < count; i++) {
              value22.push(visit2());
            }
            return value22;
          }
          case 6: {
            let count = bb.read32();
            let value22 = {};
            for (let i = 0; i < count; i++) {
              value22[decodeUTF8(bb.read())] = visit2();
            }
            return value22;
          }
          default:
            throw new Error("Invalid packet");
        }
      };
      let bb = new ByteBuffer(bytes);
      let id3 = bb.read32();
      let isRequest = (id3 & 1) === 0;
      id3 >>>= 1;
      let value2 = visit2();
      if (bb.ptr !== bytes.length) {
        throw new Error("Invalid packet");
      }
      return { id: id3, isRequest, value: value2 };
    }
    var ByteBuffer = class {
      constructor(buf = new Uint8Array(1024)) {
        this.buf = buf;
        this.len = 0;
        this.ptr = 0;
      }
      _write(delta) {
        if (this.len + delta > this.buf.length) {
          let clone = new Uint8Array((this.len + delta) * 2);
          clone.set(this.buf);
          this.buf = clone;
        }
        this.len += delta;
        return this.len - delta;
      }
      write8(value2) {
        let offset = this._write(1);
        this.buf[offset] = value2;
      }
      write32(value2) {
        let offset = this._write(4);
        writeUInt32LE(this.buf, value2, offset);
      }
      write(bytes) {
        let offset = this._write(4 + bytes.length);
        writeUInt32LE(this.buf, bytes.length, offset);
        this.buf.set(bytes, offset + 4);
      }
      _read(delta) {
        if (this.ptr + delta > this.buf.length) {
          throw new Error("Invalid packet");
        }
        this.ptr += delta;
        return this.ptr - delta;
      }
      read8() {
        return this.buf[this._read(1)];
      }
      read32() {
        return readUInt32LE(this.buf, this._read(4));
      }
      read() {
        let length = this.read32();
        let bytes = new Uint8Array(length);
        let ptr = this._read(bytes.length);
        bytes.set(this.buf.subarray(ptr, ptr + length));
        return bytes;
      }
    };
    var encodeUTF8;
    var decodeUTF8;
    var encodeInvariant;
    if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
      let encoder = new TextEncoder();
      let decoder2 = new TextDecoder();
      encodeUTF8 = (text2) => encoder.encode(text2);
      decodeUTF8 = (bytes) => decoder2.decode(bytes);
      encodeInvariant = 'new TextEncoder().encode("")';
    } else if (typeof Buffer !== "undefined") {
      encodeUTF8 = (text2) => Buffer.from(text2);
      decodeUTF8 = (bytes) => {
        let { buffer, byteOffset, byteLength } = bytes;
        return Buffer.from(buffer, byteOffset, byteLength).toString();
      };
      encodeInvariant = 'Buffer.from("")';
    } else {
      throw new Error("No UTF-8 codec found");
    }
    if (!(encodeUTF8("") instanceof Uint8Array))
      throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
    function readUInt32LE(buffer, offset) {
      return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
    }
    function writeUInt32LE(buffer, value2, offset) {
      buffer[offset++] = value2;
      buffer[offset++] = value2 >> 8;
      buffer[offset++] = value2 >> 16;
      buffer[offset++] = value2 >> 24;
    }
    var quote3 = JSON.stringify;
    var buildLogLevelDefault = "warning";
    var transformLogLevelDefault = "silent";
    function validateTarget(target) {
      validateStringValue(target, "target");
      if (target.indexOf(",") >= 0) throw new Error(`Invalid target: ${target}`);
      return target;
    }
    var canBeAnything = () => null;
    var mustBeBoolean = (value2) => typeof value2 === "boolean" ? null : "a boolean";
    var mustBeString = (value2) => typeof value2 === "string" ? null : "a string";
    var mustBeRegExp = (value2) => value2 instanceof RegExp ? null : "a RegExp object";
    var mustBeInteger = (value2) => typeof value2 === "number" && value2 === (value2 | 0) ? null : "an integer";
    var mustBeFunction = (value2) => typeof value2 === "function" ? null : "a function";
    var mustBeArray = (value2) => Array.isArray(value2) ? null : "an array";
    var mustBeObject = (value2) => typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "an object";
    var mustBeEntryPoints = (value2) => typeof value2 === "object" && value2 !== null ? null : "an array or an object";
    var mustBeWebAssemblyModule = (value2) => value2 instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
    var mustBeObjectOrNull = (value2) => typeof value2 === "object" && !Array.isArray(value2) ? null : "an object or null";
    var mustBeStringOrBoolean = (value2) => typeof value2 === "string" || typeof value2 === "boolean" ? null : "a string or a boolean";
    var mustBeStringOrObject = (value2) => typeof value2 === "string" || typeof value2 === "object" && value2 !== null && !Array.isArray(value2) ? null : "a string or an object";
    var mustBeStringOrArray = (value2) => typeof value2 === "string" || Array.isArray(value2) ? null : "a string or an array";
    var mustBeStringOrUint8Array = (value2) => typeof value2 === "string" || value2 instanceof Uint8Array ? null : "a string or a Uint8Array";
    var mustBeStringOrURL = (value2) => typeof value2 === "string" || value2 instanceof URL ? null : "a string or a URL";
    function getFlag(object2, keys, key, mustBeFn) {
      let value2 = object2[key];
      keys[key + ""] = true;
      if (value2 === void 0) return void 0;
      let mustBe = mustBeFn(value2);
      if (mustBe !== null) throw new Error(`${quote3(key)} must be ${mustBe}`);
      return value2;
    }
    function checkForInvalidFlags(object2, keys, where) {
      for (let key in object2) {
        if (!(key in keys)) {
          throw new Error(`Invalid option ${where}: ${quote3(key)}`);
        }
      }
    }
    function validateInitializeOptions(options2) {
      let keys = /* @__PURE__ */ Object.create(null);
      let wasmURL = getFlag(options2, keys, "wasmURL", mustBeStringOrURL);
      let wasmModule = getFlag(options2, keys, "wasmModule", mustBeWebAssemblyModule);
      let worker = getFlag(options2, keys, "worker", mustBeBoolean);
      checkForInvalidFlags(options2, keys, "in initialize() call");
      return {
        wasmURL,
        wasmModule,
        worker
      };
    }
    function validateMangleCache(mangleCache) {
      let validated;
      if (mangleCache !== void 0) {
        validated = /* @__PURE__ */ Object.create(null);
        for (let key in mangleCache) {
          let value2 = mangleCache[key];
          if (typeof value2 === "string" || value2 === false) {
            validated[key] = value2;
          } else {
            throw new Error(`Expected ${quote3(key)} in mangle cache to map to either a string or false`);
          }
        }
      }
      return validated;
    }
    function pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault) {
      let color = getFlag(options2, keys, "color", mustBeBoolean);
      let logLevel = getFlag(options2, keys, "logLevel", mustBeString);
      let logLimit = getFlag(options2, keys, "logLimit", mustBeInteger);
      if (color !== void 0) flags.push(`--color=${color}`);
      else if (isTTY2) flags.push(`--color=true`);
      flags.push(`--log-level=${logLevel || logLevelDefault}`);
      flags.push(`--log-limit=${logLimit || 0}`);
    }
    function validateStringValue(value2, what, key) {
      if (typeof value2 !== "string") {
        throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote3(key) : ""} to be a string, got ${typeof value2} instead`);
      }
      return value2;
    }
    function pushCommonFlags(flags, options2, keys) {
      let legalComments = getFlag(options2, keys, "legalComments", mustBeString);
      let sourceRoot = getFlag(options2, keys, "sourceRoot", mustBeString);
      let sourcesContent = getFlag(options2, keys, "sourcesContent", mustBeBoolean);
      let target = getFlag(options2, keys, "target", mustBeStringOrArray);
      let format2 = getFlag(options2, keys, "format", mustBeString);
      let globalName = getFlag(options2, keys, "globalName", mustBeString);
      let mangleProps = getFlag(options2, keys, "mangleProps", mustBeRegExp);
      let reserveProps = getFlag(options2, keys, "reserveProps", mustBeRegExp);
      let mangleQuoted = getFlag(options2, keys, "mangleQuoted", mustBeBoolean);
      let minify = getFlag(options2, keys, "minify", mustBeBoolean);
      let minifySyntax = getFlag(options2, keys, "minifySyntax", mustBeBoolean);
      let minifyWhitespace = getFlag(options2, keys, "minifyWhitespace", mustBeBoolean);
      let minifyIdentifiers = getFlag(options2, keys, "minifyIdentifiers", mustBeBoolean);
      let lineLimit = getFlag(options2, keys, "lineLimit", mustBeInteger);
      let drop = getFlag(options2, keys, "drop", mustBeArray);
      let dropLabels = getFlag(options2, keys, "dropLabels", mustBeArray);
      let charset = getFlag(options2, keys, "charset", mustBeString);
      let treeShaking = getFlag(options2, keys, "treeShaking", mustBeBoolean);
      let ignoreAnnotations = getFlag(options2, keys, "ignoreAnnotations", mustBeBoolean);
      let jsx = getFlag(options2, keys, "jsx", mustBeString);
      let jsxFactory = getFlag(options2, keys, "jsxFactory", mustBeString);
      let jsxFragment = getFlag(options2, keys, "jsxFragment", mustBeString);
      let jsxImportSource = getFlag(options2, keys, "jsxImportSource", mustBeString);
      let jsxDev = getFlag(options2, keys, "jsxDev", mustBeBoolean);
      let jsxSideEffects = getFlag(options2, keys, "jsxSideEffects", mustBeBoolean);
      let define2 = getFlag(options2, keys, "define", mustBeObject);
      let logOverride = getFlag(options2, keys, "logOverride", mustBeObject);
      let supported = getFlag(options2, keys, "supported", mustBeObject);
      let pure = getFlag(options2, keys, "pure", mustBeArray);
      let keepNames = getFlag(options2, keys, "keepNames", mustBeBoolean);
      let platform2 = getFlag(options2, keys, "platform", mustBeString);
      let tsconfigRaw = getFlag(options2, keys, "tsconfigRaw", mustBeStringOrObject);
      if (legalComments) flags.push(`--legal-comments=${legalComments}`);
      if (sourceRoot !== void 0) flags.push(`--source-root=${sourceRoot}`);
      if (sourcesContent !== void 0) flags.push(`--sources-content=${sourcesContent}`);
      if (target) {
        if (Array.isArray(target)) flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
        else flags.push(`--target=${validateTarget(target)}`);
      }
      if (format2) flags.push(`--format=${format2}`);
      if (globalName) flags.push(`--global-name=${globalName}`);
      if (platform2) flags.push(`--platform=${platform2}`);
      if (tsconfigRaw) flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
      if (minify) flags.push("--minify");
      if (minifySyntax) flags.push("--minify-syntax");
      if (minifyWhitespace) flags.push("--minify-whitespace");
      if (minifyIdentifiers) flags.push("--minify-identifiers");
      if (lineLimit) flags.push(`--line-limit=${lineLimit}`);
      if (charset) flags.push(`--charset=${charset}`);
      if (treeShaking !== void 0) flags.push(`--tree-shaking=${treeShaking}`);
      if (ignoreAnnotations) flags.push(`--ignore-annotations`);
      if (drop) for (let what of drop) flags.push(`--drop:${validateStringValue(what, "drop")}`);
      if (dropLabels) flags.push(`--drop-labels=${Array.from(dropLabels).map((what) => validateStringValue(what, "dropLabels")).join(",")}`);
      if (mangleProps) flags.push(`--mangle-props=${mangleProps.source}`);
      if (reserveProps) flags.push(`--reserve-props=${reserveProps.source}`);
      if (mangleQuoted !== void 0) flags.push(`--mangle-quoted=${mangleQuoted}`);
      if (jsx) flags.push(`--jsx=${jsx}`);
      if (jsxFactory) flags.push(`--jsx-factory=${jsxFactory}`);
      if (jsxFragment) flags.push(`--jsx-fragment=${jsxFragment}`);
      if (jsxImportSource) flags.push(`--jsx-import-source=${jsxImportSource}`);
      if (jsxDev) flags.push(`--jsx-dev`);
      if (jsxSideEffects) flags.push(`--jsx-side-effects`);
      if (define2) {
        for (let key in define2) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid define: ${key}`);
          flags.push(`--define:${key}=${validateStringValue(define2[key], "define", key)}`);
        }
      }
      if (logOverride) {
        for (let key in logOverride) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid log override: ${key}`);
          flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
        }
      }
      if (supported) {
        for (let key in supported) {
          if (key.indexOf("=") >= 0) throw new Error(`Invalid supported: ${key}`);
          const value2 = supported[key];
          if (typeof value2 !== "boolean") throw new Error(`Expected value for supported ${quote3(key)} to be a boolean, got ${typeof value2} instead`);
          flags.push(`--supported:${key}=${value2}`);
        }
      }
      if (pure) for (let fn of pure) flags.push(`--pure:${validateStringValue(fn, "pure")}`);
      if (keepNames) flags.push(`--keep-names`);
    }
    function flagsForBuildOptions(callName, options2, isTTY2, logLevelDefault, writeDefault) {
      var _a2;
      let flags = [];
      let entries = [];
      let keys = /* @__PURE__ */ Object.create(null);
      let stdinContents = null;
      let stdinResolveDir = null;
      pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options2, keys);
      let sourcemap = getFlag(options2, keys, "sourcemap", mustBeStringOrBoolean);
      let bundle2 = getFlag(options2, keys, "bundle", mustBeBoolean);
      let splitting = getFlag(options2, keys, "splitting", mustBeBoolean);
      let preserveSymlinks = getFlag(options2, keys, "preserveSymlinks", mustBeBoolean);
      let metafile = getFlag(options2, keys, "metafile", mustBeBoolean);
      let outfile = getFlag(options2, keys, "outfile", mustBeString);
      let outdir = getFlag(options2, keys, "outdir", mustBeString);
      let outbase = getFlag(options2, keys, "outbase", mustBeString);
      let tsconfig = getFlag(options2, keys, "tsconfig", mustBeString);
      let resolveExtensions = getFlag(options2, keys, "resolveExtensions", mustBeArray);
      let nodePathsInput = getFlag(options2, keys, "nodePaths", mustBeArray);
      let mainFields = getFlag(options2, keys, "mainFields", mustBeArray);
      let conditions = getFlag(options2, keys, "conditions", mustBeArray);
      let external = getFlag(options2, keys, "external", mustBeArray);
      let packages = getFlag(options2, keys, "packages", mustBeString);
      let alias = getFlag(options2, keys, "alias", mustBeObject);
      let loader = getFlag(options2, keys, "loader", mustBeObject);
      let outExtension = getFlag(options2, keys, "outExtension", mustBeObject);
      let publicPath = getFlag(options2, keys, "publicPath", mustBeString);
      let entryNames = getFlag(options2, keys, "entryNames", mustBeString);
      let chunkNames = getFlag(options2, keys, "chunkNames", mustBeString);
      let assetNames = getFlag(options2, keys, "assetNames", mustBeString);
      let inject = getFlag(options2, keys, "inject", mustBeArray);
      let banner = getFlag(options2, keys, "banner", mustBeObject);
      let footer = getFlag(options2, keys, "footer", mustBeObject);
      let entryPoints = getFlag(options2, keys, "entryPoints", mustBeEntryPoints);
      let absWorkingDir = getFlag(options2, keys, "absWorkingDir", mustBeString);
      let stdin = getFlag(options2, keys, "stdin", mustBeObject);
      let write = (_a2 = getFlag(options2, keys, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
      let allowOverwrite = getFlag(options2, keys, "allowOverwrite", mustBeBoolean);
      let mangleCache = getFlag(options2, keys, "mangleCache", mustBeObject);
      keys.plugins = true;
      checkForInvalidFlags(options2, keys, `in ${callName}() call`);
      if (sourcemap) flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
      if (bundle2) flags.push("--bundle");
      if (allowOverwrite) flags.push("--allow-overwrite");
      if (splitting) flags.push("--splitting");
      if (preserveSymlinks) flags.push("--preserve-symlinks");
      if (metafile) flags.push(`--metafile`);
      if (outfile) flags.push(`--outfile=${outfile}`);
      if (outdir) flags.push(`--outdir=${outdir}`);
      if (outbase) flags.push(`--outbase=${outbase}`);
      if (tsconfig) flags.push(`--tsconfig=${tsconfig}`);
      if (packages) flags.push(`--packages=${packages}`);
      if (resolveExtensions) {
        let values = [];
        for (let value2 of resolveExtensions) {
          validateStringValue(value2, "resolve extension");
          if (value2.indexOf(",") >= 0) throw new Error(`Invalid resolve extension: ${value2}`);
          values.push(value2);
        }
        flags.push(`--resolve-extensions=${values.join(",")}`);
      }
      if (publicPath) flags.push(`--public-path=${publicPath}`);
      if (entryNames) flags.push(`--entry-names=${entryNames}`);
      if (chunkNames) flags.push(`--chunk-names=${chunkNames}`);
      if (assetNames) flags.push(`--asset-names=${assetNames}`);
      if (mainFields) {
        let values = [];
        for (let value2 of mainFields) {
          validateStringValue(value2, "main field");
          if (value2.indexOf(",") >= 0) throw new Error(`Invalid main field: ${value2}`);
          values.push(value2);
        }
        flags.push(`--main-fields=${values.join(",")}`);
      }
      if (conditions) {
        let values = [];
        for (let value2 of conditions) {
          validateStringValue(value2, "condition");
          if (value2.indexOf(",") >= 0) throw new Error(`Invalid condition: ${value2}`);
          values.push(value2);
        }
        flags.push(`--conditions=${values.join(",")}`);
      }
      if (external) for (let name2 of external) flags.push(`--external:${validateStringValue(name2, "external")}`);
      if (alias) {
        for (let old in alias) {
          if (old.indexOf("=") >= 0) throw new Error(`Invalid package name in alias: ${old}`);
          flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
        }
      }
      if (banner) {
        for (let type in banner) {
          if (type.indexOf("=") >= 0) throw new Error(`Invalid banner file type: ${type}`);
          flags.push(`--banner:${type}=${validateStringValue(banner[type], "banner", type)}`);
        }
      }
      if (footer) {
        for (let type in footer) {
          if (type.indexOf("=") >= 0) throw new Error(`Invalid footer file type: ${type}`);
          flags.push(`--footer:${type}=${validateStringValue(footer[type], "footer", type)}`);
        }
      }
      if (inject) for (let path32 of inject) flags.push(`--inject:${validateStringValue(path32, "inject")}`);
      if (loader) {
        for (let ext2 in loader) {
          if (ext2.indexOf("=") >= 0) throw new Error(`Invalid loader extension: ${ext2}`);
          flags.push(`--loader:${ext2}=${validateStringValue(loader[ext2], "loader", ext2)}`);
        }
      }
      if (outExtension) {
        for (let ext2 in outExtension) {
          if (ext2.indexOf("=") >= 0) throw new Error(`Invalid out extension: ${ext2}`);
          flags.push(`--out-extension:${ext2}=${validateStringValue(outExtension[ext2], "out extension", ext2)}`);
        }
      }
      if (entryPoints) {
        if (Array.isArray(entryPoints)) {
          for (let i = 0, n = entryPoints.length; i < n; i++) {
            let entryPoint = entryPoints[i];
            if (typeof entryPoint === "object" && entryPoint !== null) {
              let entryPointKeys = /* @__PURE__ */ Object.create(null);
              let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
              let output = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
              checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
              if (input === void 0) throw new Error('Missing property "in" for entry point at index ' + i);
              if (output === void 0) throw new Error('Missing property "out" for entry point at index ' + i);
              entries.push([output, input]);
            } else {
              entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
            }
          }
        } else {
          for (let key in entryPoints) {
            entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
          }
        }
      }
      if (stdin) {
        let stdinKeys = /* @__PURE__ */ Object.create(null);
        let contents2 = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
        let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
        let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
        let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
        checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
        if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
        if (loader2) flags.push(`--loader=${loader2}`);
        if (resolveDir) stdinResolveDir = resolveDir;
        if (typeof contents2 === "string") stdinContents = encodeUTF8(contents2);
        else if (contents2 instanceof Uint8Array) stdinContents = contents2;
      }
      let nodePaths = [];
      if (nodePathsInput) {
        for (let value2 of nodePathsInput) {
          value2 += "";
          nodePaths.push(value2);
        }
      }
      return {
        entries,
        flags,
        write,
        stdinContents,
        stdinResolveDir,
        absWorkingDir,
        nodePaths,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function flagsForTransformOptions(callName, options2, isTTY2, logLevelDefault) {
      let flags = [];
      let keys = /* @__PURE__ */ Object.create(null);
      pushLogFlags(flags, options2, keys, isTTY2, logLevelDefault);
      pushCommonFlags(flags, options2, keys);
      let sourcemap = getFlag(options2, keys, "sourcemap", mustBeStringOrBoolean);
      let sourcefile = getFlag(options2, keys, "sourcefile", mustBeString);
      let loader = getFlag(options2, keys, "loader", mustBeString);
      let banner = getFlag(options2, keys, "banner", mustBeString);
      let footer = getFlag(options2, keys, "footer", mustBeString);
      let mangleCache = getFlag(options2, keys, "mangleCache", mustBeObject);
      checkForInvalidFlags(options2, keys, `in ${callName}() call`);
      if (sourcemap) flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
      if (sourcefile) flags.push(`--sourcefile=${sourcefile}`);
      if (loader) flags.push(`--loader=${loader}`);
      if (banner) flags.push(`--banner=${banner}`);
      if (footer) flags.push(`--footer=${footer}`);
      return {
        flags,
        mangleCache: validateMangleCache(mangleCache)
      };
    }
    function createChannel(streamIn) {
      const requestCallbacksByKey = {};
      const closeData = { didClose: false, reason: "" };
      let responseCallbacks = {};
      let nextRequestID = 0;
      let nextBuildKey = 0;
      let stdout = new Uint8Array(16 * 1024);
      let stdoutUsed = 0;
      let readFromStdout = (chunk) => {
        let limit = stdoutUsed + chunk.length;
        if (limit > stdout.length) {
          let swap = new Uint8Array(limit * 2);
          swap.set(stdout);
          stdout = swap;
        }
        stdout.set(chunk, stdoutUsed);
        stdoutUsed += chunk.length;
        let offset = 0;
        while (offset + 4 <= stdoutUsed) {
          let length = readUInt32LE(stdout, offset);
          if (offset + 4 + length > stdoutUsed) {
            break;
          }
          offset += 4;
          handleIncomingPacket(stdout.subarray(offset, offset + length));
          offset += length;
        }
        if (offset > 0) {
          stdout.copyWithin(0, offset, stdoutUsed);
          stdoutUsed -= offset;
        }
      };
      let afterClose = (error) => {
        closeData.didClose = true;
        if (error) closeData.reason = ": " + (error.message || error);
        const text2 = "The service was stopped" + closeData.reason;
        for (let id3 in responseCallbacks) {
          responseCallbacks[id3](text2, null);
        }
        responseCallbacks = {};
      };
      let sendRequest = (refs, value2, callback) => {
        if (closeData.didClose) return callback("The service is no longer running" + closeData.reason, null);
        let id3 = nextRequestID++;
        responseCallbacks[id3] = (error, response) => {
          try {
            callback(error, response);
          } finally {
            if (refs) refs.unref();
          }
        };
        if (refs) refs.ref();
        streamIn.writeToStdin(encodePacket({ id: id3, isRequest: true, value: value2 }));
      };
      let sendResponse = (id3, value2) => {
        if (closeData.didClose) throw new Error("The service is no longer running" + closeData.reason);
        streamIn.writeToStdin(encodePacket({ id: id3, isRequest: false, value: value2 }));
      };
      let handleRequest = async (id3, request) => {
        try {
          if (request.command === "ping") {
            sendResponse(id3, {});
            return;
          }
          if (typeof request.key === "number") {
            const requestCallbacks = requestCallbacksByKey[request.key];
            if (!requestCallbacks) {
              return;
            }
            const callback = requestCallbacks[request.command];
            if (callback) {
              await callback(id3, request);
              return;
            }
          }
          throw new Error(`Invalid command: ` + request.command);
        } catch (e) {
          const errors = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
          try {
            sendResponse(id3, { errors });
          } catch {
          }
        }
      };
      let isFirstPacket = true;
      let handleIncomingPacket = (bytes) => {
        if (isFirstPacket) {
          isFirstPacket = false;
          let binaryVersion = String.fromCharCode(...bytes);
          if (binaryVersion !== "0.21.5") {
            throw new Error(`Cannot start service: Host version "${"0.21.5"}" does not match binary version ${quote3(binaryVersion)}`);
          }
          return;
        }
        let packet = decodePacket(bytes);
        if (packet.isRequest) {
          handleRequest(packet.id, packet.value);
        } else {
          let callback = responseCallbacks[packet.id];
          delete responseCallbacks[packet.id];
          if (packet.value.error) callback(packet.value.error, {});
          else callback(null, packet.value);
        }
      };
      let buildOrContext = ({ callName, refs, options: options2, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
        let refCount = 0;
        const buildKey = nextBuildKey++;
        const requestCallbacks = {};
        const buildRefs = {
          ref() {
            if (++refCount === 1) {
              if (refs) refs.ref();
            }
          },
          unref() {
            if (--refCount === 0) {
              delete requestCallbacksByKey[buildKey];
              if (refs) refs.unref();
            }
          }
        };
        requestCallbacksByKey[buildKey] = requestCallbacks;
        buildRefs.ref();
        buildOrContextImpl(
          callName,
          buildKey,
          sendRequest,
          sendResponse,
          buildRefs,
          streamIn,
          requestCallbacks,
          options2,
          isTTY2,
          defaultWD2,
          (err, res) => {
            try {
              callback(err, res);
            } finally {
              buildRefs.unref();
            }
          }
        );
      };
      let transform22 = ({ callName, refs, input, options: options2, isTTY: isTTY2, fs: fs32, callback }) => {
        const details = createObjectStash();
        let start = (inputPath) => {
          try {
            if (typeof input !== "string" && !(input instanceof Uint8Array))
              throw new Error('The input to "transform" must be a string or a Uint8Array');
            let {
              flags,
              mangleCache
            } = flagsForTransformOptions(callName, options2, isTTY2, transformLogLevelDefault);
            let request = {
              command: "transform",
              flags,
              inputFS: inputPath !== null,
              input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
            };
            if (mangleCache) request.mangleCache = mangleCache;
            sendRequest(refs, request, (error, response) => {
              if (error) return callback(new Error(error), null);
              let errors = replaceDetailsInMessages(response.errors, details);
              let warnings = replaceDetailsInMessages(response.warnings, details);
              let outstanding = 1;
              let next = () => {
                if (--outstanding === 0) {
                  let result = {
                    warnings,
                    code: response.code,
                    map: response.map,
                    mangleCache: void 0,
                    legalComments: void 0
                  };
                  if ("legalComments" in response) result.legalComments = response == null ? void 0 : response.legalComments;
                  if (response.mangleCache) result.mangleCache = response == null ? void 0 : response.mangleCache;
                  callback(null, result);
                }
              };
              if (errors.length > 0) return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
              if (response.codeFS) {
                outstanding++;
                fs32.readFile(response.code, (err, contents2) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.code = contents2;
                    next();
                  }
                });
              }
              if (response.mapFS) {
                outstanding++;
                fs32.readFile(response.map, (err, contents2) => {
                  if (err !== null) {
                    callback(err, null);
                  } else {
                    response.map = contents2;
                    next();
                  }
                });
              }
              next();
            });
          } catch (e) {
            let flags = [];
            try {
              pushLogFlags(flags, options2, {}, isTTY2, transformLogLevelDefault);
            } catch {
            }
            const error = extractErrorMessageV8(e, streamIn, details, void 0, "");
            sendRequest(refs, { command: "error", flags, error }, () => {
              error.detail = details.load(error.detail);
              callback(failureErrorWithLog("Transform failed", [error], []), null);
            });
          }
        };
        if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
          let next = start;
          start = () => fs32.writeFile(input, next);
        }
        start(null);
      };
      let formatMessages22 = ({ callName, refs, messages: messages2, options: options2, callback }) => {
        if (!options2) throw new Error(`Missing second argument in ${callName}() call`);
        let keys = {};
        let kind = getFlag(options2, keys, "kind", mustBeString);
        let color = getFlag(options2, keys, "color", mustBeBoolean);
        let terminalWidth = getFlag(options2, keys, "terminalWidth", mustBeInteger);
        checkForInvalidFlags(options2, keys, `in ${callName}() call`);
        if (kind === void 0) throw new Error(`Missing "kind" in ${callName}() call`);
        if (kind !== "error" && kind !== "warning") throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
        let request = {
          command: "format-msgs",
          messages: sanitizeMessages(messages2, "messages", null, "", terminalWidth),
          isWarning: kind === "warning"
        };
        if (color !== void 0) request.color = color;
        if (terminalWidth !== void 0) request.terminalWidth = terminalWidth;
        sendRequest(refs, request, (error, response) => {
          if (error) return callback(new Error(error), null);
          callback(null, response.messages);
        });
      };
      let analyzeMetafile2 = ({ callName, refs, metafile, options: options2, callback }) => {
        if (options2 === void 0) options2 = {};
        let keys = {};
        let color = getFlag(options2, keys, "color", mustBeBoolean);
        let verbose = getFlag(options2, keys, "verbose", mustBeBoolean);
        checkForInvalidFlags(options2, keys, `in ${callName}() call`);
        let request = {
          command: "analyze-metafile",
          metafile
        };
        if (color !== void 0) request.color = color;
        if (verbose !== void 0) request.verbose = verbose;
        sendRequest(refs, request, (error, response) => {
          if (error) return callback(new Error(error), null);
          callback(null, response.result);
        });
      };
      return {
        readFromStdout,
        afterClose,
        service: {
          buildOrContext,
          transform: transform22,
          formatMessages: formatMessages22,
          analyzeMetafile: analyzeMetafile2
        }
      };
    }
    function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options2, isTTY2, defaultWD2, callback) {
      const details = createObjectStash();
      const isContext = callName === "context";
      const handleError = (e, pluginName) => {
        const flags = [];
        try {
          pushLogFlags(flags, options2, {}, isTTY2, buildLogLevelDefault);
        } catch {
        }
        const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
        sendRequest(refs, { command: "error", flags, error: message }, () => {
          message.detail = details.load(message.detail);
          callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
        });
      };
      let plugins2;
      if (typeof options2 === "object") {
        const value2 = options2.plugins;
        if (value2 !== void 0) {
          if (!Array.isArray(value2)) return handleError(new Error(`"plugins" must be an array`), "");
          plugins2 = value2;
        }
      }
      if (plugins2 && plugins2.length > 0) {
        if (streamIn.isSync) return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
        handlePlugins(
          buildKey,
          sendRequest,
          sendResponse,
          refs,
          streamIn,
          requestCallbacks,
          options2,
          plugins2,
          details
        ).then(
          (result) => {
            if (!result.ok) return handleError(result.error, result.pluginName);
            try {
              buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
            } catch (e) {
              handleError(e, "");
            }
          },
          (e) => handleError(e, "")
        );
        return;
      }
      try {
        buildOrContextContinue(null, (result, done) => done([], []), () => {
        });
      } catch (e) {
        handleError(e, "");
      }
      function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
        const writeDefault = streamIn.hasFS;
        const {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache
        } = flagsForBuildOptions(callName, options2, isTTY2, buildLogLevelDefault, writeDefault);
        if (write && !streamIn.hasFS) throw new Error(`The "write" option is unavailable in this environment`);
        const request = {
          command: "build",
          key: buildKey,
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir: absWorkingDir || defaultWD2,
          nodePaths,
          context: isContext
        };
        if (requestPlugins) request.plugins = requestPlugins;
        if (mangleCache) request.mangleCache = mangleCache;
        const buildResponseToResult = (response, callback2) => {
          const result = {
            errors: replaceDetailsInMessages(response.errors, details),
            warnings: replaceDetailsInMessages(response.warnings, details),
            outputFiles: void 0,
            metafile: void 0,
            mangleCache: void 0
          };
          const originalErrors = result.errors.slice();
          const originalWarnings = result.warnings.slice();
          if (response.outputFiles) result.outputFiles = response.outputFiles.map(convertOutputFiles);
          if (response.metafile) result.metafile = JSON.parse(response.metafile);
          if (response.mangleCache) result.mangleCache = response.mangleCache;
          if (response.writeToStdout !== void 0) console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
          runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
            if (originalErrors.length > 0 || onEndErrors.length > 0) {
              const error = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
              return callback2(error, null, onEndErrors, onEndWarnings);
            }
            callback2(null, result, onEndErrors, onEndWarnings);
          });
        };
        let latestResultPromise;
        let provideLatestResult;
        if (isContext)
          requestCallbacks["on-end"] = (id3, request2) => new Promise((resolve8) => {
            buildResponseToResult(request2, (err, result, onEndErrors, onEndWarnings) => {
              const response = {
                errors: onEndErrors,
                warnings: onEndWarnings
              };
              if (provideLatestResult) provideLatestResult(err, result);
              latestResultPromise = void 0;
              provideLatestResult = void 0;
              sendResponse(id3, response);
              resolve8();
            });
          });
        sendRequest(refs, request, (error, response) => {
          if (error) return callback(new Error(error), null);
          if (!isContext) {
            return buildResponseToResult(response, (err, res) => {
              scheduleOnDisposeCallbacks();
              return callback(err, res);
            });
          }
          if (response.errors.length > 0) {
            return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
          }
          let didDispose = false;
          const result = {
            rebuild: () => {
              if (!latestResultPromise) latestResultPromise = new Promise((resolve8, reject) => {
                let settlePromise;
                provideLatestResult = (err, result2) => {
                  if (!settlePromise) settlePromise = () => err ? reject(err) : resolve8(result2);
                };
                const triggerAnotherBuild = () => {
                  const request2 = {
                    command: "rebuild",
                    key: buildKey
                  };
                  sendRequest(refs, request2, (error2, response2) => {
                    if (error2) {
                      reject(new Error(error2));
                    } else if (settlePromise) {
                      settlePromise();
                    } else {
                      triggerAnotherBuild();
                    }
                  });
                };
                triggerAnotherBuild();
              });
              return latestResultPromise;
            },
            watch: (options22 = {}) => new Promise((resolve8, reject) => {
              if (!streamIn.hasFS) throw new Error(`Cannot use the "watch" API in this environment`);
              const keys = {};
              checkForInvalidFlags(options22, keys, `in watch() call`);
              const request2 = {
                command: "watch",
                key: buildKey
              };
              sendRequest(refs, request2, (error2) => {
                if (error2) reject(new Error(error2));
                else resolve8(void 0);
              });
            }),
            serve: (options22 = {}) => new Promise((resolve8, reject) => {
              if (!streamIn.hasFS) throw new Error(`Cannot use the "serve" API in this environment`);
              const keys = {};
              const port = getFlag(options22, keys, "port", mustBeInteger);
              const host = getFlag(options22, keys, "host", mustBeString);
              const servedir = getFlag(options22, keys, "servedir", mustBeString);
              const keyfile = getFlag(options22, keys, "keyfile", mustBeString);
              const certfile = getFlag(options22, keys, "certfile", mustBeString);
              const fallback = getFlag(options22, keys, "fallback", mustBeString);
              const onRequest = getFlag(options22, keys, "onRequest", mustBeFunction);
              checkForInvalidFlags(options22, keys, `in serve() call`);
              const request2 = {
                command: "serve",
                key: buildKey,
                onRequest: !!onRequest
              };
              if (port !== void 0) request2.port = port;
              if (host !== void 0) request2.host = host;
              if (servedir !== void 0) request2.servedir = servedir;
              if (keyfile !== void 0) request2.keyfile = keyfile;
              if (certfile !== void 0) request2.certfile = certfile;
              if (fallback !== void 0) request2.fallback = fallback;
              sendRequest(refs, request2, (error2, response2) => {
                if (error2) return reject(new Error(error2));
                if (onRequest) {
                  requestCallbacks["serve-request"] = (id3, request3) => {
                    onRequest(request3.args);
                    sendResponse(id3, {});
                  };
                }
                resolve8(response2);
              });
            }),
            cancel: () => new Promise((resolve8) => {
              if (didDispose) return resolve8();
              const request2 = {
                command: "cancel",
                key: buildKey
              };
              sendRequest(refs, request2, () => {
                resolve8();
              });
            }),
            dispose: () => new Promise((resolve8) => {
              if (didDispose) return resolve8();
              didDispose = true;
              const request2 = {
                command: "dispose",
                key: buildKey
              };
              sendRequest(refs, request2, () => {
                resolve8();
                scheduleOnDisposeCallbacks();
                refs.unref();
              });
            })
          };
          refs.ref();
          callback(null, result);
        });
      }
    }
    var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins2, details) => {
      let onStartCallbacks = [];
      let onEndCallbacks = [];
      let onResolveCallbacks = {};
      let onLoadCallbacks = {};
      let onDisposeCallbacks = [];
      let nextCallbackID = 0;
      let i = 0;
      let requestPlugins = [];
      let isSetupDone = false;
      plugins2 = [...plugins2];
      for (let item of plugins2) {
        let keys = {};
        if (typeof item !== "object") throw new Error(`Plugin at index ${i} must be an object`);
        const name2 = getFlag(item, keys, "name", mustBeString);
        if (typeof name2 !== "string" || name2 === "") throw new Error(`Plugin at index ${i} is missing a name`);
        try {
          let setup = getFlag(item, keys, "setup", mustBeFunction);
          if (typeof setup !== "function") throw new Error(`Plugin is missing a setup function`);
          checkForInvalidFlags(item, keys, `on plugin ${quote3(name2)}`);
          let plugin3 = {
            name: name2,
            onStart: false,
            onEnd: false,
            onResolve: [],
            onLoad: []
          };
          i++;
          let resolve8 = (path32, options2 = {}) => {
            if (!isSetupDone) throw new Error('Cannot call "resolve" before plugin setup has completed');
            if (typeof path32 !== "string") throw new Error(`The path to resolve must be a string`);
            let keys2 = /* @__PURE__ */ Object.create(null);
            let pluginName = getFlag(options2, keys2, "pluginName", mustBeString);
            let importer = getFlag(options2, keys2, "importer", mustBeString);
            let namespace2 = getFlag(options2, keys2, "namespace", mustBeString);
            let resolveDir = getFlag(options2, keys2, "resolveDir", mustBeString);
            let kind = getFlag(options2, keys2, "kind", mustBeString);
            let pluginData = getFlag(options2, keys2, "pluginData", canBeAnything);
            let importAttributes = getFlag(options2, keys2, "with", mustBeObject);
            checkForInvalidFlags(options2, keys2, "in resolve() call");
            return new Promise((resolve22, reject) => {
              const request = {
                command: "resolve",
                path: path32,
                key: buildKey,
                pluginName: name2
              };
              if (pluginName != null) request.pluginName = pluginName;
              if (importer != null) request.importer = importer;
              if (namespace2 != null) request.namespace = namespace2;
              if (resolveDir != null) request.resolveDir = resolveDir;
              if (kind != null) request.kind = kind;
              else throw new Error(`Must specify "kind" when calling "resolve"`);
              if (pluginData != null) request.pluginData = details.store(pluginData);
              if (importAttributes != null) request.with = sanitizeStringMap(importAttributes, "with");
              sendRequest(refs, request, (error, response) => {
                if (error !== null) reject(new Error(error));
                else resolve22({
                  errors: replaceDetailsInMessages(response.errors, details),
                  warnings: replaceDetailsInMessages(response.warnings, details),
                  path: response.path,
                  external: response.external,
                  sideEffects: response.sideEffects,
                  namespace: response.namespace,
                  suffix: response.suffix,
                  pluginData: details.load(response.pluginData)
                });
              });
            });
          };
          let promise2 = setup({
            initialOptions,
            resolve: resolve8,
            onStart(callback) {
              let registeredText = `This error came from the "onStart" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
              onStartCallbacks.push({ name: name2, callback, note: registeredNote });
              plugin3.onStart = true;
            },
            onEnd(callback) {
              let registeredText = `This error came from the "onEnd" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
              onEndCallbacks.push({ name: name2, callback, note: registeredNote });
              plugin3.onEnd = true;
            },
            onResolve(options2, callback) {
              let registeredText = `This error came from the "onResolve" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
              let keys2 = {};
              let filter2 = getFlag(options2, keys2, "filter", mustBeRegExp);
              let namespace2 = getFlag(options2, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options2, keys2, `in onResolve() call for plugin ${quote3(name2)}`);
              if (filter2 == null) throw new Error(`onResolve() call is missing a filter`);
              let id3 = nextCallbackID++;
              onResolveCallbacks[id3] = { name: name2, callback, note: registeredNote };
              plugin3.onResolve.push({ id: id3, filter: filter2.source, namespace: namespace2 || "" });
            },
            onLoad(options2, callback) {
              let registeredText = `This error came from the "onLoad" callback registered here:`;
              let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
              let keys2 = {};
              let filter2 = getFlag(options2, keys2, "filter", mustBeRegExp);
              let namespace2 = getFlag(options2, keys2, "namespace", mustBeString);
              checkForInvalidFlags(options2, keys2, `in onLoad() call for plugin ${quote3(name2)}`);
              if (filter2 == null) throw new Error(`onLoad() call is missing a filter`);
              let id3 = nextCallbackID++;
              onLoadCallbacks[id3] = { name: name2, callback, note: registeredNote };
              plugin3.onLoad.push({ id: id3, filter: filter2.source, namespace: namespace2 || "" });
            },
            onDispose(callback) {
              onDisposeCallbacks.push(callback);
            },
            esbuild: streamIn.esbuild
          });
          if (promise2) await promise2;
          requestPlugins.push(plugin3);
        } catch (e) {
          return { ok: false, error: e, pluginName: name2 };
        }
      }
      requestCallbacks["on-start"] = async (id3, request) => {
        let response = { errors: [], warnings: [] };
        await Promise.all(onStartCallbacks.map(async ({ name: name2, callback, note }) => {
          try {
            let result = await callback();
            if (result != null) {
              if (typeof result !== "object") throw new Error(`Expected onStart() callback in plugin ${quote3(name2)} to return an object`);
              let keys = {};
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              checkForInvalidFlags(result, keys, `from onStart() callback in plugin ${quote3(name2)}`);
              if (errors != null) response.errors.push(...sanitizeMessages(errors, "errors", details, name2, void 0));
              if (warnings != null) response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name2, void 0));
            }
          } catch (e) {
            response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name2));
          }
        }));
        sendResponse(id3, response);
      };
      requestCallbacks["on-resolve"] = async (id3, request) => {
        let response = {}, name2 = "", callback, note;
        for (let id22 of request.ids) {
          try {
            ({ name: name2, callback, note } = onResolveCallbacks[id22]);
            let result = await callback({
              path: request.path,
              importer: request.importer,
              namespace: request.namespace,
              resolveDir: request.resolveDir,
              kind: request.kind,
              pluginData: details.load(request.pluginData),
              with: request.with
            });
            if (result != null) {
              if (typeof result !== "object") throw new Error(`Expected onResolve() callback in plugin ${quote3(name2)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result, keys, "pluginName", mustBeString);
              let path32 = getFlag(result, keys, "path", mustBeString);
              let namespace2 = getFlag(result, keys, "namespace", mustBeString);
              let suffix = getFlag(result, keys, "suffix", mustBeString);
              let external = getFlag(result, keys, "external", mustBeBoolean);
              let sideEffects = getFlag(result, keys, "sideEffects", mustBeBoolean);
              let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys, `from onResolve() callback in plugin ${quote3(name2)}`);
              response.id = id22;
              if (pluginName != null) response.pluginName = pluginName;
              if (path32 != null) response.path = path32;
              if (namespace2 != null) response.namespace = namespace2;
              if (suffix != null) response.suffix = suffix;
              if (external != null) response.external = external;
              if (sideEffects != null) response.sideEffects = sideEffects;
              if (pluginData != null) response.pluginData = details.store(pluginData);
              if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name2, void 0);
              if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name2, void 0);
              if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id22, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name2)] };
            break;
          }
        }
        sendResponse(id3, response);
      };
      requestCallbacks["on-load"] = async (id3, request) => {
        let response = {}, name2 = "", callback, note;
        for (let id22 of request.ids) {
          try {
            ({ name: name2, callback, note } = onLoadCallbacks[id22]);
            let result = await callback({
              path: request.path,
              namespace: request.namespace,
              suffix: request.suffix,
              pluginData: details.load(request.pluginData),
              with: request.with
            });
            if (result != null) {
              if (typeof result !== "object") throw new Error(`Expected onLoad() callback in plugin ${quote3(name2)} to return an object`);
              let keys = {};
              let pluginName = getFlag(result, keys, "pluginName", mustBeString);
              let contents2 = getFlag(result, keys, "contents", mustBeStringOrUint8Array);
              let resolveDir = getFlag(result, keys, "resolveDir", mustBeString);
              let pluginData = getFlag(result, keys, "pluginData", canBeAnything);
              let loader = getFlag(result, keys, "loader", mustBeString);
              let errors = getFlag(result, keys, "errors", mustBeArray);
              let warnings = getFlag(result, keys, "warnings", mustBeArray);
              let watchFiles = getFlag(result, keys, "watchFiles", mustBeArray);
              let watchDirs = getFlag(result, keys, "watchDirs", mustBeArray);
              checkForInvalidFlags(result, keys, `from onLoad() callback in plugin ${quote3(name2)}`);
              response.id = id22;
              if (pluginName != null) response.pluginName = pluginName;
              if (contents2 instanceof Uint8Array) response.contents = contents2;
              else if (contents2 != null) response.contents = encodeUTF8(contents2);
              if (resolveDir != null) response.resolveDir = resolveDir;
              if (pluginData != null) response.pluginData = details.store(pluginData);
              if (loader != null) response.loader = loader;
              if (errors != null) response.errors = sanitizeMessages(errors, "errors", details, name2, void 0);
              if (warnings != null) response.warnings = sanitizeMessages(warnings, "warnings", details, name2, void 0);
              if (watchFiles != null) response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
              if (watchDirs != null) response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
              break;
            }
          } catch (e) {
            response = { id: id22, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name2)] };
            break;
          }
        }
        sendResponse(id3, response);
      };
      let runOnEndCallbacks = (result, done) => done([], []);
      if (onEndCallbacks.length > 0) {
        runOnEndCallbacks = (result, done) => {
          (async () => {
            const onEndErrors = [];
            const onEndWarnings = [];
            for (const { name: name2, callback, note } of onEndCallbacks) {
              let newErrors;
              let newWarnings;
              try {
                const value2 = await callback(result);
                if (value2 != null) {
                  if (typeof value2 !== "object") throw new Error(`Expected onEnd() callback in plugin ${quote3(name2)} to return an object`);
                  let keys = {};
                  let errors = getFlag(value2, keys, "errors", mustBeArray);
                  let warnings = getFlag(value2, keys, "warnings", mustBeArray);
                  checkForInvalidFlags(value2, keys, `from onEnd() callback in plugin ${quote3(name2)}`);
                  if (errors != null) newErrors = sanitizeMessages(errors, "errors", details, name2, void 0);
                  if (warnings != null) newWarnings = sanitizeMessages(warnings, "warnings", details, name2, void 0);
                }
              } catch (e) {
                newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name2)];
              }
              if (newErrors) {
                onEndErrors.push(...newErrors);
                try {
                  result.errors.push(...newErrors);
                } catch {
                }
              }
              if (newWarnings) {
                onEndWarnings.push(...newWarnings);
                try {
                  result.warnings.push(...newWarnings);
                } catch {
                }
              }
            }
            done(onEndErrors, onEndWarnings);
          })();
        };
      }
      let scheduleOnDisposeCallbacks = () => {
        for (const cb of onDisposeCallbacks) {
          setTimeout(() => cb(), 0);
        }
      };
      isSetupDone = true;
      return {
        ok: true,
        requestPlugins,
        runOnEndCallbacks,
        scheduleOnDisposeCallbacks
      };
    };
    function createObjectStash() {
      const map = /* @__PURE__ */ new Map();
      let nextID = 0;
      return {
        load(id3) {
          return map.get(id3);
        },
        store(value2) {
          if (value2 === void 0) return -1;
          const id3 = nextID++;
          map.set(id3, value2);
          return id3;
        }
      };
    }
    function extractCallerV8(e, streamIn, ident) {
      let note;
      let tried = false;
      return () => {
        if (tried) return note;
        tried = true;
        try {
          let lines = (e.stack + "").split("\n");
          lines.splice(1, 1);
          let location2 = parseStackLinesV8(streamIn, lines, ident);
          if (location2) {
            note = { text: e.message, location: location2 };
            return note;
          }
        } catch {
        }
      };
    }
    function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
      let text2 = "Internal error";
      let location2 = null;
      try {
        text2 = (e && e.message || e) + "";
      } catch {
      }
      try {
        location2 = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
      } catch {
      }
      return { id: "", pluginName, text: text2, location: location2, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
    }
    function parseStackLinesV8(streamIn, lines, ident) {
      let at2 = "    at ";
      if (streamIn.readFileSync && !lines[0].startsWith(at2) && lines[1].startsWith(at2)) {
        for (let i = 1; i < lines.length; i++) {
          let line = lines[i];
          if (!line.startsWith(at2)) continue;
          line = line.slice(at2.length);
          while (true) {
            let match2 = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
            if (match2) {
              line = match2[1];
              continue;
            }
            match2 = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
            if (match2) {
              line = match2[1];
              continue;
            }
            match2 = /^(\S+):(\d+):(\d+)$/.exec(line);
            if (match2) {
              let contents2;
              try {
                contents2 = streamIn.readFileSync(match2[1], "utf8");
              } catch {
                break;
              }
              let lineText = contents2.split(/\r\n|\r|\n|\u2028|\u2029/)[+match2[2] - 1] || "";
              let column = +match2[3] - 1;
              let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
              return {
                file: match2[1],
                namespace: "file",
                line: +match2[2],
                column: encodeUTF8(lineText.slice(0, column)).length,
                length: encodeUTF8(lineText.slice(column, column + length)).length,
                lineText: lineText + "\n" + lines.slice(1).join("\n"),
                suggestion: ""
              };
            }
            break;
          }
        }
      }
      return null;
    }
    function failureErrorWithLog(text2, errors, warnings) {
      let limit = 5;
      text2 += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
        if (i === limit) return "\n...";
        if (!e.location) return `
error: ${e.text}`;
        let { file, line, column } = e.location;
        let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
        return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
      }).join("");
      let error = new Error(text2);
      for (const [key, value2] of [["errors", errors], ["warnings", warnings]]) {
        Object.defineProperty(error, key, {
          configurable: true,
          enumerable: true,
          get: () => value2,
          set: (value22) => Object.defineProperty(error, key, {
            configurable: true,
            enumerable: true,
            value: value22
          })
        });
      }
      return error;
    }
    function replaceDetailsInMessages(messages2, stash) {
      for (const message of messages2) {
        message.detail = stash.load(message.detail);
      }
      return messages2;
    }
    function sanitizeLocation(location2, where, terminalWidth) {
      if (location2 == null) return null;
      let keys = {};
      let file = getFlag(location2, keys, "file", mustBeString);
      let namespace2 = getFlag(location2, keys, "namespace", mustBeString);
      let line = getFlag(location2, keys, "line", mustBeInteger);
      let column = getFlag(location2, keys, "column", mustBeInteger);
      let length = getFlag(location2, keys, "length", mustBeInteger);
      let lineText = getFlag(location2, keys, "lineText", mustBeString);
      let suggestion = getFlag(location2, keys, "suggestion", mustBeString);
      checkForInvalidFlags(location2, keys, where);
      if (lineText) {
        const relevantASCII = lineText.slice(
          0,
          (column && column > 0 ? column : 0) + (length && length > 0 ? length : 0) + (terminalWidth && terminalWidth > 0 ? terminalWidth : 80)
        );
        if (!/[\x7F-\uFFFF]/.test(relevantASCII) && !/\n/.test(lineText)) {
          lineText = relevantASCII;
        }
      }
      return {
        file: file || "",
        namespace: namespace2 || "",
        line: line || 0,
        column: column || 0,
        length: length || 0,
        lineText: lineText || "",
        suggestion: suggestion || ""
      };
    }
    function sanitizeMessages(messages2, property, stash, fallbackPluginName, terminalWidth) {
      let messagesClone = [];
      let index4 = 0;
      for (const message of messages2) {
        let keys = {};
        let id3 = getFlag(message, keys, "id", mustBeString);
        let pluginName = getFlag(message, keys, "pluginName", mustBeString);
        let text2 = getFlag(message, keys, "text", mustBeString);
        let location2 = getFlag(message, keys, "location", mustBeObjectOrNull);
        let notes = getFlag(message, keys, "notes", mustBeArray);
        let detail = getFlag(message, keys, "detail", canBeAnything);
        let where = `in element ${index4} of "${property}"`;
        checkForInvalidFlags(message, keys, where);
        let notesClone = [];
        if (notes) {
          for (const note of notes) {
            let noteKeys = {};
            let noteText = getFlag(note, noteKeys, "text", mustBeString);
            let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
            checkForInvalidFlags(note, noteKeys, where);
            notesClone.push({
              text: noteText || "",
              location: sanitizeLocation(noteLocation, where, terminalWidth)
            });
          }
        }
        messagesClone.push({
          id: id3 || "",
          pluginName: pluginName || fallbackPluginName,
          text: text2 || "",
          location: sanitizeLocation(location2, where, terminalWidth),
          notes: notesClone,
          detail: stash ? stash.store(detail) : -1
        });
        index4++;
      }
      return messagesClone;
    }
    function sanitizeStringArray(values, property) {
      const result = [];
      for (const value2 of values) {
        if (typeof value2 !== "string") throw new Error(`${quote3(property)} must be an array of strings`);
        result.push(value2);
      }
      return result;
    }
    function sanitizeStringMap(map, property) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const key in map) {
        const value2 = map[key];
        if (typeof value2 !== "string") throw new Error(`key ${quote3(key)} in object ${quote3(property)} must be a string`);
        result[key] = value2;
      }
      return result;
    }
    function convertOutputFiles({ path: path32, contents: contents2, hash: hash3 }) {
      let text2 = null;
      return {
        path: path32,
        contents: contents2,
        hash: hash3,
        get text() {
          const binary2 = this.contents;
          if (text2 === null || binary2 !== contents2) {
            contents2 = binary2;
            text2 = decodeUTF8(binary2);
          }
          return text2;
        }
      };
    }
    var fs6 = __require("fs");
    var os2 = __require("os");
    var path9 = __require("path");
    var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
    var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
    var packageDarwin_arm64 = "@esbuild/darwin-arm64";
    var packageDarwin_x64 = "@esbuild/darwin-x64";
    var knownWindowsPackages = {
      "win32 arm64 LE": "@esbuild/win32-arm64",
      "win32 ia32 LE": "@esbuild/win32-ia32",
      "win32 x64 LE": "@esbuild/win32-x64"
    };
    var knownUnixlikePackages = {
      "aix ppc64 BE": "@esbuild/aix-ppc64",
      "android arm64 LE": "@esbuild/android-arm64",
      "darwin arm64 LE": "@esbuild/darwin-arm64",
      "darwin x64 LE": "@esbuild/darwin-x64",
      "freebsd arm64 LE": "@esbuild/freebsd-arm64",
      "freebsd x64 LE": "@esbuild/freebsd-x64",
      "linux arm LE": "@esbuild/linux-arm",
      "linux arm64 LE": "@esbuild/linux-arm64",
      "linux ia32 LE": "@esbuild/linux-ia32",
      "linux mips64el LE": "@esbuild/linux-mips64el",
      "linux ppc64 LE": "@esbuild/linux-ppc64",
      "linux riscv64 LE": "@esbuild/linux-riscv64",
      "linux s390x BE": "@esbuild/linux-s390x",
      "linux x64 LE": "@esbuild/linux-x64",
      "linux loong64 LE": "@esbuild/linux-loong64",
      "netbsd x64 LE": "@esbuild/netbsd-x64",
      "openbsd x64 LE": "@esbuild/openbsd-x64",
      "sunos x64 LE": "@esbuild/sunos-x64"
    };
    var knownWebAssemblyFallbackPackages = {
      "android arm LE": "@esbuild/android-arm",
      "android x64 LE": "@esbuild/android-x64"
    };
    function pkgAndSubpathForCurrentPlatform() {
      let pkg;
      let subpath;
      let isWASM = false;
      let platformKey = `${process.platform} ${os2.arch()} ${os2.endianness()}`;
      if (platformKey in knownWindowsPackages) {
        pkg = knownWindowsPackages[platformKey];
        subpath = "esbuild.exe";
      } else if (platformKey in knownUnixlikePackages) {
        pkg = knownUnixlikePackages[platformKey];
        subpath = "bin/esbuild";
      } else if (platformKey in knownWebAssemblyFallbackPackages) {
        pkg = knownWebAssemblyFallbackPackages[platformKey];
        subpath = "bin/esbuild";
        isWASM = true;
      } else {
        throw new Error(`Unsupported platform: ${platformKey}`);
      }
      return { pkg, subpath, isWASM };
    }
    function pkgForSomeOtherPlatform() {
      const libMainJS = __require.resolve("esbuild");
      const nodeModulesDirectory = path9.dirname(path9.dirname(path9.dirname(libMainJS)));
      if (path9.basename(nodeModulesDirectory) === "node_modules") {
        for (const unixKey in knownUnixlikePackages) {
          try {
            const pkg = knownUnixlikePackages[unixKey];
            if (fs6.existsSync(path9.join(nodeModulesDirectory, pkg))) return pkg;
          } catch {
          }
        }
        for (const windowsKey in knownWindowsPackages) {
          try {
            const pkg = knownWindowsPackages[windowsKey];
            if (fs6.existsSync(path9.join(nodeModulesDirectory, pkg))) return pkg;
          } catch {
          }
        }
      }
      return null;
    }
    function downloadedBinPath(pkg, subpath) {
      const esbuildLibDir = path9.dirname(__require.resolve("esbuild"));
      return path9.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path9.basename(subpath)}`);
    }
    function generateBinPath() {
      if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
        if (!fs6.existsSync(ESBUILD_BINARY_PATH)) {
          console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
        } else {
          return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
        }
      }
      const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
      let binPath;
      try {
        binPath = __require.resolve(`${pkg}/${subpath}`);
      } catch (e) {
        binPath = downloadedBinPath(pkg, subpath);
        if (!fs6.existsSync(binPath)) {
          try {
            __require.resolve(pkg);
          } catch {
            const otherPkg = pkgForSomeOtherPlatform();
            if (otherPkg) {
              let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
              }
              throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
            }
            throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
          }
          throw e;
        }
      }
      if (/\.zip\//.test(binPath)) {
        let pnpapi;
        try {
          pnpapi = __require("pnpapi");
        } catch (e) {
        }
        if (pnpapi) {
          const root4 = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
          const binTargetPath = path9.join(
            root4,
            "node_modules",
            ".cache",
            "esbuild",
            `pnpapi-${pkg.replace("/", "-")}-${"0.21.5"}-${path9.basename(subpath)}`
          );
          if (!fs6.existsSync(binTargetPath)) {
            fs6.mkdirSync(path9.dirname(binTargetPath), { recursive: true });
            fs6.copyFileSync(binPath, binTargetPath);
            fs6.chmodSync(binTargetPath, 493);
          }
          return { binPath: binTargetPath, isWASM };
        }
      }
      return { binPath, isWASM };
    }
    var child_process = __require("child_process");
    var crypto2 = __require("crypto");
    var path22 = __require("path");
    var fs22 = __require("fs");
    var os22 = __require("os");
    var tty = __require("tty");
    var worker_threads;
    if (process.env.ESBUILD_WORKER_THREADS !== "0") {
      try {
        worker_threads = __require("worker_threads");
      } catch {
      }
      let [major, minor] = process.versions.node.split(".");
      if (
        // <v12.17.0 does not work
        +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
      ) {
        worker_threads = void 0;
      }
    }
    var _a;
    var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.21.5";
    var esbuildCommandAndArgs = () => {
      if ((!ESBUILD_BINARY_PATH || false) && (path22.basename(__filename) !== "main.js" || path22.basename(__dirname) !== "lib")) {
        throw new Error(
          `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
        );
      }
      if (false) {
        return ["node", [path22.join(__dirname, "..", "bin", "esbuild")]];
      } else {
        const { binPath, isWASM } = generateBinPath();
        if (isWASM) {
          return ["node", [binPath]];
        } else {
          return [binPath, []];
        }
      }
    };
    var isTTY = () => tty.isatty(2);
    var fsSync = {
      readFile(tempFile, callback) {
        try {
          let contents2 = fs22.readFileSync(tempFile, "utf8");
          try {
            fs22.unlinkSync(tempFile);
          } catch {
          }
          callback(null, contents2);
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents2, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFileSync(tempFile, contents2);
          callback(tempFile);
        } catch {
          callback(null);
        }
      }
    };
    var fsAsync = {
      readFile(tempFile, callback) {
        try {
          fs22.readFile(tempFile, "utf8", (err, contents2) => {
            try {
              fs22.unlink(tempFile, () => callback(err, contents2));
            } catch {
              callback(err, contents2);
            }
          });
        } catch (err) {
          callback(err, null);
        }
      },
      writeFile(contents2, callback) {
        try {
          let tempFile = randomFileName();
          fs22.writeFile(tempFile, contents2, (err) => err !== null ? callback(null) : callback(tempFile));
        } catch {
          callback(null);
        }
      }
    };
    var version4 = "0.21.5";
    var build3 = (options2) => ensureServiceIsRunning().build(options2);
    var context = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
    var transform3 = (input, options2) => ensureServiceIsRunning().transform(input, options2);
    var formatMessages2 = (messages2, options2) => ensureServiceIsRunning().formatMessages(messages2, options2);
    var analyzeMetafile = (messages2, options2) => ensureServiceIsRunning().analyzeMetafile(messages2, options2);
    var buildSync = (options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.buildSync(options2);
      }
      let result;
      runServiceSync((service) => service.buildOrContext({
        callName: "buildSync",
        refs: null,
        options: options2,
        isTTY: isTTY(),
        defaultWD,
        callback: (err, res) => {
          if (err) throw err;
          result = res;
        }
      }));
      return result;
    };
    var transformSync = (input, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.transformSync(input, options2);
      }
      let result;
      runServiceSync((service) => service.transform({
        callName: "transformSync",
        refs: null,
        input,
        options: options2 || {},
        isTTY: isTTY(),
        fs: fsSync,
        callback: (err, res) => {
          if (err) throw err;
          result = res;
        }
      }));
      return result;
    };
    var formatMessagesSync = (messages2, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.formatMessagesSync(messages2, options2);
      }
      let result;
      runServiceSync((service) => service.formatMessages({
        callName: "formatMessagesSync",
        refs: null,
        messages: messages2,
        options: options2,
        callback: (err, res) => {
          if (err) throw err;
          result = res;
        }
      }));
      return result;
    };
    var analyzeMetafileSync = (metafile, options2) => {
      if (worker_threads && !isInternalWorkerThread) {
        if (!workerThreadService) workerThreadService = startWorkerThreadService(worker_threads);
        return workerThreadService.analyzeMetafileSync(metafile, options2);
      }
      let result;
      runServiceSync((service) => service.analyzeMetafile({
        callName: "analyzeMetafileSync",
        refs: null,
        metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
        options: options2,
        callback: (err, res) => {
          if (err) throw err;
          result = res;
        }
      }));
      return result;
    };
    var stop = () => {
      if (stopService) stopService();
      if (workerThreadService) workerThreadService.stop();
      return Promise.resolve();
    };
    var initializeWasCalled = false;
    var initialize = (options2) => {
      options2 = validateInitializeOptions(options2 || {});
      if (options2.wasmURL) throw new Error(`The "wasmURL" option only works in the browser`);
      if (options2.wasmModule) throw new Error(`The "wasmModule" option only works in the browser`);
      if (options2.worker) throw new Error(`The "worker" option only works in the browser`);
      if (initializeWasCalled) throw new Error('Cannot call "initialize" more than once');
      ensureServiceIsRunning();
      initializeWasCalled = true;
      return Promise.resolve();
    };
    var defaultWD = process.cwd();
    var longLivedService;
    var stopService;
    var ensureServiceIsRunning = () => {
      if (longLivedService) return longLivedService;
      let [command, args] = esbuildCommandAndArgs();
      let child = child_process.spawn(command, args.concat(`--service=${"0.21.5"}`, "--ping"), {
        windowsHide: true,
        stdio: ["pipe", "pipe", "inherit"],
        cwd: defaultWD
      });
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          child.stdin.write(bytes, (err) => {
            if (err) afterClose(err);
          });
        },
        readFileSync: fs22.readFileSync,
        isSync: false,
        hasFS: true,
        esbuild: node_exports2
      });
      child.stdin.on("error", afterClose);
      child.on("error", afterClose);
      const stdin = child.stdin;
      const stdout = child.stdout;
      stdout.on("data", readFromStdout);
      stdout.on("end", afterClose);
      stopService = () => {
        stdin.destroy();
        stdout.destroy();
        child.kill();
        initializeWasCalled = false;
        longLivedService = void 0;
        stopService = void 0;
      };
      let refCount = 0;
      child.unref();
      if (stdin.unref) {
        stdin.unref();
      }
      if (stdout.unref) {
        stdout.unref();
      }
      const refs = {
        ref() {
          if (++refCount === 1) child.ref();
        },
        unref() {
          if (--refCount === 0) child.unref();
        }
      };
      longLivedService = {
        build: (options2) => new Promise((resolve8, reject) => {
          service.buildOrContext({
            callName: "build",
            refs,
            options: options2,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve8(res)
          });
        }),
        context: (options2) => new Promise((resolve8, reject) => service.buildOrContext({
          callName: "context",
          refs,
          options: options2,
          isTTY: isTTY(),
          defaultWD,
          callback: (err, res) => err ? reject(err) : resolve8(res)
        })),
        transform: (input, options2) => new Promise((resolve8, reject) => service.transform({
          callName: "transform",
          refs,
          input,
          options: options2 || {},
          isTTY: isTTY(),
          fs: fsAsync,
          callback: (err, res) => err ? reject(err) : resolve8(res)
        })),
        formatMessages: (messages2, options2) => new Promise((resolve8, reject) => service.formatMessages({
          callName: "formatMessages",
          refs,
          messages: messages2,
          options: options2,
          callback: (err, res) => err ? reject(err) : resolve8(res)
        })),
        analyzeMetafile: (metafile, options2) => new Promise((resolve8, reject) => service.analyzeMetafile({
          callName: "analyzeMetafile",
          refs,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options: options2,
          callback: (err, res) => err ? reject(err) : resolve8(res)
        }))
      };
      return longLivedService;
    };
    var runServiceSync = (callback) => {
      let [command, args] = esbuildCommandAndArgs();
      let stdin = new Uint8Array();
      let { readFromStdout, afterClose, service } = createChannel({
        writeToStdin(bytes) {
          if (stdin.length !== 0) throw new Error("Must run at most one command");
          stdin = bytes;
        },
        isSync: true,
        hasFS: true,
        esbuild: node_exports2
      });
      callback(service);
      let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.21.5"}`), {
        cwd: defaultWD,
        windowsHide: true,
        input: stdin,
        // We don't know how large the output could be. If it's too large, the
        // command will fail with ENOBUFS. Reserve 16mb for now since that feels
        // like it should be enough. Also allow overriding this with an environment
        // variable.
        maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
      });
      readFromStdout(stdout);
      afterClose(null);
    };
    var randomFileName = () => {
      return path22.join(os22.tmpdir(), `esbuild-${crypto2.randomBytes(32).toString("hex")}`);
    };
    var workerThreadService = null;
    var startWorkerThreadService = (worker_threads2) => {
      let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
      let worker = new worker_threads2.Worker(__filename, {
        workerData: { workerPort, defaultWD, esbuildVersion: "0.21.5" },
        transferList: [workerPort],
        // From node's documentation: https://nodejs.org/api/worker_threads.html
        //
        //   Take care when launching worker threads from preload scripts (scripts loaded
        //   and run using the `-r` command line flag). Unless the `execArgv` option is
        //   explicitly set, new Worker threads automatically inherit the command line flags
        //   from the running process and will preload the same preload scripts as the main
        //   thread. If the preload script unconditionally launches a worker thread, every
        //   thread spawned will spawn another until the application crashes.
        //
        execArgv: []
      });
      let nextID = 0;
      let fakeBuildError = (text2) => {
        let error = new Error(`Build failed with 1 error:
error: ${text2}`);
        let errors = [{ id: "", pluginName: "", text: text2, location: null, notes: [], detail: void 0 }];
        error.errors = errors;
        error.warnings = [];
        return error;
      };
      let validateBuildSyncOptions = (options2) => {
        if (!options2) return;
        let plugins2 = options2.plugins;
        if (plugins2 && plugins2.length > 0) throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
      };
      let applyProperties = (object2, properties) => {
        for (let key in properties) {
          object2[key] = properties[key];
        }
      };
      let runCallSync = (command, args) => {
        let id3 = nextID++;
        let sharedBuffer = new SharedArrayBuffer(8);
        let sharedBufferView = new Int32Array(sharedBuffer);
        let msg = { sharedBuffer, id: id3, command, args };
        worker.postMessage(msg);
        let status2 = Atomics.wait(sharedBufferView, 0, 0);
        if (status2 !== "ok" && status2 !== "not-equal") throw new Error("Internal error: Atomics.wait() failed: " + status2);
        let { message: { id: id22, resolve: resolve8, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
        if (id3 !== id22) throw new Error(`Internal error: Expected id ${id3} but got id ${id22}`);
        if (reject) {
          applyProperties(reject, properties);
          throw reject;
        }
        return resolve8;
      };
      worker.unref();
      return {
        buildSync(options2) {
          validateBuildSyncOptions(options2);
          return runCallSync("build", [options2]);
        },
        transformSync(input, options2) {
          return runCallSync("transform", [input, options2]);
        },
        formatMessagesSync(messages2, options2) {
          return runCallSync("formatMessages", [messages2, options2]);
        },
        analyzeMetafileSync(metafile, options2) {
          return runCallSync("analyzeMetafile", [metafile, options2]);
        },
        stop() {
          worker.terminate();
          workerThreadService = null;
        }
      };
    };
    var startSyncServiceWorker = () => {
      let workerPort = worker_threads.workerData.workerPort;
      let parentPort = worker_threads.parentPort;
      let extractProperties = (object2) => {
        let properties = {};
        if (object2 && typeof object2 === "object") {
          for (let key in object2) {
            properties[key] = object2[key];
          }
        }
        return properties;
      };
      try {
        let service = ensureServiceIsRunning();
        defaultWD = worker_threads.workerData.defaultWD;
        parentPort.on("message", (msg) => {
          (async () => {
            let { sharedBuffer, id: id3, command, args } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            try {
              switch (command) {
                case "build":
                  workerPort.postMessage({ id: id3, resolve: await service.build(args[0]) });
                  break;
                case "transform":
                  workerPort.postMessage({ id: id3, resolve: await service.transform(args[0], args[1]) });
                  break;
                case "formatMessages":
                  workerPort.postMessage({ id: id3, resolve: await service.formatMessages(args[0], args[1]) });
                  break;
                case "analyzeMetafile":
                  workerPort.postMessage({ id: id3, resolve: await service.analyzeMetafile(args[0], args[1]) });
                  break;
                default:
                  throw new Error(`Invalid command: ${command}`);
              }
            } catch (reject) {
              workerPort.postMessage({ id: id3, reject, properties: extractProperties(reject) });
            }
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          })();
        });
      } catch (reject) {
        parentPort.on("message", (msg) => {
          let { sharedBuffer, id: id3 } = msg;
          let sharedBufferView = new Int32Array(sharedBuffer);
          workerPort.postMessage({ id: id3, reject, properties: extractProperties(reject) });
          Atomics.add(sharedBufferView, 0, 1);
          Atomics.notify(sharedBufferView, 0, Infinity);
        });
      }
    };
    if (isInternalWorkerThread) {
      startSyncServiceWorker();
    }
    var node_default = node_exports2;
  }
});

// node_modules/vite/dist/node/constants.js
import path, { resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { readFileSync } from "node:fs";
var version, CSS_LANGS_RE, FS_PREFIX, CLIENT_PUBLIC_PATH, ENV_PUBLIC_PATH, VITE_PACKAGE_DIR, CLIENT_ENTRY, ENV_ENTRY, CLIENT_DIR, KNOWN_ASSET_TYPES, DEFAULT_ASSETS_RE;
var init_constants = __esm({
  "node_modules/vite/dist/node/constants.js"() {
    ({ version } = JSON.parse(
      readFileSync(new URL("../../package.json", import.meta.url)).toString()
    ));
    CSS_LANGS_RE = /\.(css|less|sass|scss|styl|stylus|pcss|postcss|sss)(?:$|\?)/;
    FS_PREFIX = `/@fs/`;
    CLIENT_PUBLIC_PATH = `/@vite/client`;
    ENV_PUBLIC_PATH = `/@vite/env`;
    VITE_PACKAGE_DIR = resolve(
      // import.meta.url is `dist/node/constants.js` after bundle
      fileURLToPath(import.meta.url),
      "../../.."
    );
    CLIENT_ENTRY = resolve(VITE_PACKAGE_DIR, "dist/client/client.mjs");
    ENV_ENTRY = resolve(VITE_PACKAGE_DIR, "dist/client/env.mjs");
    CLIENT_DIR = path.dirname(CLIENT_ENTRY);
    KNOWN_ASSET_TYPES = [
      // images
      "apng",
      "bmp",
      "png",
      "jpe?g",
      "jfif",
      "pjpeg",
      "pjp",
      "gif",
      "svg",
      "ico",
      "webp",
      "avif",
      // media
      "mp4",
      "webm",
      "ogg",
      "mp3",
      "wav",
      "flac",
      "aac",
      "opus",
      "mov",
      "m4a",
      "vtt",
      // fonts
      "woff2?",
      "eot",
      "ttf",
      "otf",
      // other
      "webmanifest",
      "pdf",
      "txt"
    ];
    DEFAULT_ASSETS_RE = new RegExp(
      `\\.(` + KNOWN_ASSET_TYPES.join("|") + `)(\\?.*)?$`
    );
  }
});

// node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js
import { fileURLToPath as __cjs_fileURLToPath } from "node:url";
import { dirname as __cjs_dirname } from "node:path";
import { createRequire as __cjs_createRequire } from "node:module";
function stringifyNode(node3, custom) {
  var type = node3.type;
  var value2 = node3.value;
  var buf;
  var customResult;
  if (custom && (customResult = custom(node3)) !== void 0) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value2;
  } else if (type === "string") {
    buf = node3.quote || "";
    return buf + value2 + (node3.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value2 + (node3.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node3.before || "") + value2 + (node3.after || "");
  } else if (Array.isArray(node3.nodes)) {
    buf = stringify$1(node3.nodes, custom);
    if (type !== "function") {
      return buf;
    }
    return value2 + "(" + (node3.before || "") + buf + (node3.after || "") + (node3.unclosed ? "" : ")");
  }
  return value2;
}
function stringify$1(nodes, custom) {
  var result, i;
  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}
function requireUnit() {
  if (hasRequiredUnit) return unit;
  hasRequiredUnit = 1;
  var minus = "-".charCodeAt(0);
  var plus3 = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);
  function likeNumber(value2) {
    var code = value2.charCodeAt(0);
    var nextCode;
    if (code === plus3 || code === minus) {
      nextCode = value2.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      var nextNextCode = value2.charCodeAt(2);
      if (nextCode === dot && nextNextCode >= 48 && nextNextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code === dot) {
      nextCode = value2.charCodeAt(1);
      if (nextCode >= 48 && nextCode <= 57) {
        return true;
      }
      return false;
    }
    if (code >= 48 && code <= 57) {
      return true;
    }
    return false;
  }
  unit = function(value2) {
    var pos = 0;
    var length = value2.length;
    var code;
    var nextCode;
    var nextNextCode;
    if (length === 0 || !likeNumber(value2)) {
      return false;
    }
    code = value2.charCodeAt(pos);
    if (code === plus3 || code === minus) {
      pos++;
    }
    while (pos < length) {
      code = value2.charCodeAt(pos);
      if (code < 48 || code > 57) {
        break;
      }
      pos += 1;
    }
    code = value2.charCodeAt(pos);
    nextCode = value2.charCodeAt(pos + 1);
    if (code === dot && nextCode >= 48 && nextCode <= 57) {
      pos += 2;
      while (pos < length) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    code = value2.charCodeAt(pos);
    nextCode = value2.charCodeAt(pos + 1);
    nextNextCode = value2.charCodeAt(pos + 2);
    if ((code === exp || code === EXP) && (nextCode >= 48 && nextCode <= 57 || (nextCode === plus3 || nextCode === minus) && nextNextCode >= 48 && nextNextCode <= 57)) {
      pos += nextCode === plus3 || nextCode === minus ? 3 : 2;
      while (pos < length) {
        code = value2.charCodeAt(pos);
        if (code < 48 || code > 57) {
          break;
        }
        pos += 1;
      }
    }
    return {
      number: value2.slice(0, pos),
      unit: value2.slice(pos)
    };
  };
  return unit;
}
function ValueParser(value2) {
  if (this instanceof ValueParser) {
    this.nodes = parse2(value2);
    return this;
  }
  return new ValueParser(value2);
}
var __filename2, __dirname2, require2, openParentheses, closeParentheses, singleQuote, doubleQuote, backslash, slash, comma, colon, star, uLower, uUpper, plus, isUnicodeRange, parse$1, walk$1, stringify_1, unit, hasRequiredUnit, parse2, walk2, stringify, lib;
var init_dep_IQS_Za7F = __esm({
  "node_modules/vite/dist/node/chunks/dep-IQS-Za7F.js"() {
    __filename2 = __cjs_fileURLToPath(import.meta.url);
    __dirname2 = __cjs_dirname(__filename2);
    require2 = __cjs_createRequire(import.meta.url);
    openParentheses = "(".charCodeAt(0);
    closeParentheses = ")".charCodeAt(0);
    singleQuote = "'".charCodeAt(0);
    doubleQuote = '"'.charCodeAt(0);
    backslash = "\\".charCodeAt(0);
    slash = "/".charCodeAt(0);
    comma = ",".charCodeAt(0);
    colon = ":".charCodeAt(0);
    star = "*".charCodeAt(0);
    uLower = "u".charCodeAt(0);
    uUpper = "U".charCodeAt(0);
    plus = "+".charCodeAt(0);
    isUnicodeRange = /^[a-f0-9?-]+$/i;
    parse$1 = function(input) {
      var tokens = [];
      var value2 = input;
      var next, quote3, prev, token, escape2, escapePos, whitespacePos, parenthesesOpenPos;
      var pos = 0;
      var code = value2.charCodeAt(pos);
      var max = value2.length;
      var stack = [{ nodes: tokens }];
      var balanced2 = 0;
      var parent;
      var name2 = "";
      var before = "";
      var after = "";
      while (pos < max) {
        if (code <= 32) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          token = value2.slice(pos, next);
          prev = tokens[tokens.length - 1];
          if (code === closeParentheses && balanced2) {
            after = token;
          } else if (prev && prev.type === "div") {
            prev.after = token;
            prev.sourceEndIndex += token.length;
          } else if (code === comma || code === colon || code === slash && value2.charCodeAt(next + 1) !== star && (!parent || parent && parent.type === "function" && parent.value !== "calc")) {
            before = token;
          } else {
            tokens.push({
              type: "space",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        } else if (code === singleQuote || code === doubleQuote) {
          next = pos;
          quote3 = code === singleQuote ? "'" : '"';
          token = {
            type: "string",
            sourceIndex: pos,
            quote: quote3
          };
          do {
            escape2 = false;
            next = value2.indexOf(quote3, next + 1);
            if (~next) {
              escapePos = next;
              while (value2.charCodeAt(escapePos - 1) === backslash) {
                escapePos -= 1;
                escape2 = !escape2;
              }
            } else {
              value2 += quote3;
              next = value2.length - 1;
              token.unclosed = true;
            }
          } while (escape2);
          token.value = value2.slice(pos + 1, next);
          token.sourceEndIndex = token.unclosed ? next : next + 1;
          tokens.push(token);
          pos = next + 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash && value2.charCodeAt(pos + 1) === star) {
          next = value2.indexOf("*/", pos);
          token = {
            type: "comment",
            sourceIndex: pos,
            sourceEndIndex: next + 2
          };
          if (next === -1) {
            token.unclosed = true;
            next = value2.length;
            token.sourceEndIndex = next;
          }
          token.value = value2.slice(pos + 2, next);
          tokens.push(token);
          pos = next + 2;
          code = value2.charCodeAt(pos);
        } else if ((code === slash || code === star) && parent && parent.type === "function" && parent.value === "calc") {
          token = value2[pos];
          tokens.push({
            type: "word",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token
          });
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (code === slash || code === comma || code === colon) {
          token = value2[pos];
          tokens.push({
            type: "div",
            sourceIndex: pos - before.length,
            sourceEndIndex: pos + token.length,
            value: token,
            before,
            after: ""
          });
          before = "";
          pos += 1;
          code = value2.charCodeAt(pos);
        } else if (openParentheses === code) {
          next = pos;
          do {
            next += 1;
            code = value2.charCodeAt(next);
          } while (code <= 32);
          parenthesesOpenPos = pos;
          token = {
            type: "function",
            sourceIndex: pos - name2.length,
            value: name2,
            before: value2.slice(parenthesesOpenPos + 1, next)
          };
          pos = next;
          if (name2 === "url" && code !== singleQuote && code !== doubleQuote) {
            next -= 1;
            do {
              escape2 = false;
              next = value2.indexOf(")", next + 1);
              if (~next) {
                escapePos = next;
                while (value2.charCodeAt(escapePos - 1) === backslash) {
                  escapePos -= 1;
                  escape2 = !escape2;
                }
              } else {
                value2 += ")";
                next = value2.length - 1;
                token.unclosed = true;
              }
            } while (escape2);
            whitespacePos = next;
            do {
              whitespacePos -= 1;
              code = value2.charCodeAt(whitespacePos);
            } while (code <= 32);
            if (parenthesesOpenPos < whitespacePos) {
              if (pos !== whitespacePos + 1) {
                token.nodes = [
                  {
                    type: "word",
                    sourceIndex: pos,
                    sourceEndIndex: whitespacePos + 1,
                    value: value2.slice(pos, whitespacePos + 1)
                  }
                ];
              } else {
                token.nodes = [];
              }
              if (token.unclosed && whitespacePos + 1 !== next) {
                token.after = "";
                token.nodes.push({
                  type: "space",
                  sourceIndex: whitespacePos + 1,
                  sourceEndIndex: next,
                  value: value2.slice(whitespacePos + 1, next)
                });
              } else {
                token.after = value2.slice(whitespacePos + 1, next);
                token.sourceEndIndex = next;
              }
            } else {
              token.after = "";
              token.nodes = [];
            }
            pos = next + 1;
            token.sourceEndIndex = token.unclosed ? next : pos;
            code = value2.charCodeAt(pos);
            tokens.push(token);
          } else {
            balanced2 += 1;
            token.after = "";
            token.sourceEndIndex = pos + 1;
            tokens.push(token);
            stack.push(token);
            tokens = token.nodes = [];
            parent = token;
          }
          name2 = "";
        } else if (closeParentheses === code && balanced2) {
          pos += 1;
          code = value2.charCodeAt(pos);
          parent.after = after;
          parent.sourceEndIndex += after.length;
          after = "";
          balanced2 -= 1;
          stack[stack.length - 1].sourceEndIndex = pos;
          stack.pop();
          parent = stack[balanced2];
          tokens = parent.nodes;
        } else {
          next = pos;
          do {
            if (code === backslash) {
              next += 1;
            }
            next += 1;
            code = value2.charCodeAt(next);
          } while (next < max && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === star && parent && parent.type === "function" && parent.value === "calc" || code === slash && parent.type === "function" && parent.value === "calc" || code === closeParentheses && balanced2));
          token = value2.slice(pos, next);
          if (openParentheses === code) {
            name2 = token;
          } else if ((uLower === token.charCodeAt(0) || uUpper === token.charCodeAt(0)) && plus === token.charCodeAt(1) && isUnicodeRange.test(token.slice(2))) {
            tokens.push({
              type: "unicode-range",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          } else {
            tokens.push({
              type: "word",
              sourceIndex: pos,
              sourceEndIndex: next,
              value: token
            });
          }
          pos = next;
        }
      }
      for (pos = stack.length - 1; pos; pos -= 1) {
        stack[pos].unclosed = true;
        stack[pos].sourceEndIndex = value2.length;
      }
      return stack[0].nodes;
    };
    walk$1 = function walk(nodes, cb, bubble) {
      var i, max, node3, result;
      for (i = 0, max = nodes.length; i < max; i += 1) {
        node3 = nodes[i];
        if (!bubble) {
          result = cb(node3, i, nodes);
        }
        if (result !== false && node3.type === "function" && Array.isArray(node3.nodes)) {
          walk(node3.nodes, cb, bubble);
        }
        if (bubble) {
          cb(node3, i, nodes);
        }
      }
    };
    stringify_1 = stringify$1;
    parse2 = parse$1;
    walk2 = walk$1;
    stringify = stringify_1;
    ValueParser.prototype.toString = function() {
      return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
    };
    ValueParser.prototype.walk = function(cb, bubble) {
      walk2(this.nodes, cb, bubble);
      return this;
    };
    ValueParser.unit = requireUnit();
    ValueParser.walk = walk2;
    ValueParser.stringify = stringify;
    lib = ValueParser;
  }
});

// node_modules/vite/dist/node/chunks/dep-COdkJwUb.js
var dep_COdkJwUb_exports = {};
__export(dep_COdkJwUb_exports, {
  i: () => index$1
});
import require$$0 from "path";
import require$$0__default from "fs";
import { fileURLToPath as __cjs_fileURLToPath2 } from "node:url";
import { dirname as __cjs_dirname2 } from "node:path";
import { createRequire as __cjs_createRequire2 } from "node:module";
function _mergeNamespaces(n, m) {
  for (var i = 0; i < m.length; i++) {
    var e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (var k in e) {
        if (k !== "default" && !(k in n)) {
          n[k] = e[k];
        }
      }
    }
  }
  return n;
}
function convert(content, encoding) {
  if (Buffer.isEncoding(encoding)) {
    return content.toString(encoding);
  }
  return content;
}
function isValid(url2) {
  return anyDataURLRegexp.test(url2);
}
function contents(url2) {
  if (base64DataURLRegexp.test(url2)) {
    return Buffer.from(url2.slice(21), "base64").toString();
  }
  if (plainDataURLRegexp.test(url2)) {
    return decodeURIComponent(url2.slice(20));
  }
  return decodeURIComponent(url2.slice(14));
}
function parseCharset(result, atRule2, conditions, from) {
  if (atRule2.prev()) {
    return result.warn("@charset must precede all other statements", {
      node: atRule2
    });
  }
  return {
    type: "charset",
    node: atRule2,
    conditions: [...conditions],
    from
  };
}
function parseImport(result, atRule2, conditions, from) {
  let prev = atRule2.prev();
  if (prev) {
    do {
      if (prev.type === "comment" || prev.type === "atrule" && prev.name === "import") {
        prev = prev.prev();
        continue;
      }
      break;
    } while (prev);
  }
  if (prev) {
    do {
      if (prev.type === "comment" || prev.type === "atrule" && (prev.name === "charset" || prev.name === "layer" && !prev.nodes)) {
        prev = prev.prev();
        continue;
      }
      return result.warn(
        "@import must precede all other statements (besides @charset or empty @layer)",
        { node: atRule2 }
      );
    } while (prev);
  }
  if (atRule2.nodes) {
    return result.warn(
      "It looks like you didn't end your @import statement correctly. Child nodes are attached to it.",
      { node: atRule2 }
    );
  }
  const params = valueParser(atRule2.params).nodes;
  const stmt = {
    type: "import",
    uri: "",
    fullUri: "",
    node: atRule2,
    conditions: [...conditions],
    from
  };
  let layer;
  let media;
  let supports;
  for (let i = 0; i < params.length; i++) {
    const node3 = params[i];
    if (node3.type === "space" || node3.type === "comment") continue;
    if (node3.type === "string") {
      if (stmt.uri) {
        return result.warn(`Multiple url's in '${atRule2.toString()}'`, {
          node: atRule2
        });
      }
      if (!node3.value) {
        return result.warn(`Unable to find uri in '${atRule2.toString()}'`, {
          node: atRule2
        });
      }
      stmt.uri = node3.value;
      stmt.fullUri = stringify2(node3);
      continue;
    }
    if (node3.type === "function" && /^url$/i.test(node3.value)) {
      if (stmt.uri) {
        return result.warn(`Multiple url's in '${atRule2.toString()}'`, {
          node: atRule2
        });
      }
      if (!node3.nodes?.[0]?.value) {
        return result.warn(`Unable to find uri in '${atRule2.toString()}'`, {
          node: atRule2
        });
      }
      stmt.uri = node3.nodes[0].value;
      stmt.fullUri = stringify2(node3);
      continue;
    }
    if (!stmt.uri) {
      return result.warn(`Unable to find uri in '${atRule2.toString()}'`, {
        node: atRule2
      });
    }
    if ((node3.type === "word" || node3.type === "function") && /^layer$/i.test(node3.value)) {
      if (typeof layer !== "undefined") {
        return result.warn(`Multiple layers in '${atRule2.toString()}'`, {
          node: atRule2
        });
      }
      if (typeof supports !== "undefined") {
        return result.warn(
          `layers must be defined before support conditions in '${atRule2.toString()}'`,
          {
            node: atRule2
          }
        );
      }
      if (node3.nodes) {
        layer = stringify2(node3.nodes);
      } else {
        layer = "";
      }
      continue;
    }
    if (node3.type === "function" && /^supports$/i.test(node3.value)) {
      if (typeof supports !== "undefined") {
        return result.warn(
          `Multiple support conditions in '${atRule2.toString()}'`,
          {
            node: atRule2
          }
        );
      }
      supports = stringify2(node3.nodes);
      continue;
    }
    media = stringify2(params.slice(i));
    break;
  }
  if (!stmt.uri) {
    return result.warn(`Unable to find uri in '${atRule2.toString()}'`, {
      node: atRule2
    });
  }
  if (typeof media !== "undefined" || typeof layer !== "undefined" || typeof supports !== "undefined") {
    stmt.conditions.push({
      layer,
      media,
      supports
    });
  }
  return stmt;
}
function runPostcss(postcss3, content, filename, plugins2, parsers, index4) {
  if (!index4) index4 = 0;
  return postcss3(plugins2).process(content, {
    from: filename,
    parser: parsers[index4]
  }).catch((err) => {
    index4++;
    if (index4 === parsers.length) throw err;
    return runPostcss(postcss3, content, filename, plugins2, parsers, index4);
  });
}
async function parseStyles$1(result, styles, options2, state, conditions, from, postcss3) {
  const statements = parseStatements2(result, styles, conditions, from);
  for (const stmt of statements) {
    if (stmt.type !== "import" || !isProcessableURL(stmt.uri)) {
      continue;
    }
    if (options2.filter && !options2.filter(stmt.uri)) {
      continue;
    }
    await resolveImportId(result, stmt, options2, state, postcss3);
  }
  let charset;
  const imports = [];
  const bundle2 = [];
  function handleCharset(stmt) {
    if (!charset) charset = stmt;
    else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) {
      throw stmt.node.error(
        `Incompatible @charset statements:
  ${stmt.node.params} specified in ${stmt.node.source.input.file}
  ${charset.node.params} specified in ${charset.node.source.input.file}`
      );
    }
  }
  statements.forEach((stmt) => {
    if (stmt.type === "charset") handleCharset(stmt);
    else if (stmt.type === "import") {
      if (stmt.children) {
        stmt.children.forEach((child, index4) => {
          if (child.type === "import") imports.push(child);
          else if (child.type === "charset") handleCharset(child);
          else bundle2.push(child);
          if (index4 === 0) child.parent = stmt;
        });
      } else imports.push(stmt);
    } else if (stmt.type === "nodes") {
      bundle2.push(stmt);
    }
  });
  return charset ? [charset, ...imports.concat(bundle2)] : imports.concat(bundle2);
}
async function resolveImportId(result, stmt, options2, state, postcss3) {
  if (dataURL.isValid(stmt.uri)) {
    stmt.children = await loadImportContent(
      result,
      stmt,
      stmt.uri,
      options2,
      state,
      postcss3
    );
    return;
  } else if (dataURL.isValid(stmt.from.slice(-1))) {
    throw stmt.node.error(
      `Unable to import '${stmt.uri}' from a stylesheet that is embedded in a data url`
    );
  }
  const atRule2 = stmt.node;
  let sourceFile;
  if (atRule2.source?.input?.file) {
    sourceFile = atRule2.source.input.file;
  }
  const base = sourceFile ? path$1.dirname(atRule2.source.input.file) : options2.root;
  const paths = [await options2.resolve(stmt.uri, base, options2, atRule2)].flat();
  const resolved = await Promise.all(
    paths.map((file) => {
      return !path$1.isAbsolute(file) ? resolveId$1(file) : file;
    })
  );
  resolved.forEach((file) => {
    result.messages.push({
      type: "dependency",
      plugin: "postcss-import",
      file,
      parent: sourceFile
    });
  });
  const importedContent = await Promise.all(
    resolved.map((file) => {
      return loadImportContent(result, stmt, file, options2, state, postcss3);
    })
  );
  stmt.children = importedContent.flat().filter((x) => !!x);
}
async function loadImportContent(result, stmt, filename, options2, state, postcss3) {
  const atRule2 = stmt.node;
  const { conditions, from } = stmt;
  const stmtDuplicateCheckKey = conditions.map(
    (condition) => formatImportPrelude2(condition.layer, condition.media, condition.supports)
  ).join(":");
  if (options2.skipDuplicates) {
    if (state.importedFiles[filename]?.[stmtDuplicateCheckKey]) {
      return;
    }
    if (!state.importedFiles[filename]) {
      state.importedFiles[filename] = {};
    }
    state.importedFiles[filename][stmtDuplicateCheckKey] = true;
  }
  if (from.includes(filename)) {
    return;
  }
  const content = await options2.load(filename, options2);
  if (content.trim() === "" && options2.warnOnEmpty) {
    result.warn(`${filename} is empty`, { node: atRule2 });
    return;
  }
  if (options2.skipDuplicates && state.hashFiles[content]?.[stmtDuplicateCheckKey]) {
    return;
  }
  const importedResult = await processContent2(
    result,
    content,
    filename,
    options2,
    postcss3
  );
  const styles = importedResult.root;
  result.messages = result.messages.concat(importedResult.messages);
  if (options2.skipDuplicates) {
    const hasImport = styles.some((child) => {
      return child.type === "atrule" && child.name === "import";
    });
    if (!hasImport) {
      if (!state.hashFiles[content]) {
        state.hashFiles[content] = {};
      }
      state.hashFiles[content][stmtDuplicateCheckKey] = true;
    }
  }
  return parseStyles$1(
    result,
    styles,
    options2,
    state,
    conditions,
    [...from, filename],
    postcss3
  );
}
function isProcessableURL(uri) {
  if (/^(?:[a-z]+:)?\/\//i.test(uri)) {
    return false;
  }
  try {
    const url2 = new URL(uri, "https://example.com");
    if (url2.search) {
      return false;
    }
  } catch {
  }
  return true;
}
function AtImport(options2) {
  options2 = {
    root: process.cwd(),
    path: [],
    skipDuplicates: true,
    resolve: resolveId,
    load: loadContent2,
    plugins: [],
    addModulesDirectories: [],
    warnOnEmpty: true,
    ...options2
  };
  options2.root = path2.resolve(options2.root);
  if (typeof options2.path === "string") options2.path = [options2.path];
  if (!Array.isArray(options2.path)) options2.path = [];
  options2.path = options2.path.map((p) => path2.resolve(options2.root, p));
  return {
    postcssPlugin: "postcss-import",
    async Once(styles, { result, atRule: atRule2, postcss: postcss3 }) {
      const state = {
        importedFiles: {},
        hashFiles: {}
      };
      if (styles.source?.input?.file) {
        state.importedFiles[styles.source.input.file] = {};
      }
      if (options2.plugins && !Array.isArray(options2.plugins)) {
        throw new Error("plugins option must be an array");
      }
      const bundle2 = await parseStyles(
        result,
        styles,
        options2,
        state,
        [],
        [],
        postcss3
      );
      applyRaws2(bundle2);
      applyConditions2(bundle2, atRule2);
      applyStyles2(bundle2, styles);
    }
  };
}
var __filename3, __dirname3, require3, __require2, formatImportPrelude$2, formatImportPrelude$1, base64EncodedImport, base64EncodedConditionalImport2, applyConditions$1, applyRaws$1, applyStyles$1, readCache$1, pify$2, processFn, pify$1, pifyExports, fs, path$3, pify, stat, readFile, resolve2, cache, readCacheExports, anyDataURLRegexp, base64DataURLRegexp, plainDataURLRegexp, dataUrl, readCache, dataURL$1, loadContent$1, valueParser, stringify2, parseStatements$1, path$2, sugarss, processContent$1, path$1, dataURL, parseStatements2, processContent2, resolveId$1, formatImportPrelude2, parseStyles_1, path2, applyConditions2, applyRaws2, applyStyles2, loadContent2, parseStyles, resolveId, postcssImport, index, index$1;
var init_dep_COdkJwUb = __esm({
  "node_modules/vite/dist/node/chunks/dep-COdkJwUb.js"() {
    init_dep_C6uTJdX2();
    init_dep_IQS_Za7F();
    __filename3 = __cjs_fileURLToPath2(import.meta.url);
    __dirname3 = __cjs_dirname2(__filename3);
    require3 = __cjs_createRequire2(import.meta.url);
    __require2 = require3;
    formatImportPrelude$2 = function formatImportPrelude(layer, media, supports) {
      const parts = [];
      if (typeof layer !== "undefined") {
        let layerParams = "layer";
        if (layer) {
          layerParams = `layer(${layer})`;
        }
        parts.push(layerParams);
      }
      if (typeof supports !== "undefined") {
        parts.push(`supports(${supports})`);
      }
      if (typeof media !== "undefined") {
        parts.push(media);
      }
      return parts.join(" ");
    };
    formatImportPrelude$1 = formatImportPrelude$2;
    base64EncodedImport = function base64EncodedConditionalImport(prelude, conditions) {
      conditions.reverse();
      const first2 = conditions.pop();
      let params = `${prelude} ${formatImportPrelude$1(
        first2.layer,
        first2.media,
        first2.supports
      )}`;
      for (const condition of conditions) {
        params = `'data:text/css;base64,${Buffer.from(`@import ${params}`).toString(
          "base64"
        )}' ${formatImportPrelude$1(
          condition.layer,
          condition.media,
          condition.supports
        )}`;
      }
      return params;
    };
    base64EncodedConditionalImport2 = base64EncodedImport;
    applyConditions$1 = function applyConditions(bundle2, atRule2) {
      bundle2.forEach((stmt) => {
        if (stmt.type === "charset" || stmt.type === "warning" || !stmt.conditions?.length) {
          return;
        }
        if (stmt.type === "import") {
          stmt.node.params = base64EncodedConditionalImport2(
            stmt.fullUri,
            stmt.conditions
          );
          return;
        }
        const { nodes } = stmt;
        const { parent } = nodes[0];
        const atRules = [];
        for (const condition of stmt.conditions) {
          if (typeof condition.media !== "undefined") {
            const mediaNode = atRule2({
              name: "media",
              params: condition.media,
              source: parent.source
            });
            atRules.push(mediaNode);
          }
          if (typeof condition.supports !== "undefined") {
            const supportsNode = atRule2({
              name: "supports",
              params: `(${condition.supports})`,
              source: parent.source
            });
            atRules.push(supportsNode);
          }
          if (typeof condition.layer !== "undefined") {
            const layerNode = atRule2({
              name: "layer",
              params: condition.layer,
              source: parent.source
            });
            atRules.push(layerNode);
          }
        }
        const outerAtRule = atRules.shift();
        const innerAtRule = atRules.reduce((previous, next) => {
          previous.append(next);
          return next;
        }, outerAtRule);
        parent.insertBefore(nodes[0], outerAtRule);
        nodes.forEach((node3) => {
          node3.parent = void 0;
        });
        nodes[0].raws.before = nodes[0].raws.before || "\n";
        innerAtRule.append(nodes);
        stmt.type = "nodes";
        stmt.nodes = [outerAtRule];
        delete stmt.node;
      });
    };
    applyRaws$1 = function applyRaws(bundle2) {
      bundle2.forEach((stmt, index4) => {
        if (index4 === 0) return;
        if (stmt.parent) {
          const { before } = stmt.parent.node.raws;
          if (stmt.type === "nodes") stmt.nodes[0].raws.before = before;
          else stmt.node.raws.before = before;
        } else if (stmt.type === "nodes") {
          stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || "\n";
        }
      });
    };
    applyStyles$1 = function applyStyles(bundle2, styles) {
      styles.nodes = [];
      bundle2.forEach((stmt) => {
        if (["charset", "import"].includes(stmt.type)) {
          stmt.node.parent = void 0;
          styles.append(stmt.node);
        } else if (stmt.type === "nodes") {
          stmt.nodes.forEach((node3) => {
            node3.parent = void 0;
            styles.append(node3);
          });
        }
      });
    };
    readCache$1 = { exports: {} };
    pify$2 = { exports: {} };
    processFn = function(fn, P, opts) {
      return function() {
        var that = this;
        var args = new Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        return new P(function(resolve8, reject) {
          args.push(function(err, result) {
            if (err) {
              reject(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i2 = 1; i2 < arguments.length; i2++) {
                results[i2 - 1] = arguments[i2];
              }
              resolve8(results);
            } else {
              resolve8(result);
            }
          });
          fn.apply(that, args);
        });
      };
    };
    pify$1 = pify$2.exports = function(obj, P, opts) {
      if (typeof P !== "function") {
        opts = P;
        P = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter2 = function(key) {
        var match2 = function(pattern2) {
          return typeof pattern2 === "string" ? key === pattern2 : pattern2.test(key);
        };
        return opts.include ? opts.include.some(match2) : !opts.exclude.some(match2);
      };
      var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret2, key) {
        var x = obj[key];
        ret2[key] = typeof x === "function" && filter2(key) ? processFn(x, P, opts) : x;
        return ret2;
      }, ret);
    };
    pify$1.all = pify$1;
    pifyExports = pify$2.exports;
    fs = require$$0__default;
    path$3 = require$$0;
    pify = pifyExports;
    stat = pify(fs.stat);
    readFile = pify(fs.readFile);
    resolve2 = path$3.resolve;
    cache = /* @__PURE__ */ Object.create(null);
    readCache$1.exports = function(path9, encoding) {
      path9 = resolve2(path9);
      return stat(path9).then(function(stats) {
        var item = cache[path9];
        if (item && item.mtime.getTime() === stats.mtime.getTime()) {
          return convert(item.content, encoding);
        }
        return readFile(path9).then(function(data) {
          cache[path9] = {
            mtime: stats.mtime,
            content: data
          };
          return convert(data, encoding);
        });
      }).catch(function(err) {
        cache[path9] = null;
        return Promise.reject(err);
      });
    };
    readCache$1.exports.sync = function(path9, encoding) {
      path9 = resolve2(path9);
      try {
        var stats = fs.statSync(path9);
        var item = cache[path9];
        if (item && item.mtime.getTime() === stats.mtime.getTime()) {
          return convert(item.content, encoding);
        }
        var data = fs.readFileSync(path9);
        cache[path9] = {
          mtime: stats.mtime,
          content: data
        };
        return convert(data, encoding);
      } catch (err) {
        cache[path9] = null;
        throw err;
      }
    };
    readCache$1.exports.get = function(path9, encoding) {
      path9 = resolve2(path9);
      if (cache[path9]) {
        return convert(cache[path9].content, encoding);
      }
      return null;
    };
    readCache$1.exports.clear = function() {
      cache = /* @__PURE__ */ Object.create(null);
    };
    readCacheExports = readCache$1.exports;
    anyDataURLRegexp = /^data:text\/css(?:;(base64|plain))?,/i;
    base64DataURLRegexp = /^data:text\/css;base64,/i;
    plainDataURLRegexp = /^data:text\/css;plain,/i;
    dataUrl = {
      isValid,
      contents
    };
    readCache = readCacheExports;
    dataURL$1 = dataUrl;
    loadContent$1 = function loadContent(filename) {
      if (dataURL$1.isValid(filename)) {
        return dataURL$1.contents(filename);
      }
      return readCache(filename, "utf-8");
    };
    valueParser = lib;
    ({ stringify: stringify2 } = valueParser);
    parseStatements$1 = function parseStatements(result, styles, conditions, from) {
      const statements = [];
      let nodes = [];
      styles.each((node3) => {
        let stmt;
        if (node3.type === "atrule") {
          if (node3.name === "import")
            stmt = parseImport(result, node3, conditions, from);
          else if (node3.name === "charset")
            stmt = parseCharset(result, node3, conditions, from);
        }
        if (stmt) {
          if (nodes.length) {
            statements.push({
              type: "nodes",
              nodes,
              conditions: [...conditions],
              from
            });
            nodes = [];
          }
          statements.push(stmt);
        } else nodes.push(node3);
      });
      if (nodes.length) {
        statements.push({
          type: "nodes",
          nodes,
          conditions: [...conditions],
          from
        });
      }
      return statements;
    };
    path$2 = require$$0;
    processContent$1 = function processContent(result, content, filename, options2, postcss3) {
      const { plugins: plugins2 } = options2;
      const ext2 = path$2.extname(filename);
      const parserList = [];
      if (ext2 === ".sss") {
        if (!sugarss) {
          try {
            sugarss = __require2("sugarss");
          } catch {
          }
        }
        if (sugarss)
          return runPostcss(postcss3, content, filename, plugins2, [sugarss]);
      }
      if (result.opts.syntax?.parse) {
        parserList.push(result.opts.syntax.parse);
      }
      if (result.opts.parser) parserList.push(result.opts.parser);
      parserList.push(null);
      return runPostcss(postcss3, content, filename, plugins2, parserList);
    };
    path$1 = require$$0;
    dataURL = dataUrl;
    parseStatements2 = parseStatements$1;
    processContent2 = processContent$1;
    resolveId$1 = (id3) => id3;
    formatImportPrelude2 = formatImportPrelude$2;
    parseStyles_1 = parseStyles$1;
    path2 = require$$0;
    applyConditions2 = applyConditions$1;
    applyRaws2 = applyRaws$1;
    applyStyles2 = applyStyles$1;
    loadContent2 = loadContent$1;
    parseStyles = parseStyles_1;
    resolveId = (id3) => id3;
    AtImport.postcss = true;
    postcssImport = AtImport;
    index = /* @__PURE__ */ getDefaultExportFromCjs(postcssImport);
    index$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: index
    }, [postcssImport]);
  }
});

// node_modules/picocolors/picocolors.js
var require_picocolors = __commonJS({
  "node_modules/picocolors/picocolors.js"(exports2, module) {
    var p = process || {};
    var argv2 = p.argv || [];
    var env2 = p.env || {};
    var isColorSupported2 = !(!!env2.NO_COLOR || argv2.includes("--no-color")) && (!!env2.FORCE_COLOR || argv2.includes("--color") || p.platform === "win32" || (p.stdout || {}).isTTY && env2.TERM !== "dumb" || !!env2.CI);
    var formatter2 = (open2, close2, replace = open2) => (input) => {
      let string4 = "" + input, index4 = string4.indexOf(close2, open2.length);
      return ~index4 ? open2 + replaceClose2(string4, close2, replace, index4) + close2 : open2 + string4 + close2;
    };
    var replaceClose2 = (string4, close2, replace, index4) => {
      let result = "", cursor = 0;
      do {
        result += string4.substring(cursor, index4) + replace;
        cursor = index4 + close2.length;
        index4 = string4.indexOf(close2, cursor);
      } while (~index4);
      return result + string4.substring(cursor);
    };
    var createColors2 = (enabled = isColorSupported2) => {
      let f = enabled ? formatter2 : () => String;
      return {
        isColorSupported: enabled,
        reset: f("\x1B[0m", "\x1B[0m"),
        bold: f("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: f("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: f("\x1B[3m", "\x1B[23m"),
        underline: f("\x1B[4m", "\x1B[24m"),
        inverse: f("\x1B[7m", "\x1B[27m"),
        hidden: f("\x1B[8m", "\x1B[28m"),
        strikethrough: f("\x1B[9m", "\x1B[29m"),
        black: f("\x1B[30m", "\x1B[39m"),
        red: f("\x1B[31m", "\x1B[39m"),
        green: f("\x1B[32m", "\x1B[39m"),
        yellow: f("\x1B[33m", "\x1B[39m"),
        blue: f("\x1B[34m", "\x1B[39m"),
        magenta: f("\x1B[35m", "\x1B[39m"),
        cyan: f("\x1B[36m", "\x1B[39m"),
        white: f("\x1B[37m", "\x1B[39m"),
        gray: f("\x1B[90m", "\x1B[39m"),
        bgBlack: f("\x1B[40m", "\x1B[49m"),
        bgRed: f("\x1B[41m", "\x1B[49m"),
        bgGreen: f("\x1B[42m", "\x1B[49m"),
        bgYellow: f("\x1B[43m", "\x1B[49m"),
        bgBlue: f("\x1B[44m", "\x1B[49m"),
        bgMagenta: f("\x1B[45m", "\x1B[49m"),
        bgCyan: f("\x1B[46m", "\x1B[49m"),
        bgWhite: f("\x1B[47m", "\x1B[49m"),
        blackBright: f("\x1B[90m", "\x1B[39m"),
        redBright: f("\x1B[91m", "\x1B[39m"),
        greenBright: f("\x1B[92m", "\x1B[39m"),
        yellowBright: f("\x1B[93m", "\x1B[39m"),
        blueBright: f("\x1B[94m", "\x1B[39m"),
        magentaBright: f("\x1B[95m", "\x1B[39m"),
        cyanBright: f("\x1B[96m", "\x1B[39m"),
        whiteBright: f("\x1B[97m", "\x1B[39m"),
        bgBlackBright: f("\x1B[100m", "\x1B[49m"),
        bgRedBright: f("\x1B[101m", "\x1B[49m"),
        bgGreenBright: f("\x1B[102m", "\x1B[49m"),
        bgYellowBright: f("\x1B[103m", "\x1B[49m"),
        bgBlueBright: f("\x1B[104m", "\x1B[49m"),
        bgMagentaBright: f("\x1B[105m", "\x1B[49m"),
        bgCyanBright: f("\x1B[106m", "\x1B[49m"),
        bgWhiteBright: f("\x1B[107m", "\x1B[49m")
      };
    };
    module.exports = createColors2();
    module.exports.createColors = createColors2;
  }
});

// node_modules/postcss/lib/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/postcss/lib/tokenize.js"(exports2, module) {
    "use strict";
    var SINGLE_QUOTE2 = "'".charCodeAt(0);
    var DOUBLE_QUOTE2 = '"'.charCodeAt(0);
    var BACKSLASH = "\\".charCodeAt(0);
    var SLASH2 = "/".charCodeAt(0);
    var NEWLINE = "\n".charCodeAt(0);
    var SPACE = " ".charCodeAt(0);
    var FEED = "\f".charCodeAt(0);
    var TAB = "	".charCodeAt(0);
    var CR = "\r".charCodeAt(0);
    var OPEN_SQUARE = "[".charCodeAt(0);
    var CLOSE_SQUARE = "]".charCodeAt(0);
    var OPEN_PARENTHESES = "(".charCodeAt(0);
    var CLOSE_PARENTHESES = ")".charCodeAt(0);
    var OPEN_CURLY = "{".charCodeAt(0);
    var CLOSE_CURLY = "}".charCodeAt(0);
    var SEMICOLON = ";".charCodeAt(0);
    var ASTERISK = "*".charCodeAt(0);
    var COLON2 = ":".charCodeAt(0);
    var AT = "@".charCodeAt(0);
    var RE_AT_END = /[\t\n\f\r "#'()/;[\\\]{}]/g;
    var RE_WORD_END = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g;
    var RE_BAD_BRACKET = /.[\r\n"'(/\\]/;
    var RE_HEX_ESCAPE = /[\da-f]/i;
    module.exports = function tokenizer(input, options2 = {}) {
      let css = input.css.valueOf();
      let ignore = options2.ignoreErrors;
      let code, content, escape2, next, quote3;
      let currentToken, escaped2, escapePos, n, prev;
      let length = css.length;
      let pos = 0;
      let buffer = [];
      let returned = [];
      function position() {
        return pos;
      }
      function unclosed(what) {
        throw input.error("Unclosed " + what, pos);
      }
      function endOfFile() {
        return returned.length === 0 && pos >= length;
      }
      function nextToken(opts) {
        if (returned.length) return returned.pop();
        if (pos >= length) return;
        let ignoreUnclosed = opts ? opts.ignoreUnclosed : false;
        code = css.charCodeAt(pos);
        switch (code) {
          case NEWLINE:
          case SPACE:
          case TAB:
          case CR:
          case FEED: {
            next = pos;
            do {
              next += 1;
              code = css.charCodeAt(next);
            } while (code === SPACE || code === NEWLINE || code === TAB || code === CR || code === FEED);
            currentToken = ["space", css.slice(pos, next)];
            pos = next - 1;
            break;
          }
          case OPEN_SQUARE:
          case CLOSE_SQUARE:
          case OPEN_CURLY:
          case CLOSE_CURLY:
          case COLON2:
          case SEMICOLON:
          case CLOSE_PARENTHESES: {
            let controlChar = String.fromCharCode(code);
            currentToken = [controlChar, controlChar, pos];
            break;
          }
          case OPEN_PARENTHESES: {
            prev = buffer.length ? buffer.pop()[1] : "";
            n = css.charCodeAt(pos + 1);
            if (prev === "url" && n !== SINGLE_QUOTE2 && n !== DOUBLE_QUOTE2 && n !== SPACE && n !== NEWLINE && n !== TAB && n !== FEED && n !== CR) {
              next = pos;
              do {
                escaped2 = false;
                next = css.indexOf(")", next + 1);
                if (next === -1) {
                  if (ignore || ignoreUnclosed) {
                    next = pos;
                    break;
                  } else {
                    unclosed("bracket");
                  }
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                  escapePos -= 1;
                  escaped2 = !escaped2;
                }
              } while (escaped2);
              currentToken = ["brackets", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              next = css.indexOf(")", pos + 1);
              content = css.slice(pos, next + 1);
              if (next === -1 || RE_BAD_BRACKET.test(content)) {
                currentToken = ["(", "(", pos];
              } else {
                currentToken = ["brackets", content, pos, next];
                pos = next;
              }
            }
            break;
          }
          case SINGLE_QUOTE2:
          case DOUBLE_QUOTE2: {
            quote3 = code === SINGLE_QUOTE2 ? "'" : '"';
            next = pos;
            do {
              escaped2 = false;
              next = css.indexOf(quote3, next + 1);
              if (next === -1) {
                if (ignore || ignoreUnclosed) {
                  next = pos + 1;
                  break;
                } else {
                  unclosed("string");
                }
              }
              escapePos = next;
              while (css.charCodeAt(escapePos - 1) === BACKSLASH) {
                escapePos -= 1;
                escaped2 = !escaped2;
              }
            } while (escaped2);
            currentToken = ["string", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case AT: {
            RE_AT_END.lastIndex = pos + 1;
            RE_AT_END.test(css);
            if (RE_AT_END.lastIndex === 0) {
              next = css.length - 1;
            } else {
              next = RE_AT_END.lastIndex - 2;
            }
            currentToken = ["at-word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          case BACKSLASH: {
            next = pos;
            escape2 = true;
            while (css.charCodeAt(next + 1) === BACKSLASH) {
              next += 1;
              escape2 = !escape2;
            }
            code = css.charCodeAt(next + 1);
            if (escape2 && code !== SLASH2 && code !== SPACE && code !== NEWLINE && code !== TAB && code !== CR && code !== FEED) {
              next += 1;
              if (RE_HEX_ESCAPE.test(css.charAt(next))) {
                while (RE_HEX_ESCAPE.test(css.charAt(next + 1))) {
                  next += 1;
                }
                if (css.charCodeAt(next + 1) === SPACE) {
                  next += 1;
                }
              }
            }
            currentToken = ["word", css.slice(pos, next + 1), pos, next];
            pos = next;
            break;
          }
          default: {
            if (code === SLASH2 && css.charCodeAt(pos + 1) === ASTERISK) {
              next = css.indexOf("*/", pos + 2) + 1;
              if (next === 0) {
                if (ignore || ignoreUnclosed) {
                  next = css.length;
                } else {
                  unclosed("comment");
                }
              }
              currentToken = ["comment", css.slice(pos, next + 1), pos, next];
              pos = next;
            } else {
              RE_WORD_END.lastIndex = pos + 1;
              RE_WORD_END.test(css);
              if (RE_WORD_END.lastIndex === 0) {
                next = css.length - 1;
              } else {
                next = RE_WORD_END.lastIndex - 2;
              }
              currentToken = ["word", css.slice(pos, next + 1), pos, next];
              buffer.push(currentToken);
              pos = next;
            }
            break;
          }
        }
        pos++;
        return currentToken;
      }
      function back(token) {
        returned.push(token);
      }
      return {
        back,
        endOfFile,
        nextToken,
        position
      };
    };
  }
});

// node_modules/postcss/lib/terminal-highlight.js
var require_terminal_highlight = __commonJS({
  "node_modules/postcss/lib/terminal-highlight.js"(exports2, module) {
    "use strict";
    var pico = require_picocolors();
    var tokenizer = require_tokenize();
    var Input2;
    function registerInput(dependant) {
      Input2 = dependant;
    }
    var HIGHLIGHT_THEME = {
      ";": pico.yellow,
      ":": pico.yellow,
      "(": pico.cyan,
      ")": pico.cyan,
      "[": pico.yellow,
      "]": pico.yellow,
      "{": pico.yellow,
      "}": pico.yellow,
      "at-word": pico.cyan,
      "brackets": pico.cyan,
      "call": pico.cyan,
      "class": pico.yellow,
      "comment": pico.gray,
      "hash": pico.magenta,
      "string": pico.green
    };
    function getTokenType([type, value2], processor2) {
      if (type === "word") {
        if (value2[0] === ".") {
          return "class";
        }
        if (value2[0] === "#") {
          return "hash";
        }
      }
      if (!processor2.endOfFile()) {
        let next = processor2.nextToken();
        processor2.back(next);
        if (next[0] === "brackets" || next[0] === "(") return "call";
      }
      return type;
    }
    function terminalHighlight(css) {
      let processor2 = tokenizer(new Input2(css), { ignoreErrors: true });
      let result = "";
      while (!processor2.endOfFile()) {
        let token = processor2.nextToken();
        let color = HIGHLIGHT_THEME[getTokenType(token, processor2)];
        if (color) {
          result += token[1].split(/\r?\n/).map((i) => color(i)).join("\n");
        } else {
          result += token[1];
        }
      }
      return result;
    }
    terminalHighlight.registerInput = registerInput;
    module.exports = terminalHighlight;
  }
});

// node_modules/postcss/lib/css-syntax-error.js
var require_css_syntax_error = __commonJS({
  "node_modules/postcss/lib/css-syntax-error.js"(exports2, module) {
    "use strict";
    var pico = require_picocolors();
    var terminalHighlight = require_terminal_highlight();
    var CssSyntaxError2 = class _CssSyntaxError extends Error {
      constructor(message, line, column, source, file, plugin3) {
        super(message);
        this.name = "CssSyntaxError";
        this.reason = message;
        if (file) {
          this.file = file;
        }
        if (source) {
          this.source = source;
        }
        if (plugin3) {
          this.plugin = plugin3;
        }
        if (typeof line !== "undefined" && typeof column !== "undefined") {
          if (typeof line === "number") {
            this.line = line;
            this.column = column;
          } else {
            this.line = line.line;
            this.column = line.column;
            this.endLine = column.line;
            this.endColumn = column.column;
          }
        }
        this.setMessage();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _CssSyntaxError);
        }
      }
      setMessage() {
        this.message = this.plugin ? this.plugin + ": " : "";
        this.message += this.file ? this.file : "<css input>";
        if (typeof this.line !== "undefined") {
          this.message += ":" + this.line + ":" + this.column;
        }
        this.message += ": " + this.reason;
      }
      showSourceCode(color) {
        if (!this.source) return "";
        let css = this.source;
        if (color == null) color = pico.isColorSupported;
        let aside = (text2) => text2;
        let mark = (text2) => text2;
        let highlight = (text2) => text2;
        if (color) {
          let { bold, gray, red } = pico.createColors(true);
          mark = (text2) => bold(red(text2));
          aside = (text2) => gray(text2);
          if (terminalHighlight) {
            highlight = (text2) => terminalHighlight(text2);
          }
        }
        let lines = css.split(/\r?\n/);
        let start = Math.max(this.line - 3, 0);
        let end = Math.min(this.line + 2, lines.length);
        let maxWidth = String(end).length;
        return lines.slice(start, end).map((line, index4) => {
          let number = start + 1 + index4;
          let gutter = " " + (" " + number).slice(-maxWidth) + " | ";
          if (number === this.line) {
            if (line.length > 160) {
              let padding = 20;
              let subLineStart = Math.max(0, this.column - padding);
              let subLineEnd = Math.max(
                this.column + padding,
                this.endColumn + padding
              );
              let subLine = line.slice(subLineStart, subLineEnd);
              let spacing2 = aside(gutter.replace(/\d/g, " ")) + line.slice(0, Math.min(this.column - 1, padding - 1)).replace(/[^\t]/g, " ");
              return mark(">") + aside(gutter) + highlight(subLine) + "\n " + spacing2 + mark("^");
            }
            let spacing = aside(gutter.replace(/\d/g, " ")) + line.slice(0, this.column - 1).replace(/[^\t]/g, " ");
            return mark(">") + aside(gutter) + highlight(line) + "\n " + spacing + mark("^");
          }
          return " " + aside(gutter) + highlight(line);
        }).join("\n");
      }
      toString() {
        let code = this.showSourceCode();
        if (code) {
          code = "\n\n" + code + "\n";
        }
        return this.name + ": " + this.message + code;
      }
    };
    module.exports = CssSyntaxError2;
    CssSyntaxError2.default = CssSyntaxError2;
  }
});

// node_modules/postcss/lib/stringifier.js
var require_stringifier = __commonJS({
  "node_modules/postcss/lib/stringifier.js"(exports2, module) {
    "use strict";
    var DEFAULT_RAW = {
      after: "\n",
      beforeClose: "\n",
      beforeComment: "\n",
      beforeDecl: "\n",
      beforeOpen: " ",
      beforeRule: "\n",
      colon: ": ",
      commentLeft: " ",
      commentRight: " ",
      emptyBody: "",
      indent: "    ",
      semicolon: false
    };
    function capitalize2(str2) {
      return str2[0].toUpperCase() + str2.slice(1);
    }
    var Stringifier = class {
      constructor(builder) {
        this.builder = builder;
      }
      atrule(node3, semicolon4) {
        let name2 = "@" + node3.name;
        let params = node3.params ? this.rawValue(node3, "params") : "";
        if (typeof node3.raws.afterName !== "undefined") {
          name2 += node3.raws.afterName;
        } else if (params) {
          name2 += " ";
        }
        if (node3.nodes) {
          this.block(node3, name2 + params);
        } else {
          let end = (node3.raws.between || "") + (semicolon4 ? ";" : "");
          this.builder(name2 + params + end, node3);
        }
      }
      beforeAfter(node3, detect) {
        let value2;
        if (node3.type === "decl") {
          value2 = this.raw(node3, null, "beforeDecl");
        } else if (node3.type === "comment") {
          value2 = this.raw(node3, null, "beforeComment");
        } else if (detect === "before") {
          value2 = this.raw(node3, null, "beforeRule");
        } else {
          value2 = this.raw(node3, null, "beforeClose");
        }
        let buf = node3.parent;
        let depth2 = 0;
        while (buf && buf.type !== "root") {
          depth2 += 1;
          buf = buf.parent;
        }
        if (value2.includes("\n")) {
          let indent = this.raw(node3, null, "indent");
          if (indent.length) {
            for (let step = 0; step < depth2; step++) value2 += indent;
          }
        }
        return value2;
      }
      block(node3, start) {
        let between = this.raw(node3, "between", "beforeOpen");
        this.builder(start + between + "{", node3, "start");
        let after;
        if (node3.nodes && node3.nodes.length) {
          this.body(node3);
          after = this.raw(node3, "after");
        } else {
          after = this.raw(node3, "after", "emptyBody");
        }
        if (after) this.builder(after);
        this.builder("}", node3, "end");
      }
      body(node3) {
        let last = node3.nodes.length - 1;
        while (last > 0) {
          if (node3.nodes[last].type !== "comment") break;
          last -= 1;
        }
        let semicolon4 = this.raw(node3, "semicolon");
        for (let i = 0; i < node3.nodes.length; i++) {
          let child = node3.nodes[i];
          let before = this.raw(child, "before");
          if (before) this.builder(before);
          this.stringify(child, last !== i || semicolon4);
        }
      }
      comment(node3) {
        let left = this.raw(node3, "left", "commentLeft");
        let right = this.raw(node3, "right", "commentRight");
        this.builder("/*" + left + node3.text + right + "*/", node3);
      }
      decl(node3, semicolon4) {
        let between = this.raw(node3, "between", "colon");
        let string4 = node3.prop + between + this.rawValue(node3, "value");
        if (node3.important) {
          string4 += node3.raws.important || " !important";
        }
        if (semicolon4) string4 += ";";
        this.builder(string4, node3);
      }
      document(node3) {
        this.body(node3);
      }
      raw(node3, own, detect) {
        let value2;
        if (!detect) detect = own;
        if (own) {
          value2 = node3.raws[own];
          if (typeof value2 !== "undefined") return value2;
        }
        let parent = node3.parent;
        if (detect === "before") {
          if (!parent || parent.type === "root" && parent.first === node3) {
            return "";
          }
          if (parent && parent.type === "document") {
            return "";
          }
        }
        if (!parent) return DEFAULT_RAW[detect];
        let root4 = node3.root();
        if (!root4.rawCache) root4.rawCache = {};
        if (typeof root4.rawCache[detect] !== "undefined") {
          return root4.rawCache[detect];
        }
        if (detect === "before" || detect === "after") {
          return this.beforeAfter(node3, detect);
        } else {
          let method = "raw" + capitalize2(detect);
          if (this[method]) {
            value2 = this[method](root4, node3);
          } else {
            root4.walk((i) => {
              value2 = i.raws[own];
              if (typeof value2 !== "undefined") return false;
            });
          }
        }
        if (typeof value2 === "undefined") value2 = DEFAULT_RAW[detect];
        root4.rawCache[detect] = value2;
        return value2;
      }
      rawBeforeClose(root4) {
        let value2;
        root4.walk((i) => {
          if (i.nodes && i.nodes.length > 0) {
            if (typeof i.raws.after !== "undefined") {
              value2 = i.raws.after;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value2) value2 = value2.replace(/\S/g, "");
        return value2;
      }
      rawBeforeComment(root4, node3) {
        let value2;
        root4.walkComments((i) => {
          if (typeof i.raws.before !== "undefined") {
            value2 = i.raws.before;
            if (value2.includes("\n")) {
              value2 = value2.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value2 === "undefined") {
          value2 = this.raw(node3, null, "beforeDecl");
        } else if (value2) {
          value2 = value2.replace(/\S/g, "");
        }
        return value2;
      }
      rawBeforeDecl(root4, node3) {
        let value2;
        root4.walkDecls((i) => {
          if (typeof i.raws.before !== "undefined") {
            value2 = i.raws.before;
            if (value2.includes("\n")) {
              value2 = value2.replace(/[^\n]+$/, "");
            }
            return false;
          }
        });
        if (typeof value2 === "undefined") {
          value2 = this.raw(node3, null, "beforeRule");
        } else if (value2) {
          value2 = value2.replace(/\S/g, "");
        }
        return value2;
      }
      rawBeforeOpen(root4) {
        let value2;
        root4.walk((i) => {
          if (i.type !== "decl") {
            value2 = i.raws.between;
            if (typeof value2 !== "undefined") return false;
          }
        });
        return value2;
      }
      rawBeforeRule(root4) {
        let value2;
        root4.walk((i) => {
          if (i.nodes && (i.parent !== root4 || root4.first !== i)) {
            if (typeof i.raws.before !== "undefined") {
              value2 = i.raws.before;
              if (value2.includes("\n")) {
                value2 = value2.replace(/[^\n]+$/, "");
              }
              return false;
            }
          }
        });
        if (value2) value2 = value2.replace(/\S/g, "");
        return value2;
      }
      rawColon(root4) {
        let value2;
        root4.walkDecls((i) => {
          if (typeof i.raws.between !== "undefined") {
            value2 = i.raws.between.replace(/[^\s:]/g, "");
            return false;
          }
        });
        return value2;
      }
      rawEmptyBody(root4) {
        let value2;
        root4.walk((i) => {
          if (i.nodes && i.nodes.length === 0) {
            value2 = i.raws.after;
            if (typeof value2 !== "undefined") return false;
          }
        });
        return value2;
      }
      rawIndent(root4) {
        if (root4.raws.indent) return root4.raws.indent;
        let value2;
        root4.walk((i) => {
          let p = i.parent;
          if (p && p !== root4 && p.parent && p.parent === root4) {
            if (typeof i.raws.before !== "undefined") {
              let parts = i.raws.before.split("\n");
              value2 = parts[parts.length - 1];
              value2 = value2.replace(/\S/g, "");
              return false;
            }
          }
        });
        return value2;
      }
      rawSemicolon(root4) {
        let value2;
        root4.walk((i) => {
          if (i.nodes && i.nodes.length && i.last.type === "decl") {
            value2 = i.raws.semicolon;
            if (typeof value2 !== "undefined") return false;
          }
        });
        return value2;
      }
      rawValue(node3, prop) {
        let value2 = node3[prop];
        let raw = node3.raws[prop];
        if (raw && raw.value === value2) {
          return raw.raw;
        }
        return value2;
      }
      root(node3) {
        this.body(node3);
        if (node3.raws.after) this.builder(node3.raws.after);
      }
      rule(node3) {
        this.block(node3, this.rawValue(node3, "selector"));
        if (node3.raws.ownSemicolon) {
          this.builder(node3.raws.ownSemicolon, node3, "end");
        }
      }
      stringify(node3, semicolon4) {
        if (!this[node3.type]) {
          throw new Error(
            "Unknown AST node type " + node3.type + ". Maybe you need to change PostCSS stringifier."
          );
        }
        this[node3.type](node3, semicolon4);
      }
    };
    module.exports = Stringifier;
    Stringifier.default = Stringifier;
  }
});

// node_modules/postcss/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/postcss/lib/stringify.js"(exports2, module) {
    "use strict";
    var Stringifier = require_stringifier();
    function stringify5(node3, builder) {
      let str2 = new Stringifier(builder);
      str2.stringify(node3);
    }
    module.exports = stringify5;
    stringify5.default = stringify5;
  }
});

// node_modules/postcss/lib/symbols.js
var require_symbols = __commonJS({
  "node_modules/postcss/lib/symbols.js"(exports2, module) {
    "use strict";
    module.exports.isClean = Symbol("isClean");
    module.exports.my = Symbol("my");
  }
});

// node_modules/postcss/lib/node.js
var require_node = __commonJS({
  "node_modules/postcss/lib/node.js"(exports2, module) {
    "use strict";
    var CssSyntaxError2 = require_css_syntax_error();
    var Stringifier = require_stringifier();
    var stringify5 = require_stringify();
    var { isClean, my } = require_symbols();
    function cloneNode(obj, parent) {
      let cloned = new obj.constructor();
      for (let i in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, i)) {
          continue;
        }
        if (i === "proxyCache") continue;
        let value2 = obj[i];
        let type = typeof value2;
        if (i === "parent" && type === "object") {
          if (parent) cloned[i] = parent;
        } else if (i === "source") {
          cloned[i] = value2;
        } else if (Array.isArray(value2)) {
          cloned[i] = value2.map((j) => cloneNode(j, cloned));
        } else {
          if (type === "object" && value2 !== null) value2 = cloneNode(value2);
          cloned[i] = value2;
        }
      }
      return cloned;
    }
    var Node2 = class {
      constructor(defaults2 = {}) {
        this.raws = {};
        this[isClean] = false;
        this[my] = true;
        for (let name2 in defaults2) {
          if (name2 === "nodes") {
            this.nodes = [];
            for (let node3 of defaults2[name2]) {
              if (typeof node3.clone === "function") {
                this.append(node3.clone());
              } else {
                this.append(node3);
              }
            }
          } else {
            this[name2] = defaults2[name2];
          }
        }
      }
      addToError(error) {
        error.postcssNode = this;
        if (error.stack && this.source && /\n\s{4}at /.test(error.stack)) {
          let s = this.source;
          error.stack = error.stack.replace(
            /\n\s{4}at /,
            `$&${s.input.from}:${s.start.line}:${s.start.column}$&`
          );
        }
        return error;
      }
      after(add) {
        this.parent.insertAfter(this, add);
        return this;
      }
      assign(overrides = {}) {
        for (let name2 in overrides) {
          this[name2] = overrides[name2];
        }
        return this;
      }
      before(add) {
        this.parent.insertBefore(this, add);
        return this;
      }
      cleanRaws(keepBetween) {
        delete this.raws.before;
        delete this.raws.after;
        if (!keepBetween) delete this.raws.between;
      }
      clone(overrides = {}) {
        let cloned = cloneNode(this);
        for (let name2 in overrides) {
          cloned[name2] = overrides[name2];
        }
        return cloned;
      }
      cloneAfter(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertAfter(this, cloned);
        return cloned;
      }
      cloneBefore(overrides = {}) {
        let cloned = this.clone(overrides);
        this.parent.insertBefore(this, cloned);
        return cloned;
      }
      error(message, opts = {}) {
        if (this.source) {
          let { end, start } = this.rangeBy(opts);
          return this.source.input.error(
            message,
            { column: start.column, line: start.line },
            { column: end.column, line: end.line },
            opts
          );
        }
        return new CssSyntaxError2(message);
      }
      getProxyProcessor() {
        return {
          get(node3, prop) {
            if (prop === "proxyOf") {
              return node3;
            } else if (prop === "root") {
              return () => node3.root().toProxy();
            } else {
              return node3[prop];
            }
          },
          set(node3, prop, value2) {
            if (node3[prop] === value2) return true;
            node3[prop] = value2;
            if (prop === "prop" || prop === "value" || prop === "name" || prop === "params" || prop === "important" || /* c8 ignore next */
            prop === "text") {
              node3.markDirty();
            }
            return true;
          }
        };
      }
      /* c8 ignore next 3 */
      markClean() {
        this[isClean] = true;
      }
      markDirty() {
        if (this[isClean]) {
          this[isClean] = false;
          let next = this;
          while (next = next.parent) {
            next[isClean] = false;
          }
        }
      }
      next() {
        if (!this.parent) return void 0;
        let index4 = this.parent.index(this);
        return this.parent.nodes[index4 + 1];
      }
      positionBy(opts, stringRepresentation) {
        let pos = this.source.start;
        if (opts.index) {
          pos = this.positionInside(opts.index, stringRepresentation);
        } else if (opts.word) {
          stringRepresentation = this.toString();
          let index4 = stringRepresentation.indexOf(opts.word);
          if (index4 !== -1) pos = this.positionInside(index4, stringRepresentation);
        }
        return pos;
      }
      positionInside(index4, stringRepresentation) {
        let string4 = stringRepresentation || this.toString();
        let column = this.source.start.column;
        let line = this.source.start.line;
        for (let i = 0; i < index4; i++) {
          if (string4[i] === "\n") {
            column = 1;
            line += 1;
          } else {
            column += 1;
          }
        }
        return { column, line };
      }
      prev() {
        if (!this.parent) return void 0;
        let index4 = this.parent.index(this);
        return this.parent.nodes[index4 - 1];
      }
      rangeBy(opts) {
        let start = {
          column: this.source.start.column,
          line: this.source.start.line
        };
        let end = this.source.end ? {
          column: this.source.end.column + 1,
          line: this.source.end.line
        } : {
          column: start.column + 1,
          line: start.line
        };
        if (opts.word) {
          let stringRepresentation = this.toString();
          let index4 = stringRepresentation.indexOf(opts.word);
          if (index4 !== -1) {
            start = this.positionInside(index4, stringRepresentation);
            end = this.positionInside(
              index4 + opts.word.length,
              stringRepresentation
            );
          }
        } else {
          if (opts.start) {
            start = {
              column: opts.start.column,
              line: opts.start.line
            };
          } else if (opts.index) {
            start = this.positionInside(opts.index);
          }
          if (opts.end) {
            end = {
              column: opts.end.column,
              line: opts.end.line
            };
          } else if (typeof opts.endIndex === "number") {
            end = this.positionInside(opts.endIndex);
          } else if (opts.index) {
            end = this.positionInside(opts.index + 1);
          }
        }
        if (end.line < start.line || end.line === start.line && end.column <= start.column) {
          end = { column: start.column + 1, line: start.line };
        }
        return { end, start };
      }
      raw(prop, defaultType) {
        let str2 = new Stringifier();
        return str2.raw(this, prop, defaultType);
      }
      remove() {
        if (this.parent) {
          this.parent.removeChild(this);
        }
        this.parent = void 0;
        return this;
      }
      replaceWith(...nodes) {
        if (this.parent) {
          let bookmark = this;
          let foundSelf = false;
          for (let node3 of nodes) {
            if (node3 === this) {
              foundSelf = true;
            } else if (foundSelf) {
              this.parent.insertAfter(bookmark, node3);
              bookmark = node3;
            } else {
              this.parent.insertBefore(bookmark, node3);
            }
          }
          if (!foundSelf) {
            this.remove();
          }
        }
        return this;
      }
      root() {
        let result = this;
        while (result.parent && result.parent.type !== "document") {
          result = result.parent;
        }
        return result;
      }
      toJSON(_, inputs) {
        let fixed = {};
        let emitInputs = inputs == null;
        inputs = inputs || /* @__PURE__ */ new Map();
        let inputsNextIndex = 0;
        for (let name2 in this) {
          if (!Object.prototype.hasOwnProperty.call(this, name2)) {
            continue;
          }
          if (name2 === "parent" || name2 === "proxyCache") continue;
          let value2 = this[name2];
          if (Array.isArray(value2)) {
            fixed[name2] = value2.map((i) => {
              if (typeof i === "object" && i.toJSON) {
                return i.toJSON(null, inputs);
              } else {
                return i;
              }
            });
          } else if (typeof value2 === "object" && value2.toJSON) {
            fixed[name2] = value2.toJSON(null, inputs);
          } else if (name2 === "source") {
            let inputId = inputs.get(value2.input);
            if (inputId == null) {
              inputId = inputsNextIndex;
              inputs.set(value2.input, inputsNextIndex);
              inputsNextIndex++;
            }
            fixed[name2] = {
              end: value2.end,
              inputId,
              start: value2.start
            };
          } else {
            fixed[name2] = value2;
          }
        }
        if (emitInputs) {
          fixed.inputs = [...inputs.keys()].map((input) => input.toJSON());
        }
        return fixed;
      }
      toProxy() {
        if (!this.proxyCache) {
          this.proxyCache = new Proxy(this, this.getProxyProcessor());
        }
        return this.proxyCache;
      }
      toString(stringifier = stringify5) {
        if (stringifier.stringify) stringifier = stringifier.stringify;
        let result = "";
        stringifier(this, (i) => {
          result += i;
        });
        return result;
      }
      warn(result, text2, opts) {
        let data = { node: this };
        for (let i in opts) data[i] = opts[i];
        return result.warn(text2, data);
      }
      get proxyOf() {
        return this;
      }
    };
    module.exports = Node2;
    Node2.default = Node2;
  }
});

// node_modules/postcss/lib/comment.js
var require_comment = __commonJS({
  "node_modules/postcss/lib/comment.js"(exports2, module) {
    "use strict";
    var Node2 = require_node();
    var Comment2 = class extends Node2 {
      constructor(defaults2) {
        super(defaults2);
        this.type = "comment";
      }
    };
    module.exports = Comment2;
    Comment2.default = Comment2;
  }
});

// node_modules/postcss/lib/declaration.js
var require_declaration = __commonJS({
  "node_modules/postcss/lib/declaration.js"(exports2, module) {
    "use strict";
    var Node2 = require_node();
    var Declaration2 = class extends Node2 {
      constructor(defaults2) {
        if (defaults2 && typeof defaults2.value !== "undefined" && typeof defaults2.value !== "string") {
          defaults2 = { ...defaults2, value: String(defaults2.value) };
        }
        super(defaults2);
        this.type = "decl";
      }
      get variable() {
        return this.prop.startsWith("--") || this.prop[0] === "$";
      }
    };
    module.exports = Declaration2;
    Declaration2.default = Declaration2;
  }
});

// node_modules/postcss/lib/container.js
var require_container = __commonJS({
  "node_modules/postcss/lib/container.js"(exports2, module) {
    "use strict";
    var Comment2 = require_comment();
    var Declaration2 = require_declaration();
    var Node2 = require_node();
    var { isClean, my } = require_symbols();
    var AtRule2;
    var parse6;
    var Root2;
    var Rule2;
    function cleanSource(nodes) {
      return nodes.map((i) => {
        if (i.nodes) i.nodes = cleanSource(i.nodes);
        delete i.source;
        return i;
      });
    }
    function markTreeDirty(node3) {
      node3[isClean] = false;
      if (node3.proxyOf.nodes) {
        for (let i of node3.proxyOf.nodes) {
          markTreeDirty(i);
        }
      }
    }
    var Container2 = class _Container extends Node2 {
      append(...children) {
        for (let child of children) {
          let nodes = this.normalize(child, this.last);
          for (let node3 of nodes) this.proxyOf.nodes.push(node3);
        }
        this.markDirty();
        return this;
      }
      cleanRaws(keepBetween) {
        super.cleanRaws(keepBetween);
        if (this.nodes) {
          for (let node3 of this.nodes) node3.cleanRaws(keepBetween);
        }
      }
      each(callback) {
        if (!this.proxyOf.nodes) return void 0;
        let iterator = this.getIterator();
        let index4, result;
        while (this.indexes[iterator] < this.proxyOf.nodes.length) {
          index4 = this.indexes[iterator];
          result = callback(this.proxyOf.nodes[index4], index4);
          if (result === false) break;
          this.indexes[iterator] += 1;
        }
        delete this.indexes[iterator];
        return result;
      }
      every(condition) {
        return this.nodes.every(condition);
      }
      getIterator() {
        if (!this.lastEach) this.lastEach = 0;
        if (!this.indexes) this.indexes = {};
        this.lastEach += 1;
        let iterator = this.lastEach;
        this.indexes[iterator] = 0;
        return iterator;
      }
      getProxyProcessor() {
        return {
          get(node3, prop) {
            if (prop === "proxyOf") {
              return node3;
            } else if (!node3[prop]) {
              return node3[prop];
            } else if (prop === "each" || typeof prop === "string" && prop.startsWith("walk")) {
              return (...args) => {
                return node3[prop](
                  ...args.map((i) => {
                    if (typeof i === "function") {
                      return (child, index4) => i(child.toProxy(), index4);
                    } else {
                      return i;
                    }
                  })
                );
              };
            } else if (prop === "every" || prop === "some") {
              return (cb) => {
                return node3[prop](
                  (child, ...other) => cb(child.toProxy(), ...other)
                );
              };
            } else if (prop === "root") {
              return () => node3.root().toProxy();
            } else if (prop === "nodes") {
              return node3.nodes.map((i) => i.toProxy());
            } else if (prop === "first" || prop === "last") {
              return node3[prop].toProxy();
            } else {
              return node3[prop];
            }
          },
          set(node3, prop, value2) {
            if (node3[prop] === value2) return true;
            node3[prop] = value2;
            if (prop === "name" || prop === "params" || prop === "selector") {
              node3.markDirty();
            }
            return true;
          }
        };
      }
      index(child) {
        if (typeof child === "number") return child;
        if (child.proxyOf) child = child.proxyOf;
        return this.proxyOf.nodes.indexOf(child);
      }
      insertAfter(exist, add) {
        let existIndex = this.index(exist);
        let nodes = this.normalize(add, this.proxyOf.nodes[existIndex]).reverse();
        existIndex = this.index(exist);
        for (let node3 of nodes) this.proxyOf.nodes.splice(existIndex + 1, 0, node3);
        let index4;
        for (let id3 in this.indexes) {
          index4 = this.indexes[id3];
          if (existIndex < index4) {
            this.indexes[id3] = index4 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      insertBefore(exist, add) {
        let existIndex = this.index(exist);
        let type = existIndex === 0 ? "prepend" : false;
        let nodes = this.normalize(
          add,
          this.proxyOf.nodes[existIndex],
          type
        ).reverse();
        existIndex = this.index(exist);
        for (let node3 of nodes) this.proxyOf.nodes.splice(existIndex, 0, node3);
        let index4;
        for (let id3 in this.indexes) {
          index4 = this.indexes[id3];
          if (existIndex <= index4) {
            this.indexes[id3] = index4 + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      normalize(nodes, sample) {
        if (typeof nodes === "string") {
          nodes = cleanSource(parse6(nodes).nodes);
        } else if (typeof nodes === "undefined") {
          nodes = [];
        } else if (Array.isArray(nodes)) {
          nodes = nodes.slice(0);
          for (let i of nodes) {
            if (i.parent) i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type === "root" && this.type !== "document") {
          nodes = nodes.nodes.slice(0);
          for (let i of nodes) {
            if (i.parent) i.parent.removeChild(i, "ignore");
          }
        } else if (nodes.type) {
          nodes = [nodes];
        } else if (nodes.prop) {
          if (typeof nodes.value === "undefined") {
            throw new Error("Value field is missed in node creation");
          } else if (typeof nodes.value !== "string") {
            nodes.value = String(nodes.value);
          }
          nodes = [new Declaration2(nodes)];
        } else if (nodes.selector || nodes.selectors) {
          nodes = [new Rule2(nodes)];
        } else if (nodes.name) {
          nodes = [new AtRule2(nodes)];
        } else if (nodes.text) {
          nodes = [new Comment2(nodes)];
        } else {
          throw new Error("Unknown node type in node creation");
        }
        let processed = nodes.map((i) => {
          if (!i[my]) _Container.rebuild(i);
          i = i.proxyOf;
          if (i.parent) i.parent.removeChild(i);
          if (i[isClean]) markTreeDirty(i);
          if (!i.raws) i.raws = {};
          if (typeof i.raws.before === "undefined") {
            if (sample && typeof sample.raws.before !== "undefined") {
              i.raws.before = sample.raws.before.replace(/\S/g, "");
            }
          }
          i.parent = this.proxyOf;
          return i;
        });
        return processed;
      }
      prepend(...children) {
        children = children.reverse();
        for (let child of children) {
          let nodes = this.normalize(child, this.first, "prepend").reverse();
          for (let node3 of nodes) this.proxyOf.nodes.unshift(node3);
          for (let id3 in this.indexes) {
            this.indexes[id3] = this.indexes[id3] + nodes.length;
          }
        }
        this.markDirty();
        return this;
      }
      push(child) {
        child.parent = this;
        this.proxyOf.nodes.push(child);
        return this;
      }
      removeAll() {
        for (let node3 of this.proxyOf.nodes) node3.parent = void 0;
        this.proxyOf.nodes = [];
        this.markDirty();
        return this;
      }
      removeChild(child) {
        child = this.index(child);
        this.proxyOf.nodes[child].parent = void 0;
        this.proxyOf.nodes.splice(child, 1);
        let index4;
        for (let id3 in this.indexes) {
          index4 = this.indexes[id3];
          if (index4 >= child) {
            this.indexes[id3] = index4 - 1;
          }
        }
        this.markDirty();
        return this;
      }
      replaceValues(pattern2, opts, callback) {
        if (!callback) {
          callback = opts;
          opts = {};
        }
        this.walkDecls((decl2) => {
          if (opts.props && !opts.props.includes(decl2.prop)) return;
          if (opts.fast && !decl2.value.includes(opts.fast)) return;
          decl2.value = decl2.value.replace(pattern2, callback);
        });
        this.markDirty();
        return this;
      }
      some(condition) {
        return this.nodes.some(condition);
      }
      walk(callback) {
        return this.each((child, i) => {
          let result;
          try {
            result = callback(child, i);
          } catch (e) {
            throw child.addToError(e);
          }
          if (result !== false && child.walk) {
            result = child.walk(callback);
          }
          return result;
        });
      }
      walkAtRules(name2, callback) {
        if (!callback) {
          callback = name2;
          return this.walk((child, i) => {
            if (child.type === "atrule") {
              return callback(child, i);
            }
          });
        }
        if (name2 instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "atrule" && name2.test(child.name)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "atrule" && child.name === name2) {
            return callback(child, i);
          }
        });
      }
      walkComments(callback) {
        return this.walk((child, i) => {
          if (child.type === "comment") {
            return callback(child, i);
          }
        });
      }
      walkDecls(prop, callback) {
        if (!callback) {
          callback = prop;
          return this.walk((child, i) => {
            if (child.type === "decl") {
              return callback(child, i);
            }
          });
        }
        if (prop instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "decl" && prop.test(child.prop)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "decl" && child.prop === prop) {
            return callback(child, i);
          }
        });
      }
      walkRules(selector3, callback) {
        if (!callback) {
          callback = selector3;
          return this.walk((child, i) => {
            if (child.type === "rule") {
              return callback(child, i);
            }
          });
        }
        if (selector3 instanceof RegExp) {
          return this.walk((child, i) => {
            if (child.type === "rule" && selector3.test(child.selector)) {
              return callback(child, i);
            }
          });
        }
        return this.walk((child, i) => {
          if (child.type === "rule" && child.selector === selector3) {
            return callback(child, i);
          }
        });
      }
      get first() {
        if (!this.proxyOf.nodes) return void 0;
        return this.proxyOf.nodes[0];
      }
      get last() {
        if (!this.proxyOf.nodes) return void 0;
        return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
      }
    };
    Container2.registerParse = (dependant) => {
      parse6 = dependant;
    };
    Container2.registerRule = (dependant) => {
      Rule2 = dependant;
    };
    Container2.registerAtRule = (dependant) => {
      AtRule2 = dependant;
    };
    Container2.registerRoot = (dependant) => {
      Root2 = dependant;
    };
    module.exports = Container2;
    Container2.default = Container2;
    Container2.rebuild = (node3) => {
      if (node3.type === "atrule") {
        Object.setPrototypeOf(node3, AtRule2.prototype);
      } else if (node3.type === "rule") {
        Object.setPrototypeOf(node3, Rule2.prototype);
      } else if (node3.type === "decl") {
        Object.setPrototypeOf(node3, Declaration2.prototype);
      } else if (node3.type === "comment") {
        Object.setPrototypeOf(node3, Comment2.prototype);
      } else if (node3.type === "root") {
        Object.setPrototypeOf(node3, Root2.prototype);
      }
      node3[my] = true;
      if (node3.nodes) {
        node3.nodes.forEach((child) => {
          Container2.rebuild(child);
        });
      }
    };
  }
});

// node_modules/postcss/lib/at-rule.js
var require_at_rule = __commonJS({
  "node_modules/postcss/lib/at-rule.js"(exports2, module) {
    "use strict";
    var Container2 = require_container();
    var AtRule2 = class extends Container2 {
      constructor(defaults2) {
        super(defaults2);
        this.type = "atrule";
      }
      append(...children) {
        if (!this.proxyOf.nodes) this.nodes = [];
        return super.append(...children);
      }
      prepend(...children) {
        if (!this.proxyOf.nodes) this.nodes = [];
        return super.prepend(...children);
      }
    };
    module.exports = AtRule2;
    AtRule2.default = AtRule2;
    Container2.registerAtRule(AtRule2);
  }
});

// node_modules/postcss/lib/document.js
var require_document = __commonJS({
  "node_modules/postcss/lib/document.js"(exports2, module) {
    "use strict";
    var Container2 = require_container();
    var LazyResult;
    var Processor3;
    var Document3 = class extends Container2 {
      constructor(defaults2) {
        super({ type: "document", ...defaults2 });
        if (!this.nodes) {
          this.nodes = [];
        }
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor3(), this, opts);
        return lazy.stringify();
      }
    };
    Document3.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Document3.registerProcessor = (dependant) => {
      Processor3 = dependant;
    };
    module.exports = Document3;
    Document3.default = Document3;
  }
});

// node_modules/nanoid/non-secure/index.cjs
var require_non_secure = __commonJS({
  "node_modules/nanoid/non-secure/index.cjs"(exports2, module) {
    var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var customAlphabet = (alphabet, defaultSize = 21) => {
      return (size = defaultSize) => {
        let id3 = "";
        let i = size | 0;
        while (i--) {
          id3 += alphabet[Math.random() * alphabet.length | 0];
        }
        return id3;
      };
    };
    var nanoid = (size = 21) => {
      let id3 = "";
      let i = size | 0;
      while (i--) {
        id3 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id3;
    };
    module.exports = { nanoid, customAlphabet };
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus3 = 43;
      var slash4 = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus3) {
        return 62;
      }
      if (charCode == slash4) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      if (!match2) {
        return null;
      }
      return {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      if (aParsedUrl.scheme) {
        url2 += aParsedUrl.scheme + ":";
      }
      url2 += "//";
      if (aParsedUrl.auth) {
        url2 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url2 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url2 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url2 += aParsedUrl.path;
      }
      return url2;
    }
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache2 = [];
      return function(input) {
        for (var i = 0; i < cache2.length; i++) {
          if (cache2[i].input === input) {
            var temp = cache2[0];
            cache2[0] = cache2[i];
            cache2[i] = temp;
            return cache2[0].result;
          }
        }
        var result = f(input);
        cache2.unshift({
          input,
          result
        });
        if (cache2.length > MAX_CACHED_INPUTS) {
          cache2.pop();
        }
        return result;
      };
    }
    var normalize2 = lruMemoize(function normalize3(aPath) {
      var path9 = aPath;
      var url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path) {
          return aPath;
        }
        path9 = url2.path;
      }
      var isAbsolute2 = exports2.isAbsolute(path9);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path9.indexOf("/", start);
        if (i === -1) {
          parts.push(path9.slice(start));
          break;
        } else {
          parts.push(path9.slice(start, i));
          while (i < path9.length && path9[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path9 = parts.join("/");
      if (path9 === "") {
        path9 = isAbsolute2 ? "/" : ".";
      }
      if (url2) {
        url2.path = path9;
        return urlGenerate(url2);
      }
      return path9;
    });
    exports2.normalize = normalize2;
    function join2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join2;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index4 = aRoot.lastIndexOf("/");
        if (index4 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index4);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative2;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str2) {
      return JSON.parse(str2.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index4 = parsed.path.lastIndexOf("/");
          if (index4 >= 0) {
            parsed.path = parsed.path.substring(0, index4 + 1);
          }
        }
        sourceURL = join2(urlGenerate(parsed), sourceURL);
      }
      return normalize2(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports2) {
    var util3 = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set2 = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set2.add(aArray[i], aAllowDuplicates);
      }
      return set2;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util3.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util3.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util3.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports2) {
    var util3 = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util3.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util3.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util3 = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util3.getArg(aArgs, "file", null);
      this._sourceRoot = util3.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util3.getArg(aArgs, "skipValidation", false);
      this._ignoreInvalidMapping = util3.getArg(aArgs, "ignoreInvalidMapping", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot
      }));
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util3.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util3.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util3.getArg(aArgs, "generated");
      var original = util3.getArg(aArgs, "original", null);
      var source = util3.getArg(aArgs, "source", null);
      var name2 = util3.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name2) === false) {
          return;
        }
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name2 != null) {
        name2 = String(name2);
        if (!this._names.has(name2)) {
          this._names.add(name2);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name: name2
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util3.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util3.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util3.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util3.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util3.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util3.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name2 = mapping.name;
        if (name2 != null && !newNames.has(name2)) {
          newNames.add(name2);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util3.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util3.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        var message = "Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        });
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util3.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util3.relative(aSourceRoot, source);
        }
        var key = util3.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map-js/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map-js/lib/binary-search.js"(exports2) {
    exports2.GREATEST_LOWER_BOUND = 1;
    exports2.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports2.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports2.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index4 = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports2.GREATEST_LOWER_BOUND
      );
      if (index4 < 0) {
        return -1;
      }
      while (index4 - 1 >= 0) {
        if (aCompare(aHaystack[index4], aHaystack[index4 - 1], true) !== 0) {
          break;
        }
        --index4;
      }
      return index4;
    };
  }
});

// node_modules/source-map-js/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map-js/lib/quick-sort.js"(exports2) {
    function SortTemplate(comparator) {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator2, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator2(ary[j], pivot, false) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1;
          doQuickSort(ary, comparator2, p, q - 1);
          doQuickSort(ary, comparator2, q + 1, r);
        }
      }
      return doQuickSort;
    }
    function cloneSort(comparator) {
      let template = SortTemplate.toString();
      let templateFn = new Function(`return ${template}`)();
      return templateFn(comparator);
    }
    var sortCache = /* @__PURE__ */ new WeakMap();
    exports2.quickSort = function(ary, comparator, start = 0) {
      let doQuickSort = sortCache.get(comparator);
      if (doQuickSort === void 0) {
        doQuickSort = cloneSort(comparator);
        sortCache.set(comparator, doQuickSort);
      }
      doQuickSort(ary, comparator, start, ary.length - 1);
    };
  }
});

// node_modules/source-map-js/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map-js/lib/source-map-consumer.js"(exports2) {
    var util3 = require_util();
    var binarySearch2 = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util3.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index4) {
      var c = aStr.charAt(index4);
      return c === ";" || c === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      var boundCallback = aCallback.bind(context);
      var names = this._names;
      var sources = this._sources;
      var sourceMapURL = this._sourceMapURL;
      for (var i = 0, n = mappings.length; i < n; i++) {
        var mapping = mappings[i];
        var source = mapping.source === null ? null : sources.at(mapping.source);
        if (source !== null) {
          source = util3.computeSourceURL(sourceRoot, source, sourceMapURL);
        }
        boundCallback({
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : names.at(mapping.name)
        });
      }
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util3.getArg(aArgs, "line");
      var needle = {
        source: util3.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util3.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index4 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util3.compareByOriginalPositions,
        binarySearch2.LEAST_UPPER_BOUND
      );
      if (index4 >= 0) {
        var mapping = this._originalMappings[index4];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util3.getArg(mapping, "generatedLine", null),
              column: util3.getArg(mapping, "generatedColumn", null),
              lastColumn: util3.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index4];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util3.getArg(mapping, "generatedLine", null),
              column: util3.getArg(mapping, "generatedColumn", null),
              lastColumn: util3.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index4];
          }
        }
      }
      return mappings;
    };
    exports2.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util3.parseSourceMapInput(aSourceMap);
      }
      var version4 = util3.getArg(sourceMap, "version");
      var sources = util3.getArg(sourceMap, "sources");
      var names = util3.getArg(sourceMap, "names", []);
      var sourceRoot = util3.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util3.getArg(sourceMap, "sourcesContent", null);
      var mappings = util3.getArg(sourceMap, "mappings");
      var file = util3.getArg(sourceMap, "file", null);
      if (version4 != this._version) {
        throw new Error("Unsupported version: " + version4);
      }
      if (sourceRoot) {
        sourceRoot = util3.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util3.normalize).map(function(source) {
        return sourceRoot && util3.isAbsolute(sourceRoot) && util3.isAbsolute(source) ? util3.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util3.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util3.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util3.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util3.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    var compareGenerated = util3.compareByGeneratedPositionsDeflatedNoLine;
    function sortGenerated(array2, start) {
      let l = array2.length;
      let n = array2.length - start;
      if (n <= 1) {
        return;
      } else if (n == 2) {
        let a = array2[start];
        let b = array2[start + 1];
        if (compareGenerated(a, b) > 0) {
          array2[start] = b;
          array2[start + 1] = a;
        }
      } else if (n < 20) {
        for (let i = start; i < l; i++) {
          for (let j = i; j > start; j--) {
            let a = array2[j - 1];
            let b = array2[j];
            if (compareGenerated(a, b) <= 0) {
              break;
            }
            array2[j - 1] = b;
            array2[j] = a;
          }
        }
      } else {
        quickSort(array2, compareGenerated, start);
      }
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index4 = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str2, segment, end, value2;
      let subarrayStart = 0;
      while (index4 < length) {
        if (aStr.charAt(index4) === ";") {
          generatedLine++;
          index4++;
          previousGeneratedColumn = 0;
          sortGenerated(generatedMappings, subarrayStart);
          subarrayStart = generatedMappings.length;
        } else if (aStr.charAt(index4) === ",") {
          index4++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index4; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str2 = aStr.slice(index4, end);
          segment = [];
          while (index4 < end) {
            base64VLQ.decode(aStr, index4, temp);
            value2 = temp.value;
            index4 = temp.rest;
            segment.push(value2);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            let currentSource = mapping.source;
            while (originalMappings.length <= currentSource) {
              originalMappings.push(null);
            }
            if (originalMappings[currentSource] === null) {
              originalMappings[currentSource] = [];
            }
            originalMappings[currentSource].push(mapping);
          }
        }
      }
      sortGenerated(generatedMappings, subarrayStart);
      this.__generatedMappings = generatedMappings;
      for (var i = 0; i < originalMappings.length; i++) {
        if (originalMappings[i] != null) {
          quickSort(originalMappings[i], util3.compareByOriginalPositionsNoSource);
        }
      }
      this.__originalMappings = [].concat(...originalMappings);
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index4 = 0; index4 < this._generatedMappings.length; ++index4) {
        var mapping = this._generatedMappings[index4];
        if (index4 + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index4 + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util3.getArg(aArgs, "line"),
        generatedColumn: util3.getArg(aArgs, "column")
      };
      var index4 = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util3.compareByGeneratedPositionsDeflated,
        util3.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index4 >= 0) {
        var mapping = this._generatedMappings[index4];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util3.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util3.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name2 = util3.getArg(mapping, "name", null);
          if (name2 !== null) {
            name2 = this._names.at(name2);
          }
          return {
            source,
            line: util3.getArg(mapping, "originalLine", null),
            column: util3.getArg(mapping, "originalColumn", null),
            name: name2
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index4 = this._findSourceIndex(aSource);
      if (index4 >= 0) {
        return this.sourcesContent[index4];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util3.relative(this.sourceRoot, relativeSource);
      }
      var url2;
      if (this.sourceRoot != null && (url2 = util3.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util3.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util3.getArg(aArgs, "line"),
        originalColumn: util3.getArg(aArgs, "column")
      };
      var index4 = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util3.compareByOriginalPositions,
        util3.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index4 >= 0) {
        var mapping = this._originalMappings[index4];
        if (mapping.source === needle.source) {
          return {
            line: util3.getArg(mapping, "generatedLine", null),
            column: util3.getArg(mapping, "generatedColumn", null),
            lastColumn: util3.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports2.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util3.parseSourceMapInput(aSourceMap);
      }
      var version4 = util3.getArg(sourceMap, "version");
      var sections = util3.getArg(sourceMap, "sections");
      if (version4 != this._version) {
        throw new Error("Unsupported version: " + version4);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset = util3.getArg(s, "offset");
        var offsetLine = util3.getArg(offset, "line");
        var offsetColumn = util3.getArg(offset, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util3.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util3.getArg(aArgs, "line"),
        generatedColumn: util3.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch2.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content || content === "") {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util3.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j = 0; j < sectionMappings.length; j++) {
          var mapping = sectionMappings[j];
          var source = section.consumer._sources.at(mapping.source);
          if (source !== null) {
            source = util3.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          }
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name2 = null;
          if (mapping.name) {
            name2 = section.consumer._names.at(mapping.name);
            this._names.add(name2);
            name2 = this._names.indexOf(name2);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: name2
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util3.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util3.compareByOriginalPositions);
    };
    exports2.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map-js/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map-js/lib/source-node.js"(exports2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util3 = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node3 = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node3.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node3.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node3.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util3.join(aRelativePath, sourceFile);
          }
          node3.setSourceContent(sourceFile, content);
        }
      });
      return node3;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node3.add(code);
        } else {
          var source = aRelativePath ? util3.join(aRelativePath, mapping.source) : mapping.source;
          node3.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util3.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util3.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str2 = "";
      this.walk(function(chunk) {
        str2 += chunk;
      });
      return str2;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map };
    };
    exports2.SourceNode = SourceNode;
  }
});

// node_modules/source-map-js/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map-js/source-map.js"(exports2) {
    exports2.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports2.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports2.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/postcss/lib/previous-map.js
var require_previous_map = __commonJS({
  "node_modules/postcss/lib/previous-map.js"(exports2, module) {
    "use strict";
    var { existsSync: existsSync2, readFileSync: readFileSync4 } = __require("fs");
    var { dirname: dirname4, join: join2 } = __require("path");
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    function fromBase64(str2) {
      if (Buffer) {
        return Buffer.from(str2, "base64").toString();
      } else {
        return window.atob(str2);
      }
    }
    var PreviousMap = class {
      constructor(css, opts) {
        if (opts.map === false) return;
        this.loadAnnotation(css);
        this.inline = this.startWith(this.annotation, "data:");
        let prev = opts.map ? opts.map.prev : void 0;
        let text2 = this.loadMap(opts.from, prev);
        if (!this.mapFile && opts.from) {
          this.mapFile = opts.from;
        }
        if (this.mapFile) this.root = dirname4(this.mapFile);
        if (text2) this.text = text2;
      }
      consumer() {
        if (!this.consumerCache) {
          this.consumerCache = new SourceMapConsumer(this.text);
        }
        return this.consumerCache;
      }
      decodeInline(text2) {
        let baseCharsetUri = /^data:application\/json;charset=utf-?8;base64,/;
        let baseUri = /^data:application\/json;base64,/;
        let charsetUri = /^data:application\/json;charset=utf-?8,/;
        let uri = /^data:application\/json,/;
        let uriMatch = text2.match(charsetUri) || text2.match(uri);
        if (uriMatch) {
          return decodeURIComponent(text2.substr(uriMatch[0].length));
        }
        let baseUriMatch = text2.match(baseCharsetUri) || text2.match(baseUri);
        if (baseUriMatch) {
          return fromBase64(text2.substr(baseUriMatch[0].length));
        }
        let encoding = text2.match(/data:application\/json;([^,]+),/)[1];
        throw new Error("Unsupported source map encoding " + encoding);
      }
      getAnnotationURL(sourceMapString) {
        return sourceMapString.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
      }
      isMap(map) {
        if (typeof map !== "object") return false;
        return typeof map.mappings === "string" || typeof map._mappings === "string" || Array.isArray(map.sections);
      }
      loadAnnotation(css) {
        let comments = css.match(/\/\*\s*# sourceMappingURL=/g);
        if (!comments) return;
        let start = css.lastIndexOf(comments.pop());
        let end = css.indexOf("*/", start);
        if (start > -1 && end > -1) {
          this.annotation = this.getAnnotationURL(css.substring(start, end));
        }
      }
      loadFile(path9) {
        this.root = dirname4(path9);
        if (existsSync2(path9)) {
          this.mapFile = path9;
          return readFileSync4(path9, "utf-8").toString().trim();
        }
      }
      loadMap(file, prev) {
        if (prev === false) return false;
        if (prev) {
          if (typeof prev === "string") {
            return prev;
          } else if (typeof prev === "function") {
            let prevPath = prev(file);
            if (prevPath) {
              let map = this.loadFile(prevPath);
              if (!map) {
                throw new Error(
                  "Unable to load previous source map: " + prevPath.toString()
                );
              }
              return map;
            }
          } else if (prev instanceof SourceMapConsumer) {
            return SourceMapGenerator.fromSourceMap(prev).toString();
          } else if (prev instanceof SourceMapGenerator) {
            return prev.toString();
          } else if (this.isMap(prev)) {
            return JSON.stringify(prev);
          } else {
            throw new Error(
              "Unsupported previous source map format: " + prev.toString()
            );
          }
        } else if (this.inline) {
          return this.decodeInline(this.annotation);
        } else if (this.annotation) {
          let map = this.annotation;
          if (file) map = join2(dirname4(file), map);
          return this.loadFile(map);
        }
      }
      startWith(string4, start) {
        if (!string4) return false;
        return string4.substr(0, start.length) === start;
      }
      withContent() {
        return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
      }
    };
    module.exports = PreviousMap;
    PreviousMap.default = PreviousMap;
  }
});

// node_modules/postcss/lib/input.js
var require_input = __commonJS({
  "node_modules/postcss/lib/input.js"(exports2, module) {
    "use strict";
    var { nanoid } = require_non_secure();
    var { isAbsolute: isAbsolute2, resolve: resolve8 } = __require("path");
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { fileURLToPath: fileURLToPath5, pathToFileURL: pathToFileURL2 } = __require("url");
    var CssSyntaxError2 = require_css_syntax_error();
    var PreviousMap = require_previous_map();
    var terminalHighlight = require_terminal_highlight();
    var fromOffsetCache = Symbol("fromOffsetCache");
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(resolve8 && isAbsolute2);
    var Input2 = class {
      constructor(css, opts = {}) {
        if (css === null || typeof css === "undefined" || typeof css === "object" && !css.toString) {
          throw new Error(`PostCSS received ${css} instead of CSS string`);
        }
        this.css = css.toString();
        if (this.css[0] === "\uFEFF" || this.css[0] === "\uFFFE") {
          this.hasBOM = true;
          this.css = this.css.slice(1);
        } else {
          this.hasBOM = false;
        }
        if (opts.from) {
          if (!pathAvailable || /^\w+:\/\//.test(opts.from) || isAbsolute2(opts.from)) {
            this.file = opts.from;
          } else {
            this.file = resolve8(opts.from);
          }
        }
        if (pathAvailable && sourceMapAvailable) {
          let map = new PreviousMap(this.css, opts);
          if (map.text) {
            this.map = map;
            let file = map.consumer().file;
            if (!this.file && file) this.file = this.mapResolve(file);
          }
        }
        if (!this.file) {
          this.id = "<input css " + nanoid(6) + ">";
        }
        if (this.map) this.map.file = this.from;
      }
      error(message, line, column, opts = {}) {
        let endColumn, endLine, result;
        if (line && typeof line === "object") {
          let start = line;
          let end = column;
          if (typeof start.offset === "number") {
            let pos = this.fromOffset(start.offset);
            line = pos.line;
            column = pos.col;
          } else {
            line = start.line;
            column = start.column;
          }
          if (typeof end.offset === "number") {
            let pos = this.fromOffset(end.offset);
            endLine = pos.line;
            endColumn = pos.col;
          } else {
            endLine = end.line;
            endColumn = end.column;
          }
        } else if (!column) {
          let pos = this.fromOffset(line);
          line = pos.line;
          column = pos.col;
        }
        let origin = this.origin(line, column, endLine, endColumn);
        if (origin) {
          result = new CssSyntaxError2(
            message,
            origin.endLine === void 0 ? origin.line : { column: origin.column, line: origin.line },
            origin.endLine === void 0 ? origin.column : { column: origin.endColumn, line: origin.endLine },
            origin.source,
            origin.file,
            opts.plugin
          );
        } else {
          result = new CssSyntaxError2(
            message,
            endLine === void 0 ? line : { column, line },
            endLine === void 0 ? column : { column: endColumn, line: endLine },
            this.css,
            this.file,
            opts.plugin
          );
        }
        result.input = { column, endColumn, endLine, line, source: this.css };
        if (this.file) {
          if (pathToFileURL2) {
            result.input.url = pathToFileURL2(this.file).toString();
          }
          result.input.file = this.file;
        }
        return result;
      }
      fromOffset(offset) {
        let lastLine, lineToIndex;
        if (!this[fromOffsetCache]) {
          let lines = this.css.split("\n");
          lineToIndex = new Array(lines.length);
          let prevIndex = 0;
          for (let i = 0, l = lines.length; i < l; i++) {
            lineToIndex[i] = prevIndex;
            prevIndex += lines[i].length + 1;
          }
          this[fromOffsetCache] = lineToIndex;
        } else {
          lineToIndex = this[fromOffsetCache];
        }
        lastLine = lineToIndex[lineToIndex.length - 1];
        let min2 = 0;
        if (offset >= lastLine) {
          min2 = lineToIndex.length - 1;
        } else {
          let max = lineToIndex.length - 2;
          let mid;
          while (min2 < max) {
            mid = min2 + (max - min2 >> 1);
            if (offset < lineToIndex[mid]) {
              max = mid - 1;
            } else if (offset >= lineToIndex[mid + 1]) {
              min2 = mid + 1;
            } else {
              min2 = mid;
              break;
            }
          }
        }
        return {
          col: offset - lineToIndex[min2] + 1,
          line: min2 + 1
        };
      }
      mapResolve(file) {
        if (/^\w+:\/\//.test(file)) {
          return file;
        }
        return resolve8(this.map.consumer().sourceRoot || this.map.root || ".", file);
      }
      origin(line, column, endLine, endColumn) {
        if (!this.map) return false;
        let consumer = this.map.consumer();
        let from = consumer.originalPositionFor({ column, line });
        if (!from.source) return false;
        let to;
        if (typeof endLine === "number") {
          to = consumer.originalPositionFor({ column: endColumn, line: endLine });
        }
        let fromUrl;
        if (isAbsolute2(from.source)) {
          fromUrl = pathToFileURL2(from.source);
        } else {
          fromUrl = new URL(
            from.source,
            this.map.consumer().sourceRoot || pathToFileURL2(this.map.mapFile)
          );
        }
        let result = {
          column: from.column,
          endColumn: to && to.column,
          endLine: to && to.line,
          line: from.line,
          url: fromUrl.toString()
        };
        if (fromUrl.protocol === "file:") {
          if (fileURLToPath5) {
            result.file = fileURLToPath5(fromUrl);
          } else {
            throw new Error(`file: protocol is not available in this PostCSS build`);
          }
        }
        let source = consumer.sourceContentFor(from.source);
        if (source) result.source = source;
        return result;
      }
      toJSON() {
        let json = {};
        for (let name2 of ["hasBOM", "css", "file", "id"]) {
          if (this[name2] != null) {
            json[name2] = this[name2];
          }
        }
        if (this.map) {
          json.map = { ...this.map };
          if (json.map.consumerCache) {
            json.map.consumerCache = void 0;
          }
        }
        return json;
      }
      get from() {
        return this.file || this.id;
      }
    };
    module.exports = Input2;
    Input2.default = Input2;
    if (terminalHighlight && terminalHighlight.registerInput) {
      terminalHighlight.registerInput(Input2);
    }
  }
});

// node_modules/postcss/lib/root.js
var require_root = __commonJS({
  "node_modules/postcss/lib/root.js"(exports2, module) {
    "use strict";
    var Container2 = require_container();
    var LazyResult;
    var Processor3;
    var Root2 = class extends Container2 {
      constructor(defaults2) {
        super(defaults2);
        this.type = "root";
        if (!this.nodes) this.nodes = [];
      }
      normalize(child, sample, type) {
        let nodes = super.normalize(child);
        if (sample) {
          if (type === "prepend") {
            if (this.nodes.length > 1) {
              sample.raws.before = this.nodes[1].raws.before;
            } else {
              delete sample.raws.before;
            }
          } else if (this.first !== sample) {
            for (let node3 of nodes) {
              node3.raws.before = sample.raws.before;
            }
          }
        }
        return nodes;
      }
      removeChild(child, ignore) {
        let index4 = this.index(child);
        if (!ignore && index4 === 0 && this.nodes.length > 1) {
          this.nodes[1].raws.before = this.nodes[index4].raws.before;
        }
        return super.removeChild(child);
      }
      toResult(opts = {}) {
        let lazy = new LazyResult(new Processor3(), this, opts);
        return lazy.stringify();
      }
    };
    Root2.registerLazyResult = (dependant) => {
      LazyResult = dependant;
    };
    Root2.registerProcessor = (dependant) => {
      Processor3 = dependant;
    };
    module.exports = Root2;
    Root2.default = Root2;
    Container2.registerRoot(Root2);
  }
});

// node_modules/postcss/lib/list.js
var require_list = __commonJS({
  "node_modules/postcss/lib/list.js"(exports2, module) {
    "use strict";
    var list2 = {
      comma(string4) {
        return list2.split(string4, [","], true);
      },
      space(string4) {
        let spaces = [" ", "\n", "	"];
        return list2.split(string4, spaces);
      },
      split(string4, separators, last) {
        let array2 = [];
        let current = "";
        let split = false;
        let func = 0;
        let inQuote = false;
        let prevQuote = "";
        let escape2 = false;
        for (let letter of string4) {
          if (escape2) {
            escape2 = false;
          } else if (letter === "\\") {
            escape2 = true;
          } else if (inQuote) {
            if (letter === prevQuote) {
              inQuote = false;
            }
          } else if (letter === '"' || letter === "'") {
            inQuote = true;
            prevQuote = letter;
          } else if (letter === "(") {
            func += 1;
          } else if (letter === ")") {
            if (func > 0) func -= 1;
          } else if (func === 0) {
            if (separators.includes(letter)) split = true;
          }
          if (split) {
            if (current !== "") array2.push(current.trim());
            current = "";
            split = false;
          } else {
            current += letter;
          }
        }
        if (last || current !== "") array2.push(current.trim());
        return array2;
      }
    };
    module.exports = list2;
    list2.default = list2;
  }
});

// node_modules/postcss/lib/rule.js
var require_rule = __commonJS({
  "node_modules/postcss/lib/rule.js"(exports2, module) {
    "use strict";
    var Container2 = require_container();
    var list2 = require_list();
    var Rule2 = class extends Container2 {
      constructor(defaults2) {
        super(defaults2);
        this.type = "rule";
        if (!this.nodes) this.nodes = [];
      }
      get selectors() {
        return list2.comma(this.selector);
      }
      set selectors(values) {
        let match2 = this.selector ? this.selector.match(/,\s*/) : null;
        let sep2 = match2 ? match2[0] : "," + this.raw("between", "beforeOpen");
        this.selector = values.join(sep2);
      }
    };
    module.exports = Rule2;
    Rule2.default = Rule2;
    Container2.registerRule(Rule2);
  }
});

// node_modules/postcss/lib/fromJSON.js
var require_fromJSON = __commonJS({
  "node_modules/postcss/lib/fromJSON.js"(exports2, module) {
    "use strict";
    var AtRule2 = require_at_rule();
    var Comment2 = require_comment();
    var Declaration2 = require_declaration();
    var Input2 = require_input();
    var PreviousMap = require_previous_map();
    var Root2 = require_root();
    var Rule2 = require_rule();
    function fromJSON2(json, inputs) {
      if (Array.isArray(json)) return json.map((n) => fromJSON2(n));
      let { inputs: ownInputs, ...defaults2 } = json;
      if (ownInputs) {
        inputs = [];
        for (let input of ownInputs) {
          let inputHydrated = { ...input, __proto__: Input2.prototype };
          if (inputHydrated.map) {
            inputHydrated.map = {
              ...inputHydrated.map,
              __proto__: PreviousMap.prototype
            };
          }
          inputs.push(inputHydrated);
        }
      }
      if (defaults2.nodes) {
        defaults2.nodes = json.nodes.map((n) => fromJSON2(n, inputs));
      }
      if (defaults2.source) {
        let { inputId, ...source } = defaults2.source;
        defaults2.source = source;
        if (inputId != null) {
          defaults2.source.input = inputs[inputId];
        }
      }
      if (defaults2.type === "root") {
        return new Root2(defaults2);
      } else if (defaults2.type === "decl") {
        return new Declaration2(defaults2);
      } else if (defaults2.type === "rule") {
        return new Rule2(defaults2);
      } else if (defaults2.type === "comment") {
        return new Comment2(defaults2);
      } else if (defaults2.type === "atrule") {
        return new AtRule2(defaults2);
      } else {
        throw new Error("Unknown node type: " + json.type);
      }
    }
    module.exports = fromJSON2;
    fromJSON2.default = fromJSON2;
  }
});

// node_modules/postcss/lib/map-generator.js
var require_map_generator = __commonJS({
  "node_modules/postcss/lib/map-generator.js"(exports2, module) {
    "use strict";
    var { dirname: dirname4, relative: relative2, resolve: resolve8, sep: sep2 } = __require("path");
    var { SourceMapConsumer, SourceMapGenerator } = require_source_map();
    var { pathToFileURL: pathToFileURL2 } = __require("url");
    var Input2 = require_input();
    var sourceMapAvailable = Boolean(SourceMapConsumer && SourceMapGenerator);
    var pathAvailable = Boolean(dirname4 && resolve8 && relative2 && sep2);
    var MapGenerator = class {
      constructor(stringify5, root4, opts, cssString) {
        this.stringify = stringify5;
        this.mapOpts = opts.map || {};
        this.root = root4;
        this.opts = opts;
        this.css = cssString;
        this.originalCSS = cssString;
        this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
        this.memoizedFileURLs = /* @__PURE__ */ new Map();
        this.memoizedPaths = /* @__PURE__ */ new Map();
        this.memoizedURLs = /* @__PURE__ */ new Map();
      }
      addAnnotation() {
        let content;
        if (this.isInline()) {
          content = "data:application/json;base64," + this.toBase64(this.map.toString());
        } else if (typeof this.mapOpts.annotation === "string") {
          content = this.mapOpts.annotation;
        } else if (typeof this.mapOpts.annotation === "function") {
          content = this.mapOpts.annotation(this.opts.to, this.root);
        } else {
          content = this.outputFile() + ".map";
        }
        let eol = "\n";
        if (this.css.includes("\r\n")) eol = "\r\n";
        this.css += eol + "/*# sourceMappingURL=" + content + " */";
      }
      applyPrevMaps() {
        for (let prev of this.previous()) {
          let from = this.toUrl(this.path(prev.file));
          let root4 = prev.root || dirname4(prev.file);
          let map;
          if (this.mapOpts.sourcesContent === false) {
            map = new SourceMapConsumer(prev.text);
            if (map.sourcesContent) {
              map.sourcesContent = null;
            }
          } else {
            map = prev.consumer();
          }
          this.map.applySourceMap(map, from, this.toUrl(this.path(root4)));
        }
      }
      clearAnnotation() {
        if (this.mapOpts.annotation === false) return;
        if (this.root) {
          let node3;
          for (let i = this.root.nodes.length - 1; i >= 0; i--) {
            node3 = this.root.nodes[i];
            if (node3.type !== "comment") continue;
            if (node3.text.startsWith("# sourceMappingURL=")) {
              this.root.removeChild(i);
            }
          }
        } else if (this.css) {
          this.css = this.css.replace(/\n*\/\*#[\S\s]*?\*\/$/gm, "");
        }
      }
      generate() {
        this.clearAnnotation();
        if (pathAvailable && sourceMapAvailable && this.isMap()) {
          return this.generateMap();
        } else {
          let result = "";
          this.stringify(this.root, (i) => {
            result += i;
          });
          return [result];
        }
      }
      generateMap() {
        if (this.root) {
          this.generateString();
        } else if (this.previous().length === 1) {
          let prev = this.previous()[0].consumer();
          prev.file = this.outputFile();
          this.map = SourceMapGenerator.fromSourceMap(prev, {
            ignoreInvalidMapping: true
          });
        } else {
          this.map = new SourceMapGenerator({
            file: this.outputFile(),
            ignoreInvalidMapping: true
          });
          this.map.addMapping({
            generated: { column: 0, line: 1 },
            original: { column: 0, line: 1 },
            source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>"
          });
        }
        if (this.isSourcesContent()) this.setSourcesContent();
        if (this.root && this.previous().length > 0) this.applyPrevMaps();
        if (this.isAnnotation()) this.addAnnotation();
        if (this.isInline()) {
          return [this.css];
        } else {
          return [this.css, this.map];
        }
      }
      generateString() {
        this.css = "";
        this.map = new SourceMapGenerator({
          file: this.outputFile(),
          ignoreInvalidMapping: true
        });
        let line = 1;
        let column = 1;
        let noSource = "<no source>";
        let mapping = {
          generated: { column: 0, line: 0 },
          original: { column: 0, line: 0 },
          source: ""
        };
        let last, lines;
        this.stringify(this.root, (str2, node3, type) => {
          this.css += str2;
          if (node3 && type !== "end") {
            mapping.generated.line = line;
            mapping.generated.column = column - 1;
            if (node3.source && node3.source.start) {
              mapping.source = this.sourcePath(node3);
              mapping.original.line = node3.source.start.line;
              mapping.original.column = node3.source.start.column - 1;
              this.map.addMapping(mapping);
            } else {
              mapping.source = noSource;
              mapping.original.line = 1;
              mapping.original.column = 0;
              this.map.addMapping(mapping);
            }
          }
          lines = str2.match(/\n/g);
          if (lines) {
            line += lines.length;
            last = str2.lastIndexOf("\n");
            column = str2.length - last;
          } else {
            column += str2.length;
          }
          if (node3 && type !== "start") {
            let p = node3.parent || { raws: {} };
            let childless = node3.type === "decl" || node3.type === "atrule" && !node3.nodes;
            if (!childless || node3 !== p.last || p.raws.semicolon) {
              if (node3.source && node3.source.end) {
                mapping.source = this.sourcePath(node3);
                mapping.original.line = node3.source.end.line;
                mapping.original.column = node3.source.end.column - 1;
                mapping.generated.line = line;
                mapping.generated.column = column - 2;
                this.map.addMapping(mapping);
              } else {
                mapping.source = noSource;
                mapping.original.line = 1;
                mapping.original.column = 0;
                mapping.generated.line = line;
                mapping.generated.column = column - 1;
                this.map.addMapping(mapping);
              }
            }
          }
        });
      }
      isAnnotation() {
        if (this.isInline()) {
          return true;
        }
        if (typeof this.mapOpts.annotation !== "undefined") {
          return this.mapOpts.annotation;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.annotation);
        }
        return true;
      }
      isInline() {
        if (typeof this.mapOpts.inline !== "undefined") {
          return this.mapOpts.inline;
        }
        let annotation = this.mapOpts.annotation;
        if (typeof annotation !== "undefined" && annotation !== true) {
          return false;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.inline);
        }
        return true;
      }
      isMap() {
        if (typeof this.opts.map !== "undefined") {
          return !!this.opts.map;
        }
        return this.previous().length > 0;
      }
      isSourcesContent() {
        if (typeof this.mapOpts.sourcesContent !== "undefined") {
          return this.mapOpts.sourcesContent;
        }
        if (this.previous().length) {
          return this.previous().some((i) => i.withContent());
        }
        return true;
      }
      outputFile() {
        if (this.opts.to) {
          return this.path(this.opts.to);
        } else if (this.opts.from) {
          return this.path(this.opts.from);
        } else {
          return "to.css";
        }
      }
      path(file) {
        if (this.mapOpts.absolute) return file;
        if (file.charCodeAt(0) === 60) return file;
        if (/^\w+:\/\//.test(file)) return file;
        let cached = this.memoizedPaths.get(file);
        if (cached) return cached;
        let from = this.opts.to ? dirname4(this.opts.to) : ".";
        if (typeof this.mapOpts.annotation === "string") {
          from = dirname4(resolve8(from, this.mapOpts.annotation));
        }
        let path9 = relative2(from, file);
        this.memoizedPaths.set(file, path9);
        return path9;
      }
      previous() {
        if (!this.previousMaps) {
          this.previousMaps = [];
          if (this.root) {
            this.root.walk((node3) => {
              if (node3.source && node3.source.input.map) {
                let map = node3.source.input.map;
                if (!this.previousMaps.includes(map)) {
                  this.previousMaps.push(map);
                }
              }
            });
          } else {
            let input = new Input2(this.originalCSS, this.opts);
            if (input.map) this.previousMaps.push(input.map);
          }
        }
        return this.previousMaps;
      }
      setSourcesContent() {
        let already = {};
        if (this.root) {
          this.root.walk((node3) => {
            if (node3.source) {
              let from = node3.source.input.from;
              if (from && !already[from]) {
                already[from] = true;
                let fromUrl = this.usesFileUrls ? this.toFileUrl(from) : this.toUrl(this.path(from));
                this.map.setSourceContent(fromUrl, node3.source.input.css);
              }
            }
          });
        } else if (this.css) {
          let from = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
          this.map.setSourceContent(from, this.css);
        }
      }
      sourcePath(node3) {
        if (this.mapOpts.from) {
          return this.toUrl(this.mapOpts.from);
        } else if (this.usesFileUrls) {
          return this.toFileUrl(node3.source.input.from);
        } else {
          return this.toUrl(this.path(node3.source.input.from));
        }
      }
      toBase64(str2) {
        if (Buffer) {
          return Buffer.from(str2).toString("base64");
        } else {
          return window.btoa(unescape(encodeURIComponent(str2)));
        }
      }
      toFileUrl(path9) {
        let cached = this.memoizedFileURLs.get(path9);
        if (cached) return cached;
        if (pathToFileURL2) {
          let fileURL = pathToFileURL2(path9).toString();
          this.memoizedFileURLs.set(path9, fileURL);
          return fileURL;
        } else {
          throw new Error(
            "`map.absolute` option is not available in this PostCSS build"
          );
        }
      }
      toUrl(path9) {
        let cached = this.memoizedURLs.get(path9);
        if (cached) return cached;
        if (sep2 === "\\") {
          path9 = path9.replace(/\\/g, "/");
        }
        let url2 = encodeURI(path9).replace(/[#?]/g, encodeURIComponent);
        this.memoizedURLs.set(path9, url2);
        return url2;
      }
    };
    module.exports = MapGenerator;
  }
});

// node_modules/postcss/lib/parser.js
var require_parser = __commonJS({
  "node_modules/postcss/lib/parser.js"(exports2, module) {
    "use strict";
    var AtRule2 = require_at_rule();
    var Comment2 = require_comment();
    var Declaration2 = require_declaration();
    var Root2 = require_root();
    var Rule2 = require_rule();
    var tokenizer = require_tokenize();
    var SAFE_COMMENT_NEIGHBOR = {
      empty: true,
      space: true
    };
    function findLastWithPosition(tokens) {
      for (let i = tokens.length - 1; i >= 0; i--) {
        let token = tokens[i];
        let pos = token[3] || token[2];
        if (pos) return pos;
      }
    }
    var Parser3 = class {
      constructor(input) {
        this.input = input;
        this.root = new Root2();
        this.current = this.root;
        this.spaces = "";
        this.semicolon = false;
        this.createTokenizer();
        this.root.source = { input, start: { column: 1, line: 1, offset: 0 } };
      }
      atrule(token) {
        let node3 = new AtRule2();
        node3.name = token[1].slice(1);
        if (node3.name === "") {
          this.unnamedAtrule(node3, token);
        }
        this.init(node3, token[2]);
        let type;
        let prev;
        let shift;
        let last = false;
        let open2 = false;
        let params = [];
        let brackets = [];
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          type = token[0];
          if (type === "(" || type === "[") {
            brackets.push(type === "(" ? ")" : "]");
          } else if (type === "{" && brackets.length > 0) {
            brackets.push("}");
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
          }
          if (brackets.length === 0) {
            if (type === ";") {
              node3.source.end = this.getPosition(token[2]);
              node3.source.end.offset++;
              this.semicolon = true;
              break;
            } else if (type === "{") {
              open2 = true;
              break;
            } else if (type === "}") {
              if (params.length > 0) {
                shift = params.length - 1;
                prev = params[shift];
                while (prev && prev[0] === "space") {
                  prev = params[--shift];
                }
                if (prev) {
                  node3.source.end = this.getPosition(prev[3] || prev[2]);
                  node3.source.end.offset++;
                }
              }
              this.end(token);
              break;
            } else {
              params.push(token);
            }
          } else {
            params.push(token);
          }
          if (this.tokenizer.endOfFile()) {
            last = true;
            break;
          }
        }
        node3.raws.between = this.spacesAndCommentsFromEnd(params);
        if (params.length) {
          node3.raws.afterName = this.spacesAndCommentsFromStart(params);
          this.raw(node3, "params", params);
          if (last) {
            token = params[params.length - 1];
            node3.source.end = this.getPosition(token[3] || token[2]);
            node3.source.end.offset++;
            this.spaces = node3.raws.between;
            node3.raws.between = "";
          }
        } else {
          node3.raws.afterName = "";
          node3.params = "";
        }
        if (open2) {
          node3.nodes = [];
          this.current = node3;
        }
      }
      checkMissedSemicolon(tokens) {
        let colon3 = this.colon(tokens);
        if (colon3 === false) return;
        let founded = 0;
        let token;
        for (let j = colon3 - 1; j >= 0; j--) {
          token = tokens[j];
          if (token[0] !== "space") {
            founded += 1;
            if (founded === 2) break;
          }
        }
        throw this.input.error(
          "Missed semicolon",
          token[0] === "word" ? token[3] + 1 : token[2]
        );
      }
      colon(tokens) {
        let brackets = 0;
        let prev, token, type;
        for (let [i, element] of tokens.entries()) {
          token = element;
          type = token[0];
          if (type === "(") {
            brackets += 1;
          }
          if (type === ")") {
            brackets -= 1;
          }
          if (brackets === 0 && type === ":") {
            if (!prev) {
              this.doubleColon(token);
            } else if (prev[0] === "word" && prev[1] === "progid") {
              continue;
            } else {
              return i;
            }
          }
          prev = token;
        }
        return false;
      }
      comment(token) {
        let node3 = new Comment2();
        this.init(node3, token[2]);
        node3.source.end = this.getPosition(token[3] || token[2]);
        node3.source.end.offset++;
        let text2 = token[1].slice(2, -2);
        if (/^\s*$/.test(text2)) {
          node3.text = "";
          node3.raws.left = text2;
          node3.raws.right = "";
        } else {
          let match2 = text2.match(/^(\s*)([^]*\S)(\s*)$/);
          node3.text = match2[2];
          node3.raws.left = match2[1];
          node3.raws.right = match2[3];
        }
      }
      createTokenizer() {
        this.tokenizer = tokenizer(this.input);
      }
      decl(tokens, customProperty) {
        let node3 = new Declaration2();
        this.init(node3, tokens[0][2]);
        let last = tokens[tokens.length - 1];
        if (last[0] === ";") {
          this.semicolon = true;
          tokens.pop();
        }
        node3.source.end = this.getPosition(
          last[3] || last[2] || findLastWithPosition(tokens)
        );
        node3.source.end.offset++;
        while (tokens[0][0] !== "word") {
          if (tokens.length === 1) this.unknownWord(tokens);
          node3.raws.before += tokens.shift()[1];
        }
        node3.source.start = this.getPosition(tokens[0][2]);
        node3.prop = "";
        while (tokens.length) {
          let type = tokens[0][0];
          if (type === ":" || type === "space" || type === "comment") {
            break;
          }
          node3.prop += tokens.shift()[1];
        }
        node3.raws.between = "";
        let token;
        while (tokens.length) {
          token = tokens.shift();
          if (token[0] === ":") {
            node3.raws.between += token[1];
            break;
          } else {
            if (token[0] === "word" && /\w/.test(token[1])) {
              this.unknownWord([token]);
            }
            node3.raws.between += token[1];
          }
        }
        if (node3.prop[0] === "_" || node3.prop[0] === "*") {
          node3.raws.before += node3.prop[0];
          node3.prop = node3.prop.slice(1);
        }
        let firstSpaces = [];
        let next;
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment") break;
          firstSpaces.push(tokens.shift());
        }
        this.precheckMissedSemicolon(tokens);
        for (let i = tokens.length - 1; i >= 0; i--) {
          token = tokens[i];
          if (token[1].toLowerCase() === "!important") {
            node3.important = true;
            let string4 = this.stringFrom(tokens, i);
            string4 = this.spacesFromEnd(tokens) + string4;
            if (string4 !== " !important") node3.raws.important = string4;
            break;
          } else if (token[1].toLowerCase() === "important") {
            let cache2 = tokens.slice(0);
            let str2 = "";
            for (let j = i; j > 0; j--) {
              let type = cache2[j][0];
              if (str2.trim().startsWith("!") && type !== "space") {
                break;
              }
              str2 = cache2.pop()[1] + str2;
            }
            if (str2.trim().startsWith("!")) {
              node3.important = true;
              node3.raws.important = str2;
              tokens = cache2;
            }
          }
          if (token[0] !== "space" && token[0] !== "comment") {
            break;
          }
        }
        let hasWord = tokens.some((i) => i[0] !== "space" && i[0] !== "comment");
        if (hasWord) {
          node3.raws.between += firstSpaces.map((i) => i[1]).join("");
          firstSpaces = [];
        }
        this.raw(node3, "value", firstSpaces.concat(tokens), customProperty);
        if (node3.value.includes(":") && !customProperty) {
          this.checkMissedSemicolon(tokens);
        }
      }
      doubleColon(token) {
        throw this.input.error(
          "Double colon",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
      emptyRule(token) {
        let node3 = new Rule2();
        this.init(node3, token[2]);
        node3.selector = "";
        node3.raws.between = "";
        this.current = node3;
      }
      end(token) {
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.semicolon = false;
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.spaces = "";
        if (this.current.parent) {
          this.current.source.end = this.getPosition(token[2]);
          this.current.source.end.offset++;
          this.current = this.current.parent;
        } else {
          this.unexpectedClose(token);
        }
      }
      endFile() {
        if (this.current.parent) this.unclosedBlock();
        if (this.current.nodes && this.current.nodes.length) {
          this.current.raws.semicolon = this.semicolon;
        }
        this.current.raws.after = (this.current.raws.after || "") + this.spaces;
        this.root.source.end = this.getPosition(this.tokenizer.position());
      }
      freeSemicolon(token) {
        this.spaces += token[1];
        if (this.current.nodes) {
          let prev = this.current.nodes[this.current.nodes.length - 1];
          if (prev && prev.type === "rule" && !prev.raws.ownSemicolon) {
            prev.raws.ownSemicolon = this.spaces;
            this.spaces = "";
          }
        }
      }
      // Helpers
      getPosition(offset) {
        let pos = this.input.fromOffset(offset);
        return {
          column: pos.col,
          line: pos.line,
          offset
        };
      }
      init(node3, offset) {
        this.current.push(node3);
        node3.source = {
          input: this.input,
          start: this.getPosition(offset)
        };
        node3.raws.before = this.spaces;
        this.spaces = "";
        if (node3.type !== "comment") this.semicolon = false;
      }
      other(start) {
        let end = false;
        let type = null;
        let colon3 = false;
        let bracket = null;
        let brackets = [];
        let customProperty = start[1].startsWith("--");
        let tokens = [];
        let token = start;
        while (token) {
          type = token[0];
          tokens.push(token);
          if (type === "(" || type === "[") {
            if (!bracket) bracket = token;
            brackets.push(type === "(" ? ")" : "]");
          } else if (customProperty && colon3 && type === "{") {
            if (!bracket) bracket = token;
            brackets.push("}");
          } else if (brackets.length === 0) {
            if (type === ";") {
              if (colon3) {
                this.decl(tokens, customProperty);
                return;
              } else {
                break;
              }
            } else if (type === "{") {
              this.rule(tokens);
              return;
            } else if (type === "}") {
              this.tokenizer.back(tokens.pop());
              end = true;
              break;
            } else if (type === ":") {
              colon3 = true;
            }
          } else if (type === brackets[brackets.length - 1]) {
            brackets.pop();
            if (brackets.length === 0) bracket = null;
          }
          token = this.tokenizer.nextToken();
        }
        if (this.tokenizer.endOfFile()) end = true;
        if (brackets.length > 0) this.unclosedBracket(bracket);
        if (end && colon3) {
          if (!customProperty) {
            while (tokens.length) {
              token = tokens[tokens.length - 1][0];
              if (token !== "space" && token !== "comment") break;
              this.tokenizer.back(tokens.pop());
            }
          }
          this.decl(tokens, customProperty);
        } else {
          this.unknownWord(tokens);
        }
      }
      parse() {
        let token;
        while (!this.tokenizer.endOfFile()) {
          token = this.tokenizer.nextToken();
          switch (token[0]) {
            case "space":
              this.spaces += token[1];
              break;
            case ";":
              this.freeSemicolon(token);
              break;
            case "}":
              this.end(token);
              break;
            case "comment":
              this.comment(token);
              break;
            case "at-word":
              this.atrule(token);
              break;
            case "{":
              this.emptyRule(token);
              break;
            default:
              this.other(token);
              break;
          }
        }
        this.endFile();
      }
      precheckMissedSemicolon() {
      }
      raw(node3, prop, tokens, customProperty) {
        let token, type;
        let length = tokens.length;
        let value2 = "";
        let clean = true;
        let next, prev;
        for (let i = 0; i < length; i += 1) {
          token = tokens[i];
          type = token[0];
          if (type === "space" && i === length - 1 && !customProperty) {
            clean = false;
          } else if (type === "comment") {
            prev = tokens[i - 1] ? tokens[i - 1][0] : "empty";
            next = tokens[i + 1] ? tokens[i + 1][0] : "empty";
            if (!SAFE_COMMENT_NEIGHBOR[prev] && !SAFE_COMMENT_NEIGHBOR[next]) {
              if (value2.slice(-1) === ",") {
                clean = false;
              } else {
                value2 += token[1];
              }
            } else {
              clean = false;
            }
          } else {
            value2 += token[1];
          }
        }
        if (!clean) {
          let raw = tokens.reduce((all, i) => all + i[1], "");
          node3.raws[prop] = { raw, value: value2 };
        }
        node3[prop] = value2;
      }
      rule(tokens) {
        tokens.pop();
        let node3 = new Rule2();
        this.init(node3, tokens[0][2]);
        node3.raws.between = this.spacesAndCommentsFromEnd(tokens);
        this.raw(node3, "selector", tokens);
        this.current = node3;
      }
      spacesAndCommentsFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space" && lastTokenType !== "comment") break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      // Errors
      spacesAndCommentsFromStart(tokens) {
        let next;
        let spaces = "";
        while (tokens.length) {
          next = tokens[0][0];
          if (next !== "space" && next !== "comment") break;
          spaces += tokens.shift()[1];
        }
        return spaces;
      }
      spacesFromEnd(tokens) {
        let lastTokenType;
        let spaces = "";
        while (tokens.length) {
          lastTokenType = tokens[tokens.length - 1][0];
          if (lastTokenType !== "space") break;
          spaces = tokens.pop()[1] + spaces;
        }
        return spaces;
      }
      stringFrom(tokens, from) {
        let result = "";
        for (let i = from; i < tokens.length; i++) {
          result += tokens[i][1];
        }
        tokens.splice(from, tokens.length - from);
        return result;
      }
      unclosedBlock() {
        let pos = this.current.source.start;
        throw this.input.error("Unclosed block", pos.line, pos.column);
      }
      unclosedBracket(bracket) {
        throw this.input.error(
          "Unclosed bracket",
          { offset: bracket[2] },
          { offset: bracket[2] + 1 }
        );
      }
      unexpectedClose(token) {
        throw this.input.error(
          "Unexpected }",
          { offset: token[2] },
          { offset: token[2] + 1 }
        );
      }
      unknownWord(tokens) {
        throw this.input.error(
          "Unknown word",
          { offset: tokens[0][2] },
          { offset: tokens[0][2] + tokens[0][1].length }
        );
      }
      unnamedAtrule(node3, token) {
        throw this.input.error(
          "At-rule without name",
          { offset: token[2] },
          { offset: token[2] + token[1].length }
        );
      }
    };
    module.exports = Parser3;
  }
});

// node_modules/postcss/lib/parse.js
var require_parse = __commonJS({
  "node_modules/postcss/lib/parse.js"(exports2, module) {
    "use strict";
    var Container2 = require_container();
    var Input2 = require_input();
    var Parser3 = require_parser();
    function parse6(css, opts) {
      let input = new Input2(css, opts);
      let parser2 = new Parser3(input);
      try {
        parser2.parse();
      } catch (e) {
        if (process.env.NODE_ENV !== "production") {
          if (e.name === "CssSyntaxError" && opts && opts.from) {
            if (/\.scss$/i.test(opts.from)) {
              e.message += "\nYou tried to parse SCSS with the standard CSS parser; try again with the postcss-scss parser";
            } else if (/\.sass/i.test(opts.from)) {
              e.message += "\nYou tried to parse Sass with the standard CSS parser; try again with the postcss-sass parser";
            } else if (/\.less$/i.test(opts.from)) {
              e.message += "\nYou tried to parse Less with the standard CSS parser; try again with the postcss-less parser";
            }
          }
        }
        throw e;
      }
      return parser2.root;
    }
    module.exports = parse6;
    parse6.default = parse6;
    Container2.registerParse(parse6);
  }
});

// node_modules/postcss/lib/warning.js
var require_warning = __commonJS({
  "node_modules/postcss/lib/warning.js"(exports2, module) {
    "use strict";
    var Warning2 = class {
      constructor(text2, opts = {}) {
        this.type = "warning";
        this.text = text2;
        if (opts.node && opts.node.source) {
          let range2 = opts.node.rangeBy(opts);
          this.line = range2.start.line;
          this.column = range2.start.column;
          this.endLine = range2.end.line;
          this.endColumn = range2.end.column;
        }
        for (let opt in opts) this[opt] = opts[opt];
      }
      toString() {
        if (this.node) {
          return this.node.error(this.text, {
            index: this.index,
            plugin: this.plugin,
            word: this.word
          }).message;
        }
        if (this.plugin) {
          return this.plugin + ": " + this.text;
        }
        return this.text;
      }
    };
    module.exports = Warning2;
    Warning2.default = Warning2;
  }
});

// node_modules/postcss/lib/result.js
var require_result = __commonJS({
  "node_modules/postcss/lib/result.js"(exports2, module) {
    "use strict";
    var Warning2 = require_warning();
    var Result2 = class {
      constructor(processor2, root4, opts) {
        this.processor = processor2;
        this.messages = [];
        this.root = root4;
        this.opts = opts;
        this.css = void 0;
        this.map = void 0;
      }
      toString() {
        return this.css;
      }
      warn(text2, opts = {}) {
        if (!opts.plugin) {
          if (this.lastPlugin && this.lastPlugin.postcssPlugin) {
            opts.plugin = this.lastPlugin.postcssPlugin;
          }
        }
        let warning = new Warning2(text2, opts);
        this.messages.push(warning);
        return warning;
      }
      warnings() {
        return this.messages.filter((i) => i.type === "warning");
      }
      get content() {
        return this.css;
      }
    };
    module.exports = Result2;
    Result2.default = Result2;
  }
});

// node_modules/postcss/lib/warn-once.js
var require_warn_once = __commonJS({
  "node_modules/postcss/lib/warn-once.js"(exports2, module) {
    "use strict";
    var printed = {};
    module.exports = function warnOnce(message) {
      if (printed[message]) return;
      printed[message] = true;
      if (typeof console !== "undefined" && console.warn) {
        console.warn(message);
      }
    };
  }
});

// node_modules/postcss/lib/lazy-result.js
var require_lazy_result = __commonJS({
  "node_modules/postcss/lib/lazy-result.js"(exports2, module) {
    "use strict";
    var Container2 = require_container();
    var Document3 = require_document();
    var MapGenerator = require_map_generator();
    var parse6 = require_parse();
    var Result2 = require_result();
    var Root2 = require_root();
    var stringify5 = require_stringify();
    var { isClean, my } = require_symbols();
    var warnOnce = require_warn_once();
    var TYPE_TO_CLASS_NAME = {
      atrule: "AtRule",
      comment: "Comment",
      decl: "Declaration",
      document: "Document",
      root: "Root",
      rule: "Rule"
    };
    var PLUGIN_PROPS = {
      AtRule: true,
      AtRuleExit: true,
      Comment: true,
      CommentExit: true,
      Declaration: true,
      DeclarationExit: true,
      Document: true,
      DocumentExit: true,
      Once: true,
      OnceExit: true,
      postcssPlugin: true,
      prepare: true,
      Root: true,
      RootExit: true,
      Rule: true,
      RuleExit: true
    };
    var NOT_VISITORS = {
      Once: true,
      postcssPlugin: true,
      prepare: true
    };
    var CHILDREN = 0;
    function isPromise(obj) {
      return typeof obj === "object" && typeof obj.then === "function";
    }
    function getEvents(node3) {
      let key = false;
      let type = TYPE_TO_CLASS_NAME[node3.type];
      if (node3.type === "decl") {
        key = node3.prop.toLowerCase();
      } else if (node3.type === "atrule") {
        key = node3.name.toLowerCase();
      }
      if (key && node3.append) {
        return [
          type,
          type + "-" + key,
          CHILDREN,
          type + "Exit",
          type + "Exit-" + key
        ];
      } else if (key) {
        return [type, type + "-" + key, type + "Exit", type + "Exit-" + key];
      } else if (node3.append) {
        return [type, CHILDREN, type + "Exit"];
      } else {
        return [type, type + "Exit"];
      }
    }
    function toStack(node3) {
      let events2;
      if (node3.type === "document") {
        events2 = ["Document", CHILDREN, "DocumentExit"];
      } else if (node3.type === "root") {
        events2 = ["Root", CHILDREN, "RootExit"];
      } else {
        events2 = getEvents(node3);
      }
      return {
        eventIndex: 0,
        events: events2,
        iterator: 0,
        node: node3,
        visitorIndex: 0,
        visitors: []
      };
    }
    function cleanMarks(node3) {
      node3[isClean] = false;
      if (node3.nodes) node3.nodes.forEach((i) => cleanMarks(i));
      return node3;
    }
    var postcss3 = {};
    var LazyResult = class _LazyResult {
      constructor(processor2, css, opts) {
        this.stringified = false;
        this.processed = false;
        let root4;
        if (typeof css === "object" && css !== null && (css.type === "root" || css.type === "document")) {
          root4 = cleanMarks(css);
        } else if (css instanceof _LazyResult || css instanceof Result2) {
          root4 = cleanMarks(css.root);
          if (css.map) {
            if (typeof opts.map === "undefined") opts.map = {};
            if (!opts.map.inline) opts.map.inline = false;
            opts.map.prev = css.map;
          }
        } else {
          let parser2 = parse6;
          if (opts.syntax) parser2 = opts.syntax.parse;
          if (opts.parser) parser2 = opts.parser;
          if (parser2.parse) parser2 = parser2.parse;
          try {
            root4 = parser2(css, opts);
          } catch (error) {
            this.processed = true;
            this.error = error;
          }
          if (root4 && !root4[my]) {
            Container2.rebuild(root4);
          }
        }
        this.result = new Result2(processor2, root4, opts);
        this.helpers = { ...postcss3, postcss: postcss3, result: this.result };
        this.plugins = this.processor.plugins.map((plugin3) => {
          if (typeof plugin3 === "object" && plugin3.prepare) {
            return { ...plugin3, ...plugin3.prepare(this.result) };
          } else {
            return plugin3;
          }
        });
      }
      async() {
        if (this.error) return Promise.reject(this.error);
        if (this.processed) return Promise.resolve(this.result);
        if (!this.processing) {
          this.processing = this.runAsync();
        }
        return this.processing;
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      getAsyncError() {
        throw new Error("Use process(css).then(cb) to work with async plugins");
      }
      handleError(error, node3) {
        let plugin3 = this.result.lastPlugin;
        try {
          if (node3) node3.addToError(error);
          this.error = error;
          if (error.name === "CssSyntaxError" && !error.plugin) {
            error.plugin = plugin3.postcssPlugin;
            error.setMessage();
          } else if (plugin3.postcssVersion) {
            if (process.env.NODE_ENV !== "production") {
              let pluginName = plugin3.postcssPlugin;
              let pluginVer = plugin3.postcssVersion;
              let runtimeVer = this.result.processor.version;
              let a = pluginVer.split(".");
              let b = runtimeVer.split(".");
              if (a[0] !== b[0] || parseInt(a[1]) > parseInt(b[1])) {
                console.error(
                  "Unknown error from PostCSS plugin. Your current PostCSS version is " + runtimeVer + ", but " + pluginName + " uses " + pluginVer + ". Perhaps this is the source of the error below."
                );
              }
            }
          }
        } catch (err) {
          if (console && console.error) console.error(err);
        }
        return error;
      }
      prepareVisitors() {
        this.listeners = {};
        let add = (plugin3, type, cb) => {
          if (!this.listeners[type]) this.listeners[type] = [];
          this.listeners[type].push([plugin3, cb]);
        };
        for (let plugin3 of this.plugins) {
          if (typeof plugin3 === "object") {
            for (let event in plugin3) {
              if (!PLUGIN_PROPS[event] && /^[A-Z]/.test(event)) {
                throw new Error(
                  `Unknown event ${event} in ${plugin3.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
                );
              }
              if (!NOT_VISITORS[event]) {
                if (typeof plugin3[event] === "object") {
                  for (let filter2 in plugin3[event]) {
                    if (filter2 === "*") {
                      add(plugin3, event, plugin3[event][filter2]);
                    } else {
                      add(
                        plugin3,
                        event + "-" + filter2.toLowerCase(),
                        plugin3[event][filter2]
                      );
                    }
                  }
                } else if (typeof plugin3[event] === "function") {
                  add(plugin3, event, plugin3[event]);
                }
              }
            }
          }
        }
        this.hasListener = Object.keys(this.listeners).length > 0;
      }
      async runAsync() {
        this.plugin = 0;
        for (let i = 0; i < this.plugins.length; i++) {
          let plugin3 = this.plugins[i];
          let promise2 = this.runOnRoot(plugin3);
          if (isPromise(promise2)) {
            try {
              await promise2;
            } catch (error) {
              throw this.handleError(error);
            }
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root4 = this.result.root;
          while (!root4[isClean]) {
            root4[isClean] = true;
            let stack = [toStack(root4)];
            while (stack.length > 0) {
              let promise2 = this.visitTick(stack);
              if (isPromise(promise2)) {
                try {
                  await promise2;
                } catch (e) {
                  let node3 = stack[stack.length - 1].node;
                  throw this.handleError(e, node3);
                }
              }
            }
          }
          if (this.listeners.OnceExit) {
            for (let [plugin3, visitor] of this.listeners.OnceExit) {
              this.result.lastPlugin = plugin3;
              try {
                if (root4.type === "document") {
                  let roots = root4.nodes.map(
                    (subRoot) => visitor(subRoot, this.helpers)
                  );
                  await Promise.all(roots);
                } else {
                  await visitor(root4, this.helpers);
                }
              } catch (e) {
                throw this.handleError(e);
              }
            }
          }
        }
        this.processed = true;
        return this.stringify();
      }
      runOnRoot(plugin3) {
        this.result.lastPlugin = plugin3;
        try {
          if (typeof plugin3 === "object" && plugin3.Once) {
            if (this.result.root.type === "document") {
              let roots = this.result.root.nodes.map(
                (root4) => plugin3.Once(root4, this.helpers)
              );
              if (isPromise(roots[0])) {
                return Promise.all(roots);
              }
              return roots;
            }
            return plugin3.Once(this.result.root, this.helpers);
          } else if (typeof plugin3 === "function") {
            return plugin3(this.result.root, this.result);
          }
        } catch (error) {
          throw this.handleError(error);
        }
      }
      stringify() {
        if (this.error) throw this.error;
        if (this.stringified) return this.result;
        this.stringified = true;
        this.sync();
        let opts = this.result.opts;
        let str2 = stringify5;
        if (opts.syntax) str2 = opts.syntax.stringify;
        if (opts.stringifier) str2 = opts.stringifier;
        if (str2.stringify) str2 = str2.stringify;
        let map = new MapGenerator(str2, this.result.root, this.result.opts);
        let data = map.generate();
        this.result.css = data[0];
        this.result.map = data[1];
        return this.result;
      }
      sync() {
        if (this.error) throw this.error;
        if (this.processed) return this.result;
        this.processed = true;
        if (this.processing) {
          throw this.getAsyncError();
        }
        for (let plugin3 of this.plugins) {
          let promise2 = this.runOnRoot(plugin3);
          if (isPromise(promise2)) {
            throw this.getAsyncError();
          }
        }
        this.prepareVisitors();
        if (this.hasListener) {
          let root4 = this.result.root;
          while (!root4[isClean]) {
            root4[isClean] = true;
            this.walkSync(root4);
          }
          if (this.listeners.OnceExit) {
            if (root4.type === "document") {
              for (let subRoot of root4.nodes) {
                this.visitSync(this.listeners.OnceExit, subRoot);
              }
            } else {
              this.visitSync(this.listeners.OnceExit, root4);
            }
          }
        }
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (process.env.NODE_ENV !== "production") {
          if (!("from" in this.opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this.css;
      }
      visitSync(visitors, node3) {
        for (let [plugin3, visitor] of visitors) {
          this.result.lastPlugin = plugin3;
          let promise2;
          try {
            promise2 = visitor(node3, this.helpers);
          } catch (e) {
            throw this.handleError(e, node3.proxyOf);
          }
          if (node3.type !== "root" && node3.type !== "document" && !node3.parent) {
            return true;
          }
          if (isPromise(promise2)) {
            throw this.getAsyncError();
          }
        }
      }
      visitTick(stack) {
        let visit2 = stack[stack.length - 1];
        let { node: node3, visitors } = visit2;
        if (node3.type !== "root" && node3.type !== "document" && !node3.parent) {
          stack.pop();
          return;
        }
        if (visitors.length > 0 && visit2.visitorIndex < visitors.length) {
          let [plugin3, visitor] = visitors[visit2.visitorIndex];
          visit2.visitorIndex += 1;
          if (visit2.visitorIndex === visitors.length) {
            visit2.visitors = [];
            visit2.visitorIndex = 0;
          }
          this.result.lastPlugin = plugin3;
          try {
            return visitor(node3.toProxy(), this.helpers);
          } catch (e) {
            throw this.handleError(e, node3);
          }
        }
        if (visit2.iterator !== 0) {
          let iterator = visit2.iterator;
          let child;
          while (child = node3.nodes[node3.indexes[iterator]]) {
            node3.indexes[iterator] += 1;
            if (!child[isClean]) {
              child[isClean] = true;
              stack.push(toStack(child));
              return;
            }
          }
          visit2.iterator = 0;
          delete node3.indexes[iterator];
        }
        let events2 = visit2.events;
        while (visit2.eventIndex < events2.length) {
          let event = events2[visit2.eventIndex];
          visit2.eventIndex += 1;
          if (event === CHILDREN) {
            if (node3.nodes && node3.nodes.length) {
              node3[isClean] = true;
              visit2.iterator = node3.getIterator();
            }
            return;
          } else if (this.listeners[event]) {
            visit2.visitors = this.listeners[event];
            return;
          }
        }
        stack.pop();
      }
      walkSync(node3) {
        node3[isClean] = true;
        let events2 = getEvents(node3);
        for (let event of events2) {
          if (event === CHILDREN) {
            if (node3.nodes) {
              node3.each((child) => {
                if (!child[isClean]) this.walkSync(child);
              });
            }
          } else {
            let visitors = this.listeners[event];
            if (visitors) {
              if (this.visitSync(visitors, node3.toProxy())) return;
            }
          }
        }
      }
      warnings() {
        return this.sync().warnings();
      }
      get content() {
        return this.stringify().content;
      }
      get css() {
        return this.stringify().css;
      }
      get map() {
        return this.stringify().map;
      }
      get messages() {
        return this.sync().messages;
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        return this.sync().root;
      }
      get [Symbol.toStringTag]() {
        return "LazyResult";
      }
    };
    LazyResult.registerPostcss = (dependant) => {
      postcss3 = dependant;
    };
    module.exports = LazyResult;
    LazyResult.default = LazyResult;
    Root2.registerLazyResult(LazyResult);
    Document3.registerLazyResult(LazyResult);
  }
});

// node_modules/postcss/lib/no-work-result.js
var require_no_work_result = __commonJS({
  "node_modules/postcss/lib/no-work-result.js"(exports2, module) {
    "use strict";
    var MapGenerator = require_map_generator();
    var parse6 = require_parse();
    var Result2 = require_result();
    var stringify5 = require_stringify();
    var warnOnce = require_warn_once();
    var NoWorkResult = class {
      constructor(processor2, css, opts) {
        css = css.toString();
        this.stringified = false;
        this._processor = processor2;
        this._css = css;
        this._opts = opts;
        this._map = void 0;
        let root4;
        let str2 = stringify5;
        this.result = new Result2(this._processor, root4, this._opts);
        this.result.css = css;
        let self2 = this;
        Object.defineProperty(this.result, "root", {
          get() {
            return self2.root;
          }
        });
        let map = new MapGenerator(str2, root4, this._opts, css);
        if (map.isMap()) {
          let [generatedCSS, generatedMap] = map.generate();
          if (generatedCSS) {
            this.result.css = generatedCSS;
          }
          if (generatedMap) {
            this.result.map = generatedMap;
          }
        } else {
          map.clearAnnotation();
          this.result.css = map.css;
        }
      }
      async() {
        if (this.error) return Promise.reject(this.error);
        return Promise.resolve(this.result);
      }
      catch(onRejected) {
        return this.async().catch(onRejected);
      }
      finally(onFinally) {
        return this.async().then(onFinally, onFinally);
      }
      sync() {
        if (this.error) throw this.error;
        return this.result;
      }
      then(onFulfilled, onRejected) {
        if (process.env.NODE_ENV !== "production") {
          if (!("from" in this._opts)) {
            warnOnce(
              "Without `from` option PostCSS could generate wrong source map and will not find Browserslist config. Set it to CSS file path or to `undefined` to prevent this warning."
            );
          }
        }
        return this.async().then(onFulfilled, onRejected);
      }
      toString() {
        return this._css;
      }
      warnings() {
        return [];
      }
      get content() {
        return this.result.css;
      }
      get css() {
        return this.result.css;
      }
      get map() {
        return this.result.map;
      }
      get messages() {
        return [];
      }
      get opts() {
        return this.result.opts;
      }
      get processor() {
        return this.result.processor;
      }
      get root() {
        if (this._root) {
          return this._root;
        }
        let root4;
        let parser2 = parse6;
        try {
          root4 = parser2(this._css, this._opts);
        } catch (error) {
          this.error = error;
        }
        if (this.error) {
          throw this.error;
        } else {
          this._root = root4;
          return root4;
        }
      }
      get [Symbol.toStringTag]() {
        return "NoWorkResult";
      }
    };
    module.exports = NoWorkResult;
    NoWorkResult.default = NoWorkResult;
  }
});

// node_modules/postcss/lib/processor.js
var require_processor = __commonJS({
  "node_modules/postcss/lib/processor.js"(exports2, module) {
    "use strict";
    var Document3 = require_document();
    var LazyResult = require_lazy_result();
    var NoWorkResult = require_no_work_result();
    var Root2 = require_root();
    var Processor3 = class {
      constructor(plugins2 = []) {
        this.version = "8.4.47";
        this.plugins = this.normalize(plugins2);
      }
      normalize(plugins2) {
        let normalized = [];
        for (let i of plugins2) {
          if (i.postcss === true) {
            i = i();
          } else if (i.postcss) {
            i = i.postcss;
          }
          if (typeof i === "object" && Array.isArray(i.plugins)) {
            normalized = normalized.concat(i.plugins);
          } else if (typeof i === "object" && i.postcssPlugin) {
            normalized.push(i);
          } else if (typeof i === "function") {
            normalized.push(i);
          } else if (typeof i === "object" && (i.parse || i.stringify)) {
            if (process.env.NODE_ENV !== "production") {
              throw new Error(
                "PostCSS syntaxes cannot be used as plugins. Instead, please use one of the syntax/parser/stringifier options as outlined in your PostCSS runner documentation."
              );
            }
          } else {
            throw new Error(i + " is not a PostCSS plugin");
          }
        }
        return normalized;
      }
      process(css, opts = {}) {
        if (!this.plugins.length && !opts.parser && !opts.stringifier && !opts.syntax) {
          return new NoWorkResult(this, css, opts);
        } else {
          return new LazyResult(this, css, opts);
        }
      }
      use(plugin3) {
        this.plugins = this.plugins.concat(this.normalize([plugin3]));
        return this;
      }
    };
    module.exports = Processor3;
    Processor3.default = Processor3;
    Root2.registerProcessor(Processor3);
    Document3.registerProcessor(Processor3);
  }
});

// node_modules/postcss/lib/postcss.js
var require_postcss = __commonJS({
  "node_modules/postcss/lib/postcss.js"(exports2, module) {
    "use strict";
    var AtRule2 = require_at_rule();
    var Comment2 = require_comment();
    var Container2 = require_container();
    var CssSyntaxError2 = require_css_syntax_error();
    var Declaration2 = require_declaration();
    var Document3 = require_document();
    var fromJSON2 = require_fromJSON();
    var Input2 = require_input();
    var LazyResult = require_lazy_result();
    var list2 = require_list();
    var Node2 = require_node();
    var parse6 = require_parse();
    var Processor3 = require_processor();
    var Result2 = require_result();
    var Root2 = require_root();
    var Rule2 = require_rule();
    var stringify5 = require_stringify();
    var Warning2 = require_warning();
    function postcss3(...plugins2) {
      if (plugins2.length === 1 && Array.isArray(plugins2[0])) {
        plugins2 = plugins2[0];
      }
      return new Processor3(plugins2);
    }
    postcss3.plugin = function plugin3(name2, initializer) {
      let warningPrinted = false;
      function creator(...args) {
        if (console && console.warn && !warningPrinted) {
          warningPrinted = true;
          console.warn(
            name2 + ": postcss.plugin was deprecated. Migration guide:\nhttps://evilmartians.com/chronicles/postcss-8-plugin-migration"
          );
          if (process.env.LANG && process.env.LANG.startsWith("cn")) {
            console.warn(
              name2 + ": \u91CC\u9762 postcss.plugin \u88AB\u5F03\u7528. \u8FC1\u79FB\u6307\u5357:\nhttps://www.w3ctech.com/topic/2226"
            );
          }
        }
        let transformer = initializer(...args);
        transformer.postcssPlugin = name2;
        transformer.postcssVersion = new Processor3().version;
        return transformer;
      }
      let cache2;
      Object.defineProperty(creator, "postcss", {
        get() {
          if (!cache2) cache2 = creator();
          return cache2;
        }
      });
      creator.process = function(css, processOpts, pluginOpts) {
        return postcss3([creator(pluginOpts)]).process(css, processOpts);
      };
      return creator;
    };
    postcss3.stringify = stringify5;
    postcss3.parse = parse6;
    postcss3.fromJSON = fromJSON2;
    postcss3.list = list2;
    postcss3.comment = (defaults2) => new Comment2(defaults2);
    postcss3.atRule = (defaults2) => new AtRule2(defaults2);
    postcss3.decl = (defaults2) => new Declaration2(defaults2);
    postcss3.rule = (defaults2) => new Rule2(defaults2);
    postcss3.root = (defaults2) => new Root2(defaults2);
    postcss3.document = (defaults2) => new Document3(defaults2);
    postcss3.CssSyntaxError = CssSyntaxError2;
    postcss3.Declaration = Declaration2;
    postcss3.Container = Container2;
    postcss3.Processor = Processor3;
    postcss3.Document = Document3;
    postcss3.Comment = Comment2;
    postcss3.Warning = Warning2;
    postcss3.AtRule = AtRule2;
    postcss3.Result = Result2;
    postcss3.Input = Input2;
    postcss3.Rule = Rule2;
    postcss3.Root = Root2;
    postcss3.Node = Node2;
    LazyResult.registerPostcss(postcss3);
    module.exports = postcss3;
    postcss3.default = postcss3;
  }
});

// node_modules/postcss/lib/postcss.mjs
var postcss_exports = {};
__export(postcss_exports, {
  AtRule: () => AtRule,
  Comment: () => Comment,
  Container: () => Container,
  CssSyntaxError: () => CssSyntaxError,
  Declaration: () => Declaration,
  Document: () => Document,
  Input: () => Input,
  Node: () => Node,
  Processor: () => Processor,
  Result: () => Result,
  Root: () => Root,
  Rule: () => Rule,
  Warning: () => Warning,
  atRule: () => atRule,
  comment: () => comment,
  decl: () => decl,
  default: () => postcss_default,
  document: () => document2,
  fromJSON: () => fromJSON,
  list: () => list,
  parse: () => parse3,
  plugin: () => plugin,
  root: () => root,
  rule: () => rule,
  stringify: () => stringify3
});
var import_postcss, postcss_default, stringify3, fromJSON, plugin, parse3, list, document2, comment, atRule, rule, decl, root, CssSyntaxError, Declaration, Container, Processor, Document, Comment, Warning, AtRule, Result, Input, Rule, Root, Node;
var init_postcss = __esm({
  "node_modules/postcss/lib/postcss.mjs"() {
    import_postcss = __toESM(require_postcss(), 1);
    postcss_default = import_postcss.default;
    stringify3 = import_postcss.default.stringify;
    fromJSON = import_postcss.default.fromJSON;
    plugin = import_postcss.default.plugin;
    parse3 = import_postcss.default.parse;
    list = import_postcss.default.list;
    document2 = import_postcss.default.document;
    comment = import_postcss.default.comment;
    atRule = import_postcss.default.atRule;
    rule = import_postcss.default.rule;
    decl = import_postcss.default.decl;
    root = import_postcss.default.root;
    CssSyntaxError = import_postcss.default.CssSyntaxError;
    Declaration = import_postcss.default.Declaration;
    Container = import_postcss.default.Container;
    Processor = import_postcss.default.Processor;
    Document = import_postcss.default.Document;
    Comment = import_postcss.default.Comment;
    Warning = import_postcss.default.Warning;
    AtRule = import_postcss.default.AtRule;
    Result = import_postcss.default.Result;
    Input = import_postcss.default.Input;
    Rule = import_postcss.default.Rule;
    Root = import_postcss.default.Root;
    Node = import_postcss.default.Node;
  }
});

// node_modules/vite/dist/node/chunks/dep-CEGXe0Sr.js
var dep_CEGXe0Sr_exports = {};
__export(dep_CEGXe0Sr_exports, {
  i: () => index$12
});
import require$$0__default2 from "fs";
import require$$0$1 from "path";
import require$$3 from "crypto";
import require$$0$2 from "util";
import { fileURLToPath as __cjs_fileURLToPath3 } from "node:url";
import { dirname as __cjs_dirname3 } from "node:path";
import { createRequire as __cjs_createRequire3 } from "node:module";
function _mergeNamespaces2(n, m) {
  for (var i = 0; i < m.length; i++) {
    var e = m[i];
    if (typeof e !== "string" && !Array.isArray(e)) {
      for (var k in e) {
        if (k !== "default" && !(k in n)) {
          n[k] = e[k];
        }
      }
    }
  }
  return n;
}
function setFileSystem(fs6) {
  fileSystem.readFile = fs6.readFile;
  fileSystem.writeFile = fs6.writeFile;
}
function getFileSystem() {
  return fileSystem;
}
function unquote(str2) {
  if (!str2) {
    return "";
  }
  if (reg.test(str2.charAt(0))) {
    str2 = str2.substr(1);
  }
  if (reg.test(str2.charAt(str2.length - 1))) {
    str2 = str2.substr(0, str2.length - 1);
  }
  return str2;
}
function saveJSON(cssFile, json) {
  return new Promise((resolve8, reject) => {
    const {
      writeFile
    } = (0, _fs$2.getFileSystem)();
    writeFile(`${cssFile}.json`, JSON.stringify(json), (e) => e ? reject(e) : resolve8(json));
  });
}
function arrayReduce(array2, iteratee, accumulator, initAccum) {
  var index4 = -1, length = array2 ? array2.length : 0;
  while (++index4 < length) {
    accumulator = iteratee(accumulator, array2[index4], index4, array2);
  }
  return accumulator;
}
function asciiToArray(string4) {
  return string4.split("");
}
function asciiWords(string4) {
  return string4.match(reAsciiWord) || [];
}
function basePropertyOf(object2) {
  return function(key) {
    return object2 == null ? void 0 : object2[key];
  };
}
function hasUnicode(string4) {
  return reHasUnicode.test(string4);
}
function hasUnicodeWord(string4) {
  return reHasUnicodeWord.test(string4);
}
function stringToArray(string4) {
  return hasUnicode(string4) ? unicodeToArray(string4) : asciiToArray(string4);
}
function unicodeToArray(string4) {
  return string4.match(reUnicode) || [];
}
function unicodeWords(string4) {
  return string4.match(reUnicodeWord) || [];
}
function baseSlice(array2, start, end) {
  var index4 = -1, length = array2.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index4 < length) {
    result[index4] = array2[index4 + start];
  }
  return result;
}
function baseToString(value2) {
  if (typeof value2 == "string") {
    return value2;
  }
  if (isSymbol(value2)) {
    return symbolToString ? symbolToString.call(value2) : "";
  }
  var result = value2 + "";
  return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
}
function castSlice(array2, start, end) {
  var length = array2.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array2 : baseSlice(array2, start, end);
}
function createCaseFirst(methodName) {
  return function(string4) {
    string4 = toString(string4);
    var strSymbols = hasUnicode(string4) ? stringToArray(string4) : void 0;
    var chr = strSymbols ? strSymbols[0] : string4.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string4.slice(1);
    return chr[methodName]() + trailing;
  };
}
function createCompounder(callback) {
  return function(string4) {
    return arrayReduce(words(deburr(string4).replace(reApos, "")), callback, "");
  };
}
function isObjectLike(value2) {
  return !!value2 && typeof value2 == "object";
}
function isSymbol(value2) {
  return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
}
function toString(value2) {
  return value2 == null ? "" : baseToString(value2);
}
function capitalize(string4) {
  return upperFirst(toString(string4).toLowerCase());
}
function deburr(string4) {
  string4 = toString(string4);
  return string4 && string4.replace(reLatin, deburrLetter).replace(reComboMark, "");
}
function words(string4, pattern2, guard) {
  string4 = toString(string4);
  pattern2 = pattern2;
  if (pattern2 === void 0) {
    return hasUnicodeWord(string4) ? unicodeWords(string4) : asciiWords(string4);
  }
  return string4.match(pattern2) || [];
}
function _interopRequireDefault$5(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function dashesCamelCase(string4) {
  return string4.replace(/-+(\w)/g, (_, firstLetter) => firstLetter.toUpperCase());
}
function makeLocalsConventionReducer(localsConvention2, inputFile) {
  const isFunc = typeof localsConvention2 === "function";
  return (tokens, [className3, value2]) => {
    if (isFunc) {
      const convention = localsConvention2(className3, value2, inputFile);
      tokens[convention] = value2;
      return tokens;
    }
    switch (localsConvention2) {
      case "camelCase":
        tokens[className3] = value2;
        tokens[(0, _lodash.default)(className3)] = value2;
        break;
      case "camelCaseOnly":
        tokens[(0, _lodash.default)(className3)] = value2;
        break;
      case "dashes":
        tokens[className3] = value2;
        tokens[dashesCamelCase(className3)] = value2;
        break;
      case "dashesOnly":
        tokens[dashesCamelCase(className3)] = value2;
        break;
    }
    return tokens;
  };
}
function _interopRequireDefault$4(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function createError(node3, graph) {
  const er = new Error("Nondeterministic import's order");
  const related = graph[node3];
  const relatedNode = related.find(
    (relatedNode2) => graph[relatedNode2].indexOf(node3) > -1
  );
  er.nodes = [node3, relatedNode];
  return er;
}
function walkGraph(node3, graph, state, result, strict) {
  if (state[node3] === PERMANENT_MARKER) {
    return;
  }
  if (state[node3] === TEMPORARY_MARKER) {
    if (strict) {
      return createError(node3, graph);
    }
    return;
  }
  state[node3] = TEMPORARY_MARKER;
  const children = graph[node3];
  const length = children.length;
  for (let i = 0; i < length; ++i) {
    const error = walkGraph(children[i], graph, state, result, strict);
    if (error instanceof Error) {
      return error;
    }
  }
  state[node3] = PERMANENT_MARKER;
  result.push(node3);
}
function topologicalSort$1(graph, strict) {
  const result = [];
  const state = {};
  const nodes = Object.keys(graph);
  const length = nodes.length;
  for (let i = 0; i < length; ++i) {
    const er = walkGraph(nodes[i], graph, state, result, strict);
    if (er instanceof Error) {
      return er;
    }
  }
  return result;
}
function addImportToGraph(importId, parentId, graph, visited) {
  const siblingsId = parentId + "_siblings";
  const visitedId = parentId + "_" + importId;
  if (visited[visitedId] !== VISITED_MARKER) {
    if (!Array.isArray(visited[siblingsId])) {
      visited[siblingsId] = [];
    }
    const siblings = visited[siblingsId];
    if (Array.isArray(graph[importId])) {
      graph[importId] = graph[importId].concat(siblings);
    } else {
      graph[importId] = siblings.slice();
    }
    visited[visitedId] = VISITED_MARKER;
    siblings.push(importId);
  }
}
function requireWasmHash() {
  if (hasRequiredWasmHash) return wasmHash.exports;
  hasRequiredWasmHash = 1;
  const MAX_SHORT_STRING = Math.floor((65536 - 64) / 4) & ~3;
  class WasmHash {
    /**
     * @param {WebAssembly.Instance} instance wasm instance
     * @param {WebAssembly.Instance[]} instancesPool pool of instances
     * @param {number} chunkSize size of data chunks passed to wasm
     * @param {number} digestSize size of digest returned by wasm
     */
    constructor(instance, instancesPool, chunkSize, digestSize) {
      const exports2 = (
        /** @type {any} */
        instance.exports
      );
      exports2.init();
      this.exports = exports2;
      this.mem = Buffer.from(exports2.memory.buffer, 0, 65536);
      this.buffered = 0;
      this.instancesPool = instancesPool;
      this.chunkSize = chunkSize;
      this.digestSize = digestSize;
    }
    reset() {
      this.buffered = 0;
      this.exports.init();
    }
    /**
     * @param {Buffer | string} data data
     * @param {BufferEncoding=} encoding encoding
     * @returns {this} itself
     */
    update(data, encoding) {
      if (typeof data === "string") {
        while (data.length > MAX_SHORT_STRING) {
          this._updateWithShortString(data.slice(0, MAX_SHORT_STRING), encoding);
          data = data.slice(MAX_SHORT_STRING);
        }
        this._updateWithShortString(data, encoding);
        return this;
      }
      this._updateWithBuffer(data);
      return this;
    }
    /**
     * @param {string} data data
     * @param {BufferEncoding=} encoding encoding
     * @returns {void}
     */
    _updateWithShortString(data, encoding) {
      const { exports: exports2, buffered, mem, chunkSize } = this;
      let endPos;
      if (data.length < 70) {
        if (!encoding || encoding === "utf-8" || encoding === "utf8") {
          endPos = buffered;
          for (let i = 0; i < data.length; i++) {
            const cc = data.charCodeAt(i);
            if (cc < 128) {
              mem[endPos++] = cc;
            } else if (cc < 2048) {
              mem[endPos] = cc >> 6 | 192;
              mem[endPos + 1] = cc & 63 | 128;
              endPos += 2;
            } else {
              endPos += mem.write(data.slice(i), endPos, encoding);
              break;
            }
          }
        } else if (encoding === "latin1") {
          endPos = buffered;
          for (let i = 0; i < data.length; i++) {
            const cc = data.charCodeAt(i);
            mem[endPos++] = cc;
          }
        } else {
          endPos = buffered + mem.write(data, buffered, encoding);
        }
      } else {
        endPos = buffered + mem.write(data, buffered, encoding);
      }
      if (endPos < chunkSize) {
        this.buffered = endPos;
      } else {
        const l = endPos & ~(this.chunkSize - 1);
        exports2.update(l);
        const newBuffered = endPos - l;
        this.buffered = newBuffered;
        if (newBuffered > 0) {
          mem.copyWithin(0, l, endPos);
        }
      }
    }
    /**
     * @param {Buffer} data data
     * @returns {void}
     */
    _updateWithBuffer(data) {
      const { exports: exports2, buffered, mem } = this;
      const length = data.length;
      if (buffered + length < this.chunkSize) {
        data.copy(mem, buffered, 0, length);
        this.buffered += length;
      } else {
        const l = buffered + length & ~(this.chunkSize - 1);
        if (l > 65536) {
          let i = 65536 - buffered;
          data.copy(mem, buffered, 0, i);
          exports2.update(65536);
          const stop = l - buffered - 65536;
          while (i < stop) {
            data.copy(mem, 0, i, i + 65536);
            exports2.update(65536);
            i += 65536;
          }
          data.copy(mem, 0, i, l - buffered);
          exports2.update(l - buffered - i);
        } else {
          data.copy(mem, buffered, 0, l - buffered);
          exports2.update(l);
        }
        const newBuffered = length + buffered - l;
        this.buffered = newBuffered;
        if (newBuffered > 0) {
          data.copy(mem, 0, length - newBuffered, length);
        }
      }
    }
    digest(type) {
      const { exports: exports2, buffered, mem, digestSize } = this;
      exports2.final(buffered);
      this.instancesPool.push(this);
      const hex = mem.toString("latin1", 0, digestSize);
      if (type === "hex") {
        return hex;
      }
      if (type === "binary" || !type) {
        return Buffer.from(hex, "hex");
      }
      return Buffer.from(hex, "hex").toString(type);
    }
  }
  const create = (wasmModule, instancesPool, chunkSize, digestSize) => {
    if (instancesPool.length > 0) {
      const old = instancesPool.pop();
      old.reset();
      return old;
    } else {
      return new WasmHash(
        new WebAssembly.Instance(wasmModule),
        instancesPool,
        chunkSize,
        digestSize
      );
    }
  };
  wasmHash.exports = create;
  wasmHash.exports.MAX_SHORT_STRING = MAX_SHORT_STRING;
  return wasmHash.exports;
}
function requireXxhash64() {
  if (hasRequiredXxhash64) return xxhash64_1;
  hasRequiredXxhash64 = 1;
  const create = requireWasmHash();
  const xxhash64 = new WebAssembly.Module(
    Buffer.from(
      // 1173 bytes
      "AGFzbQEAAAABCAJgAX8AYAAAAwQDAQAABQMBAAEGGgV+AUIAC34BQgALfgFCAAt+AUIAC34BQgALByIEBGluaXQAAAZ1cGRhdGUAAQVmaW5hbAACBm1lbW9yeQIACrUIAzAAQtbrgu7q/Yn14AAkAELP1tO+0ser2UIkAUIAJAJC+erQ0OfJoeThACQDQgAkBAvUAQIBfwR+IABFBEAPCyMEIACtfCQEIwAhAiMBIQMjAiEEIwMhBQNAIAIgASkDAELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiECIAMgASkDCELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEDIAQgASkDEELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEEIAUgASkDGELP1tO+0ser2UJ+fEIfiUKHla+vmLbem55/fiEFIAAgAUEgaiIBSw0ACyACJAAgAyQBIAQkAiAFJAMLqwYCAX8EfiMEQgBSBH4jACICQgGJIwEiA0IHiXwjAiIEQgyJfCMDIgVCEol8IAJCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gA0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSAEQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IAVCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0FQsXP2bLx5brqJwsjBCAArXx8IQIDQCABQQhqIABNBEAgAiABKQMAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQhuJQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IQIgAUEIaiEBDAELCyABQQRqIABNBEACfyACIAE1AgBCh5Wvr5i23puef36FQheJQs/W077Sx6vZQn5C+fPd8Zn2masWfCECIAFBBGoLIQELA0AgACABRwRAIAIgATEAAELFz9my8eW66id+hUILiUKHla+vmLbem55/fiECIAFBAWohAQwBCwtBACACIAJCIYiFQs/W077Sx6vZQn4iAiACQh2IhUL5893xmfaZqxZ+IgIgAkIgiIUiAkIgiCIDQv//A4NCIIYgA0KAgPz/D4NCEIiEIgNC/4GAgPAfg0IQhiADQoD+g4CA4D+DQgiIhCIDQo+AvIDwgcAHg0IIhiADQvCBwIeAnoD4AINCBIiEIgNChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IANCsODAgYOGjJgwhHw3AwBBCCACQv////8PgyICQv//A4NCIIYgAkKAgPz/D4NCEIiEIgJC/4GAgPAfg0IQhiACQoD+g4CA4D+DQgiIhCICQo+AvIDwgcAHg0IIhiACQvCBwIeAnoD4AINCBIiEIgJChoyYsODAgYMGfEIEiEKBgoSIkKDAgAGDQid+IAJCsODAgYOGjJgwhHw3AwAL",
      "base64"
    )
  );
  xxhash64_1 = create.bind(null, xxhash64, [], 32, 16);
  return xxhash64_1;
}
function requireBatchedHash() {
  if (hasRequiredBatchedHash) return BatchedHash_1;
  hasRequiredBatchedHash = 1;
  const MAX_SHORT_STRING = requireWasmHash().MAX_SHORT_STRING;
  class BatchedHash2 {
    constructor(hash3) {
      this.string = void 0;
      this.encoding = void 0;
      this.hash = hash3;
    }
    /**
     * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
     * @param {string|Buffer} data data
     * @param {string=} inputEncoding data encoding
     * @returns {this} updated hash
     */
    update(data, inputEncoding) {
      if (this.string !== void 0) {
        if (typeof data === "string" && inputEncoding === this.encoding && this.string.length + data.length < MAX_SHORT_STRING) {
          this.string += data;
          return this;
        }
        this.hash.update(this.string, this.encoding);
        this.string = void 0;
      }
      if (typeof data === "string") {
        if (data.length < MAX_SHORT_STRING && // base64 encoding is not valid since it may contain padding chars
        (!inputEncoding || !inputEncoding.startsWith("ba"))) {
          this.string = data;
          this.encoding = inputEncoding;
        } else {
          this.hash.update(data, inputEncoding);
        }
      } else {
        this.hash.update(data);
      }
      return this;
    }
    /**
     * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
     * @param {string=} encoding encoding of the return value
     * @returns {string|Buffer} digest
     */
    digest(encoding) {
      if (this.string !== void 0) {
        this.hash.update(this.string, this.encoding);
      }
      return this.hash.digest(encoding);
    }
  }
  BatchedHash_1 = BatchedHash2;
  return BatchedHash_1;
}
function requireMd4() {
  if (hasRequiredMd4) return md4_1;
  hasRequiredMd4 = 1;
  const create = requireWasmHash();
  const md4 = new WebAssembly.Module(
    Buffer.from(
      // 2150 bytes
      "AGFzbQEAAAABCAJgAX8AYAAAAwUEAQAAAAUDAQABBhoFfwFBAAt/AUEAC38BQQALfwFBAAt/AUEACwciBARpbml0AAAGdXBkYXRlAAIFZmluYWwAAwZtZW1vcnkCAAqFEAQmAEGBxpS6BiQBQYnXtv5+JAJB/rnrxXkkA0H2qMmBASQEQQAkAAvMCgEYfyMBIQojAiEGIwMhByMEIQgDQCAAIAVLBEAgBSgCCCINIAcgBiAFKAIEIgsgCCAHIAUoAgAiDCAKIAggBiAHIAhzcXNqakEDdyIDIAYgB3Nxc2pqQQd3IgEgAyAGc3FzampBC3chAiAFKAIUIg8gASACIAUoAhAiCSADIAEgBSgCDCIOIAYgAyACIAEgA3Nxc2pqQRN3IgQgASACc3FzampBA3ciAyACIARzcXNqakEHdyEBIAUoAiAiEiADIAEgBSgCHCIRIAQgAyAFKAIYIhAgAiAEIAEgAyAEc3FzampBC3ciAiABIANzcXNqakETdyIEIAEgAnNxc2pqQQN3IQMgBSgCLCIVIAQgAyAFKAIoIhQgAiAEIAUoAiQiEyABIAIgAyACIARzcXNqakEHdyIBIAMgBHNxc2pqQQt3IgIgASADc3FzampBE3chBCAPIBAgCSAVIBQgEyAFKAI4IhYgAiAEIAUoAjQiFyABIAIgBSgCMCIYIAMgASAEIAEgAnNxc2pqQQN3IgEgAiAEc3FzampBB3ciAiABIARzcXNqakELdyIDIAkgAiAMIAEgBSgCPCIJIAQgASADIAEgAnNxc2pqQRN3IgEgAiADcnEgAiADcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyaiASakGZ84nUBWpBCXciAyAPIAQgCyACIBggASADIAIgBHJxIAIgBHFyampBmfOJ1AVqQQ13IgEgAyAEcnEgAyAEcXJqakGZ84nUBWpBA3ciAiABIANycSABIANxcmpqQZnzidQFakEFdyIEIAEgAnJxIAEgAnFyampBmfOJ1AVqQQl3IgMgECAEIAIgFyABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmogDWpBmfOJ1AVqQQN3IgIgASADcnEgASADcXJqakGZ84nUBWpBBXciBCABIAJycSABIAJxcmpqQZnzidQFakEJdyIDIBEgBCAOIAIgFiABIAMgAiAEcnEgAiAEcXJqakGZ84nUBWpBDXciASADIARycSADIARxcmpqQZnzidQFakEDdyICIAEgA3JxIAEgA3FyampBmfOJ1AVqQQV3IgQgASACcnEgASACcXJqakGZ84nUBWpBCXciAyAMIAIgAyAJIAEgAyACIARycSACIARxcmpqQZnzidQFakENdyIBcyAEc2pqQaHX5/YGakEDdyICIAQgASACcyADc2ogEmpBodfn9gZqQQl3IgRzIAFzampBodfn9gZqQQt3IgMgAiADIBggASADIARzIAJzampBodfn9gZqQQ93IgFzIARzaiANakGh1+f2BmpBA3ciAiAUIAQgASACcyADc2pqQaHX5/YGakEJdyIEcyABc2pqQaHX5/YGakELdyIDIAsgAiADIBYgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgIgEyAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3chAyAKIA4gAiADIBcgASADIARzIAJzampBodfn9gZqQQ93IgFzIARzampBodfn9gZqQQN3IgJqIQogBiAJIAEgESADIAIgFSAEIAEgAnMgA3NqakGh1+f2BmpBCXciBHMgAXNqakGh1+f2BmpBC3ciAyAEcyACc2pqQaHX5/YGakEPd2ohBiADIAdqIQcgBCAIaiEIIAVBQGshBQwBCwsgCiQBIAYkAiAHJAMgCCQECw0AIAAQASMAIABqJAAL/wQCA38BfiMAIABqrUIDhiEEIABByABqQUBxIgJBCGshAyAAIgFBAWohACABQYABOgAAA0AgACACSUEAIABBB3EbBEAgAEEAOgAAIABBAWohAAwBCwsDQCAAIAJJBEAgAEIANwMAIABBCGohAAwBCwsgAyAENwMAIAIQAUEAIwGtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEIIwKtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEQIwOtIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAEEYIwStIgRC//8DgyAEQoCA/P8Pg0IQhoQiBEL/gYCA8B+DIARCgP6DgIDgP4NCCIaEIgRCj4C8gPCBwAeDQgiGIARC8IHAh4CegPgAg0IEiIQiBEKGjJiw4MCBgwZ8QgSIQoGChIiQoMCAAYNCJ34gBEKw4MCBg4aMmDCEfDcDAAs=",
      "base64"
    )
  );
  md4_1 = create.bind(null, md4, [], 64, 32);
  return md4_1;
}
function requireBulkUpdateDecorator() {
  if (hasRequiredBulkUpdateDecorator) return BulkUpdateDecorator_1;
  hasRequiredBulkUpdateDecorator = 1;
  const BULK_SIZE = 2e3;
  const digestCaches = {};
  class BulkUpdateDecorator2 {
    /**
     * @param {Hash | function(): Hash} hashOrFactory function to create a hash
     * @param {string=} hashKey key for caching
     */
    constructor(hashOrFactory, hashKey) {
      this.hashKey = hashKey;
      if (typeof hashOrFactory === "function") {
        this.hashFactory = hashOrFactory;
        this.hash = void 0;
      } else {
        this.hashFactory = void 0;
        this.hash = hashOrFactory;
      }
      this.buffer = "";
    }
    /**
     * Update hash {@link https://nodejs.org/api/crypto.html#crypto_hash_update_data_inputencoding}
     * @param {string|Buffer} data data
     * @param {string=} inputEncoding data encoding
     * @returns {this} updated hash
     */
    update(data, inputEncoding) {
      if (inputEncoding !== void 0 || typeof data !== "string" || data.length > BULK_SIZE) {
        if (this.hash === void 0) {
          this.hash = this.hashFactory();
        }
        if (this.buffer.length > 0) {
          this.hash.update(this.buffer);
          this.buffer = "";
        }
        this.hash.update(data, inputEncoding);
      } else {
        this.buffer += data;
        if (this.buffer.length > BULK_SIZE) {
          if (this.hash === void 0) {
            this.hash = this.hashFactory();
          }
          this.hash.update(this.buffer);
          this.buffer = "";
        }
      }
      return this;
    }
    /**
     * Calculates the digest {@link https://nodejs.org/api/crypto.html#crypto_hash_digest_encoding}
     * @param {string=} encoding encoding of the return value
     * @returns {string|Buffer} digest
     */
    digest(encoding) {
      let digestCache;
      const buffer = this.buffer;
      if (this.hash === void 0) {
        const cacheKey = `${this.hashKey}-${encoding}`;
        digestCache = digestCaches[cacheKey];
        if (digestCache === void 0) {
          digestCache = digestCaches[cacheKey] = /* @__PURE__ */ new Map();
        }
        const cacheEntry = digestCache.get(buffer);
        if (cacheEntry !== void 0) {
          return cacheEntry;
        }
        this.hash = this.hashFactory();
      }
      if (buffer.length > 0) {
        this.hash.update(buffer);
      }
      const digestResult = this.hash.digest(encoding);
      if (digestCache !== void 0) {
        digestCache.set(buffer, digestResult);
      }
      return digestResult;
    }
  }
  BulkUpdateDecorator_1 = BulkUpdateDecorator2;
  return BulkUpdateDecorator_1;
}
function divmod32(uint32Array, divisor) {
  let carry = 0;
  for (let i = uint32Array.length - 1; i >= 0; i--) {
    const value2 = carry * 4294967296 + uint32Array[i];
    carry = value2 % divisor;
    uint32Array[i] = Math.floor(value2 / divisor);
  }
  return carry;
}
function encodeBufferToBase(buffer, base, length) {
  const encodeTable = baseEncodeTables[base];
  if (!encodeTable) {
    throw new Error("Unknown encoding base" + base);
  }
  const limit = Math.ceil(buffer.length * 8 / Math.log2(base));
  length = Math.min(length, limit);
  const uint32Array = new Uint32Array(Math.ceil(buffer.length / 4));
  buffer.copy(Buffer.from(uint32Array.buffer));
  let output = "";
  for (let i = 0; i < length; i++) {
    output = encodeTable[divmod32(uint32Array, base)] + output;
  }
  return output;
}
function getHashDigest$1(buffer, algorithm, digestType, maxLength) {
  algorithm = algorithm || "xxhash64";
  maxLength = maxLength || 9999;
  let hash3;
  if (algorithm === "xxhash64") {
    if (createXXHash64 === void 0) {
      createXXHash64 = requireXxhash64();
      if (BatchedHash === void 0) {
        BatchedHash = requireBatchedHash();
      }
    }
    hash3 = new BatchedHash(createXXHash64());
  } else if (algorithm === "md4") {
    if (createMd4 === void 0) {
      createMd4 = requireMd4();
      if (BatchedHash === void 0) {
        BatchedHash = requireBatchedHash();
      }
    }
    hash3 = new BatchedHash(createMd4());
  } else if (algorithm === "native-md4") {
    if (typeof crypto === "undefined") {
      crypto = require$$3;
      if (BulkUpdateDecorator === void 0) {
        BulkUpdateDecorator = requireBulkUpdateDecorator();
      }
    }
    hash3 = new BulkUpdateDecorator(() => crypto.createHash("md4"), "md4");
  } else {
    if (typeof crypto === "undefined") {
      crypto = require$$3;
      if (BulkUpdateDecorator === void 0) {
        BulkUpdateDecorator = requireBulkUpdateDecorator();
      }
    }
    hash3 = new BulkUpdateDecorator(
      () => crypto.createHash(algorithm),
      algorithm
    );
  }
  hash3.update(buffer);
  if (digestType === "base26" || digestType === "base32" || digestType === "base36" || digestType === "base49" || digestType === "base52" || digestType === "base58" || digestType === "base62") {
    return encodeBufferToBase(hash3.digest(), digestType.substr(4), maxLength);
  } else {
    return hash3.digest(digestType || "hex").substr(0, maxLength);
  }
}
function interpolateName$1(loaderContext, name2, options2 = {}) {
  let filename;
  const hasQuery = loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1;
  if (typeof name2 === "function") {
    filename = name2(
      loaderContext.resourcePath,
      hasQuery ? loaderContext.resourceQuery : void 0
    );
  } else {
    filename = name2 || "[hash].[ext]";
  }
  const context = options2.context;
  const content = options2.content;
  const regExp = options2.regExp;
  let ext2 = "bin";
  let basename2 = "file";
  let directory = "";
  let folder = "";
  let query = "";
  if (loaderContext.resourcePath) {
    const parsed = path$12.parse(loaderContext.resourcePath);
    let resourcePath = loaderContext.resourcePath;
    if (parsed.ext) {
      ext2 = parsed.ext.substr(1);
    }
    if (parsed.dir) {
      basename2 = parsed.name;
      resourcePath = parsed.dir + path$12.sep;
    }
    if (typeof context !== "undefined") {
      directory = path$12.relative(context, resourcePath + "_").replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
      directory = directory.substr(0, directory.length - 1);
    } else {
      directory = resourcePath.replace(/\\/g, "/").replace(/\.\.(\/)?/g, "_$1");
    }
    if (directory.length === 1) {
      directory = "";
    } else if (directory.length > 1) {
      folder = path$12.basename(directory);
    }
  }
  if (loaderContext.resourceQuery && loaderContext.resourceQuery.length > 1) {
    query = loaderContext.resourceQuery;
    const hashIdx = query.indexOf("#");
    if (hashIdx >= 0) {
      query = query.substr(0, hashIdx);
    }
  }
  let url2 = filename;
  if (content) {
    url2 = url2.replace(
      /\[(?:([^[:\]]+):)?(?:hash|contenthash)(?::([a-z]+\d*))?(?::(\d+))?\]/gi,
      (all, hashType, digestType, maxLength) => getHashDigest(content, hashType, digestType, parseInt(maxLength, 10))
    );
  }
  url2 = url2.replace(/\[ext\]/gi, () => ext2).replace(/\[name\]/gi, () => basename2).replace(/\[path\]/gi, () => directory).replace(/\[folder\]/gi, () => folder).replace(/\[query\]/gi, () => query);
  if (regExp && loaderContext.resourcePath) {
    const match2 = loaderContext.resourcePath.match(new RegExp(regExp));
    match2 && match2.forEach((matched, i) => {
      url2 = url2.replace(new RegExp("\\[" + i + "\\]", "ig"), matched);
    });
  }
  if (typeof loaderContext.options === "object" && typeof loaderContext.options.customInterpolateName === "function") {
    url2 = loaderContext.options.customInterpolateName.call(
      loaderContext,
      url2,
      name2,
      options2
    );
  }
  return url2;
}
function _interopRequireDefault$3(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
function isNode(node3) {
  return typeof node3 === "object" && IS_TYPE[node3.type];
}
function isNodeType(type, node3) {
  return isNode(node3) && node3.type === type;
}
function isPseudoElement(node3) {
  return isPseudo(node3) && node3.value && (node3.value.startsWith("::") || node3.value.toLowerCase() === ":before" || node3.value.toLowerCase() === ":after" || node3.value.toLowerCase() === ":first-letter" || node3.value.toLowerCase() === ":first-line");
}
function isPseudoClass(node3) {
  return isPseudo(node3) && !isPseudoElement(node3);
}
function isContainer(node3) {
  return !!(isNode(node3) && node3.walk);
}
function isNamespace(node3) {
  return isAttribute(node3) || isTag(node3);
}
function normalizeNodeArray(nodes) {
  const array2 = [];
  nodes.forEach((x) => {
    if (Array.isArray(x)) {
      normalizeNodeArray(x).forEach((item) => {
        array2.push(item);
      });
    } else if (x) {
      array2.push(x);
    }
  });
  if (array2.length > 0 && isSpacing(array2[array2.length - 1])) {
    array2.pop();
  }
  return array2;
}
function localizeNode(rule2, mode2, localAliasMap) {
  const transform3 = (node3, context) => {
    if (context.ignoreNextSpacing && !isSpacing(node3)) {
      throw new Error("Missing whitespace after " + context.ignoreNextSpacing);
    }
    if (context.enforceNoSpacing && isSpacing(node3)) {
      throw new Error("Missing whitespace before " + context.enforceNoSpacing);
    }
    let newNodes;
    switch (node3.type) {
      case "root": {
        let resultingGlobal;
        context.hasPureGlobals = false;
        newNodes = node3.nodes.map((n) => {
          const nContext = {
            global: context.global,
            lastWasSpacing: true,
            hasLocals: false,
            explicit: false
          };
          n = transform3(n, nContext);
          if (typeof resultingGlobal === "undefined") {
            resultingGlobal = nContext.global;
          } else if (resultingGlobal !== nContext.global) {
            throw new Error(
              'Inconsistent rule global/local result in rule "' + node3 + '" (multiple selectors must result in the same mode for the rule)'
            );
          }
          if (!nContext.hasLocals) {
            context.hasPureGlobals = true;
          }
          return n;
        });
        context.global = resultingGlobal;
        node3.nodes = normalizeNodeArray(newNodes);
        break;
      }
      case "selector": {
        newNodes = node3.map((childNode) => transform3(childNode, context));
        node3 = node3.clone();
        node3.nodes = normalizeNodeArray(newNodes);
        break;
      }
      case "combinator": {
        if (isSpacing(node3)) {
          if (context.ignoreNextSpacing) {
            context.ignoreNextSpacing = false;
            context.lastWasSpacing = false;
            context.enforceNoSpacing = false;
            return null;
          }
          context.lastWasSpacing = true;
          return node3;
        }
        break;
      }
      case "pseudo": {
        let childContext;
        const isNested = !!node3.length;
        const isScoped = node3.value === ":local" || node3.value === ":global";
        const isImportExport = node3.value === ":import" || node3.value === ":export";
        if (isImportExport) {
          context.hasLocals = true;
        } else if (isNested) {
          if (isScoped) {
            if (node3.nodes.length === 0) {
              throw new Error(`${node3.value}() can't be empty`);
            }
            if (context.inside) {
              throw new Error(
                `A ${node3.value} is not allowed inside of a ${context.inside}(...)`
              );
            }
            childContext = {
              global: node3.value === ":global",
              inside: node3.value,
              hasLocals: false,
              explicit: true
            };
            newNodes = node3.map((childNode) => transform3(childNode, childContext)).reduce((acc, next) => acc.concat(next.nodes), []);
            if (newNodes.length) {
              const { before, after } = node3.spaces;
              const first2 = newNodes[0];
              const last = newNodes[newNodes.length - 1];
              first2.spaces = { before, after: first2.spaces.after };
              last.spaces = { before: last.spaces.before, after };
            }
            node3 = newNodes;
            break;
          } else {
            childContext = {
              global: context.global,
              inside: context.inside,
              lastWasSpacing: true,
              hasLocals: false,
              explicit: context.explicit
            };
            newNodes = node3.map((childNode) => {
              const newContext = {
                ...childContext,
                enforceNoSpacing: false
              };
              const result = transform3(childNode, newContext);
              childContext.global = newContext.global;
              childContext.hasLocals = newContext.hasLocals;
              return result;
            });
            node3 = node3.clone();
            node3.nodes = normalizeNodeArray(newNodes);
            if (childContext.hasLocals) {
              context.hasLocals = true;
            }
          }
          break;
        } else if (isScoped) {
          if (context.inside) {
            throw new Error(
              `A ${node3.value} is not allowed inside of a ${context.inside}(...)`
            );
          }
          const addBackSpacing = !!node3.spaces.before;
          context.ignoreNextSpacing = context.lastWasSpacing ? node3.value : false;
          context.enforceNoSpacing = context.lastWasSpacing ? false : node3.value;
          context.global = node3.value === ":global";
          context.explicit = true;
          return addBackSpacing ? selectorParser$1.combinator({ value: " " }) : null;
        }
        break;
      }
      case "id":
      case "class": {
        if (!node3.value) {
          throw new Error("Invalid class or id selector syntax");
        }
        if (context.global) {
          break;
        }
        const isImportedValue = localAliasMap.has(node3.value);
        const isImportedWithExplicitScope = isImportedValue && context.explicit;
        if (!isImportedValue || isImportedWithExplicitScope) {
          const innerNode = node3.clone();
          innerNode.spaces = { before: "", after: "" };
          node3 = selectorParser$1.pseudo({
            value: ":local",
            nodes: [innerNode],
            spaces: node3.spaces
          });
          context.hasLocals = true;
        }
        break;
      }
      case "nesting": {
        if (node3.value === "&") {
          context.hasLocals = true;
        }
      }
    }
    context.lastWasSpacing = false;
    context.ignoreNextSpacing = false;
    context.enforceNoSpacing = false;
    return node3;
  };
  const rootContext = {
    global: mode2 === "global",
    hasPureGlobals: false
  };
  rootContext.selector = selectorParser$1((root4) => {
    transform3(root4, rootContext);
  }).processSync(rule2, { updateSelector: false, lossless: true });
  return rootContext;
}
function localizeDeclNode(node3, context) {
  switch (node3.type) {
    case "word":
      if (context.localizeNextItem) {
        if (!context.localAliasMap.has(node3.value)) {
          node3.value = ":local(" + node3.value + ")";
          context.localizeNextItem = false;
        }
      }
      break;
    case "function":
      if (context.options && context.options.rewriteUrl && node3.value.toLowerCase() === "url") {
        node3.nodes.map((nestedNode) => {
          if (nestedNode.type !== "string" && nestedNode.type !== "word") {
            return;
          }
          let newUrl = context.options.rewriteUrl(
            context.global,
            nestedNode.value
          );
          switch (nestedNode.type) {
            case "string":
              if (nestedNode.quote === "'") {
                newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/'/g, "\\'");
              }
              if (nestedNode.quote === '"') {
                newUrl = newUrl.replace(/(\\)/g, "\\$1").replace(/"/g, '\\"');
              }
              break;
            case "word":
              newUrl = newUrl.replace(/("|'|\)|\\)/g, "\\$1");
              break;
          }
          nestedNode.value = newUrl;
        });
      }
      break;
  }
  return node3;
}
function localizeDeclarationValues(localize, declaration, context) {
  const valueNodes = valueParser2(declaration.value);
  valueNodes.walk((node3, index4, nodes) => {
    if (node3.type === "function" && (node3.value.toLowerCase() === "var" || node3.value.toLowerCase() === "env")) {
      return false;
    }
    if (node3.type === "word" && specialKeywords.includes(node3.value.toLowerCase())) {
      return;
    }
    const subContext = {
      options: context.options,
      global: context.global,
      localizeNextItem: localize && !context.global,
      localAliasMap: context.localAliasMap
    };
    nodes[index4] = localizeDeclNode(node3, subContext);
  });
  declaration.value = valueNodes.toString();
}
function localizeDeclaration(declaration, context) {
  const isAnimation = /animation$/i.test(declaration.prop);
  if (isAnimation) {
    const validIdent = /^-?([a-z\u0080-\uFFFF_]|(\\[^\r\n\f])|-(?![0-9]))((\\[^\r\n\f])|[a-z\u0080-\uFFFF_0-9-])*$/i;
    const animationKeywords = {
      // animation-direction
      $normal: 1,
      $reverse: 1,
      $alternate: 1,
      "$alternate-reverse": 1,
      // animation-fill-mode
      $forwards: 1,
      $backwards: 1,
      $both: 1,
      // animation-iteration-count
      $infinite: 1,
      // animation-play-state
      $paused: 1,
      $running: 1,
      // animation-timing-function
      $ease: 1,
      "$ease-in": 1,
      "$ease-out": 1,
      "$ease-in-out": 1,
      $linear: 1,
      "$step-end": 1,
      "$step-start": 1,
      // Special
      $none: Infinity,
      // No matter how many times you write none, it will never be an animation name
      // Global values
      $initial: Infinity,
      $inherit: Infinity,
      $unset: Infinity,
      $revert: Infinity,
      "$revert-layer": Infinity
    };
    let parsedAnimationKeywords = {};
    const valueNodes = valueParser2(declaration.value).walk((node3) => {
      if (node3.type === "div") {
        parsedAnimationKeywords = {};
        return;
      } else if (node3.type === "function") {
        return false;
      } else if (node3.type !== "word") {
        return;
      }
      const value2 = node3.type === "word" ? node3.value.toLowerCase() : null;
      let shouldParseAnimationName = false;
      if (value2 && validIdent.test(value2)) {
        if ("$" + value2 in animationKeywords) {
          parsedAnimationKeywords["$" + value2] = "$" + value2 in parsedAnimationKeywords ? parsedAnimationKeywords["$" + value2] + 1 : 0;
          shouldParseAnimationName = parsedAnimationKeywords["$" + value2] >= animationKeywords["$" + value2];
        } else {
          shouldParseAnimationName = true;
        }
      }
      const subContext = {
        options: context.options,
        global: context.global,
        localizeNextItem: shouldParseAnimationName && !context.global,
        localAliasMap: context.localAliasMap
      };
      return localizeDeclNode(node3, subContext);
    });
    declaration.value = valueNodes.toString();
    return;
  }
  const isAnimationName = /animation(-name)?$/i.test(declaration.prop);
  if (isAnimationName) {
    return localizeDeclarationValues(true, declaration, context);
  }
  const hasUrl = /url\(/i.test(declaration.value);
  if (hasUrl) {
    return localizeDeclarationValues(false, declaration, context);
  }
}
function isNestedRule(rule2) {
  if (!rule2.parent || rule2.parent.type === "root") {
    return false;
  }
  if (rule2.parent.type === "rule") {
    return true;
  }
  return isNestedRule(rule2.parent);
}
function getSingleLocalNamesForComposes(root4, rule2) {
  if (isNestedRule(rule2)) {
    throw new Error(`composition is not allowed in nested rule 

${rule2}`);
  }
  return root4.nodes.map((node3) => {
    if (node3.type !== "selector" || node3.nodes.length !== 1) {
      throw new Error(
        `composition is only allowed when selector is single :local class name not in "${root4}"`
      );
    }
    node3 = node3.nodes[0];
    if (node3.type !== "pseudo" || node3.value !== ":local" || node3.nodes.length !== 1) {
      throw new Error(
        'composition is only allowed when selector is single :local class name not in "' + root4 + '", "' + node3 + '" is weird'
      );
    }
    node3 = node3.first;
    if (node3.type !== "selector" || node3.length !== 1) {
      throw new Error(
        'composition is only allowed when selector is single :local class name not in "' + root4 + '", "' + node3 + '" is weird'
      );
    }
    node3 = node3.first;
    if (node3.type !== "class") {
      throw new Error(
        'composition is only allowed when selector is single :local class name not in "' + root4 + '", "' + node3 + '" is weird'
      );
    }
    return node3.value;
  });
}
function unescape2(str2) {
  return str2.replace(unescapeRegExp, (_, escaped2, escapedWhitespace) => {
    const high = "0x" + escaped2 - 65536;
    return high !== high || escapedWhitespace ? escaped2 : high < 0 ? (
      // BMP codepoint
      String.fromCharCode(high + 65536)
    ) : (
      // Supplemental Plane codepoint (surrogate pair)
      String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
    );
  });
}
function hash(str2) {
  var hash3 = 5381, i = str2.length;
  while (i) {
    hash3 = hash3 * 33 ^ str2.charCodeAt(--i);
  }
  return hash3 >>> 0;
}
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function getDefaultPlugins({
  behaviour,
  generateScopedName,
  exportGlobals
}) {
  const scope = (0, _postcssModulesScope.default)({
    generateScopedName,
    exportGlobals
  });
  const plugins2 = {
    [behaviours.LOCAL]: [_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({
      mode: "local"
    }), _postcssModulesExtractImports.default, scope],
    [behaviours.GLOBAL]: [_postcssModulesValues.default, (0, _postcssModulesLocalByDefault.default)({
      mode: "global"
    }), _postcssModulesExtractImports.default, scope]
  };
  return plugins2[behaviour];
}
function isValidBehaviour(behaviour) {
  return Object.keys(behaviours).map((key) => behaviours[key]).indexOf(behaviour) > -1;
}
function getDefaultScopeBehaviour(scopeBehaviour) {
  return scopeBehaviour && isValidBehaviour(scopeBehaviour) ? scopeBehaviour : behaviours.LOCAL;
}
function generateScopedNameDefault(name2, filename, css) {
  const i = css.indexOf(`.${name2}`);
  const lineNumber = css.substr(0, i).split(/[\r\n]/).length;
  const hash3 = (0, _stringHash.default)(css).toString(36).substr(0, 5);
  return `_${name2}_${hash3}_${lineNumber}`;
}
function getScopedNameGenerator(generateScopedName, hashPrefix) {
  const scopedNameGenerator = generateScopedName || generateScopedNameDefault;
  if (typeof scopedNameGenerator === "function") {
    return scopedNameGenerator;
  }
  return (0, _genericNames.default)(scopedNameGenerator, {
    context: process.cwd(),
    hashPrefix
  });
}
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function isGlobalModule(globalModules, inputFile) {
  return globalModules.some((regex2) => inputFile.match(regex2));
}
function getDefaultPluginsList(opts, inputFile) {
  const globalModulesList = opts.globalModulePaths || null;
  const exportGlobals = opts.exportGlobals || false;
  const defaultBehaviour = (0, _scoping.getDefaultScopeBehaviour)(opts.scopeBehaviour);
  const generateScopedName = (0, _scoping.getScopedNameGenerator)(opts.generateScopedName, opts.hashPrefix);
  if (globalModulesList && isGlobalModule(globalModulesList, inputFile)) {
    return (0, _scoping.getDefaultPlugins)({
      behaviour: _scoping.behaviours.GLOBAL,
      generateScopedName,
      exportGlobals
    });
  }
  return (0, _scoping.getDefaultPlugins)({
    behaviour: defaultBehaviour,
    generateScopedName,
    exportGlobals
  });
}
function getLoader(opts, plugins2) {
  const root4 = typeof opts.root === "undefined" ? "/" : opts.root;
  return typeof opts.Loader === "function" ? new opts.Loader(root4, plugins2, opts.resolve) : new _FileSystemLoader.default(root4, plugins2, opts.resolve);
}
function isOurPlugin(plugin3) {
  return plugin3.postcssPlugin === PLUGIN_NAME;
}
function makePlugin(opts) {
  return {
    postcssPlugin: PLUGIN_NAME,
    async OnceExit(css, {
      result
    }) {
      const getJSON = opts.getJSON || _saveJSON.default;
      const inputFile = css.source.input.file;
      const pluginList = getDefaultPluginsList(opts, inputFile);
      const resultPluginIndex = result.processor.plugins.findIndex((plugin3) => isOurPlugin(plugin3));
      if (resultPluginIndex === -1) {
        throw new Error("Plugin missing from options.");
      }
      const earlierPlugins = result.processor.plugins.slice(0, resultPluginIndex);
      const loaderPlugins = [...earlierPlugins, ...pluginList];
      const loader = getLoader(opts, loaderPlugins);
      const fetcher = async (file, relativeTo, depTrace) => {
        const unquoteFile = (0, _unquote.default)(file);
        return loader.fetch.call(loader, unquoteFile, relativeTo, depTrace);
      };
      const parser2 = new _Parser.default(fetcher);
      await (0, _postcss.default)([...pluginList, parser2.plugin()]).process(css, {
        from: inputFile
      });
      const out = loader.finalSource;
      if (out) css.prepend(out);
      if (opts.localsConvention) {
        const reducer = (0, _localsConvention.makeLocalsConventionReducer)(opts.localsConvention, inputFile);
        parser2.exportTokens = Object.entries(parser2.exportTokens).reduce(reducer, {});
      }
      result.messages.push({
        type: "export",
        plugin: "postcss-modules",
        exportTokens: parser2.exportTokens
      });
      return getJSON(css.source.input.file, parser2.exportTokens, result.opts.to);
    }
  };
}
var __filename4, __dirname4, require4, build, fs2, fileSystem, pluginFactory, unquote$1, reg, Parser$1, matchValueName, replaceValueSymbols$2, replaceValueSymbols_1, replaceValueSymbols$1, replaceSymbols$1, replaceSymbols_1, importPattern, balancedQuotes, getDeclsObject, extractICSS$2, extractICSS_1, createImports, createExports, createICSSRules$1, createICSSRules_1, replaceValueSymbols, replaceSymbols, extractICSS$1, createICSSRules, src$4, _icssUtils, importRegexp, Parser, saveJSON$1, _fs$2, localsConvention, INFINITY, symbolTag, reAsciiWord, reLatin, rsAstralRange, rsComboMarksRange, rsComboSymbolsRange, rsDingbatRange, rsLowerRange, rsMathOpRange, rsNonCharRange, rsPunctuationRange, rsSpaceRange, rsUpperRange, rsVarRange, rsBreakRange, rsApos, rsAstral, rsBreak, rsCombo, rsDigits, rsDingbat, rsLower, rsMisc, rsFitz, rsModifier, rsNonAstral, rsRegional, rsSurrPair, rsUpper, rsZWJ, rsLowerMisc, rsUpperMisc, rsOptLowerContr, rsOptUpperContr, reOptMod, rsOptVar, rsOptJoin, rsSeq, rsEmoji, rsSymbol, reApos, reComboMark, reUnicode, reUnicodeWord, reHasUnicode, reHasUnicodeWord, deburredLetters, freeGlobal, freeSelf, root$2, deburrLetter, objectProto, objectToString, Symbol$1, symbolProto, symbolToString, camelCase, upperFirst, lodash_camelcase, _lodash, FileSystemLoader$1, _postcss$1, _path, _Parser$1, _fs$1, Core, traceKeySorter, FileSystemLoader, scoping, src$3, PERMANENT_MARKER, TEMPORARY_MARKER, topologicalSort_1, topologicalSort, matchImports$1, icssImport, VISITED_MARKER, srcExports$2, wasmHash, hasRequiredWasmHash, xxhash64_1, hasRequiredXxhash64, BatchedHash_1, hasRequiredBatchedHash, md4_1, hasRequiredMd4, BulkUpdateDecorator_1, hasRequiredBulkUpdateDecorator, baseEncodeTables, crypto, createXXHash64, createMd4, BatchedHash, BulkUpdateDecorator, getHashDigest_1, path$12, getHashDigest, interpolateName_1, interpolateName, path3, genericNames, src$2, dist, processor, parser, root$1, container, node$1, util, unesc, unescExports, getProp, getPropExports, ensureObject, ensureObjectExports, stripComments, stripCommentsExports, _unesc, _getProp, _ensureObject, _stripComments, nodeExports, types, TAG, STRING, SELECTOR, ROOT, PSEUDO, NESTING, ID, COMMENT, COMBINATOR, CLASS, ATTRIBUTE, UNIVERSAL, containerExports, rootExports, selector$1, selectorExports, className$1, object, hasOwnProperty$1, merge, regexAnySingleEscape, regexSingleEscape, regexExcessiveSpaces, cssesc, cssesc_1, classNameExports, comment$2, commentExports, id$1, idExports, tag$1, namespace, namespaceExports, tagExports, string$1, stringExports, pseudo$1, pseudoExports, attribute$1, node, universal$1, universalExports, combinator$2, combinatorExports, nesting$1, nestingExports, sortAscending, sortAscendingExports, tokenize, tokenTypes, ampersand, asterisk, at, comma2, colon2, semicolon, openParenthesis, closeParenthesis, openSquare, closeSquare, dollar, tilde, caret, plus2, equals, pipe, greaterThan, space, singleQuote2, doubleQuote2, slash2, bang, backslash2, cr, feed, newline, tab, str, comment$1, word, combinator$1, parserExports, processorExports, selectors, constructors, _attribute, _className, _combinator, _comment, _id, _nesting, _pseudo, _root, _selector, _string, _tag, _universal, attribute, className, combinator, comment2, id, nesting, pseudo, root2, selector, string, tag, universal, guards, _types, _IS_TYPE, IS_TYPE, isAttribute, isClassName, isCombinator, isComment, isIdentifier, isNesting, isPseudo, isRoot, isSelector, isString, isTag, isUniversal, distExports, selectorParser$1, valueParser2, extractICSS, isSpacing, specialKeywords, srcExports$1, selectorParser, hasOwnProperty2, whitespace, unescapeRegExp, plugin2, src$1, stringHash, src, ICSSUtils, matchImports, matchValueDefinition, matchImport, srcExports, _postcssModulesExtractImports, _genericNames, _postcssModulesLocalByDefault, _postcssModulesScope, _stringHash, _postcssModulesValues, behaviours, _postcss, _unquote, _Parser, _saveJSON, _localsConvention, _FileSystemLoader, _scoping, PLUGIN_NAME, _fs, _fs2, _pluginFactory, postcss2, buildExports, index2, index$12;
var init_dep_CEGXe0Sr = __esm({
  "node_modules/vite/dist/node/chunks/dep-CEGXe0Sr.js"() {
    init_dep_C6uTJdX2();
    init_postcss();
    init_dep_IQS_Za7F();
    __filename4 = __cjs_fileURLToPath3(import.meta.url);
    __dirname4 = __cjs_dirname3(__filename4);
    require4 = __cjs_createRequire3(import.meta.url);
    build = { exports: {} };
    fs2 = {};
    Object.defineProperty(fs2, "__esModule", {
      value: true
    });
    fs2.getFileSystem = getFileSystem;
    fs2.setFileSystem = setFileSystem;
    fileSystem = {
      readFile: () => {
        throw Error("readFile not implemented");
      },
      writeFile: () => {
        throw Error("writeFile not implemented");
      }
    };
    pluginFactory = {};
    unquote$1 = {};
    Object.defineProperty(unquote$1, "__esModule", {
      value: true
    });
    unquote$1.default = unquote;
    reg = /['"]/;
    Parser$1 = {};
    matchValueName = /[$]?[\w-]+/g;
    replaceValueSymbols$2 = (value2, replacements) => {
      let matches;
      while (matches = matchValueName.exec(value2)) {
        const replacement = replacements[matches[0]];
        if (replacement) {
          value2 = value2.slice(0, matches.index) + replacement + value2.slice(matchValueName.lastIndex);
          matchValueName.lastIndex -= matches[0].length - replacement.length;
        }
      }
      return value2;
    };
    replaceValueSymbols_1 = replaceValueSymbols$2;
    replaceValueSymbols$1 = replaceValueSymbols_1;
    replaceSymbols$1 = (css, replacements) => {
      css.walk((node3) => {
        if (node3.type === "decl" && node3.value) {
          node3.value = replaceValueSymbols$1(node3.value.toString(), replacements);
        } else if (node3.type === "rule" && node3.selector) {
          node3.selector = replaceValueSymbols$1(
            node3.selector.toString(),
            replacements
          );
        } else if (node3.type === "atrule" && node3.params) {
          node3.params = replaceValueSymbols$1(node3.params.toString(), replacements);
        }
      });
    };
    replaceSymbols_1 = replaceSymbols$1;
    importPattern = /^:import\(("[^"]*"|'[^']*'|[^"']+)\)$/;
    balancedQuotes = /^("[^"]*"|'[^']*'|[^"']+)$/;
    getDeclsObject = (rule2) => {
      const object2 = {};
      rule2.walkDecls((decl2) => {
        const before = decl2.raws.before ? decl2.raws.before.trim() : "";
        object2[before + decl2.prop] = decl2.value;
      });
      return object2;
    };
    extractICSS$2 = (css, removeRules = true, mode2 = "auto") => {
      const icssImports = {};
      const icssExports = {};
      function addImports(node3, path9) {
        const unquoted = path9.replace(/'|"/g, "");
        icssImports[unquoted] = Object.assign(
          icssImports[unquoted] || {},
          getDeclsObject(node3)
        );
        if (removeRules) {
          node3.remove();
        }
      }
      function addExports(node3) {
        Object.assign(icssExports, getDeclsObject(node3));
        if (removeRules) {
          node3.remove();
        }
      }
      css.each((node3) => {
        if (node3.type === "rule" && mode2 !== "at-rule") {
          if (node3.selector.slice(0, 7) === ":import") {
            const matches = importPattern.exec(node3.selector);
            if (matches) {
              addImports(node3, matches[1]);
            }
          }
          if (node3.selector === ":export") {
            addExports(node3);
          }
        }
        if (node3.type === "atrule" && mode2 !== "rule") {
          if (node3.name === "icss-import") {
            const matches = balancedQuotes.exec(node3.params);
            if (matches) {
              addImports(node3, matches[1]);
            }
          }
          if (node3.name === "icss-export") {
            addExports(node3);
          }
        }
      });
      return { icssImports, icssExports };
    };
    extractICSS_1 = extractICSS$2;
    createImports = (imports, postcss3, mode2 = "rule") => {
      return Object.keys(imports).map((path9) => {
        const aliases = imports[path9];
        const declarations = Object.keys(aliases).map(
          (key) => postcss3.decl({
            prop: key,
            value: aliases[key],
            raws: { before: "\n  " }
          })
        );
        const hasDeclarations = declarations.length > 0;
        const rule2 = mode2 === "rule" ? postcss3.rule({
          selector: `:import('${path9}')`,
          raws: { after: hasDeclarations ? "\n" : "" }
        }) : postcss3.atRule({
          name: "icss-import",
          params: `'${path9}'`,
          raws: { after: hasDeclarations ? "\n" : "" }
        });
        if (hasDeclarations) {
          rule2.append(declarations);
        }
        return rule2;
      });
    };
    createExports = (exports2, postcss3, mode2 = "rule") => {
      const declarations = Object.keys(exports2).map(
        (key) => postcss3.decl({
          prop: key,
          value: exports2[key],
          raws: { before: "\n  " }
        })
      );
      if (declarations.length === 0) {
        return [];
      }
      const rule2 = mode2 === "rule" ? postcss3.rule({
        selector: `:export`,
        raws: { after: "\n" }
      }) : postcss3.atRule({
        name: "icss-export",
        raws: { after: "\n" }
      });
      rule2.append(declarations);
      return [rule2];
    };
    createICSSRules$1 = (imports, exports2, postcss3, mode2) => [
      ...createImports(imports, postcss3, mode2),
      ...createExports(exports2, postcss3, mode2)
    ];
    createICSSRules_1 = createICSSRules$1;
    replaceValueSymbols = replaceValueSymbols_1;
    replaceSymbols = replaceSymbols_1;
    extractICSS$1 = extractICSS_1;
    createICSSRules = createICSSRules_1;
    src$4 = {
      replaceValueSymbols,
      replaceSymbols,
      extractICSS: extractICSS$1,
      createICSSRules
    };
    Object.defineProperty(Parser$1, "__esModule", {
      value: true
    });
    Parser$1.default = void 0;
    _icssUtils = src$4;
    importRegexp = /^:import\((.+)\)$/;
    Parser = class {
      constructor(pathFetcher, trace) {
        this.pathFetcher = pathFetcher;
        this.plugin = this.plugin.bind(this);
        this.exportTokens = {};
        this.translations = {};
        this.trace = trace;
      }
      plugin() {
        const parser2 = this;
        return {
          postcssPlugin: "css-modules-parser",
          async OnceExit(css) {
            await Promise.all(parser2.fetchAllImports(css));
            parser2.linkImportedSymbols(css);
            return parser2.extractExports(css);
          }
        };
      }
      fetchAllImports(css) {
        let imports = [];
        css.each((node3) => {
          if (node3.type == "rule" && node3.selector.match(importRegexp)) {
            imports.push(this.fetchImport(node3, css.source.input.from, imports.length));
          }
        });
        return imports;
      }
      linkImportedSymbols(css) {
        (0, _icssUtils.replaceSymbols)(css, this.translations);
      }
      extractExports(css) {
        css.each((node3) => {
          if (node3.type == "rule" && node3.selector == ":export") this.handleExport(node3);
        });
      }
      handleExport(exportNode) {
        exportNode.each((decl2) => {
          if (decl2.type == "decl") {
            Object.keys(this.translations).forEach((translation) => {
              decl2.value = decl2.value.replace(translation, this.translations[translation]);
            });
            this.exportTokens[decl2.prop] = decl2.value;
          }
        });
        exportNode.remove();
      }
      async fetchImport(importNode, relativeTo, depNr) {
        const file = importNode.selector.match(importRegexp)[1];
        const depTrace = this.trace + String.fromCharCode(depNr);
        const exports2 = await this.pathFetcher(file, relativeTo, depTrace);
        try {
          importNode.each((decl2) => {
            if (decl2.type == "decl") {
              this.translations[decl2.prop] = exports2[decl2.value];
            }
          });
          importNode.remove();
        } catch (err) {
          console.log(err);
        }
      }
    };
    Parser$1.default = Parser;
    saveJSON$1 = {};
    Object.defineProperty(saveJSON$1, "__esModule", {
      value: true
    });
    saveJSON$1.default = saveJSON;
    _fs$2 = fs2;
    localsConvention = {};
    INFINITY = 1 / 0;
    symbolTag = "[object Symbol]";
    reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    rsAstralRange = "\\ud800-\\udfff";
    rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    rsComboSymbolsRange = "\\u20d0-\\u20f0";
    rsDingbatRange = "\\u2700-\\u27bf";
    rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    rsPunctuationRange = "\\u2000-\\u206f";
    rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    rsVarRange = "\\ufe0e\\ufe0f";
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    rsApos = "['\u2019]";
    rsAstral = "[" + rsAstralRange + "]";
    rsBreak = "[" + rsBreakRange + "]";
    rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    rsDigits = "\\d+";
    rsDingbat = "[" + rsDingbatRange + "]";
    rsLower = "[" + rsLowerRange + "]";
    rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    rsFitz = "\\ud83c[\\udffb-\\udfff]";
    rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    rsNonAstral = "[^" + rsAstralRange + "]";
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    rsUpper = "[" + rsUpperRange + "]";
    rsZWJ = "\\u200d";
    rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    reOptMod = rsModifier + "?";
    rsOptVar = "[" + rsVarRange + "]?";
    rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    rsSeq = rsOptVar + reOptMod + rsOptJoin;
    rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    reApos = RegExp(rsApos, "g");
    reComboMark = RegExp(rsCombo, "g");
    reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    freeSelf = typeof self == "object" && self && self.Object === Object && self;
    root$2 = freeGlobal || freeSelf || Function("return this")();
    deburrLetter = basePropertyOf(deburredLetters);
    objectProto = Object.prototype;
    objectToString = objectProto.toString;
    Symbol$1 = root$2.Symbol;
    symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
    symbolToString = symbolProto ? symbolProto.toString : void 0;
    camelCase = createCompounder(function(result, word2, index4) {
      word2 = word2.toLowerCase();
      return result + (index4 ? capitalize(word2) : word2);
    });
    upperFirst = createCaseFirst("toUpperCase");
    lodash_camelcase = camelCase;
    Object.defineProperty(localsConvention, "__esModule", {
      value: true
    });
    localsConvention.makeLocalsConventionReducer = makeLocalsConventionReducer;
    _lodash = _interopRequireDefault$5(lodash_camelcase);
    FileSystemLoader$1 = {};
    Object.defineProperty(FileSystemLoader$1, "__esModule", {
      value: true
    });
    FileSystemLoader$1.default = void 0;
    _postcss$1 = _interopRequireDefault$4(postcss_default);
    _path = _interopRequireDefault$4(require$$0$1);
    _Parser$1 = _interopRequireDefault$4(Parser$1);
    _fs$1 = fs2;
    Core = class _Core {
      constructor(plugins2) {
        this.plugins = plugins2 || _Core.defaultPlugins;
      }
      async load(sourceString, sourcePath, trace, pathFetcher) {
        const parser2 = new _Parser$1.default(pathFetcher, trace);
        const plugins2 = this.plugins.concat([parser2.plugin()]);
        const result = await (0, _postcss$1.default)(plugins2).process(sourceString, {
          from: sourcePath
        });
        return {
          injectableSource: result.css,
          exportTokens: parser2.exportTokens
        };
      }
    };
    traceKeySorter = (a, b) => {
      if (a.length < b.length) {
        return a < b.substring(0, a.length) ? -1 : 1;
      }
      if (a.length > b.length) {
        return a.substring(0, b.length) <= b ? -1 : 1;
      }
      return a < b ? -1 : 1;
    };
    FileSystemLoader = class {
      constructor(root4, plugins2, fileResolve) {
        if (root4 === "/" && process.platform === "win32") {
          const cwdDrive = process.cwd().slice(0, 3);
          if (!/^[A-Za-z]:\\$/.test(cwdDrive)) {
            throw new Error(`Failed to obtain root from "${process.cwd()}".`);
          }
          root4 = cwdDrive;
        }
        this.root = root4;
        this.fileResolve = fileResolve;
        this.sources = {};
        this.traces = {};
        this.importNr = 0;
        this.core = new Core(plugins2);
        this.tokensByFile = {};
        this.fs = (0, _fs$1.getFileSystem)();
      }
      async fetch(_newPath, relativeTo, _trace) {
        const newPath = _newPath.replace(/^["']|["']$/g, "");
        const trace = _trace || String.fromCharCode(this.importNr++);
        const useFileResolve = typeof this.fileResolve === "function";
        const fileResolvedPath = useFileResolve ? await this.fileResolve(newPath, relativeTo) : await Promise.resolve();
        if (fileResolvedPath && !_path.default.isAbsolute(fileResolvedPath)) {
          throw new Error('The returned path from the "fileResolve" option must be absolute.');
        }
        const relativeDir = _path.default.dirname(relativeTo);
        const rootRelativePath = fileResolvedPath || _path.default.resolve(relativeDir, newPath);
        let fileRelativePath = fileResolvedPath || _path.default.resolve(_path.default.resolve(this.root, relativeDir), newPath);
        if (!useFileResolve && newPath[0] !== "." && !_path.default.isAbsolute(newPath)) {
          try {
            fileRelativePath = require4.resolve(newPath);
          } catch (e) {
          }
        }
        const tokens = this.tokensByFile[fileRelativePath];
        if (tokens) return tokens;
        return new Promise((resolve8, reject) => {
          this.fs.readFile(fileRelativePath, "utf-8", async (err, source) => {
            if (err) reject(err);
            const {
              injectableSource,
              exportTokens
            } = await this.core.load(source, rootRelativePath, trace, this.fetch.bind(this));
            this.sources[fileRelativePath] = injectableSource;
            this.traces[trace] = fileRelativePath;
            this.tokensByFile[fileRelativePath] = exportTokens;
            resolve8(exportTokens);
          });
        });
      }
      get finalSource() {
        const traces = this.traces;
        const sources = this.sources;
        let written = /* @__PURE__ */ new Set();
        return Object.keys(traces).sort(traceKeySorter).map((key) => {
          const filename = traces[key];
          if (written.has(filename)) {
            return null;
          }
          written.add(filename);
          return sources[filename];
        }).join("");
      }
    };
    FileSystemLoader$1.default = FileSystemLoader;
    scoping = {};
    src$3 = { exports: {} };
    PERMANENT_MARKER = 2;
    TEMPORARY_MARKER = 1;
    topologicalSort_1 = topologicalSort$1;
    topologicalSort = topologicalSort_1;
    matchImports$1 = /^(.+?)\s+from\s+(?:"([^"]+)"|'([^']+)'|(global))$/;
    icssImport = /^:import\((?:"([^"]+)"|'([^']+)')\)/;
    VISITED_MARKER = 1;
    src$3.exports = (options2 = {}) => {
      let importIndex = 0;
      const createImportedName = typeof options2.createImportedName !== "function" ? (importName) => `i__imported_${importName.replace(/\W/g, "_")}_${importIndex++}` : options2.createImportedName;
      const failOnWrongOrder = options2.failOnWrongOrder;
      return {
        postcssPlugin: "postcss-modules-extract-imports",
        prepare() {
          const graph = {};
          const visited = {};
          const existingImports = {};
          const importDecls = {};
          const imports = {};
          return {
            Once(root4, postcss3) {
              root4.walkRules((rule2) => {
                const matches = icssImport.exec(rule2.selector);
                if (matches) {
                  const [
                    ,
                    /*match*/
                    doubleQuotePath,
                    singleQuotePath
                  ] = matches;
                  const importPath = doubleQuotePath || singleQuotePath;
                  addImportToGraph(importPath, "root", graph, visited);
                  existingImports[importPath] = rule2;
                }
              });
              root4.walkDecls(/^composes$/, (declaration) => {
                const multiple = declaration.value.split(",");
                const values = [];
                multiple.forEach((value2) => {
                  const matches = value2.trim().match(matchImports$1);
                  if (!matches) {
                    values.push(value2);
                    return;
                  }
                  let tmpSymbols;
                  let [
                    ,
                    /*match*/
                    symbols,
                    doubleQuotePath,
                    singleQuotePath,
                    global2
                  ] = matches;
                  if (global2) {
                    tmpSymbols = symbols.split(/\s+/).map((s) => `global(${s})`);
                  } else {
                    const importPath = doubleQuotePath || singleQuotePath;
                    let parent = declaration.parent;
                    let parentIndexes = "";
                    while (parent.type !== "root") {
                      parentIndexes = parent.parent.index(parent) + "_" + parentIndexes;
                      parent = parent.parent;
                    }
                    const { selector: selector3 } = declaration.parent;
                    const parentRule = `_${parentIndexes}${selector3}`;
                    addImportToGraph(importPath, parentRule, graph, visited);
                    importDecls[importPath] = declaration;
                    imports[importPath] = imports[importPath] || {};
                    tmpSymbols = symbols.split(/\s+/).map((s) => {
                      if (!imports[importPath][s]) {
                        imports[importPath][s] = createImportedName(s, importPath);
                      }
                      return imports[importPath][s];
                    });
                  }
                  values.push(tmpSymbols.join(" "));
                });
                declaration.value = values.join(", ");
              });
              const importsOrder = topologicalSort(graph, failOnWrongOrder);
              if (importsOrder instanceof Error) {
                const importPath = importsOrder.nodes.find(
                  (importPath2) => (
                    // eslint-disable-next-line no-prototype-builtins
                    importDecls.hasOwnProperty(importPath2)
                  )
                );
                const decl2 = importDecls[importPath];
                throw decl2.error(
                  "Failed to resolve order of composed modules " + importsOrder.nodes.map((importPath2) => "`" + importPath2 + "`").join(", ") + ".",
                  {
                    plugin: "postcss-modules-extract-imports",
                    word: "composes"
                  }
                );
              }
              let lastImportRule;
              importsOrder.forEach((path9) => {
                const importedSymbols = imports[path9];
                let rule2 = existingImports[path9];
                if (!rule2 && importedSymbols) {
                  rule2 = postcss3.rule({
                    selector: `:import("${path9}")`,
                    raws: { after: "\n" }
                  });
                  if (lastImportRule) {
                    root4.insertAfter(lastImportRule, rule2);
                  } else {
                    root4.prepend(rule2);
                  }
                }
                lastImportRule = rule2;
                if (!importedSymbols) {
                  return;
                }
                Object.keys(importedSymbols).forEach((importedSymbol) => {
                  rule2.append(
                    postcss3.decl({
                      value: importedSymbol,
                      prop: importedSymbols[importedSymbol],
                      raws: { before: "\n  " }
                    })
                  );
                });
              });
            }
          };
        }
      };
    };
    src$3.exports.postcss = true;
    srcExports$2 = src$3.exports;
    wasmHash = { exports: {} };
    baseEncodeTables = {
      26: "abcdefghijklmnopqrstuvwxyz",
      32: "123456789abcdefghjkmnpqrstuvwxyz",
      // no 0lio
      36: "0123456789abcdefghijklmnopqrstuvwxyz",
      49: "abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      // no lIO
      52: "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      58: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ",
      // no 0lIO
      62: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
      64: "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_"
    };
    crypto = void 0;
    createXXHash64 = void 0;
    createMd4 = void 0;
    BatchedHash = void 0;
    BulkUpdateDecorator = void 0;
    getHashDigest_1 = getHashDigest$1;
    path$12 = require$$0$1;
    getHashDigest = getHashDigest_1;
    interpolateName_1 = interpolateName$1;
    interpolateName = interpolateName_1;
    path3 = require$$0$1;
    genericNames = function createGenerator(pattern2, options2) {
      options2 = options2 || {};
      var context = options2 && typeof options2.context === "string" ? options2.context : process.cwd();
      var hashPrefix = options2 && typeof options2.hashPrefix === "string" ? options2.hashPrefix : "";
      return function generate2(localName, filepath) {
        var name2 = pattern2.replace(/\[local\]/gi, localName);
        var loaderContext = {
          resourcePath: filepath
        };
        var loaderOptions = {
          content: hashPrefix + path3.relative(context, filepath).replace(/\\/g, "/") + "\0" + localName,
          context
        };
        var genericName = interpolateName(loaderContext, name2, loaderOptions);
        return genericName.replace(new RegExp("[^a-zA-Z0-9\\-_\xA0-\uFFFF]", "g"), "-").replace(/^((-?[0-9])|--)/, "_$1");
      };
    };
    src$2 = { exports: {} };
    dist = { exports: {} };
    processor = { exports: {} };
    parser = { exports: {} };
    root$1 = { exports: {} };
    container = { exports: {} };
    node$1 = { exports: {} };
    util = {};
    unesc = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = unesc2;
      function gobbleHex(str2) {
        var lower = str2.toLowerCase();
        var hex = "";
        var spaceTerminated = false;
        for (var i = 0; i < 6 && lower[i] !== void 0; i++) {
          var code = lower.charCodeAt(i);
          var valid = code >= 97 && code <= 102 || code >= 48 && code <= 57;
          spaceTerminated = code === 32;
          if (!valid) {
            break;
          }
          hex += lower[i];
        }
        if (hex.length === 0) {
          return void 0;
        }
        var codePoint = parseInt(hex, 16);
        var isSurrogate = codePoint >= 55296 && codePoint <= 57343;
        if (isSurrogate || codePoint === 0 || codePoint > 1114111) {
          return ["\uFFFD", hex.length + (spaceTerminated ? 1 : 0)];
        }
        return [String.fromCodePoint(codePoint), hex.length + (spaceTerminated ? 1 : 0)];
      }
      var CONTAINS_ESCAPE = /\\/;
      function unesc2(str2) {
        var needToProcess = CONTAINS_ESCAPE.test(str2);
        if (!needToProcess) {
          return str2;
        }
        var ret = "";
        for (var i = 0; i < str2.length; i++) {
          if (str2[i] === "\\") {
            var gobbled = gobbleHex(str2.slice(i + 1, i + 7));
            if (gobbled !== void 0) {
              ret += gobbled[0];
              i += gobbled[1];
              continue;
            }
            if (str2[i + 1] === "\\") {
              ret += "\\";
              i++;
              continue;
            }
            if (str2.length === i + 1) {
              ret += str2[i];
            }
            continue;
          }
          ret += str2[i];
        }
        return ret;
      }
      module.exports = exports2.default;
    })(unesc, unesc.exports);
    unescExports = unesc.exports;
    getProp = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = getProp2;
      function getProp2(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            return void 0;
          }
          obj = obj[prop];
        }
        return obj;
      }
      module.exports = exports2.default;
    })(getProp, getProp.exports);
    getPropExports = getProp.exports;
    ensureObject = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = ensureObject2;
      function ensureObject2(obj) {
        for (var _len = arguments.length, props = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          props[_key - 1] = arguments[_key];
        }
        while (props.length > 0) {
          var prop = props.shift();
          if (!obj[prop]) {
            obj[prop] = {};
          }
          obj = obj[prop];
        }
      }
      module.exports = exports2.default;
    })(ensureObject, ensureObject.exports);
    ensureObjectExports = ensureObject.exports;
    stripComments = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = stripComments2;
      function stripComments2(str2) {
        var s = "";
        var commentStart = str2.indexOf("/*");
        var lastEnd = 0;
        while (commentStart >= 0) {
          s = s + str2.slice(lastEnd, commentStart);
          var commentEnd = str2.indexOf("*/", commentStart + 2);
          if (commentEnd < 0) {
            return s;
          }
          lastEnd = commentEnd + 2;
          commentStart = str2.indexOf("/*", lastEnd);
        }
        s = s + str2.slice(lastEnd);
        return s;
      }
      module.exports = exports2.default;
    })(stripComments, stripComments.exports);
    stripCommentsExports = stripComments.exports;
    util.__esModule = true;
    util.unesc = util.stripComments = util.getProp = util.ensureObject = void 0;
    _unesc = _interopRequireDefault$3(unescExports);
    util.unesc = _unesc["default"];
    _getProp = _interopRequireDefault$3(getPropExports);
    util.getProp = _getProp["default"];
    _ensureObject = _interopRequireDefault$3(ensureObjectExports);
    util.ensureObject = _ensureObject["default"];
    _stripComments = _interopRequireDefault$3(stripCommentsExports);
    util.stripComments = _stripComments["default"];
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _util = util;
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var cloneNode = function cloneNode2(obj, parent) {
        if (typeof obj !== "object" || obj === null) {
          return obj;
        }
        var cloned = new obj.constructor();
        for (var i in obj) {
          if (!obj.hasOwnProperty(i)) {
            continue;
          }
          var value2 = obj[i];
          var type = typeof value2;
          if (i === "parent" && type === "object") {
            if (parent) {
              cloned[i] = parent;
            }
          } else if (value2 instanceof Array) {
            cloned[i] = value2.map(function(j) {
              return cloneNode2(j, cloned);
            });
          } else {
            cloned[i] = cloneNode2(value2, cloned);
          }
        }
        return cloned;
      };
      var Node2 = /* @__PURE__ */ function() {
        function Node3(opts) {
          if (opts === void 0) {
            opts = {};
          }
          Object.assign(this, opts);
          this.spaces = this.spaces || {};
          this.spaces.before = this.spaces.before || "";
          this.spaces.after = this.spaces.after || "";
        }
        var _proto = Node3.prototype;
        _proto.remove = function remove() {
          if (this.parent) {
            this.parent.removeChild(this);
          }
          this.parent = void 0;
          return this;
        };
        _proto.replaceWith = function replaceWith() {
          if (this.parent) {
            for (var index4 in arguments) {
              this.parent.insertBefore(this, arguments[index4]);
            }
            this.remove();
          }
          return this;
        };
        _proto.next = function next() {
          return this.parent.at(this.parent.index(this) + 1);
        };
        _proto.prev = function prev() {
          return this.parent.at(this.parent.index(this) - 1);
        };
        _proto.clone = function clone(overrides) {
          if (overrides === void 0) {
            overrides = {};
          }
          var cloned = cloneNode(this);
          for (var name2 in overrides) {
            cloned[name2] = overrides[name2];
          }
          return cloned;
        };
        _proto.appendToPropertyAndEscape = function appendToPropertyAndEscape(name2, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          var originalValue = this[name2];
          var originalEscaped = this.raws[name2];
          this[name2] = originalValue + value2;
          if (originalEscaped || valueEscaped !== value2) {
            this.raws[name2] = (originalEscaped || originalValue) + valueEscaped;
          } else {
            delete this.raws[name2];
          }
        };
        _proto.setPropertyAndEscape = function setPropertyAndEscape(name2, value2, valueEscaped) {
          if (!this.raws) {
            this.raws = {};
          }
          this[name2] = value2;
          this.raws[name2] = valueEscaped;
        };
        _proto.setPropertyWithoutEscape = function setPropertyWithoutEscape(name2, value2) {
          this[name2] = value2;
          if (this.raws) {
            delete this.raws[name2];
          }
        };
        _proto.isAtPosition = function isAtPosition(line, column) {
          if (this.source && this.source.start && this.source.end) {
            if (this.source.start.line > line) {
              return false;
            }
            if (this.source.end.line < line) {
              return false;
            }
            if (this.source.start.line === line && this.source.start.column > column) {
              return false;
            }
            if (this.source.end.line === line && this.source.end.column < column) {
              return false;
            }
            return true;
          }
          return void 0;
        };
        _proto.stringifyProperty = function stringifyProperty(name2) {
          return this.raws && this.raws[name2] || this[name2];
        };
        _proto.valueToString = function valueToString() {
          return String(this.stringifyProperty("value"));
        };
        _proto.toString = function toString2() {
          return [this.rawSpaceBefore, this.valueToString(), this.rawSpaceAfter].join("");
        };
        _createClass(Node3, [{
          key: "rawSpaceBefore",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.before;
            if (rawSpace === void 0) {
              rawSpace = this.spaces && this.spaces.before;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.before = raw;
          }
        }, {
          key: "rawSpaceAfter",
          get: function get() {
            var rawSpace = this.raws && this.raws.spaces && this.raws.spaces.after;
            if (rawSpace === void 0) {
              rawSpace = this.spaces.after;
            }
            return rawSpace || "";
          },
          set: function set2(raw) {
            (0, _util.ensureObject)(this, "raws", "spaces");
            this.raws.spaces.after = raw;
          }
        }]);
        return Node3;
      }();
      exports2["default"] = Node2;
      module.exports = exports2.default;
    })(node$1, node$1.exports);
    nodeExports = node$1.exports;
    types = {};
    types.__esModule = true;
    types.UNIVERSAL = types.TAG = types.STRING = types.SELECTOR = types.ROOT = types.PSEUDO = types.NESTING = types.ID = types.COMMENT = types.COMBINATOR = types.CLASS = types.ATTRIBUTE = void 0;
    TAG = "tag";
    types.TAG = TAG;
    STRING = "string";
    types.STRING = STRING;
    SELECTOR = "selector";
    types.SELECTOR = SELECTOR;
    ROOT = "root";
    types.ROOT = ROOT;
    PSEUDO = "pseudo";
    types.PSEUDO = PSEUDO;
    NESTING = "nesting";
    types.NESTING = NESTING;
    ID = "id";
    types.ID = ID;
    COMMENT = "comment";
    types.COMMENT = COMMENT;
    COMBINATOR = "combinator";
    types.COMBINATOR = COMBINATOR;
    CLASS = "class";
    types.CLASS = CLASS;
    ATTRIBUTE = "attribute";
    types.ATTRIBUTE = ATTRIBUTE;
    UNIVERSAL = "universal";
    types.UNIVERSAL = UNIVERSAL;
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var types$12 = _interopRequireWildcard(types);
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
        if (it) return (it = it.call(o)).next.bind(it);
        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
          if (it) o = it;
          var i = 0;
          return function() {
            if (i >= o.length) return { done: true };
            return { done: false, value: o[i++] };
          };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;
        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Container2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Container3, _Node);
        function Container3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          if (!_this.nodes) {
            _this.nodes = [];
          }
          return _this;
        }
        var _proto = Container3.prototype;
        _proto.append = function append2(selector3) {
          selector3.parent = this;
          this.nodes.push(selector3);
          return this;
        };
        _proto.prepend = function prepend(selector3) {
          selector3.parent = this;
          this.nodes.unshift(selector3);
          return this;
        };
        _proto.at = function at2(index4) {
          return this.nodes[index4];
        };
        _proto.index = function index4(child) {
          if (typeof child === "number") {
            return child;
          }
          return this.nodes.indexOf(child);
        };
        _proto.removeChild = function removeChild(child) {
          child = this.index(child);
          this.at(child).parent = void 0;
          this.nodes.splice(child, 1);
          var index4;
          for (var id3 in this.indexes) {
            index4 = this.indexes[id3];
            if (index4 >= child) {
              this.indexes[id3] = index4 - 1;
            }
          }
          return this;
        };
        _proto.removeAll = function removeAll() {
          for (var _iterator = _createForOfIteratorHelperLoose(this.nodes), _step; !(_step = _iterator()).done; ) {
            var node3 = _step.value;
            node3.parent = void 0;
          }
          this.nodes = [];
          return this;
        };
        _proto.empty = function empty() {
          return this.removeAll();
        };
        _proto.insertAfter = function insertAfter(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex + 1, 0, newNode);
          newNode.parent = this;
          var index4;
          for (var id3 in this.indexes) {
            index4 = this.indexes[id3];
            if (oldIndex <= index4) {
              this.indexes[id3] = index4 + 1;
            }
          }
          return this;
        };
        _proto.insertBefore = function insertBefore(oldNode, newNode) {
          newNode.parent = this;
          var oldIndex = this.index(oldNode);
          this.nodes.splice(oldIndex, 0, newNode);
          newNode.parent = this;
          var index4;
          for (var id3 in this.indexes) {
            index4 = this.indexes[id3];
            if (index4 <= oldIndex) {
              this.indexes[id3] = index4 + 1;
            }
          }
          return this;
        };
        _proto._findChildAtPosition = function _findChildAtPosition(line, col) {
          var found2 = void 0;
          this.each(function(node3) {
            if (node3.atPosition) {
              var foundChild = node3.atPosition(line, col);
              if (foundChild) {
                found2 = foundChild;
                return false;
              }
            } else if (node3.isAtPosition(line, col)) {
              found2 = node3;
              return false;
            }
          });
          return found2;
        };
        _proto.atPosition = function atPosition(line, col) {
          if (this.isAtPosition(line, col)) {
            return this._findChildAtPosition(line, col) || this;
          } else {
            return void 0;
          }
        };
        _proto._inferEndPosition = function _inferEndPosition() {
          if (this.last && this.last.source && this.last.source.end) {
            this.source = this.source || {};
            this.source.end = this.source.end || {};
            Object.assign(this.source.end, this.last.source.end);
          }
        };
        _proto.each = function each(callback) {
          if (!this.lastEach) {
            this.lastEach = 0;
          }
          if (!this.indexes) {
            this.indexes = {};
          }
          this.lastEach++;
          var id3 = this.lastEach;
          this.indexes[id3] = 0;
          if (!this.length) {
            return void 0;
          }
          var index4, result;
          while (this.indexes[id3] < this.length) {
            index4 = this.indexes[id3];
            result = callback(this.at(index4), index4);
            if (result === false) {
              break;
            }
            this.indexes[id3] += 1;
          }
          delete this.indexes[id3];
          if (result === false) {
            return false;
          }
        };
        _proto.walk = function walk3(callback) {
          return this.each(function(node3, i) {
            var result = callback(node3, i);
            if (result !== false && node3.length) {
              result = node3.walk(callback);
            }
            if (result === false) {
              return false;
            }
          });
        };
        _proto.walkAttributes = function walkAttributes(callback) {
          var _this2 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.ATTRIBUTE) {
              return callback.call(_this2, selector3);
            }
          });
        };
        _proto.walkClasses = function walkClasses(callback) {
          var _this3 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.CLASS) {
              return callback.call(_this3, selector3);
            }
          });
        };
        _proto.walkCombinators = function walkCombinators(callback) {
          var _this4 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.COMBINATOR) {
              return callback.call(_this4, selector3);
            }
          });
        };
        _proto.walkComments = function walkComments(callback) {
          var _this5 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.COMMENT) {
              return callback.call(_this5, selector3);
            }
          });
        };
        _proto.walkIds = function walkIds(callback) {
          var _this6 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.ID) {
              return callback.call(_this6, selector3);
            }
          });
        };
        _proto.walkNesting = function walkNesting(callback) {
          var _this7 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.NESTING) {
              return callback.call(_this7, selector3);
            }
          });
        };
        _proto.walkPseudos = function walkPseudos(callback) {
          var _this8 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.PSEUDO) {
              return callback.call(_this8, selector3);
            }
          });
        };
        _proto.walkTags = function walkTags(callback) {
          var _this9 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.TAG) {
              return callback.call(_this9, selector3);
            }
          });
        };
        _proto.walkUniversals = function walkUniversals(callback) {
          var _this10 = this;
          return this.walk(function(selector3) {
            if (selector3.type === types$12.UNIVERSAL) {
              return callback.call(_this10, selector3);
            }
          });
        };
        _proto.split = function split(callback) {
          var _this11 = this;
          var current = [];
          return this.reduce(function(memo, node3, index4) {
            var split2 = callback.call(_this11, node3);
            current.push(node3);
            if (split2) {
              memo.push(current);
              current = [];
            } else if (index4 === _this11.length - 1) {
              memo.push(current);
            }
            return memo;
          }, []);
        };
        _proto.map = function map(callback) {
          return this.nodes.map(callback);
        };
        _proto.reduce = function reduce(callback, memo) {
          return this.nodes.reduce(callback, memo);
        };
        _proto.every = function every(callback) {
          return this.nodes.every(callback);
        };
        _proto.some = function some(callback) {
          return this.nodes.some(callback);
        };
        _proto.filter = function filter2(callback) {
          return this.nodes.filter(callback);
        };
        _proto.sort = function sort2(callback) {
          return this.nodes.sort(callback);
        };
        _proto.toString = function toString2() {
          return this.map(String).join("");
        };
        _createClass(Container3, [{
          key: "first",
          get: function get() {
            return this.at(0);
          }
        }, {
          key: "last",
          get: function get() {
            return this.at(this.length - 1);
          }
        }, {
          key: "length",
          get: function get() {
            return this.nodes.length;
          }
        }]);
        return Container3;
      }(_node["default"]);
      exports2["default"] = Container2;
      module.exports = exports2.default;
    })(container, container.exports);
    containerExports = container.exports;
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _container = _interopRequireDefault2(containerExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Root2 = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Root3, _Container);
        function Root3(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.ROOT;
          return _this;
        }
        var _proto = Root3.prototype;
        _proto.toString = function toString2() {
          var str2 = this.reduce(function(memo, selector3) {
            memo.push(String(selector3));
            return memo;
          }, []).join(",");
          return this.trailingComma ? str2 + "," : str2;
        };
        _proto.error = function error(message, options2) {
          if (this._error) {
            return this._error(message, options2);
          } else {
            return new Error(message);
          }
        };
        _createClass(Root3, [{
          key: "errorGenerator",
          set: function set2(handler) {
            this._error = handler;
          }
        }]);
        return Root3;
      }(_container["default"]);
      exports2["default"] = Root2;
      module.exports = exports2.default;
    })(root$1, root$1.exports);
    rootExports = root$1.exports;
    selector$1 = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _container = _interopRequireDefault2(containerExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Selector = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Selector2, _Container);
        function Selector2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.SELECTOR;
          return _this;
        }
        return Selector2;
      }(_container["default"]);
      exports2["default"] = Selector;
      module.exports = exports2.default;
    })(selector$1, selector$1.exports);
    selectorExports = selector$1.exports;
    className$1 = { exports: {} };
    object = {};
    hasOwnProperty$1 = object.hasOwnProperty;
    merge = function merge2(options2, defaults2) {
      if (!options2) {
        return defaults2;
      }
      var result = {};
      for (var key in defaults2) {
        result[key] = hasOwnProperty$1.call(options2, key) ? options2[key] : defaults2[key];
      }
      return result;
    };
    regexAnySingleEscape = /[ -,\.\/:-@\[-\^`\{-~]/;
    regexSingleEscape = /[ -,\.\/:-@\[\]\^`\{-~]/;
    regexExcessiveSpaces = /(^|\\+)?(\\[A-F0-9]{1,6})\x20(?![a-fA-F0-9\x20])/g;
    cssesc = function cssesc2(string4, options2) {
      options2 = merge(options2, cssesc2.options);
      if (options2.quotes != "single" && options2.quotes != "double") {
        options2.quotes = "single";
      }
      var quote3 = options2.quotes == "double" ? '"' : "'";
      var isIdentifier2 = options2.isIdentifier;
      var firstChar = string4.charAt(0);
      var output = "";
      var counter = 0;
      var length = string4.length;
      while (counter < length) {
        var character = string4.charAt(counter++);
        var codePoint = character.charCodeAt();
        var value2 = void 0;
        if (codePoint < 32 || codePoint > 126) {
          if (codePoint >= 55296 && codePoint <= 56319 && counter < length) {
            var extra = string4.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              codePoint = ((codePoint & 1023) << 10) + (extra & 1023) + 65536;
            } else {
              counter--;
            }
          }
          value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
        } else {
          if (options2.escapeEverything) {
            if (regexAnySingleEscape.test(character)) {
              value2 = "\\" + character;
            } else {
              value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
            }
          } else if (/[\t\n\f\r\x0B]/.test(character)) {
            value2 = "\\" + codePoint.toString(16).toUpperCase() + " ";
          } else if (character == "\\" || !isIdentifier2 && (character == '"' && quote3 == character || character == "'" && quote3 == character) || isIdentifier2 && regexSingleEscape.test(character)) {
            value2 = "\\" + character;
          } else {
            value2 = character;
          }
        }
        output += value2;
      }
      if (isIdentifier2) {
        if (/^-[-\d]/.test(output)) {
          output = "\\-" + output.slice(1);
        } else if (/\d/.test(firstChar)) {
          output = "\\3" + firstChar + " " + output.slice(1);
        }
      }
      output = output.replace(regexExcessiveSpaces, function($0, $1, $2) {
        if ($1 && $1.length % 2) {
          return $0;
        }
        return ($1 || "") + $2;
      });
      if (!isIdentifier2 && options2.wrap) {
        return quote3 + output + quote3;
      }
      return output;
    };
    cssesc.options = {
      "escapeEverything": false,
      "isIdentifier": false,
      "quotes": "single",
      "wrap": false
    };
    cssesc.version = "3.0.0";
    cssesc_1 = cssesc;
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _util = util;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var ClassName = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ClassName2, _Node);
        function ClassName2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.CLASS;
          _this._constructed = true;
          return _this;
        }
        var _proto = ClassName2.prototype;
        _proto.valueToString = function valueToString() {
          return "." + _Node.prototype.valueToString.call(this);
        };
        _createClass(ClassName2, [{
          key: "value",
          get: function get() {
            return this._value;
          },
          set: function set2(v) {
            if (this._constructed) {
              var escaped2 = (0, _cssesc["default"])(v, {
                isIdentifier: true
              });
              if (escaped2 !== v) {
                (0, _util.ensureObject)(this, "raws");
                this.raws.value = escaped2;
              } else if (this.raws) {
                delete this.raws.value;
              }
            }
            this._value = v;
          }
        }]);
        return ClassName2;
      }(_node["default"]);
      exports2["default"] = ClassName;
      module.exports = exports2.default;
    })(className$1, className$1.exports);
    classNameExports = className$1.exports;
    comment$2 = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Comment2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Comment3, _Node);
        function Comment3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.COMMENT;
          return _this;
        }
        return Comment3;
      }(_node["default"]);
      exports2["default"] = Comment2;
      module.exports = exports2.default;
    })(comment$2, comment$2.exports);
    commentExports = comment$2.exports;
    id$1 = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var ID2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(ID3, _Node);
        function ID3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.ID;
          return _this;
        }
        var _proto = ID3.prototype;
        _proto.valueToString = function valueToString() {
          return "#" + _Node.prototype.valueToString.call(this);
        };
        return ID3;
      }(_node["default"]);
      exports2["default"] = ID2;
      module.exports = exports2.default;
    })(id$1, id$1.exports);
    idExports = id$1.exports;
    tag$1 = { exports: {} };
    namespace = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _util = util;
      var _node = _interopRequireDefault2(nodeExports);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Namespace = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Namespace2, _Node);
        function Namespace2() {
          return _Node.apply(this, arguments) || this;
        }
        var _proto = Namespace2.prototype;
        _proto.qualifiedName = function qualifiedName(value2) {
          if (this.namespace) {
            return this.namespaceString + "|" + value2;
          } else {
            return value2;
          }
        };
        _proto.valueToString = function valueToString() {
          return this.qualifiedName(_Node.prototype.valueToString.call(this));
        };
        _createClass(Namespace2, [{
          key: "namespace",
          get: function get() {
            return this._namespace;
          },
          set: function set2(namespace2) {
            if (namespace2 === true || namespace2 === "*" || namespace2 === "&") {
              this._namespace = namespace2;
              if (this.raws) {
                delete this.raws.namespace;
              }
              return;
            }
            var escaped2 = (0, _cssesc["default"])(namespace2, {
              isIdentifier: true
            });
            this._namespace = namespace2;
            if (escaped2 !== namespace2) {
              (0, _util.ensureObject)(this, "raws");
              this.raws.namespace = escaped2;
            } else if (this.raws) {
              delete this.raws.namespace;
            }
          }
        }, {
          key: "ns",
          get: function get() {
            return this._namespace;
          },
          set: function set2(namespace2) {
            this.namespace = namespace2;
          }
        }, {
          key: "namespaceString",
          get: function get() {
            if (this.namespace) {
              var ns = this.stringifyProperty("namespace");
              if (ns === true) {
                return "";
              } else {
                return ns;
              }
            } else {
              return "";
            }
          }
        }]);
        return Namespace2;
      }(_node["default"]);
      exports2["default"] = Namespace;
      module.exports = exports2.default;
    })(namespace, namespace.exports);
    namespaceExports = namespace.exports;
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _namespace = _interopRequireDefault2(namespaceExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Tag = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Tag2, _Namespace);
        function Tag2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types2.TAG;
          return _this;
        }
        return Tag2;
      }(_namespace["default"]);
      exports2["default"] = Tag;
      module.exports = exports2.default;
    })(tag$1, tag$1.exports);
    tagExports = tag$1.exports;
    string$1 = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var String2 = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(String3, _Node);
        function String3(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.STRING;
          return _this;
        }
        return String3;
      }(_node["default"]);
      exports2["default"] = String2;
      module.exports = exports2.default;
    })(string$1, string$1.exports);
    stringExports = string$1.exports;
    pseudo$1 = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _container = _interopRequireDefault2(containerExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Pseudo = /* @__PURE__ */ function(_Container) {
        _inheritsLoose(Pseudo2, _Container);
        function Pseudo2(opts) {
          var _this;
          _this = _Container.call(this, opts) || this;
          _this.type = _types2.PSEUDO;
          return _this;
        }
        var _proto = Pseudo2.prototype;
        _proto.toString = function toString2() {
          var params = this.length ? "(" + this.map(String).join(",") + ")" : "";
          return [this.rawSpaceBefore, this.stringifyProperty("value"), params, this.rawSpaceAfter].join("");
        };
        return Pseudo2;
      }(_container["default"]);
      exports2["default"] = Pseudo;
      module.exports = exports2.default;
    })(pseudo$1, pseudo$1.exports);
    pseudoExports = pseudo$1.exports;
    attribute$1 = {};
    node = require$$0$2.deprecate;
    (function(exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      exports2.unescapeValue = unescapeValue;
      var _cssesc = _interopRequireDefault2(cssesc_1);
      var _unesc2 = _interopRequireDefault2(unescExports);
      var _namespace = _interopRequireDefault2(namespaceExports);
      var _types2 = types;
      var _CSSESC_QUOTE_OPTIONS;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var deprecate = node;
      var WRAPPED_IN_QUOTES = /^('|")([^]*)\1$/;
      var warnOfDeprecatedValueAssignment = deprecate(function() {
      }, "Assigning an attribute a value containing characters that might need to be escaped is deprecated. Call attribute.setValue() instead.");
      var warnOfDeprecatedQuotedAssignment = deprecate(function() {
      }, "Assigning attr.quoted is deprecated and has no effect. Assign to attr.quoteMark instead.");
      var warnOfDeprecatedConstructor = deprecate(function() {
      }, "Constructing an Attribute selector with a value without specifying quoteMark is deprecated. Note: The value should be unescaped now.");
      function unescapeValue(value2) {
        var deprecatedUsage = false;
        var quoteMark = null;
        var unescaped = value2;
        var m = unescaped.match(WRAPPED_IN_QUOTES);
        if (m) {
          quoteMark = m[1];
          unescaped = m[2];
        }
        unescaped = (0, _unesc2["default"])(unescaped);
        if (unescaped !== value2) {
          deprecatedUsage = true;
        }
        return {
          deprecatedUsage,
          unescaped,
          quoteMark
        };
      }
      function handleDeprecatedContructorOpts(opts) {
        if (opts.quoteMark !== void 0) {
          return opts;
        }
        if (opts.value === void 0) {
          return opts;
        }
        warnOfDeprecatedConstructor();
        var _unescapeValue = unescapeValue(opts.value), quoteMark = _unescapeValue.quoteMark, unescaped = _unescapeValue.unescaped;
        if (!opts.raws) {
          opts.raws = {};
        }
        if (opts.raws.value === void 0) {
          opts.raws.value = opts.value;
        }
        opts.value = unescaped;
        opts.quoteMark = quoteMark;
        return opts;
      }
      var Attribute = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Attribute2, _Namespace);
        function Attribute2(opts) {
          var _this;
          if (opts === void 0) {
            opts = {};
          }
          _this = _Namespace.call(this, handleDeprecatedContructorOpts(opts)) || this;
          _this.type = _types2.ATTRIBUTE;
          _this.raws = _this.raws || {};
          Object.defineProperty(_this.raws, "unquoted", {
            get: deprecate(function() {
              return _this.value;
            }, "attr.raws.unquoted is deprecated. Call attr.value instead."),
            set: deprecate(function() {
              return _this.value;
            }, "Setting attr.raws.unquoted is deprecated and has no effect. attr.value is unescaped by default now.")
          });
          _this._constructed = true;
          return _this;
        }
        var _proto = Attribute2.prototype;
        _proto.getQuotedValue = function getQuotedValue(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var quoteMark = this._determineQuoteMark(options2);
          var cssescopts = CSSESC_QUOTE_OPTIONS[quoteMark];
          var escaped2 = (0, _cssesc["default"])(this._value, cssescopts);
          return escaped2;
        };
        _proto._determineQuoteMark = function _determineQuoteMark(options2) {
          return options2.smart ? this.smartQuoteMark(options2) : this.preferredQuoteMark(options2);
        };
        _proto.setValue = function setValue(value2, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this._value = value2;
          this._quoteMark = this._determineQuoteMark(options2);
          this._syncRawValue();
        };
        _proto.smartQuoteMark = function smartQuoteMark(options2) {
          var v = this.value;
          var numSingleQuotes = v.replace(/[^']/g, "").length;
          var numDoubleQuotes = v.replace(/[^"]/g, "").length;
          if (numSingleQuotes + numDoubleQuotes === 0) {
            var escaped2 = (0, _cssesc["default"])(v, {
              isIdentifier: true
            });
            if (escaped2 === v) {
              return Attribute2.NO_QUOTE;
            } else {
              var pref = this.preferredQuoteMark(options2);
              if (pref === Attribute2.NO_QUOTE) {
                var quote3 = this.quoteMark || options2.quoteMark || Attribute2.DOUBLE_QUOTE;
                var opts = CSSESC_QUOTE_OPTIONS[quote3];
                var quoteValue = (0, _cssesc["default"])(v, opts);
                if (quoteValue.length < escaped2.length) {
                  return quote3;
                }
              }
              return pref;
            }
          } else if (numDoubleQuotes === numSingleQuotes) {
            return this.preferredQuoteMark(options2);
          } else if (numDoubleQuotes < numSingleQuotes) {
            return Attribute2.DOUBLE_QUOTE;
          } else {
            return Attribute2.SINGLE_QUOTE;
          }
        };
        _proto.preferredQuoteMark = function preferredQuoteMark(options2) {
          var quoteMark = options2.preferCurrentQuoteMark ? this.quoteMark : options2.quoteMark;
          if (quoteMark === void 0) {
            quoteMark = options2.preferCurrentQuoteMark ? options2.quoteMark : this.quoteMark;
          }
          if (quoteMark === void 0) {
            quoteMark = Attribute2.DOUBLE_QUOTE;
          }
          return quoteMark;
        };
        _proto._syncRawValue = function _syncRawValue() {
          var rawValue = (0, _cssesc["default"])(this._value, CSSESC_QUOTE_OPTIONS[this.quoteMark]);
          if (rawValue === this._value) {
            if (this.raws) {
              delete this.raws.value;
            }
          } else {
            this.raws.value = rawValue;
          }
        };
        _proto._handleEscapes = function _handleEscapes(prop, value2) {
          if (this._constructed) {
            var escaped2 = (0, _cssesc["default"])(value2, {
              isIdentifier: true
            });
            if (escaped2 !== value2) {
              this.raws[prop] = escaped2;
            } else {
              delete this.raws[prop];
            }
          }
        };
        _proto._spacesFor = function _spacesFor(name2) {
          var attrSpaces = {
            before: "",
            after: ""
          };
          var spaces = this.spaces[name2] || {};
          var rawSpaces = this.raws.spaces && this.raws.spaces[name2] || {};
          return Object.assign(attrSpaces, spaces, rawSpaces);
        };
        _proto._stringFor = function _stringFor(name2, spaceName, concat2) {
          if (spaceName === void 0) {
            spaceName = name2;
          }
          if (concat2 === void 0) {
            concat2 = defaultAttrConcat;
          }
          var attrSpaces = this._spacesFor(spaceName);
          return concat2(this.stringifyProperty(name2), attrSpaces);
        };
        _proto.offsetOf = function offsetOf(name2) {
          var count = 1;
          var attributeSpaces = this._spacesFor("attribute");
          count += attributeSpaces.before.length;
          if (name2 === "namespace" || name2 === "ns") {
            return this.namespace ? count : -1;
          }
          if (name2 === "attributeNS") {
            return count;
          }
          count += this.namespaceString.length;
          if (this.namespace) {
            count += 1;
          }
          if (name2 === "attribute") {
            return count;
          }
          count += this.stringifyProperty("attribute").length;
          count += attributeSpaces.after.length;
          var operatorSpaces = this._spacesFor("operator");
          count += operatorSpaces.before.length;
          var operator = this.stringifyProperty("operator");
          if (name2 === "operator") {
            return operator ? count : -1;
          }
          count += operator.length;
          count += operatorSpaces.after.length;
          var valueSpaces = this._spacesFor("value");
          count += valueSpaces.before.length;
          var value2 = this.stringifyProperty("value");
          if (name2 === "value") {
            return value2 ? count : -1;
          }
          count += value2.length;
          count += valueSpaces.after.length;
          var insensitiveSpaces = this._spacesFor("insensitive");
          count += insensitiveSpaces.before.length;
          if (name2 === "insensitive") {
            return this.insensitive ? count : -1;
          }
          return -1;
        };
        _proto.toString = function toString2() {
          var _this2 = this;
          var selector3 = [this.rawSpaceBefore, "["];
          selector3.push(this._stringFor("qualifiedAttribute", "attribute"));
          if (this.operator && (this.value || this.value === "")) {
            selector3.push(this._stringFor("operator"));
            selector3.push(this._stringFor("value"));
            selector3.push(this._stringFor("insensitiveFlag", "insensitive", function(attrValue, attrSpaces) {
              if (attrValue.length > 0 && !_this2.quoted && attrSpaces.before.length === 0 && !(_this2.spaces.value && _this2.spaces.value.after)) {
                attrSpaces.before = " ";
              }
              return defaultAttrConcat(attrValue, attrSpaces);
            }));
          }
          selector3.push("]");
          selector3.push(this.rawSpaceAfter);
          return selector3.join("");
        };
        _createClass(Attribute2, [{
          key: "quoted",
          get: function get() {
            var qm = this.quoteMark;
            return qm === "'" || qm === '"';
          },
          set: function set2(value2) {
            warnOfDeprecatedQuotedAssignment();
          }
          /**
           * returns a single (`'`) or double (`"`) quote character if the value is quoted.
           * returns `null` if the value is not quoted.
           * returns `undefined` if the quotation state is unknown (this can happen when
           * the attribute is constructed without specifying a quote mark.)
           */
        }, {
          key: "quoteMark",
          get: function get() {
            return this._quoteMark;
          },
          set: function set2(quoteMark) {
            if (!this._constructed) {
              this._quoteMark = quoteMark;
              return;
            }
            if (this._quoteMark !== quoteMark) {
              this._quoteMark = quoteMark;
              this._syncRawValue();
            }
          }
        }, {
          key: "qualifiedAttribute",
          get: function get() {
            return this.qualifiedName(this.raws.attribute || this.attribute);
          }
        }, {
          key: "insensitiveFlag",
          get: function get() {
            return this.insensitive ? "i" : "";
          }
        }, {
          key: "value",
          get: function get() {
            return this._value;
          },
          set: (
            /**
             * Before 3.0, the value had to be set to an escaped value including any wrapped
             * quote marks. In 3.0, the semantics of `Attribute.value` changed so that the value
             * is unescaped during parsing and any quote marks are removed.
             *
             * Because the ambiguity of this semantic change, if you set `attr.value = newValue`,
             * a deprecation warning is raised when the new value contains any characters that would
             * require escaping (including if it contains wrapped quotes).
             *
             * Instead, you should call `attr.setValue(newValue, opts)` and pass options that describe
             * how the new value is quoted.
             */
            function set2(v) {
              if (this._constructed) {
                var _unescapeValue2 = unescapeValue(v), deprecatedUsage = _unescapeValue2.deprecatedUsage, unescaped = _unescapeValue2.unescaped, quoteMark = _unescapeValue2.quoteMark;
                if (deprecatedUsage) {
                  warnOfDeprecatedValueAssignment();
                }
                if (unescaped === this._value && quoteMark === this._quoteMark) {
                  return;
                }
                this._value = unescaped;
                this._quoteMark = quoteMark;
                this._syncRawValue();
              } else {
                this._value = v;
              }
            }
          )
        }, {
          key: "insensitive",
          get: function get() {
            return this._insensitive;
          },
          set: function set2(insensitive) {
            if (!insensitive) {
              this._insensitive = false;
              if (this.raws && (this.raws.insensitiveFlag === "I" || this.raws.insensitiveFlag === "i")) {
                this.raws.insensitiveFlag = void 0;
              }
            }
            this._insensitive = insensitive;
          }
        }, {
          key: "attribute",
          get: function get() {
            return this._attribute;
          },
          set: function set2(name2) {
            this._handleEscapes("attribute", name2);
            this._attribute = name2;
          }
        }]);
        return Attribute2;
      }(_namespace["default"]);
      exports2["default"] = Attribute;
      Attribute.NO_QUOTE = null;
      Attribute.SINGLE_QUOTE = "'";
      Attribute.DOUBLE_QUOTE = '"';
      var CSSESC_QUOTE_OPTIONS = (_CSSESC_QUOTE_OPTIONS = {
        "'": {
          quotes: "single",
          wrap: true
        },
        '"': {
          quotes: "double",
          wrap: true
        }
      }, _CSSESC_QUOTE_OPTIONS[null] = {
        isIdentifier: true
      }, _CSSESC_QUOTE_OPTIONS);
      function defaultAttrConcat(attrValue, attrSpaces) {
        return "" + attrSpaces.before + attrValue + attrSpaces.after;
      }
    })(attribute$1);
    universal$1 = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _namespace = _interopRequireDefault2(namespaceExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Universal = /* @__PURE__ */ function(_Namespace) {
        _inheritsLoose(Universal2, _Namespace);
        function Universal2(opts) {
          var _this;
          _this = _Namespace.call(this, opts) || this;
          _this.type = _types2.UNIVERSAL;
          _this.value = "*";
          return _this;
        }
        return Universal2;
      }(_namespace["default"]);
      exports2["default"] = Universal;
      module.exports = exports2.default;
    })(universal$1, universal$1.exports);
    universalExports = universal$1.exports;
    combinator$2 = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Combinator = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Combinator2, _Node);
        function Combinator2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.COMBINATOR;
          return _this;
        }
        return Combinator2;
      }(_node["default"]);
      exports2["default"] = Combinator;
      module.exports = exports2.default;
    })(combinator$2, combinator$2.exports);
    combinatorExports = combinator$2.exports;
    nesting$1 = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _node = _interopRequireDefault2(nodeExports);
      var _types2 = types;
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      var Nesting = /* @__PURE__ */ function(_Node) {
        _inheritsLoose(Nesting2, _Node);
        function Nesting2(opts) {
          var _this;
          _this = _Node.call(this, opts) || this;
          _this.type = _types2.NESTING;
          _this.value = "&";
          return _this;
        }
        return Nesting2;
      }(_node["default"]);
      exports2["default"] = Nesting;
      module.exports = exports2.default;
    })(nesting$1, nesting$1.exports);
    nestingExports = nesting$1.exports;
    sortAscending = { exports: {} };
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = sortAscending2;
      function sortAscending2(list2) {
        return list2.sort(function(a, b) {
          return a - b;
        });
      }
      module.exports = exports2.default;
    })(sortAscending, sortAscending.exports);
    sortAscendingExports = sortAscending.exports;
    tokenize = {};
    tokenTypes = {};
    tokenTypes.__esModule = true;
    tokenTypes.word = tokenTypes.tilde = tokenTypes.tab = tokenTypes.str = tokenTypes.space = tokenTypes.slash = tokenTypes.singleQuote = tokenTypes.semicolon = tokenTypes.plus = tokenTypes.pipe = tokenTypes.openSquare = tokenTypes.openParenthesis = tokenTypes.newline = tokenTypes.greaterThan = tokenTypes.feed = tokenTypes.equals = tokenTypes.doubleQuote = tokenTypes.dollar = tokenTypes.cr = tokenTypes.comment = tokenTypes.comma = tokenTypes.combinator = tokenTypes.colon = tokenTypes.closeSquare = tokenTypes.closeParenthesis = tokenTypes.caret = tokenTypes.bang = tokenTypes.backslash = tokenTypes.at = tokenTypes.asterisk = tokenTypes.ampersand = void 0;
    ampersand = 38;
    tokenTypes.ampersand = ampersand;
    asterisk = 42;
    tokenTypes.asterisk = asterisk;
    at = 64;
    tokenTypes.at = at;
    comma2 = 44;
    tokenTypes.comma = comma2;
    colon2 = 58;
    tokenTypes.colon = colon2;
    semicolon = 59;
    tokenTypes.semicolon = semicolon;
    openParenthesis = 40;
    tokenTypes.openParenthesis = openParenthesis;
    closeParenthesis = 41;
    tokenTypes.closeParenthesis = closeParenthesis;
    openSquare = 91;
    tokenTypes.openSquare = openSquare;
    closeSquare = 93;
    tokenTypes.closeSquare = closeSquare;
    dollar = 36;
    tokenTypes.dollar = dollar;
    tilde = 126;
    tokenTypes.tilde = tilde;
    caret = 94;
    tokenTypes.caret = caret;
    plus2 = 43;
    tokenTypes.plus = plus2;
    equals = 61;
    tokenTypes.equals = equals;
    pipe = 124;
    tokenTypes.pipe = pipe;
    greaterThan = 62;
    tokenTypes.greaterThan = greaterThan;
    space = 32;
    tokenTypes.space = space;
    singleQuote2 = 39;
    tokenTypes.singleQuote = singleQuote2;
    doubleQuote2 = 34;
    tokenTypes.doubleQuote = doubleQuote2;
    slash2 = 47;
    tokenTypes.slash = slash2;
    bang = 33;
    tokenTypes.bang = bang;
    backslash2 = 92;
    tokenTypes.backslash = backslash2;
    cr = 13;
    tokenTypes.cr = cr;
    feed = 12;
    tokenTypes.feed = feed;
    newline = 10;
    tokenTypes.newline = newline;
    tab = 9;
    tokenTypes.tab = tab;
    str = singleQuote2;
    tokenTypes.str = str;
    comment$1 = -1;
    tokenTypes.comment = comment$1;
    word = -2;
    tokenTypes.word = word;
    combinator$1 = -3;
    tokenTypes.combinator = combinator$1;
    (function(exports2) {
      exports2.__esModule = true;
      exports2.FIELDS = void 0;
      exports2["default"] = tokenize2;
      var t = _interopRequireWildcard(tokenTypes);
      var _unescapable, _wordDelimiters;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      var unescapable = (_unescapable = {}, _unescapable[t.tab] = true, _unescapable[t.newline] = true, _unescapable[t.cr] = true, _unescapable[t.feed] = true, _unescapable);
      var wordDelimiters = (_wordDelimiters = {}, _wordDelimiters[t.space] = true, _wordDelimiters[t.tab] = true, _wordDelimiters[t.newline] = true, _wordDelimiters[t.cr] = true, _wordDelimiters[t.feed] = true, _wordDelimiters[t.ampersand] = true, _wordDelimiters[t.asterisk] = true, _wordDelimiters[t.bang] = true, _wordDelimiters[t.comma] = true, _wordDelimiters[t.colon] = true, _wordDelimiters[t.semicolon] = true, _wordDelimiters[t.openParenthesis] = true, _wordDelimiters[t.closeParenthesis] = true, _wordDelimiters[t.openSquare] = true, _wordDelimiters[t.closeSquare] = true, _wordDelimiters[t.singleQuote] = true, _wordDelimiters[t.doubleQuote] = true, _wordDelimiters[t.plus] = true, _wordDelimiters[t.pipe] = true, _wordDelimiters[t.tilde] = true, _wordDelimiters[t.greaterThan] = true, _wordDelimiters[t.equals] = true, _wordDelimiters[t.dollar] = true, _wordDelimiters[t.caret] = true, _wordDelimiters[t.slash] = true, _wordDelimiters);
      var hex = {};
      var hexChars = "0123456789abcdefABCDEF";
      for (var i = 0; i < hexChars.length; i++) {
        hex[hexChars.charCodeAt(i)] = true;
      }
      function consumeWord(css, start) {
        var next = start;
        var code;
        do {
          code = css.charCodeAt(next);
          if (wordDelimiters[code]) {
            return next - 1;
          } else if (code === t.backslash) {
            next = consumeEscape(css, next) + 1;
          } else {
            next++;
          }
        } while (next < css.length);
        return next - 1;
      }
      function consumeEscape(css, start) {
        var next = start;
        var code = css.charCodeAt(next + 1);
        if (unescapable[code]) ;
        else if (hex[code]) {
          var hexDigits2 = 0;
          do {
            next++;
            hexDigits2++;
            code = css.charCodeAt(next + 1);
          } while (hex[code] && hexDigits2 < 6);
          if (hexDigits2 < 6 && code === t.space) {
            next++;
          }
        } else {
          next++;
        }
        return next;
      }
      var FIELDS = {
        TYPE: 0,
        START_LINE: 1,
        START_COL: 2,
        END_LINE: 3,
        END_COL: 4,
        START_POS: 5,
        END_POS: 6
      };
      exports2.FIELDS = FIELDS;
      function tokenize2(input) {
        var tokens = [];
        var css = input.css.valueOf();
        var _css = css, length = _css.length;
        var offset = -1;
        var line = 1;
        var start = 0;
        var end = 0;
        var code, content, endColumn, endLine, escaped2, escapePos, last, lines, next, nextLine, nextOffset, quote3, tokenType2;
        function unclosed(what, fix) {
          if (input.safe) {
            css += fix;
            next = css.length - 1;
          } else {
            throw input.error("Unclosed " + what, line, start - offset, start);
          }
        }
        while (start < length) {
          code = css.charCodeAt(start);
          if (code === t.newline) {
            offset = start;
            line += 1;
          }
          switch (code) {
            case t.space:
            case t.tab:
            case t.newline:
            case t.cr:
            case t.feed:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
                if (code === t.newline) {
                  offset = next;
                  line += 1;
                }
              } while (code === t.space || code === t.newline || code === t.tab || code === t.cr || code === t.feed);
              tokenType2 = t.space;
              endLine = line;
              endColumn = next - offset - 1;
              end = next;
              break;
            case t.plus:
            case t.greaterThan:
            case t.tilde:
            case t.pipe:
              next = start;
              do {
                next += 1;
                code = css.charCodeAt(next);
              } while (code === t.plus || code === t.greaterThan || code === t.tilde || code === t.pipe);
              tokenType2 = t.combinator;
              endLine = line;
              endColumn = start - offset;
              end = next;
              break;
            // Consume these characters as single tokens.
            case t.asterisk:
            case t.ampersand:
            case t.bang:
            case t.comma:
            case t.equals:
            case t.dollar:
            case t.caret:
            case t.openSquare:
            case t.closeSquare:
            case t.colon:
            case t.semicolon:
            case t.openParenthesis:
            case t.closeParenthesis:
              next = start;
              tokenType2 = code;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;
            case t.singleQuote:
            case t.doubleQuote:
              quote3 = code === t.singleQuote ? "'" : '"';
              next = start;
              do {
                escaped2 = false;
                next = css.indexOf(quote3, next + 1);
                if (next === -1) {
                  unclosed("quote", quote3);
                }
                escapePos = next;
                while (css.charCodeAt(escapePos - 1) === t.backslash) {
                  escapePos -= 1;
                  escaped2 = !escaped2;
                }
              } while (escaped2);
              tokenType2 = t.str;
              endLine = line;
              endColumn = start - offset;
              end = next + 1;
              break;
            default:
              if (code === t.slash && css.charCodeAt(start + 1) === t.asterisk) {
                next = css.indexOf("*/", start + 2) + 1;
                if (next === 0) {
                  unclosed("comment", "*/");
                }
                content = css.slice(start, next + 1);
                lines = content.split("\n");
                last = lines.length - 1;
                if (last > 0) {
                  nextLine = line + last;
                  nextOffset = next - lines[last].length;
                } else {
                  nextLine = line;
                  nextOffset = offset;
                }
                tokenType2 = t.comment;
                line = nextLine;
                endLine = nextLine;
                endColumn = next - nextOffset;
              } else if (code === t.slash) {
                next = start;
                tokenType2 = code;
                endLine = line;
                endColumn = start - offset;
                end = next + 1;
              } else {
                next = consumeWord(css, start);
                tokenType2 = t.word;
                endLine = line;
                endColumn = next - offset;
              }
              end = next + 1;
              break;
          }
          tokens.push([
            tokenType2,
            // [0] Token type
            line,
            // [1] Starting line
            start - offset,
            // [2] Starting column
            endLine,
            // [3] Ending line
            endColumn,
            // [4] Ending column
            start,
            // [5] Start position / Source index
            end
            // [6] End position
          ]);
          if (nextOffset) {
            offset = nextOffset;
            nextOffset = null;
          }
          start = end;
        }
        return tokens;
      }
    })(tokenize);
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _root2 = _interopRequireDefault2(rootExports);
      var _selector2 = _interopRequireDefault2(selectorExports);
      var _className2 = _interopRequireDefault2(classNameExports);
      var _comment2 = _interopRequireDefault2(commentExports);
      var _id2 = _interopRequireDefault2(idExports);
      var _tag2 = _interopRequireDefault2(tagExports);
      var _string2 = _interopRequireDefault2(stringExports);
      var _pseudo2 = _interopRequireDefault2(pseudoExports);
      var _attribute2 = _interopRequireWildcard(attribute$1);
      var _universal2 = _interopRequireDefault2(universalExports);
      var _combinator2 = _interopRequireDefault2(combinatorExports);
      var _nesting2 = _interopRequireDefault2(nestingExports);
      var _sortAscending = _interopRequireDefault2(sortAscendingExports);
      var _tokenize = _interopRequireWildcard(tokenize);
      var tokens = _interopRequireWildcard(tokenTypes);
      var types$12 = _interopRequireWildcard(types);
      var _util = util;
      var _WHITESPACE_TOKENS, _Object$assign;
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        Object.defineProperty(Constructor, "prototype", { writable: false });
        return Constructor;
      }
      var WHITESPACE_TOKENS = (_WHITESPACE_TOKENS = {}, _WHITESPACE_TOKENS[tokens.space] = true, _WHITESPACE_TOKENS[tokens.cr] = true, _WHITESPACE_TOKENS[tokens.feed] = true, _WHITESPACE_TOKENS[tokens.newline] = true, _WHITESPACE_TOKENS[tokens.tab] = true, _WHITESPACE_TOKENS);
      var WHITESPACE_EQUIV_TOKENS = Object.assign({}, WHITESPACE_TOKENS, (_Object$assign = {}, _Object$assign[tokens.comment] = true, _Object$assign));
      function tokenStart(token) {
        return {
          line: token[_tokenize.FIELDS.START_LINE],
          column: token[_tokenize.FIELDS.START_COL]
        };
      }
      function tokenEnd(token) {
        return {
          line: token[_tokenize.FIELDS.END_LINE],
          column: token[_tokenize.FIELDS.END_COL]
        };
      }
      function getSource(startLine, startColumn, endLine, endColumn) {
        return {
          start: {
            line: startLine,
            column: startColumn
          },
          end: {
            line: endLine,
            column: endColumn
          }
        };
      }
      function getTokenSource(token) {
        return getSource(token[_tokenize.FIELDS.START_LINE], token[_tokenize.FIELDS.START_COL], token[_tokenize.FIELDS.END_LINE], token[_tokenize.FIELDS.END_COL]);
      }
      function getTokenSourceSpan(startToken, endToken) {
        if (!startToken) {
          return void 0;
        }
        return getSource(startToken[_tokenize.FIELDS.START_LINE], startToken[_tokenize.FIELDS.START_COL], endToken[_tokenize.FIELDS.END_LINE], endToken[_tokenize.FIELDS.END_COL]);
      }
      function unescapeProp(node3, prop) {
        var value2 = node3[prop];
        if (typeof value2 !== "string") {
          return;
        }
        if (value2.indexOf("\\") !== -1) {
          (0, _util.ensureObject)(node3, "raws");
          node3[prop] = (0, _util.unesc)(value2);
          if (node3.raws[prop] === void 0) {
            node3.raws[prop] = value2;
          }
        }
        return node3;
      }
      function indexesOf(array2, item) {
        var i = -1;
        var indexes = [];
        while ((i = array2.indexOf(item, i + 1)) !== -1) {
          indexes.push(i);
        }
        return indexes;
      }
      function uniqs() {
        var list2 = Array.prototype.concat.apply([], arguments);
        return list2.filter(function(item, i) {
          return i === list2.indexOf(item);
        });
      }
      var Parser3 = /* @__PURE__ */ function() {
        function Parser4(rule2, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          this.rule = rule2;
          this.options = Object.assign({
            lossy: false,
            safe: false
          }, options2);
          this.position = 0;
          this.css = typeof this.rule === "string" ? this.rule : this.rule.selector;
          this.tokens = (0, _tokenize["default"])({
            css: this.css,
            error: this._errorGenerator(),
            safe: this.options.safe
          });
          var rootSource = getTokenSourceSpan(this.tokens[0], this.tokens[this.tokens.length - 1]);
          this.root = new _root2["default"]({
            source: rootSource
          });
          this.root.errorGenerator = this._errorGenerator();
          var selector3 = new _selector2["default"]({
            source: {
              start: {
                line: 1,
                column: 1
              }
            },
            sourceIndex: 0
          });
          this.root.append(selector3);
          this.current = selector3;
          this.loop();
        }
        var _proto = Parser4.prototype;
        _proto._errorGenerator = function _errorGenerator() {
          var _this = this;
          return function(message, errorOptions) {
            if (typeof _this.rule === "string") {
              return new Error(message);
            }
            return _this.rule.error(message, errorOptions);
          };
        };
        _proto.attribute = function attribute3() {
          var attr = [];
          var startingToken = this.currToken;
          this.position++;
          while (this.position < this.tokens.length && this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            attr.push(this.currToken);
            this.position++;
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] !== tokens.closeSquare) {
            return this.expected("closing square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
          }
          var len = attr.length;
          var node3 = {
            source: getSource(startingToken[1], startingToken[2], this.currToken[3], this.currToken[4]),
            sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
          };
          if (len === 1 && !~[tokens.word].indexOf(attr[0][_tokenize.FIELDS.TYPE])) {
            return this.expected("attribute", attr[0][_tokenize.FIELDS.START_POS]);
          }
          var pos = 0;
          var spaceBefore = "";
          var commentBefore = "";
          var lastAdded = null;
          var spaceAfterMeaningfulToken = false;
          while (pos < len) {
            var token = attr[pos];
            var content = this.content(token);
            var next = attr[pos + 1];
            switch (token[_tokenize.FIELDS.TYPE]) {
              case tokens.space:
                spaceAfterMeaningfulToken = true;
                if (this.options.lossy) {
                  break;
                }
                if (lastAdded) {
                  (0, _util.ensureObject)(node3, "spaces", lastAdded);
                  var prevContent = node3.spaces[lastAdded].after || "";
                  node3.spaces[lastAdded].after = prevContent + content;
                  var existingComment = (0, _util.getProp)(node3, "raws", "spaces", lastAdded, "after") || null;
                  if (existingComment) {
                    node3.raws.spaces[lastAdded].after = existingComment + content;
                  }
                } else {
                  spaceBefore = spaceBefore + content;
                  commentBefore = commentBefore + content;
                }
                break;
              case tokens.asterisk:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content;
                  lastAdded = "operator";
                } else if ((!node3.namespace || lastAdded === "namespace" && !spaceAfterMeaningfulToken) && next) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node3, "spaces", "attribute");
                    node3.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node3, "raws", "spaces", "attribute");
                    node3.raws.spaces.attribute.before = spaceBefore;
                    commentBefore = "";
                  }
                  node3.namespace = (node3.namespace || "") + content;
                  var rawValue = (0, _util.getProp)(node3, "raws", "namespace") || null;
                  if (rawValue) {
                    node3.raws.namespace += content;
                  }
                  lastAdded = "namespace";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.dollar:
                if (lastAdded === "value") {
                  var oldRawValue = (0, _util.getProp)(node3, "raws", "value");
                  node3.value += "$";
                  if (oldRawValue) {
                    node3.raws.value = oldRawValue + "$";
                  }
                  break;
                }
              // Falls through
              case tokens.caret:
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content;
                  lastAdded = "operator";
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.combinator:
                if (content === "~" && next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content;
                  lastAdded = "operator";
                }
                if (content !== "|") {
                  spaceAfterMeaningfulToken = false;
                  break;
                }
                if (next[_tokenize.FIELDS.TYPE] === tokens.equals) {
                  node3.operator = content;
                  lastAdded = "operator";
                } else if (!node3.namespace && !node3.attribute) {
                  node3.namespace = true;
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.word:
                if (next && this.content(next) === "|" && attr[pos + 2] && attr[pos + 2][_tokenize.FIELDS.TYPE] !== tokens.equals && // this look-ahead probably fails with comment nodes involved.
                !node3.operator && !node3.namespace) {
                  node3.namespace = content;
                  lastAdded = "namespace";
                } else if (!node3.attribute || lastAdded === "attribute" && !spaceAfterMeaningfulToken) {
                  if (spaceBefore) {
                    (0, _util.ensureObject)(node3, "spaces", "attribute");
                    node3.spaces.attribute.before = spaceBefore;
                    spaceBefore = "";
                  }
                  if (commentBefore) {
                    (0, _util.ensureObject)(node3, "raws", "spaces", "attribute");
                    node3.raws.spaces.attribute.before = commentBefore;
                    commentBefore = "";
                  }
                  node3.attribute = (node3.attribute || "") + content;
                  var _rawValue = (0, _util.getProp)(node3, "raws", "attribute") || null;
                  if (_rawValue) {
                    node3.raws.attribute += content;
                  }
                  lastAdded = "attribute";
                } else if (!node3.value && node3.value !== "" || lastAdded === "value" && !(spaceAfterMeaningfulToken || node3.quoteMark)) {
                  var _unescaped = (0, _util.unesc)(content);
                  var _oldRawValue = (0, _util.getProp)(node3, "raws", "value") || "";
                  var oldValue = node3.value || "";
                  node3.value = oldValue + _unescaped;
                  node3.quoteMark = null;
                  if (_unescaped !== content || _oldRawValue) {
                    (0, _util.ensureObject)(node3, "raws");
                    node3.raws.value = (_oldRawValue || oldValue) + content;
                  }
                  lastAdded = "value";
                } else {
                  var insensitive = content === "i" || content === "I";
                  if ((node3.value || node3.value === "") && (node3.quoteMark || spaceAfterMeaningfulToken)) {
                    node3.insensitive = insensitive;
                    if (!insensitive || content === "I") {
                      (0, _util.ensureObject)(node3, "raws");
                      node3.raws.insensitiveFlag = content;
                    }
                    lastAdded = "insensitive";
                    if (spaceBefore) {
                      (0, _util.ensureObject)(node3, "spaces", "insensitive");
                      node3.spaces.insensitive.before = spaceBefore;
                      spaceBefore = "";
                    }
                    if (commentBefore) {
                      (0, _util.ensureObject)(node3, "raws", "spaces", "insensitive");
                      node3.raws.spaces.insensitive.before = commentBefore;
                      commentBefore = "";
                    }
                  } else if (node3.value || node3.value === "") {
                    lastAdded = "value";
                    node3.value += content;
                    if (node3.raws.value) {
                      node3.raws.value += content;
                    }
                  }
                }
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.str:
                if (!node3.attribute || !node3.operator) {
                  return this.error("Expected an attribute followed by an operator preceding the string.", {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                var _unescapeValue = (0, _attribute2.unescapeValue)(content), unescaped = _unescapeValue.unescaped, quoteMark = _unescapeValue.quoteMark;
                node3.value = unescaped;
                node3.quoteMark = quoteMark;
                lastAdded = "value";
                (0, _util.ensureObject)(node3, "raws");
                node3.raws.value = content;
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.equals:
                if (!node3.attribute) {
                  return this.expected("attribute", token[_tokenize.FIELDS.START_POS], content);
                }
                if (node3.value) {
                  return this.error('Unexpected "=" found; an operator was already defined.', {
                    index: token[_tokenize.FIELDS.START_POS]
                  });
                }
                node3.operator = node3.operator ? node3.operator + content : content;
                lastAdded = "operator";
                spaceAfterMeaningfulToken = false;
                break;
              case tokens.comment:
                if (lastAdded) {
                  if (spaceAfterMeaningfulToken || next && next[_tokenize.FIELDS.TYPE] === tokens.space || lastAdded === "insensitive") {
                    var lastComment = (0, _util.getProp)(node3, "spaces", lastAdded, "after") || "";
                    var rawLastComment = (0, _util.getProp)(node3, "raws", "spaces", lastAdded, "after") || lastComment;
                    (0, _util.ensureObject)(node3, "raws", "spaces", lastAdded);
                    node3.raws.spaces[lastAdded].after = rawLastComment + content;
                  } else {
                    var lastValue = node3[lastAdded] || "";
                    var rawLastValue = (0, _util.getProp)(node3, "raws", lastAdded) || lastValue;
                    (0, _util.ensureObject)(node3, "raws");
                    node3.raws[lastAdded] = rawLastValue + content;
                  }
                } else {
                  commentBefore = commentBefore + content;
                }
                break;
              default:
                return this.error('Unexpected "' + content + '" found.', {
                  index: token[_tokenize.FIELDS.START_POS]
                });
            }
            pos++;
          }
          unescapeProp(node3, "attribute");
          unescapeProp(node3, "namespace");
          this.newNode(new _attribute2["default"](node3));
          this.position++;
        };
        _proto.parseWhitespaceEquivalentTokens = function parseWhitespaceEquivalentTokens(stopPosition) {
          if (stopPosition < 0) {
            stopPosition = this.tokens.length;
          }
          var startPosition = this.position;
          var nodes = [];
          var space2 = "";
          var lastComment = void 0;
          do {
            if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) {
              if (!this.options.lossy) {
                space2 += this.content();
              }
            } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.comment) {
              var spaces = {};
              if (space2) {
                spaces.before = space2;
                space2 = "";
              }
              lastComment = new _comment2["default"]({
                value: this.content(),
                source: getTokenSource(this.currToken),
                sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
                spaces
              });
              nodes.push(lastComment);
            }
          } while (++this.position < stopPosition);
          if (space2) {
            if (lastComment) {
              lastComment.spaces.after = space2;
            } else if (!this.options.lossy) {
              var firstToken = this.tokens[startPosition];
              var lastToken = this.tokens[this.position - 1];
              nodes.push(new _string2["default"]({
                value: "",
                source: getSource(firstToken[_tokenize.FIELDS.START_LINE], firstToken[_tokenize.FIELDS.START_COL], lastToken[_tokenize.FIELDS.END_LINE], lastToken[_tokenize.FIELDS.END_COL]),
                sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
                spaces: {
                  before: space2,
                  after: ""
                }
              }));
            }
          }
          return nodes;
        };
        _proto.convertWhitespaceNodesToSpace = function convertWhitespaceNodesToSpace(nodes, requiredSpace) {
          var _this2 = this;
          if (requiredSpace === void 0) {
            requiredSpace = false;
          }
          var space2 = "";
          var rawSpace = "";
          nodes.forEach(function(n) {
            var spaceBefore = _this2.lossySpace(n.spaces.before, requiredSpace);
            var rawSpaceBefore = _this2.lossySpace(n.rawSpaceBefore, requiredSpace);
            space2 += spaceBefore + _this2.lossySpace(n.spaces.after, requiredSpace && spaceBefore.length === 0);
            rawSpace += spaceBefore + n.value + _this2.lossySpace(n.rawSpaceAfter, requiredSpace && rawSpaceBefore.length === 0);
          });
          if (rawSpace === space2) {
            rawSpace = void 0;
          }
          var result = {
            space: space2,
            rawSpace
          };
          return result;
        };
        _proto.isNamedCombinator = function isNamedCombinator(position) {
          if (position === void 0) {
            position = this.position;
          }
          return this.tokens[position + 0] && this.tokens[position + 0][_tokenize.FIELDS.TYPE] === tokens.slash && this.tokens[position + 1] && this.tokens[position + 1][_tokenize.FIELDS.TYPE] === tokens.word && this.tokens[position + 2] && this.tokens[position + 2][_tokenize.FIELDS.TYPE] === tokens.slash;
        };
        _proto.namedCombinator = function namedCombinator() {
          if (this.isNamedCombinator()) {
            var nameRaw = this.content(this.tokens[this.position + 1]);
            var name2 = (0, _util.unesc)(nameRaw).toLowerCase();
            var raws = {};
            if (name2 !== nameRaw) {
              raws.value = "/" + nameRaw + "/";
            }
            var node3 = new _combinator2["default"]({
              value: "/" + name2 + "/",
              source: getSource(this.currToken[_tokenize.FIELDS.START_LINE], this.currToken[_tokenize.FIELDS.START_COL], this.tokens[this.position + 2][_tokenize.FIELDS.END_LINE], this.tokens[this.position + 2][_tokenize.FIELDS.END_COL]),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS],
              raws
            });
            this.position = this.position + 3;
            return node3;
          } else {
            this.unexpected();
          }
        };
        _proto.combinator = function combinator3() {
          var _this3 = this;
          if (this.content() === "|") {
            return this.namespace();
          }
          var nextSigTokenPos = this.locateNextMeaningfulToken(this.position);
          if (nextSigTokenPos < 0 || this.tokens[nextSigTokenPos][_tokenize.FIELDS.TYPE] === tokens.comma) {
            var nodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
            if (nodes.length > 0) {
              var last = this.current.last;
              if (last) {
                var _this$convertWhitespa = this.convertWhitespaceNodesToSpace(nodes), space2 = _this$convertWhitespa.space, rawSpace = _this$convertWhitespa.rawSpace;
                if (rawSpace !== void 0) {
                  last.rawSpaceAfter += rawSpace;
                }
                last.spaces.after += space2;
              } else {
                nodes.forEach(function(n) {
                  return _this3.newNode(n);
                });
              }
            }
            return;
          }
          var firstToken = this.currToken;
          var spaceOrDescendantSelectorNodes = void 0;
          if (nextSigTokenPos > this.position) {
            spaceOrDescendantSelectorNodes = this.parseWhitespaceEquivalentTokens(nextSigTokenPos);
          }
          var node3;
          if (this.isNamedCombinator()) {
            node3 = this.namedCombinator();
          } else if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.combinator) {
            node3 = new _combinator2["default"]({
              value: this.content(),
              source: getTokenSource(this.currToken),
              sourceIndex: this.currToken[_tokenize.FIELDS.START_POS]
            });
            this.position++;
          } else if (WHITESPACE_TOKENS[this.currToken[_tokenize.FIELDS.TYPE]]) ;
          else if (!spaceOrDescendantSelectorNodes) {
            this.unexpected();
          }
          if (node3) {
            if (spaceOrDescendantSelectorNodes) {
              var _this$convertWhitespa2 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes), _space = _this$convertWhitespa2.space, _rawSpace = _this$convertWhitespa2.rawSpace;
              node3.spaces.before = _space;
              node3.rawSpaceBefore = _rawSpace;
            }
          } else {
            var _this$convertWhitespa3 = this.convertWhitespaceNodesToSpace(spaceOrDescendantSelectorNodes, true), _space2 = _this$convertWhitespa3.space, _rawSpace2 = _this$convertWhitespa3.rawSpace;
            if (!_rawSpace2) {
              _rawSpace2 = _space2;
            }
            var spaces = {};
            var raws = {
              spaces: {}
            };
            if (_space2.endsWith(" ") && _rawSpace2.endsWith(" ")) {
              spaces.before = _space2.slice(0, _space2.length - 1);
              raws.spaces.before = _rawSpace2.slice(0, _rawSpace2.length - 1);
            } else if (_space2.startsWith(" ") && _rawSpace2.startsWith(" ")) {
              spaces.after = _space2.slice(1);
              raws.spaces.after = _rawSpace2.slice(1);
            } else {
              raws.value = _rawSpace2;
            }
            node3 = new _combinator2["default"]({
              value: " ",
              source: getTokenSourceSpan(firstToken, this.tokens[this.position - 1]),
              sourceIndex: firstToken[_tokenize.FIELDS.START_POS],
              spaces,
              raws
            });
          }
          if (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.space) {
            node3.spaces.after = this.optionalSpace(this.content());
            this.position++;
          }
          return this.newNode(node3);
        };
        _proto.comma = function comma5() {
          if (this.position === this.tokens.length - 1) {
            this.root.trailingComma = true;
            this.position++;
            return;
          }
          this.current._inferEndPosition();
          var selector3 = new _selector2["default"]({
            source: {
              start: tokenStart(this.tokens[this.position + 1])
            },
            sourceIndex: this.tokens[this.position + 1][_tokenize.FIELDS.START_POS]
          });
          this.current.parent.append(selector3);
          this.current = selector3;
          this.position++;
        };
        _proto.comment = function comment4() {
          var current = this.currToken;
          this.newNode(new _comment2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.error = function error(message, opts) {
          throw this.root.error(message, opts);
        };
        _proto.missingBackslash = function missingBackslash() {
          return this.error("Expected a backslash preceding the semicolon.", {
            index: this.currToken[_tokenize.FIELDS.START_POS]
          });
        };
        _proto.missingParenthesis = function missingParenthesis() {
          return this.expected("opening parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.missingSquareBracket = function missingSquareBracket() {
          return this.expected("opening square bracket", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpected = function unexpected() {
          return this.error("Unexpected '" + this.content() + "'. Escaping special characters with \\ may help.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.unexpectedPipe = function unexpectedPipe() {
          return this.error("Unexpected '|'.", this.currToken[_tokenize.FIELDS.START_POS]);
        };
        _proto.namespace = function namespace2() {
          var before = this.prevToken && this.content(this.prevToken) || true;
          if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.position++;
            return this.word(before);
          } else if (this.nextToken[_tokenize.FIELDS.TYPE] === tokens.asterisk) {
            this.position++;
            return this.universal(before);
          }
          this.unexpectedPipe();
        };
        _proto.nesting = function nesting3() {
          if (this.nextToken) {
            var nextContent = this.content(this.nextToken);
            if (nextContent === "|") {
              this.position++;
              return;
            }
          }
          var current = this.currToken;
          this.newNode(new _nesting2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.parentheses = function parentheses() {
          var last = this.current.last;
          var unbalanced = 1;
          this.position++;
          if (last && last.type === types$12.PSEUDO) {
            var selector3 = new _selector2["default"]({
              source: {
                start: tokenStart(this.tokens[this.position])
              },
              sourceIndex: this.tokens[this.position][_tokenize.FIELDS.START_POS]
            });
            var cache2 = this.current;
            last.append(selector3);
            this.current = selector3;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              if (unbalanced) {
                this.parse();
              } else {
                this.current.source.end = tokenEnd(this.currToken);
                this.current.parent.source.end = tokenEnd(this.currToken);
                this.position++;
              }
            }
            this.current = cache2;
          } else {
            var parenStart = this.currToken;
            var parenValue = "(";
            var parenEnd;
            while (this.position < this.tokens.length && unbalanced) {
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                unbalanced++;
              }
              if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
                unbalanced--;
              }
              parenEnd = this.currToken;
              parenValue += this.parseParenthesisToken(this.currToken);
              this.position++;
            }
            if (last) {
              last.appendToPropertyAndEscape("value", parenValue, parenValue);
            } else {
              this.newNode(new _string2["default"]({
                value: parenValue,
                source: getSource(parenStart[_tokenize.FIELDS.START_LINE], parenStart[_tokenize.FIELDS.START_COL], parenEnd[_tokenize.FIELDS.END_LINE], parenEnd[_tokenize.FIELDS.END_COL]),
                sourceIndex: parenStart[_tokenize.FIELDS.START_POS]
              }));
            }
          }
          if (unbalanced) {
            return this.expected("closing parenthesis", this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.pseudo = function pseudo3() {
          var _this4 = this;
          var pseudoStr = "";
          var startingToken = this.currToken;
          while (this.currToken && this.currToken[_tokenize.FIELDS.TYPE] === tokens.colon) {
            pseudoStr += this.content();
            this.position++;
          }
          if (!this.currToken) {
            return this.expected(["pseudo-class", "pseudo-element"], this.position - 1);
          }
          if (this.currToken[_tokenize.FIELDS.TYPE] === tokens.word) {
            this.splitWord(false, function(first2, length) {
              pseudoStr += first2;
              _this4.newNode(new _pseudo2["default"]({
                value: pseudoStr,
                source: getTokenSourceSpan(startingToken, _this4.currToken),
                sourceIndex: startingToken[_tokenize.FIELDS.START_POS]
              }));
              if (length > 1 && _this4.nextToken && _this4.nextToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis) {
                _this4.error("Misplaced parenthesis.", {
                  index: _this4.nextToken[_tokenize.FIELDS.START_POS]
                });
              }
            });
          } else {
            return this.expected(["pseudo-class", "pseudo-element"], this.currToken[_tokenize.FIELDS.START_POS]);
          }
        };
        _proto.space = function space2() {
          var content = this.content();
          if (this.position === 0 || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.prevToken[_tokenize.FIELDS.TYPE] === tokens.openParenthesis || this.current.nodes.every(function(node3) {
            return node3.type === "comment";
          })) {
            this.spaces = this.optionalSpace(content);
            this.position++;
          } else if (this.position === this.tokens.length - 1 || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.comma || this.nextToken[_tokenize.FIELDS.TYPE] === tokens.closeParenthesis) {
            this.current.last.spaces.after = this.optionalSpace(content);
            this.position++;
          } else {
            this.combinator();
          }
        };
        _proto.string = function string4() {
          var current = this.currToken;
          this.newNode(new _string2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }));
          this.position++;
        };
        _proto.universal = function universal3(namespace2) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          var current = this.currToken;
          this.newNode(new _universal2["default"]({
            value: this.content(),
            source: getTokenSource(current),
            sourceIndex: current[_tokenize.FIELDS.START_POS]
          }), namespace2);
          this.position++;
        };
        _proto.splitWord = function splitWord(namespace2, firstCallback) {
          var _this5 = this;
          var nextToken = this.nextToken;
          var word2 = this.content();
          while (nextToken && ~[tokens.dollar, tokens.caret, tokens.equals, tokens.word].indexOf(nextToken[_tokenize.FIELDS.TYPE])) {
            this.position++;
            var current = this.content();
            word2 += current;
            if (current.lastIndexOf("\\") === current.length - 1) {
              var next = this.nextToken;
              if (next && next[_tokenize.FIELDS.TYPE] === tokens.space) {
                word2 += this.requiredSpace(this.content(next));
                this.position++;
              }
            }
            nextToken = this.nextToken;
          }
          var hasClass = indexesOf(word2, ".").filter(function(i) {
            var escapedDot = word2[i - 1] === "\\";
            var isKeyframesPercent = /^\d+\.\d+%$/.test(word2);
            return !escapedDot && !isKeyframesPercent;
          });
          var hasId = indexesOf(word2, "#").filter(function(i) {
            return word2[i - 1] !== "\\";
          });
          var interpolations = indexesOf(word2, "#{");
          if (interpolations.length) {
            hasId = hasId.filter(function(hashIndex) {
              return !~interpolations.indexOf(hashIndex);
            });
          }
          var indices = (0, _sortAscending["default"])(uniqs([0].concat(hasClass, hasId)));
          indices.forEach(function(ind, i) {
            var index4 = indices[i + 1] || word2.length;
            var value2 = word2.slice(ind, index4);
            if (i === 0 && firstCallback) {
              return firstCallback.call(_this5, value2, indices.length);
            }
            var node3;
            var current2 = _this5.currToken;
            var sourceIndex = current2[_tokenize.FIELDS.START_POS] + indices[i];
            var source = getSource(current2[1], current2[2] + ind, current2[3], current2[2] + (index4 - 1));
            if (~hasClass.indexOf(ind)) {
              var classNameOpts = {
                value: value2.slice(1),
                source,
                sourceIndex
              };
              node3 = new _className2["default"](unescapeProp(classNameOpts, "value"));
            } else if (~hasId.indexOf(ind)) {
              var idOpts = {
                value: value2.slice(1),
                source,
                sourceIndex
              };
              node3 = new _id2["default"](unescapeProp(idOpts, "value"));
            } else {
              var tagOpts = {
                value: value2,
                source,
                sourceIndex
              };
              unescapeProp(tagOpts, "value");
              node3 = new _tag2["default"](tagOpts);
            }
            _this5.newNode(node3, namespace2);
            namespace2 = null;
          });
          this.position++;
        };
        _proto.word = function word2(namespace2) {
          var nextToken = this.nextToken;
          if (nextToken && this.content(nextToken) === "|") {
            this.position++;
            return this.namespace();
          }
          return this.splitWord(namespace2);
        };
        _proto.loop = function loop() {
          while (this.position < this.tokens.length) {
            this.parse(true);
          }
          this.current._inferEndPosition();
          return this.root;
        };
        _proto.parse = function parse6(throwOnParenthesis) {
          switch (this.currToken[_tokenize.FIELDS.TYPE]) {
            case tokens.space:
              this.space();
              break;
            case tokens.comment:
              this.comment();
              break;
            case tokens.openParenthesis:
              this.parentheses();
              break;
            case tokens.closeParenthesis:
              if (throwOnParenthesis) {
                this.missingParenthesis();
              }
              break;
            case tokens.openSquare:
              this.attribute();
              break;
            case tokens.dollar:
            case tokens.caret:
            case tokens.equals:
            case tokens.word:
              this.word();
              break;
            case tokens.colon:
              this.pseudo();
              break;
            case tokens.comma:
              this.comma();
              break;
            case tokens.asterisk:
              this.universal();
              break;
            case tokens.ampersand:
              this.nesting();
              break;
            case tokens.slash:
            case tokens.combinator:
              this.combinator();
              break;
            case tokens.str:
              this.string();
              break;
            // These cases throw; no break needed.
            case tokens.closeSquare:
              this.missingSquareBracket();
            case tokens.semicolon:
              this.missingBackslash();
            default:
              this.unexpected();
          }
        };
        _proto.expected = function expected(description2, index4, found2) {
          if (Array.isArray(description2)) {
            var last = description2.pop();
            description2 = description2.join(", ") + " or " + last;
          }
          var an = /^[aeiou]/.test(description2[0]) ? "an" : "a";
          if (!found2) {
            return this.error("Expected " + an + " " + description2 + ".", {
              index: index4
            });
          }
          return this.error("Expected " + an + " " + description2 + ', found "' + found2 + '" instead.', {
            index: index4
          });
        };
        _proto.requiredSpace = function requiredSpace(space2) {
          return this.options.lossy ? " " : space2;
        };
        _proto.optionalSpace = function optionalSpace(space2) {
          return this.options.lossy ? "" : space2;
        };
        _proto.lossySpace = function lossySpace(space2, required2) {
          if (this.options.lossy) {
            return required2 ? " " : "";
          } else {
            return space2;
          }
        };
        _proto.parseParenthesisToken = function parseParenthesisToken(token) {
          var content = this.content(token);
          if (token[_tokenize.FIELDS.TYPE] === tokens.space) {
            return this.requiredSpace(content);
          } else {
            return content;
          }
        };
        _proto.newNode = function newNode(node3, namespace2) {
          if (namespace2) {
            if (/^ +$/.test(namespace2)) {
              if (!this.options.lossy) {
                this.spaces = (this.spaces || "") + namespace2;
              }
              namespace2 = true;
            }
            node3.namespace = namespace2;
            unescapeProp(node3, "namespace");
          }
          if (this.spaces) {
            node3.spaces.before = this.spaces;
            this.spaces = "";
          }
          return this.current.append(node3);
        };
        _proto.content = function content(token) {
          if (token === void 0) {
            token = this.currToken;
          }
          return this.css.slice(token[_tokenize.FIELDS.START_POS], token[_tokenize.FIELDS.END_POS]);
        };
        _proto.locateNextMeaningfulToken = function locateNextMeaningfulToken(startPosition) {
          if (startPosition === void 0) {
            startPosition = this.position + 1;
          }
          var searchPosition = startPosition;
          while (searchPosition < this.tokens.length) {
            if (WHITESPACE_EQUIV_TOKENS[this.tokens[searchPosition][_tokenize.FIELDS.TYPE]]) {
              searchPosition++;
              continue;
            } else {
              return searchPosition;
            }
          }
          return -1;
        };
        _createClass(Parser4, [{
          key: "currToken",
          get: function get() {
            return this.tokens[this.position];
          }
        }, {
          key: "nextToken",
          get: function get() {
            return this.tokens[this.position + 1];
          }
        }, {
          key: "prevToken",
          get: function get() {
            return this.tokens[this.position - 1];
          }
        }]);
        return Parser4;
      }();
      exports2["default"] = Parser3;
      module.exports = exports2.default;
    })(parser, parser.exports);
    parserExports = parser.exports;
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _parser = _interopRequireDefault2(parserExports);
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var Processor3 = /* @__PURE__ */ function() {
        function Processor4(func, options2) {
          this.func = func || function noop2() {
          };
          this.funcRes = null;
          this.options = options2;
        }
        var _proto = Processor4.prototype;
        _proto._shouldUpdateSelector = function _shouldUpdateSelector(rule2, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var merged = Object.assign({}, this.options, options2);
          if (merged.updateSelector === false) {
            return false;
          } else {
            return typeof rule2 !== "string";
          }
        };
        _proto._isLossy = function _isLossy(options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var merged = Object.assign({}, this.options, options2);
          if (merged.lossless === false) {
            return true;
          } else {
            return false;
          }
        };
        _proto._root = function _root2(rule2, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var parser2 = new _parser["default"](rule2, this._parseOptions(options2));
          return parser2.root;
        };
        _proto._parseOptions = function _parseOptions(options2) {
          return {
            lossy: this._isLossy(options2)
          };
        };
        _proto._run = function _run(rule2, options2) {
          var _this = this;
          if (options2 === void 0) {
            options2 = {};
          }
          return new Promise(function(resolve8, reject) {
            try {
              var root4 = _this._root(rule2, options2);
              Promise.resolve(_this.func(root4)).then(function(transform3) {
                var string4 = void 0;
                if (_this._shouldUpdateSelector(rule2, options2)) {
                  string4 = root4.toString();
                  rule2.selector = string4;
                }
                return {
                  transform: transform3,
                  root: root4,
                  string: string4
                };
              }).then(resolve8, reject);
            } catch (e) {
              reject(e);
              return;
            }
          });
        };
        _proto._runSync = function _runSync(rule2, options2) {
          if (options2 === void 0) {
            options2 = {};
          }
          var root4 = this._root(rule2, options2);
          var transform3 = this.func(root4);
          if (transform3 && typeof transform3.then === "function") {
            throw new Error("Selector processor returned a promise to a synchronous call.");
          }
          var string4 = void 0;
          if (options2.updateSelector && typeof rule2 !== "string") {
            string4 = root4.toString();
            rule2.selector = string4;
          }
          return {
            transform: transform3,
            root: root4,
            string: string4
          };
        };
        _proto.ast = function ast(rule2, options2) {
          return this._run(rule2, options2).then(function(result) {
            return result.root;
          });
        };
        _proto.astSync = function astSync(rule2, options2) {
          return this._runSync(rule2, options2).root;
        };
        _proto.transform = function transform3(rule2, options2) {
          return this._run(rule2, options2).then(function(result) {
            return result.transform;
          });
        };
        _proto.transformSync = function transformSync(rule2, options2) {
          return this._runSync(rule2, options2).transform;
        };
        _proto.process = function process2(rule2, options2) {
          return this._run(rule2, options2).then(function(result) {
            return result.string || result.root.toString();
          });
        };
        _proto.processSync = function processSync(rule2, options2) {
          var result = this._runSync(rule2, options2);
          return result.string || result.root.toString();
        };
        return Processor4;
      }();
      exports2["default"] = Processor3;
      module.exports = exports2.default;
    })(processor, processor.exports);
    processorExports = processor.exports;
    selectors = {};
    constructors = {};
    constructors.__esModule = true;
    constructors.universal = constructors.tag = constructors.string = constructors.selector = constructors.root = constructors.pseudo = constructors.nesting = constructors.id = constructors.comment = constructors.combinator = constructors.className = constructors.attribute = void 0;
    _attribute = _interopRequireDefault$2(attribute$1);
    _className = _interopRequireDefault$2(classNameExports);
    _combinator = _interopRequireDefault$2(combinatorExports);
    _comment = _interopRequireDefault$2(commentExports);
    _id = _interopRequireDefault$2(idExports);
    _nesting = _interopRequireDefault$2(nestingExports);
    _pseudo = _interopRequireDefault$2(pseudoExports);
    _root = _interopRequireDefault$2(rootExports);
    _selector = _interopRequireDefault$2(selectorExports);
    _string = _interopRequireDefault$2(stringExports);
    _tag = _interopRequireDefault$2(tagExports);
    _universal = _interopRequireDefault$2(universalExports);
    attribute = function attribute2(opts) {
      return new _attribute["default"](opts);
    };
    constructors.attribute = attribute;
    className = function className2(opts) {
      return new _className["default"](opts);
    };
    constructors.className = className;
    combinator = function combinator2(opts) {
      return new _combinator["default"](opts);
    };
    constructors.combinator = combinator;
    comment2 = function comment3(opts) {
      return new _comment["default"](opts);
    };
    constructors.comment = comment2;
    id = function id2(opts) {
      return new _id["default"](opts);
    };
    constructors.id = id;
    nesting = function nesting2(opts) {
      return new _nesting["default"](opts);
    };
    constructors.nesting = nesting;
    pseudo = function pseudo2(opts) {
      return new _pseudo["default"](opts);
    };
    constructors.pseudo = pseudo;
    root2 = function root3(opts) {
      return new _root["default"](opts);
    };
    constructors.root = root2;
    selector = function selector2(opts) {
      return new _selector["default"](opts);
    };
    constructors.selector = selector;
    string = function string2(opts) {
      return new _string["default"](opts);
    };
    constructors.string = string;
    tag = function tag2(opts) {
      return new _tag["default"](opts);
    };
    constructors.tag = tag;
    universal = function universal2(opts) {
      return new _universal["default"](opts);
    };
    constructors.universal = universal;
    guards = {};
    guards.__esModule = true;
    guards.isComment = guards.isCombinator = guards.isClassName = guards.isAttribute = void 0;
    guards.isContainer = isContainer;
    guards.isIdentifier = void 0;
    guards.isNamespace = isNamespace;
    guards.isNesting = void 0;
    guards.isNode = isNode;
    guards.isPseudo = void 0;
    guards.isPseudoClass = isPseudoClass;
    guards.isPseudoElement = isPseudoElement;
    guards.isUniversal = guards.isTag = guards.isString = guards.isSelector = guards.isRoot = void 0;
    _types = types;
    IS_TYPE = (_IS_TYPE = {}, _IS_TYPE[_types.ATTRIBUTE] = true, _IS_TYPE[_types.CLASS] = true, _IS_TYPE[_types.COMBINATOR] = true, _IS_TYPE[_types.COMMENT] = true, _IS_TYPE[_types.ID] = true, _IS_TYPE[_types.NESTING] = true, _IS_TYPE[_types.PSEUDO] = true, _IS_TYPE[_types.ROOT] = true, _IS_TYPE[_types.SELECTOR] = true, _IS_TYPE[_types.STRING] = true, _IS_TYPE[_types.TAG] = true, _IS_TYPE[_types.UNIVERSAL] = true, _IS_TYPE);
    isAttribute = isNodeType.bind(null, _types.ATTRIBUTE);
    guards.isAttribute = isAttribute;
    isClassName = isNodeType.bind(null, _types.CLASS);
    guards.isClassName = isClassName;
    isCombinator = isNodeType.bind(null, _types.COMBINATOR);
    guards.isCombinator = isCombinator;
    isComment = isNodeType.bind(null, _types.COMMENT);
    guards.isComment = isComment;
    isIdentifier = isNodeType.bind(null, _types.ID);
    guards.isIdentifier = isIdentifier;
    isNesting = isNodeType.bind(null, _types.NESTING);
    guards.isNesting = isNesting;
    isPseudo = isNodeType.bind(null, _types.PSEUDO);
    guards.isPseudo = isPseudo;
    isRoot = isNodeType.bind(null, _types.ROOT);
    guards.isRoot = isRoot;
    isSelector = isNodeType.bind(null, _types.SELECTOR);
    guards.isSelector = isSelector;
    isString = isNodeType.bind(null, _types.STRING);
    guards.isString = isString;
    isTag = isNodeType.bind(null, _types.TAG);
    guards.isTag = isTag;
    isUniversal = isNodeType.bind(null, _types.UNIVERSAL);
    guards.isUniversal = isUniversal;
    (function(exports2) {
      exports2.__esModule = true;
      var _types2 = types;
      Object.keys(_types2).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports2 && exports2[key] === _types2[key]) return;
        exports2[key] = _types2[key];
      });
      var _constructors = constructors;
      Object.keys(_constructors).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports2 && exports2[key] === _constructors[key]) return;
        exports2[key] = _constructors[key];
      });
      var _guards = guards;
      Object.keys(_guards).forEach(function(key) {
        if (key === "default" || key === "__esModule") return;
        if (key in exports2 && exports2[key] === _guards[key]) return;
        exports2[key] = _guards[key];
      });
    })(selectors);
    (function(module, exports2) {
      exports2.__esModule = true;
      exports2["default"] = void 0;
      var _processor = _interopRequireDefault2(processorExports);
      var selectors$1 = _interopRequireWildcard(selectors);
      function _getRequireWildcardCache(nodeInterop) {
        if (typeof WeakMap !== "function") return null;
        var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
        var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
        return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
          return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
        })(nodeInterop);
      }
      function _interopRequireWildcard(obj, nodeInterop) {
        if (obj && obj.__esModule) {
          return obj;
        }
        if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
          return { "default": obj };
        }
        var cache2 = _getRequireWildcardCache(nodeInterop);
        if (cache2 && cache2.has(obj)) {
          return cache2.get(obj);
        }
        var newObj = {};
        var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
        for (var key in obj) {
          if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
              Object.defineProperty(newObj, key, desc);
            } else {
              newObj[key] = obj[key];
            }
          }
        }
        newObj["default"] = obj;
        if (cache2) {
          cache2.set(obj, newObj);
        }
        return newObj;
      }
      function _interopRequireDefault2(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var parser2 = function parser3(processor2) {
        return new _processor["default"](processor2);
      };
      Object.assign(parser2, selectors$1);
      delete parser2.__esModule;
      var _default = parser2;
      exports2["default"] = _default;
      module.exports = exports2.default;
    })(dist, dist.exports);
    distExports = dist.exports;
    selectorParser$1 = distExports;
    valueParser2 = lib;
    ({ extractICSS } = src$4);
    isSpacing = (node3) => node3.type === "combinator" && node3.value === " ";
    specialKeywords = [
      "none",
      "inherit",
      "initial",
      "revert",
      "revert-layer",
      "unset"
    ];
    src$2.exports = (options2 = {}) => {
      if (options2 && options2.mode && options2.mode !== "global" && options2.mode !== "local" && options2.mode !== "pure") {
        throw new Error(
          'options.mode must be either "global", "local" or "pure" (default "local")'
        );
      }
      const pureMode = options2 && options2.mode === "pure";
      const globalMode = options2 && options2.mode === "global";
      return {
        postcssPlugin: "postcss-modules-local-by-default",
        prepare() {
          const localAliasMap = /* @__PURE__ */ new Map();
          return {
            Once(root4) {
              const { icssImports } = extractICSS(root4, false);
              Object.keys(icssImports).forEach((key) => {
                Object.keys(icssImports[key]).forEach((prop) => {
                  localAliasMap.set(prop, icssImports[key][prop]);
                });
              });
              root4.walkAtRules((atRule2) => {
                if (/keyframes$/i.test(atRule2.name)) {
                  const globalMatch = /^\s*:global\s*\((.+)\)\s*$/.exec(
                    atRule2.params
                  );
                  const localMatch = /^\s*:local\s*\((.+)\)\s*$/.exec(
                    atRule2.params
                  );
                  let globalKeyframes = globalMode;
                  if (globalMatch) {
                    if (pureMode) {
                      throw atRule2.error(
                        "@keyframes :global(...) is not allowed in pure mode"
                      );
                    }
                    atRule2.params = globalMatch[1];
                    globalKeyframes = true;
                  } else if (localMatch) {
                    atRule2.params = localMatch[0];
                    globalKeyframes = false;
                  } else if (atRule2.params && !globalMode && !localAliasMap.has(atRule2.params)) {
                    atRule2.params = ":local(" + atRule2.params + ")";
                  }
                  atRule2.walkDecls((declaration) => {
                    localizeDeclaration(declaration, {
                      localAliasMap,
                      options: options2,
                      global: globalKeyframes
                    });
                  });
                } else if (/scope$/i.test(atRule2.name)) {
                  if (atRule2.params) {
                    atRule2.params = atRule2.params.split("to").map((item) => {
                      const selector3 = item.trim().slice(1, -1).trim();
                      const context = localizeNode(
                        selector3,
                        options2.mode,
                        localAliasMap
                      );
                      context.options = options2;
                      context.localAliasMap = localAliasMap;
                      if (pureMode && context.hasPureGlobals) {
                        throw atRule2.error(
                          'Selector in at-rule"' + selector3 + '" is not pure (pure selectors must contain at least one local class or id)'
                        );
                      }
                      return `(${context.selector})`;
                    }).join(" to ");
                  }
                  atRule2.nodes.forEach((declaration) => {
                    if (declaration.type === "decl") {
                      localizeDeclaration(declaration, {
                        localAliasMap,
                        options: options2,
                        global: globalMode
                      });
                    }
                  });
                } else if (atRule2.nodes) {
                  atRule2.nodes.forEach((declaration) => {
                    if (declaration.type === "decl") {
                      localizeDeclaration(declaration, {
                        localAliasMap,
                        options: options2,
                        global: globalMode
                      });
                    }
                  });
                }
              });
              root4.walkRules((rule2) => {
                if (rule2.parent && rule2.parent.type === "atrule" && /keyframes$/i.test(rule2.parent.name)) {
                  return;
                }
                const context = localizeNode(rule2, options2.mode, localAliasMap);
                context.options = options2;
                context.localAliasMap = localAliasMap;
                if (pureMode && context.hasPureGlobals) {
                  throw rule2.error(
                    'Selector "' + rule2.selector + '" is not pure (pure selectors must contain at least one local class or id)'
                  );
                }
                rule2.selector = context.selector;
                if (rule2.nodes) {
                  rule2.nodes.forEach(
                    (declaration) => localizeDeclaration(declaration, context)
                  );
                }
              });
            }
          };
        }
      };
    };
    src$2.exports.postcss = true;
    srcExports$1 = src$2.exports;
    selectorParser = distExports;
    hasOwnProperty2 = Object.prototype.hasOwnProperty;
    whitespace = "[\\x20\\t\\r\\n\\f]";
    unescapeRegExp = new RegExp(
      "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)",
      "ig"
    );
    plugin2 = (options2 = {}) => {
      const generateScopedName = options2 && options2.generateScopedName || plugin2.generateScopedName;
      const generateExportEntry = options2 && options2.generateExportEntry || plugin2.generateExportEntry;
      const exportGlobals = options2 && options2.exportGlobals;
      return {
        postcssPlugin: "postcss-modules-scope",
        Once(root4, { rule: rule2 }) {
          const exports2 = /* @__PURE__ */ Object.create(null);
          function exportScopedName(name2, rawName, node3) {
            const scopedName = generateScopedName(
              rawName ? rawName : name2,
              root4.source.input.from,
              root4.source.input.css,
              node3
            );
            const exportEntry = generateExportEntry(
              rawName ? rawName : name2,
              scopedName,
              root4.source.input.from,
              root4.source.input.css,
              node3
            );
            const { key, value: value2 } = exportEntry;
            exports2[key] = exports2[key] || [];
            if (exports2[key].indexOf(value2) < 0) {
              exports2[key].push(value2);
            }
            return scopedName;
          }
          function localizeNode2(node3) {
            switch (node3.type) {
              case "selector":
                node3.nodes = node3.map((item) => localizeNode2(item));
                return node3;
              case "class":
                return selectorParser.className({
                  value: exportScopedName(
                    node3.value,
                    node3.raws && node3.raws.value ? node3.raws.value : null,
                    node3
                  )
                });
              case "id": {
                return selectorParser.id({
                  value: exportScopedName(
                    node3.value,
                    node3.raws && node3.raws.value ? node3.raws.value : null,
                    node3
                  )
                });
              }
              case "attribute": {
                if (node3.attribute === "class" && node3.operator === "=") {
                  return selectorParser.attribute({
                    attribute: node3.attribute,
                    operator: node3.operator,
                    quoteMark: "'",
                    value: exportScopedName(node3.value, null, null)
                  });
                }
              }
            }
            throw new Error(
              `${node3.type} ("${node3}") is not allowed in a :local block`
            );
          }
          function traverseNode(node3) {
            switch (node3.type) {
              case "pseudo":
                if (node3.value === ":local") {
                  if (node3.nodes.length !== 1) {
                    throw new Error('Unexpected comma (",") in :local block');
                  }
                  const selector3 = localizeNode2(node3.first);
                  selector3.first.spaces = node3.spaces;
                  const nextNode = node3.next();
                  if (nextNode && nextNode.type === "combinator" && nextNode.value === " " && /\\[A-F0-9]{1,6}$/.test(selector3.last.value)) {
                    selector3.last.spaces.after = " ";
                  }
                  node3.replaceWith(selector3);
                  return;
                }
              /* falls through */
              case "root":
              case "selector": {
                node3.each((item) => traverseNode(item));
                break;
              }
              case "id":
              case "class":
                if (exportGlobals) {
                  exports2[node3.value] = [node3.value];
                }
                break;
            }
            return node3;
          }
          const importedNames = {};
          root4.walkRules(/^:import\(.+\)$/, (rule3) => {
            rule3.walkDecls((decl2) => {
              importedNames[decl2.prop] = true;
            });
          });
          root4.walkRules((rule3) => {
            let parsedSelector = selectorParser().astSync(rule3);
            rule3.selector = traverseNode(parsedSelector.clone()).toString();
            rule3.walkDecls(/^(composes|compose-with)$/i, (decl2) => {
              const localNames = getSingleLocalNamesForComposes(
                parsedSelector,
                decl2.parent
              );
              const multiple = decl2.value.split(",");
              multiple.forEach((value2) => {
                const classes = value2.trim().split(/\s+/);
                classes.forEach((className3) => {
                  const global2 = /^global\(([^)]+)\)$/.exec(className3);
                  if (global2) {
                    localNames.forEach((exportedName) => {
                      exports2[exportedName].push(global2[1]);
                    });
                  } else if (hasOwnProperty2.call(importedNames, className3)) {
                    localNames.forEach((exportedName) => {
                      exports2[exportedName].push(className3);
                    });
                  } else if (hasOwnProperty2.call(exports2, className3)) {
                    localNames.forEach((exportedName) => {
                      exports2[className3].forEach((item) => {
                        exports2[exportedName].push(item);
                      });
                    });
                  } else {
                    throw decl2.error(
                      `referenced class name "${className3}" in ${decl2.prop} not found`
                    );
                  }
                });
              });
              decl2.remove();
            });
            rule3.walkDecls((decl2) => {
              if (!/:local\s*\((.+?)\)/.test(decl2.value)) {
                return;
              }
              let tokens = decl2.value.split(/(,|'[^']*'|"[^"]*")/);
              tokens = tokens.map((token, idx) => {
                if (idx === 0 || tokens[idx - 1] === ",") {
                  let result = token;
                  const localMatch = /:local\s*\((.+?)\)/.exec(token);
                  if (localMatch) {
                    const input = localMatch.input;
                    const matchPattern = localMatch[0];
                    const matchVal = localMatch[1];
                    const newVal = exportScopedName(matchVal);
                    result = input.replace(matchPattern, newVal);
                  } else {
                    return token;
                  }
                  return result;
                } else {
                  return token;
                }
              });
              decl2.value = tokens.join("");
            });
          });
          root4.walkAtRules(/keyframes$/i, (atRule2) => {
            const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(atRule2.params);
            if (!localMatch) {
              return;
            }
            atRule2.params = exportScopedName(localMatch[1]);
          });
          root4.walkAtRules(/scope$/i, (atRule2) => {
            if (atRule2.params) {
              atRule2.params = atRule2.params.split("to").map((item) => {
                const selector3 = item.trim().slice(1, -1).trim();
                const localMatch = /^\s*:local\s*\((.+?)\)\s*$/.exec(selector3);
                if (!localMatch) {
                  return `(${selector3})`;
                }
                let parsedSelector = selectorParser().astSync(selector3);
                return `(${traverseNode(parsedSelector).toString()})`;
              }).join(" to ");
            }
          });
          const exportedNames = Object.keys(exports2);
          if (exportedNames.length > 0) {
            const exportRule = rule2({ selector: ":export" });
            exportedNames.forEach(
              (exportedName) => exportRule.append({
                prop: exportedName,
                value: exports2[exportedName].join(" "),
                raws: { before: "\n  " }
              })
            );
            root4.append(exportRule);
          }
        }
      };
    };
    plugin2.postcss = true;
    plugin2.generateScopedName = function(name2, path9) {
      const sanitisedPath = path9.replace(/\.[^./\\]+$/, "").replace(/[\W_]+/g, "_").replace(/^_|_$/g, "");
      return `_${sanitisedPath}__${name2}`.trim();
    };
    plugin2.generateExportEntry = function(name2, scopedName) {
      return {
        key: unescape2(name2),
        value: unescape2(scopedName)
      };
    };
    src$1 = plugin2;
    stringHash = hash;
    src = { exports: {} };
    ICSSUtils = src$4;
    matchImports = /^(.+?|\([\s\S]+?\))\s+from\s+("[^"]*"|'[^']*'|[\w-]+)$/;
    matchValueDefinition = /(?:\s+|^)([\w-]+):?(.*?)$/;
    matchImport = /^([\w-]+)(?:\s+as\s+([\w-]+))?/;
    src.exports = (options2) => {
      let importIndex = 0;
      const createImportedName = options2 && options2.createImportedName || ((importName) => `i__const_${importName.replace(/\W/g, "_")}_${importIndex++}`);
      return {
        postcssPlugin: "postcss-modules-values",
        prepare(result) {
          const importAliases = [];
          const definitions = {};
          return {
            Once(root4, postcss3) {
              root4.walkAtRules(/value/i, (atRule2) => {
                const matches = atRule2.params.match(matchImports);
                if (matches) {
                  let [
                    ,
                    /*match*/
                    aliases,
                    path9
                  ] = matches;
                  if (definitions[path9]) {
                    path9 = definitions[path9];
                  }
                  const imports = aliases.replace(/^\(\s*([\s\S]+)\s*\)$/, "$1").split(/\s*,\s*/).map((alias) => {
                    const tokens = matchImport.exec(alias);
                    if (tokens) {
                      const [
                        ,
                        /*match*/
                        theirName,
                        myName = theirName
                      ] = tokens;
                      const importedName = createImportedName(myName);
                      definitions[myName] = importedName;
                      return { theirName, importedName };
                    } else {
                      throw new Error(`@import statement "${alias}" is invalid!`);
                    }
                  });
                  importAliases.push({ path: path9, imports });
                  atRule2.remove();
                  return;
                }
                if (atRule2.params.indexOf("@value") !== -1) {
                  result.warn("Invalid value definition: " + atRule2.params);
                }
                let [, key, value2] = `${atRule2.params}${atRule2.raws.between}`.match(
                  matchValueDefinition
                );
                const normalizedValue = value2.replace(/\/\*((?!\*\/).*?)\*\//g, "");
                if (normalizedValue.length === 0) {
                  result.warn("Invalid value definition: " + atRule2.params);
                  atRule2.remove();
                  return;
                }
                let isOnlySpace = /^\s+$/.test(normalizedValue);
                if (!isOnlySpace) {
                  value2 = value2.trim();
                }
                definitions[key] = ICSSUtils.replaceValueSymbols(
                  value2,
                  definitions
                );
                atRule2.remove();
              });
              if (!Object.keys(definitions).length) {
                return;
              }
              ICSSUtils.replaceSymbols(root4, definitions);
              const exportDeclarations = Object.keys(definitions).map(
                (key) => postcss3.decl({
                  value: definitions[key],
                  prop: key,
                  raws: { before: "\n  " }
                })
              );
              if (exportDeclarations.length > 0) {
                const exportRule = postcss3.rule({
                  selector: ":export",
                  raws: { after: "\n" }
                });
                exportRule.append(exportDeclarations);
                root4.prepend(exportRule);
              }
              importAliases.reverse().forEach(({ path: path9, imports }) => {
                const importRule = postcss3.rule({
                  selector: `:import(${path9})`,
                  raws: { after: "\n" }
                });
                imports.forEach(({ theirName, importedName }) => {
                  importRule.append({
                    value: theirName,
                    prop: importedName,
                    raws: { before: "\n  " }
                  });
                });
                root4.prepend(importRule);
              });
            }
          };
        }
      };
    };
    src.exports.postcss = true;
    srcExports = src.exports;
    Object.defineProperty(scoping, "__esModule", {
      value: true
    });
    scoping.behaviours = void 0;
    scoping.getDefaultPlugins = getDefaultPlugins;
    scoping.getDefaultScopeBehaviour = getDefaultScopeBehaviour;
    scoping.getScopedNameGenerator = getScopedNameGenerator;
    _postcssModulesExtractImports = _interopRequireDefault$1(srcExports$2);
    _genericNames = _interopRequireDefault$1(genericNames);
    _postcssModulesLocalByDefault = _interopRequireDefault$1(srcExports$1);
    _postcssModulesScope = _interopRequireDefault$1(src$1);
    _stringHash = _interopRequireDefault$1(stringHash);
    _postcssModulesValues = _interopRequireDefault$1(srcExports);
    behaviours = {
      LOCAL: "local",
      GLOBAL: "global"
    };
    scoping.behaviours = behaviours;
    Object.defineProperty(pluginFactory, "__esModule", {
      value: true
    });
    pluginFactory.makePlugin = makePlugin;
    _postcss = _interopRequireDefault(postcss_default);
    _unquote = _interopRequireDefault(unquote$1);
    _Parser = _interopRequireDefault(Parser$1);
    _saveJSON = _interopRequireDefault(saveJSON$1);
    _localsConvention = localsConvention;
    _FileSystemLoader = _interopRequireDefault(FileSystemLoader$1);
    _scoping = scoping;
    PLUGIN_NAME = "postcss-modules";
    _fs = require$$0__default2;
    _fs2 = fs2;
    _pluginFactory = pluginFactory;
    (0, _fs2.setFileSystem)({
      readFile: _fs.readFile,
      writeFile: _fs.writeFile
    });
    build.exports = (opts = {}) => (0, _pluginFactory.makePlugin)(opts);
    postcss2 = build.exports.postcss = true;
    buildExports = build.exports;
    index2 = /* @__PURE__ */ getDefaultExportFromCjs(buildExports);
    index$12 = /* @__PURE__ */ _mergeNamespaces2({
      __proto__: null,
      default: index2,
      postcss: postcss2
    }, [buildExports]);
  }
});

// require("../lightningcss.*.node") in node_modules/lightningcss/node/index.js
var globRequire_lightningcss_node;
var init_ = __esm({
  'require("../lightningcss.*.node") in node_modules/lightningcss/node/index.js'() {
    globRequire_lightningcss_node = __glob({});
  }
});

// node_modules/detect-libc/lib/process.js
var require_process = __commonJS({
  "node_modules/detect-libc/lib/process.js"(exports2, module) {
    "use strict";
    var isLinux2 = () => process.platform === "linux";
    var report = null;
    var getReport = () => {
      if (!report) {
        if (isLinux2() && process.report) {
          const orig = process.report.excludeNetwork;
          process.report.excludeNetwork = true;
          report = process.report.getReport();
          process.report.excludeNetwork = orig;
        } else {
          report = {};
        }
      }
      return report;
    };
    module.exports = { isLinux: isLinux2, getReport };
  }
});

// node_modules/detect-libc/lib/filesystem.js
var require_filesystem = __commonJS({
  "node_modules/detect-libc/lib/filesystem.js"(exports2, module) {
    "use strict";
    var fs6 = __require("fs");
    var LDD_PATH = "/usr/bin/ldd";
    var readFileSync4 = (path9) => fs6.readFileSync(path9, "utf-8");
    var readFile2 = (path9) => new Promise((resolve8, reject) => {
      fs6.readFile(path9, "utf-8", (err, data) => {
        if (err) {
          reject(err);
        } else {
          resolve8(data);
        }
      });
    });
    module.exports = {
      LDD_PATH,
      readFileSync: readFileSync4,
      readFile: readFile2
    };
  }
});

// node_modules/detect-libc/lib/detect-libc.js
var require_detect_libc = __commonJS({
  "node_modules/detect-libc/lib/detect-libc.js"(exports2, module) {
    "use strict";
    var childProcess2 = __require("child_process");
    var { isLinux: isLinux2, getReport } = require_process();
    var { LDD_PATH, readFile: readFile2, readFileSync: readFileSync4 } = require_filesystem();
    var cachedFamilyFilesystem;
    var cachedVersionFilesystem;
    var command = "getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true";
    var commandOut = "";
    var safeCommand = () => {
      if (!commandOut) {
        return new Promise((resolve8) => {
          childProcess2.exec(command, (err, out) => {
            commandOut = err ? " " : out;
            resolve8(commandOut);
          });
        });
      }
      return commandOut;
    };
    var safeCommandSync = () => {
      if (!commandOut) {
        try {
          commandOut = childProcess2.execSync(command, { encoding: "utf8" });
        } catch (_err) {
          commandOut = " ";
        }
      }
      return commandOut;
    };
    var GLIBC = "glibc";
    var RE_GLIBC_VERSION = /LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i;
    var MUSL = "musl";
    var isFileMusl = (f) => f.includes("libc.musl-") || f.includes("ld-musl-");
    var familyFromReport = () => {
      const report = getReport();
      if (report.header && report.header.glibcVersionRuntime) {
        return GLIBC;
      }
      if (Array.isArray(report.sharedObjects)) {
        if (report.sharedObjects.some(isFileMusl)) {
          return MUSL;
        }
      }
      return null;
    };
    var familyFromCommand = (out) => {
      const [getconf, ldd1] = out.split(/[\r\n]+/);
      if (getconf && getconf.includes(GLIBC)) {
        return GLIBC;
      }
      if (ldd1 && ldd1.includes(MUSL)) {
        return MUSL;
      }
      return null;
    };
    var getFamilyFromLddContent = (content) => {
      if (content.includes("musl")) {
        return MUSL;
      }
      if (content.includes("GNU C Library")) {
        return GLIBC;
      }
      return null;
    };
    var familyFromFilesystem = async () => {
      if (cachedFamilyFilesystem !== void 0) {
        return cachedFamilyFilesystem;
      }
      cachedFamilyFilesystem = null;
      try {
        const lddContent = await readFile2(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
      } catch (e) {
      }
      return cachedFamilyFilesystem;
    };
    var familyFromFilesystemSync = () => {
      if (cachedFamilyFilesystem !== void 0) {
        return cachedFamilyFilesystem;
      }
      cachedFamilyFilesystem = null;
      try {
        const lddContent = readFileSync4(LDD_PATH);
        cachedFamilyFilesystem = getFamilyFromLddContent(lddContent);
      } catch (e) {
      }
      return cachedFamilyFilesystem;
    };
    var family = async () => {
      let family2 = null;
      if (isLinux2()) {
        family2 = await familyFromFilesystem();
        if (!family2) {
          family2 = familyFromReport();
        }
        if (!family2) {
          const out = await safeCommand();
          family2 = familyFromCommand(out);
        }
      }
      return family2;
    };
    var familySync = () => {
      let family2 = null;
      if (isLinux2()) {
        family2 = familyFromFilesystemSync();
        if (!family2) {
          family2 = familyFromReport();
        }
        if (!family2) {
          const out = safeCommandSync();
          family2 = familyFromCommand(out);
        }
      }
      return family2;
    };
    var isNonGlibcLinux = async () => isLinux2() && await family() !== GLIBC;
    var isNonGlibcLinuxSync = () => isLinux2() && familySync() !== GLIBC;
    var versionFromFilesystem = async () => {
      if (cachedVersionFilesystem !== void 0) {
        return cachedVersionFilesystem;
      }
      cachedVersionFilesystem = null;
      try {
        const lddContent = await readFile2(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
          cachedVersionFilesystem = versionMatch[1];
        }
      } catch (e) {
      }
      return cachedVersionFilesystem;
    };
    var versionFromFilesystemSync = () => {
      if (cachedVersionFilesystem !== void 0) {
        return cachedVersionFilesystem;
      }
      cachedVersionFilesystem = null;
      try {
        const lddContent = readFileSync4(LDD_PATH);
        const versionMatch = lddContent.match(RE_GLIBC_VERSION);
        if (versionMatch) {
          cachedVersionFilesystem = versionMatch[1];
        }
      } catch (e) {
      }
      return cachedVersionFilesystem;
    };
    var versionFromReport = () => {
      const report = getReport();
      if (report.header && report.header.glibcVersionRuntime) {
        return report.header.glibcVersionRuntime;
      }
      return null;
    };
    var versionSuffix = (s) => s.trim().split(/\s+/)[1];
    var versionFromCommand = (out) => {
      const [getconf, ldd1, ldd2] = out.split(/[\r\n]+/);
      if (getconf && getconf.includes(GLIBC)) {
        return versionSuffix(getconf);
      }
      if (ldd1 && ldd2 && ldd1.includes(MUSL)) {
        return versionSuffix(ldd2);
      }
      return null;
    };
    var version4 = async () => {
      let version5 = null;
      if (isLinux2()) {
        version5 = await versionFromFilesystem();
        if (!version5) {
          version5 = versionFromReport();
        }
        if (!version5) {
          const out = await safeCommand();
          version5 = versionFromCommand(out);
        }
      }
      return version5;
    };
    var versionSync = () => {
      let version5 = null;
      if (isLinux2()) {
        version5 = versionFromFilesystemSync();
        if (!version5) {
          version5 = versionFromReport();
        }
        if (!version5) {
          const out = safeCommandSync();
          version5 = versionFromCommand(out);
        }
      }
      return version5;
    };
    module.exports = {
      GLIBC,
      MUSL,
      family,
      familySync,
      isNonGlibcLinux,
      isNonGlibcLinuxSync,
      version: version4,
      versionSync
    };
  }
});

// node_modules/lightningcss/node/browserslistToTargets.js
var require_browserslistToTargets = __commonJS({
  "node_modules/lightningcss/node/browserslistToTargets.js"(exports2, module) {
    var BROWSER_MAPPING = {
      and_chr: "chrome",
      and_ff: "firefox",
      ie_mob: "ie",
      op_mob: "opera",
      and_qq: null,
      and_uc: null,
      baidu: null,
      bb: null,
      kaios: null,
      op_mini: null
    };
    function browserslistToTargets2(browserslist) {
      let targets = {};
      for (let browser2 of browserslist) {
        let [name2, v] = browser2.split(" ");
        if (BROWSER_MAPPING[name2] === null) {
          continue;
        }
        let version4 = parseVersion(v);
        if (version4 == null) {
          continue;
        }
        if (targets[name2] == null || version4 < targets[name2]) {
          targets[name2] = version4;
        }
      }
      return targets;
    }
    function parseVersion(version4) {
      let [major, minor = 0, patch = 0] = version4.split("-")[0].split(".").map((v) => parseInt(v, 10));
      if (isNaN(major) || isNaN(minor) || isNaN(patch)) {
        return null;
      }
      return major << 16 | minor << 8 | patch;
    }
    module.exports = browserslistToTargets2;
  }
});

// node_modules/lightningcss/node/composeVisitors.js
var require_composeVisitors = __commonJS({
  "node_modules/lightningcss/node/composeVisitors.js"(exports2, module) {
    function composeVisitors2(visitors) {
      if (visitors.length === 1) {
        return visitors[0];
      }
      let res = {};
      composeSimpleVisitors(res, visitors, "StyleSheet");
      composeSimpleVisitors(res, visitors, "StyleSheetExit");
      composeObjectVisitors(res, visitors, "Rule", ruleVisitor, wrapCustomAndUnknownAtRule);
      composeObjectVisitors(res, visitors, "RuleExit", ruleVisitor, wrapCustomAndUnknownAtRule);
      composeObjectVisitors(res, visitors, "Declaration", declarationVisitor, wrapCustomProperty);
      composeObjectVisitors(res, visitors, "DeclarationExit", declarationVisitor, wrapCustomProperty);
      composeSimpleVisitors(res, visitors, "Url");
      composeSimpleVisitors(res, visitors, "Color");
      composeSimpleVisitors(res, visitors, "Image");
      composeSimpleVisitors(res, visitors, "ImageExit");
      composeSimpleVisitors(res, visitors, "Length");
      composeSimpleVisitors(res, visitors, "Angle");
      composeSimpleVisitors(res, visitors, "Ratio");
      composeSimpleVisitors(res, visitors, "Resolution");
      composeSimpleVisitors(res, visitors, "Time");
      composeSimpleVisitors(res, visitors, "CustomIdent");
      composeSimpleVisitors(res, visitors, "DashedIdent");
      composeArrayFunctions(res, visitors, "MediaQuery");
      composeArrayFunctions(res, visitors, "MediaQueryExit");
      composeSimpleVisitors(res, visitors, "SupportsCondition");
      composeSimpleVisitors(res, visitors, "SupportsConditionExit");
      composeArrayFunctions(res, visitors, "Selector");
      composeTokenVisitors(res, visitors, "Token", "token", false);
      composeTokenVisitors(res, visitors, "Function", "function", false);
      composeTokenVisitors(res, visitors, "FunctionExit", "function", true);
      composeTokenVisitors(res, visitors, "Variable", "var", false);
      composeTokenVisitors(res, visitors, "VariableExit", "var", true);
      composeTokenVisitors(res, visitors, "EnvironmentVariable", "env", false);
      composeTokenVisitors(res, visitors, "EnvironmentVariableExit", "env", true);
      return res;
    }
    module.exports = composeVisitors2;
    function wrapCustomAndUnknownAtRule(k, f) {
      if (k === "unknown") {
        return (value2) => f({ type: "unknown", value: value2 });
      }
      if (k === "custom") {
        return (value2) => f({ type: "custom", value: value2 });
      }
      return f;
    }
    function wrapCustomProperty(k, f) {
      return k === "custom" ? (value2) => f({ property: "custom", value: value2 }) : f;
    }
    function ruleVisitor(f, item) {
      if (typeof f === "object") {
        if (item.type === "unknown") {
          let v = f.unknown;
          if (typeof v === "object") {
            v = v[item.value.name];
          }
          return v?.(item.value);
        }
        if (item.type === "custom") {
          let v = f.custom;
          if (typeof v === "object") {
            v = v[item.value.name];
          }
          return v?.(item.value);
        }
        return f[item.type]?.(item);
      }
      return f?.(item);
    }
    function declarationVisitor(f, item) {
      if (typeof f === "object") {
        let name2 = item.property;
        if (item.property === "unparsed") {
          name2 = item.value.propertyId.property;
        } else if (item.property === "custom") {
          let v = f.custom;
          if (typeof v === "object") {
            v = v[item.value.name];
          }
          return v?.(item.value);
        }
        return f[name2]?.(item);
      }
      return f?.(item);
    }
    function extractObjectsOrFunctions(visitors, key) {
      let values = [];
      let hasFunction = false;
      let allKeys = /* @__PURE__ */ new Set();
      for (let visitor of visitors) {
        let v = visitor[key];
        if (v) {
          if (typeof v === "function") {
            hasFunction = true;
          } else {
            for (let key2 in v) {
              allKeys.add(key2);
            }
          }
          values.push(v);
        }
      }
      return [values, hasFunction, allKeys];
    }
    function composeObjectVisitors(res, visitors, key, apply, wrapKey) {
      let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
      if (values.length === 0) {
        return;
      }
      if (values.length === 1) {
        res[key] = values[0];
        return;
      }
      let f = createArrayVisitor(visitors, (visitor, item) => apply(visitor[key], item));
      if (hasFunction) {
        res[key] = f;
      } else {
        let v = {};
        for (let k of allKeys) {
          v[k] = wrapKey(k, f);
        }
        res[key] = v;
      }
    }
    function composeTokenVisitors(res, visitors, key, type, isExit) {
      let [values, hasFunction, allKeys] = extractObjectsOrFunctions(visitors, key);
      if (values.length === 0) {
        return;
      }
      if (values.length === 1) {
        res[key] = values[0];
        return;
      }
      let f = createTokenVisitor(visitors, type, isExit);
      if (hasFunction) {
        res[key] = f;
      } else {
        let v = {};
        for (let key2 of allKeys) {
          v[key2] = f;
        }
        res[key] = v;
      }
    }
    function createTokenVisitor(visitors, type, isExit) {
      let v = createArrayVisitor(visitors, (visitor, item) => {
        let f;
        switch (item.type) {
          case "token":
            f = visitor.Token;
            if (typeof f === "object") {
              f = f[item.value.type];
            }
            break;
          case "function":
            f = isExit ? visitor.FunctionExit : visitor.Function;
            if (typeof f === "object") {
              f = f[item.value.name];
            }
            break;
          case "var":
            f = isExit ? visitor.VariableExit : visitor.Variable;
            break;
          case "env":
            f = isExit ? visitor.EnvironmentVariableExit : visitor.EnvironmentVariable;
            if (typeof f === "object") {
              let name2;
              switch (item.value.name.type) {
                case "ua":
                case "unknown":
                  name2 = item.value.name.value;
                  break;
                case "custom":
                  name2 = item.value.name.ident;
                  break;
              }
              f = f[name2];
            }
            break;
          case "color":
            f = visitor.Color;
            break;
          case "url":
            f = visitor.Url;
            break;
          case "length":
            f = visitor.Length;
            break;
          case "angle":
            f = visitor.Angle;
            break;
          case "time":
            f = visitor.Time;
            break;
          case "resolution":
            f = visitor.Resolution;
            break;
          case "dashed-ident":
            f = visitor.DashedIdent;
            break;
        }
        if (!f) {
          return;
        }
        let res = f(item.value);
        switch (item.type) {
          case "color":
          case "url":
          case "length":
          case "angle":
          case "time":
          case "resolution":
          case "dashed-ident":
            if (Array.isArray(res)) {
              res = res.map((value2) => ({ type: item.type, value: value2 }));
            } else if (res) {
              res = { type: item.type, value: res };
            }
            break;
        }
        return res;
      });
      return (value2) => v({ type, value: value2 });
    }
    function extractFunctions(visitors, key) {
      let functions = [];
      for (let visitor of visitors) {
        let f = visitor[key];
        if (f) {
          functions.push(f);
        }
      }
      return functions;
    }
    function composeSimpleVisitors(res, visitors, key) {
      let functions = extractFunctions(visitors, key);
      if (functions.length === 0) {
        return;
      }
      if (functions.length === 1) {
        res[key] = functions[0];
        return;
      }
      res[key] = (arg) => {
        let mutated = false;
        for (let f of functions) {
          let res2 = f(arg);
          if (res2) {
            arg = res2;
            mutated = true;
          }
        }
        return mutated ? arg : void 0;
      };
    }
    function composeArrayFunctions(res, visitors, key) {
      let functions = extractFunctions(visitors, key);
      if (functions.length === 0) {
        return;
      }
      if (functions.length === 1) {
        res[key] = functions[0];
        return;
      }
      res[key] = createArrayVisitor(functions, (f, item) => f(item));
    }
    function createArrayVisitor(visitors, apply) {
      let seen2 = new Bitset(visitors.length);
      return (arg) => {
        let arr = [arg];
        let mutated = false;
        seen2.clear();
        for (let i = 0; i < arr.length; i++) {
          for (let v = 0; v < visitors.length; ) {
            if (seen2.get(v)) {
              v++;
              continue;
            }
            let item = arr[i];
            let visitor = visitors[v];
            let res = apply(visitor, item);
            if (Array.isArray(res)) {
              if (res.length === 0) {
                arr.splice(i, 1);
              } else if (res.length === 1) {
                arr[i] = res[0];
              } else {
                arr.splice(i, 1, ...res);
              }
              mutated = true;
              seen2.set(v);
              v = 0;
            } else if (res) {
              arr[i] = res;
              mutated = true;
              seen2.set(v);
              v = 0;
            } else {
              v++;
            }
          }
        }
        if (!mutated) {
          return;
        }
        return arr.length === 1 ? arr[0] : arr;
      };
    }
    var Bitset = class {
      constructor(maxBits = 32) {
        this.bits = 0;
        this.more = maxBits > 32 ? new Uint32Array(Math.ceil((maxBits - 32) / 32)) : null;
      }
      /** @param {number} bit */
      get(bit) {
        if (bit >= 32 && this.more) {
          let i = Math.floor((bit - 32) / 32);
          let b = bit % 32;
          return Boolean(this.more[i] & 1 << b);
        } else {
          return Boolean(this.bits & 1 << bit);
        }
      }
      /** @param {number} bit */
      set(bit) {
        if (bit >= 32 && this.more) {
          let i = Math.floor((bit - 32) / 32);
          let b = bit % 32;
          this.more[i] |= 1 << b;
        } else {
          this.bits |= 1 << bit;
        }
      }
      clear() {
        this.bits = 0;
        if (this.more) {
          this.more.fill(0);
        }
      }
    };
  }
});

// node_modules/lightningcss/node/flags.js
var require_flags = __commonJS({
  "node_modules/lightningcss/node/flags.js"(exports2) {
    exports2.Features = {
      Nesting: 1,
      NotSelectorList: 2,
      DirSelector: 4,
      LangSelectorList: 8,
      IsSelector: 16,
      TextDecorationThicknessPercent: 32,
      MediaIntervalSyntax: 64,
      MediaRangeSyntax: 128,
      CustomMediaQueries: 256,
      ClampFunction: 512,
      ColorFunction: 1024,
      OklabColors: 2048,
      LabColors: 4096,
      P3Colors: 8192,
      HexAlphaColors: 16384,
      SpaceSeparatedColorNotation: 32768,
      FontFamilySystemUi: 65536,
      DoublePositionGradients: 131072,
      VendorPrefixes: 262144,
      LogicalProperties: 524288,
      LightDark: 1048576,
      Selectors: 31,
      MediaQueries: 448,
      Colors: 1113088
    };
  }
});

// node_modules/lightningcss/node/index.js
var require_node2 = __commonJS({
  "node_modules/lightningcss/node/index.js"(exports2, module) {
    init_();
    var parts = [process.platform, process.arch];
    if (process.platform === "linux") {
      const { MUSL, familySync } = require_detect_libc();
      const family = familySync();
      if (family === MUSL) {
        parts.push("musl");
      } else if (process.arch === "arm") {
        parts.push("gnueabihf");
      } else {
        parts.push("gnu");
      }
    } else if (process.platform === "win32") {
      parts.push("msvc");
    }
    if (process.env.CSS_TRANSFORMER_WASM) {
      module.exports = __require("../pkg");
    } else {
      try {
        module.exports = __require(`lightningcss-${parts.join("-")}`);
      } catch (err) {
        module.exports = globRequire_lightningcss_node(`../lightningcss.${parts.join("-")}.node`);
      }
    }
    module.exports.browserslistToTargets = require_browserslistToTargets();
    module.exports.composeVisitors = require_composeVisitors();
    module.exports.Features = require_flags().Features;
  }
});

// node_modules/lightningcss/node/index.mjs
var node_exports = {};
__export(node_exports, {
  Features: () => Features,
  browserslistToTargets: () => browserslistToTargets,
  bundle: () => bundle,
  bundleAsync: () => bundleAsync,
  composeVisitors: () => composeVisitors,
  transform: () => transform,
  transformStyleAttribute: () => transformStyleAttribute
});
var import_index, transform, transformStyleAttribute, bundle, bundleAsync, browserslistToTargets, composeVisitors, Features;
var init_node = __esm({
  "node_modules/lightningcss/node/index.mjs"() {
    import_index = __toESM(require_node2(), 1);
    ({ transform, transformStyleAttribute, bundle, bundleAsync, browserslistToTargets, composeVisitors, Features } = import_index.default);
  }
});

// node_modules/vite/dist/node/chunks/dep-C6uTJdX2.js
import * as fs$j from "node:fs";
import fs__default, { promises as promises$1 } from "node:fs";
import fsp, { lstat as lstat$3, readdir as readdir$5, readlink, realpath as realpath$2 } from "node:fs/promises";
import path$n, { win32 as win32$1, posix as posix$1, isAbsolute as isAbsolute$1, join as join$2, extname as extname$1, dirname as dirname$2, relative as relative$2, basename as basename$2 } from "node:path";
import { fileURLToPath as fileURLToPath2, URL as URL$3, parse as parse$h, pathToFileURL } from "node:url";
import { promisify as promisify$4, format as format$2, inspect } from "node:util";
import { createRequire as createRequire$1, builtinModules } from "node:module";
import require$$0$3 from "tty";
import require$$0$4, { win32, posix, isAbsolute, resolve as resolve$3, relative as relative$1, basename as basename$1, extname, dirname as dirname$1, join as join$1, sep as sep$1, normalize as normalize$1 } from "path";
import require$$0__default3, { lstatSync, readdir as readdir$4, readdirSync, readlinkSync, realpathSync as realpathSync$1, existsSync, readFileSync as readFileSync2, statSync as statSync$1 } from "fs";
import { EventEmitter as EventEmitter$4 } from "node:events";
import Stream$1 from "node:stream";
import { StringDecoder } from "node:string_decoder";
import { exec, execSync } from "node:child_process";
import require$$0$5 from "util";
import require$$4$1 from "net";
import require$$0$7 from "events";
import require$$0$9 from "url";
import require$$1 from "http";
import require$$0$6 from "stream";
import require$$2 from "os";
import require$$2$1 from "child_process";
import require$$3$1 from "crypto";
import require$$0$8, { createRequire as createRequire$2 } from "module";
import assert$1 from "node:assert";
import v8 from "node:v8";
import { Buffer as Buffer$1 } from "node:buffer";
import readline from "node:readline";
import zlib$1 from "zlib";
import require$$0$a from "buffer";
import require$$1$1 from "https";
import require$$4$2 from "tls";
import require$$4$3 from "assert";
import { fileURLToPath as __cjs_fileURLToPath4 } from "node:url";
import { dirname as __cjs_dirname4 } from "node:path";
import { createRequire as __cjs_createRequire4 } from "node:module";
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
function commonjsRequire(path9) {
  throw new Error('Could not dynamically require "' + path9 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
function slash$1(p) {
  return p.replace(windowsSlashRE, "/");
}
function cleanUrl(url2) {
  return url2.replace(postfixRE, "");
}
function isArray(arg) {
  return Array.isArray(arg);
}
function ensureArray(thing) {
  if (isArray(thing))
    return thing;
  if (thing == null)
    return [];
  return [thing];
}
function getMatcherString(id3, resolutionBase) {
  if (resolutionBase === false || isAbsolute(id3) || id3.startsWith("**")) {
    return normalizePath$5(id3);
  }
  const basePath = normalizePath$5(resolve$3(resolutionBase || "")).replace(/[-^$*+?.()|[\]{}]/g, "\\$&");
  return posix.join(basePath, normalizePath$5(id3));
}
function balanced$1(a, b, str2) {
  if (a instanceof RegExp) a = maybeMatch(a, str2);
  if (b instanceof RegExp) b = maybeMatch(b, str2);
  var r = range$1(a, b, str2);
  return r && {
    start: r[0],
    end: r[1],
    pre: str2.slice(0, r[0]),
    body: str2.slice(r[0] + a.length, r[1]),
    post: str2.slice(r[1] + b.length)
  };
}
function maybeMatch(reg2, str2) {
  var m = str2.match(reg2);
  return m ? m[0] : null;
}
function range$1(a, b, str2) {
  var begs, beg, left, right, result;
  var ai = str2.indexOf(a);
  var bi = str2.indexOf(b, ai + 1);
  var i = ai;
  if (ai >= 0 && bi > 0) {
    if (a === b) {
      return [ai, bi];
    }
    begs = [];
    left = str2.length;
    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str2.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [begs.pop(), bi];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }
        bi = str2.indexOf(b, i + 1);
      }
      i = ai < bi && ai >= 0 ? ai : bi;
    }
    if (begs.length) {
      result = [left, right];
    }
  }
  return result;
}
function numeric(str2) {
  return parseInt(str2, 10) == str2 ? parseInt(str2, 10) : str2.charCodeAt(0);
}
function escapeBraces(str2) {
  return str2.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
}
function unescapeBraces(str2) {
  return str2.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
}
function parseCommaParts(str2) {
  if (!str2)
    return [""];
  var parts = [];
  var m = balanced("{", "}", str2);
  if (!m)
    return str2.split(",");
  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(",");
  p[p.length - 1] += "{" + body + "}";
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length - 1] += postParts.shift();
    p.push.apply(p, postParts);
  }
  parts.push.apply(parts, p);
  return parts;
}
function expandTop(str2) {
  if (!str2)
    return [];
  if (str2.substr(0, 2) === "{}") {
    str2 = "\\{\\}" + str2.substr(2);
  }
  return expand$3(escapeBraces(str2), true).map(unescapeBraces);
}
function embrace(str2) {
  return "{" + str2 + "}";
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}
function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}
function expand$3(str2, isTop) {
  var expansions = [];
  var m = balanced("{", "}", str2);
  if (!m) return [str2];
  var pre = m.pre;
  var post = m.post.length ? expand$3(m.post, false) : [""];
  if (/\$$/.test(m.pre)) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + "{" + m.body + "}" + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str2 = m.pre + "{" + m.body + escClose + m.post;
        return expand$3(str2);
      }
      return [str2];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand$3(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad2 = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad2) {
            var need = width - c.length;
            if (need > 0) {
              var z2 = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z2 + c.slice(1);
              else
                c = z2 + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];
      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand$3(n[j], false));
      }
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }
  return expansions;
}
function globStreamSync(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).streamSync();
}
function globStream(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).stream();
}
function globSync(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).walkSync();
}
async function glob_(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).walk();
}
function globIterateSync(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).iterateSync();
}
function globIterate(pattern2, options2 = {}) {
  return new Glob(pattern2, options2).iterate();
}
function requireMs$1() {
  if (hasRequiredMs$1) return ms$1;
  hasRequiredMs$1 = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms$1 = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse6(val);
    } else if (type === "number" && isFinite(val)) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse6(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type = (match2[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms$1;
}
function requireCommon() {
  if (hasRequiredCommon) return common$b;
  hasRequiredCommon = 1;
  function setup(env2) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs$1();
    createDebug.destroy = destroy2;
    Object.keys(env2).forEach((key) => {
      createDebug[key] = env2[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace2) {
      let hash3 = 0;
      for (let i = 0; i < namespace2.length; i++) {
        hash3 = (hash3 << 5) - hash3 + namespace2.charCodeAt(i);
        hash3 |= 0;
      }
      return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace2) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self2 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index4 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
          if (match2 === "%%") {
            return "%";
          }
          index4++;
          const formatter2 = createDebug.formatters[format2];
          if (typeof formatter2 === "function") {
            const val = args[index4];
            match2 = formatter2.call(self2, val);
            args.splice(index4, 1);
            index4--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace2;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace2);
      debug2.extend = extend;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace2);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend(namespace2, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$b = setup;
  return common$b;
}
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3.exports;
  hasRequiredBrowser$1 = 1;
  (function(module, exports2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index4 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index4++;
        if (match2 === "%c") {
          lastC = index4;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = requireCommon()(exports2);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  })(browser$3, browser$3.exports);
  return browser$3.exports;
}
function requireNode$1() {
  if (hasRequiredNode$1) return node$12.exports;
  hasRequiredNode$1 = 1;
  (function(module, exports2) {
    const tty = require$$0$3;
    const util3 = require$$0$5;
    exports2.init = init2;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require5("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util3.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon()(exports2);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  })(node$12, node$12.exports);
  return node$12.exports;
}
function resolveDependencyVersion(dep, pkgRelativePath = "../../package.json") {
  const pkgPath = path$n.resolve(_require$1.resolve(dep), pkgRelativePath);
  return JSON.parse(fs__default.readFileSync(pkgPath, "utf-8")).version;
}
function createDebugger(namespace2, options2 = {}) {
  const log2 = debug$i(namespace2);
  const { onlyWhenFocused } = options2;
  let enabled = log2.enabled;
  if (enabled && onlyWhenFocused) {
    const ns = typeof onlyWhenFocused === "string" ? onlyWhenFocused : namespace2;
    enabled = !!DEBUG?.includes(ns);
  }
  if (enabled) {
    return (...args) => {
      if (!filter || args.some((a) => a?.includes?.(filter))) {
        log2(...args);
      }
    };
  }
}
function testCaseInsensitiveFS() {
  if (!CLIENT_ENTRY.endsWith("client.mjs")) {
    throw new Error(
      `cannot test case insensitive FS, CLIENT_ENTRY const doesn't contain client.mjs`
    );
  }
  if (!fs__default.existsSync(CLIENT_ENTRY)) {
    throw new Error(
      "cannot test case insensitive FS, CLIENT_ENTRY does not point to an existing file: " + CLIENT_ENTRY
    );
  }
  return fs__default.existsSync(CLIENT_ENTRY.replace("client.mjs", "cLiEnT.mjs"));
}
function normalizePath$3(id3) {
  return path$n.posix.normalize(isWindows$3 ? slash$1(id3) : id3);
}
async function asyncReplace(input, re, replacer) {
  let match2;
  let remaining = input;
  let rewritten = "";
  while (match2 = re.exec(remaining)) {
    rewritten += remaining.slice(0, match2.index);
    rewritten += await replacer(match2);
    remaining = remaining.slice(match2.index + match2[0].length);
  }
  rewritten += remaining;
  return rewritten;
}
function tryStatSync(file) {
  try {
    return fs__default.statSync(file, { throwIfNoEntry: false });
  } catch {
  }
}
function windowsMappedRealpathSync(path22) {
  const realPath = fs__default.realpathSync.native(path22);
  if (realPath.startsWith("\\\\")) {
    for (const [network, volume] of windowsNetworkMap) {
      if (realPath.startsWith(network)) return realPath.replace(network, volume);
    }
  }
  return realPath;
}
function windowsSafeRealPathSync(path22) {
  if (!firstSafeRealPathSyncRun) {
    optimizeSafeRealPathSync();
    firstSafeRealPathSyncRun = true;
  }
  return fs__default.realpathSync(path22);
}
function optimizeSafeRealPathSync() {
  const nodeVersion = process.versions.node.split(".").map(Number);
  if (nodeVersion[0] < 18 || nodeVersion[0] === 18 && nodeVersion[1] < 10) {
    safeRealpathSync = fs__default.realpathSync;
    return;
  }
  try {
    fs__default.realpathSync.native(path$n.resolve("./"));
  } catch (error) {
    if (error.message.includes("EISDIR: illegal operation on a directory")) {
      safeRealpathSync = fs__default.realpathSync;
      return;
    }
  }
  exec("net use", (error, stdout) => {
    if (error) return;
    const lines = stdout.split("\n");
    for (const line of lines) {
      const m = parseNetUseRE.exec(line);
      if (m) windowsNetworkMap.set(m[2], m[1]);
    }
    if (windowsNetworkMap.size === 0) {
      safeRealpathSync = fs__default.realpathSync.native;
    } else {
      safeRealpathSync = windowsMappedRealpathSync;
    }
  });
}
function joinSrcset(ret) {
  return ret.map(({ url: url2, descriptor }) => url2 + (descriptor ? ` ${descriptor}` : "")).join(", ");
}
function splitSrcSetDescriptor(srcs) {
  return splitSrcSet(srcs).map((s) => {
    const src3 = s.replace(escapedSpaceCharacters, " ").trim();
    const url2 = imageSetUrlRE.exec(src3)?.[0] ?? "";
    return {
      url: url2,
      descriptor: src3.slice(url2.length).trim()
    };
  }).filter(({ url: url2 }) => !!url2);
}
function processSrcSet(srcs, replacer) {
  return Promise.all(
    splitSrcSetDescriptor(srcs).map(async ({ url: url2, descriptor }) => ({
      url: await replacer({ url: url2, descriptor }),
      descriptor
    }))
  ).then(joinSrcset);
}
function splitSrcSet(srcs) {
  const parts = [];
  const cleanedSrcs = srcs.replace(cleanSrcSetRE, blankReplacer);
  let startIndex = 0;
  let splitIndex;
  do {
    splitIndex = cleanedSrcs.indexOf(",", startIndex);
    parts.push(
      srcs.slice(startIndex, splitIndex !== -1 ? splitIndex : void 0)
    );
    startIndex = splitIndex + 1;
  } while (splitIndex !== -1);
  return parts;
}
function partialEncodeURIPath(uri) {
  if (uri.startsWith("data:")) return uri;
  const filePath = cleanUrl(uri);
  const postfix = filePath !== uri ? uri.slice(filePath.length) : "";
  return filePath.replaceAll("%", "%25") + postfix;
}
function clearScreen() {
  const repeatCount = process.stdout.rows - 2;
  const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
  console.log(blank);
  readline.cursorTo(process.stdout, 0, 0);
  readline.clearScreenDown(process.stdout);
}
function getTimeFormatter() {
  timeFormatter ??= new Intl.DateTimeFormat(void 0, {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  });
  return timeFormatter;
}
function createLogger(level = "info", options2 = {}) {
  if (options2.customLogger) {
    return options2.customLogger;
  }
  const loggedErrors = /* @__PURE__ */ new WeakSet();
  const { prefix = "[vite]", allowClearScreen = true } = options2;
  const thresh = LogLevels[level];
  const canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI;
  const clear = canClearScreen ? clearScreen : () => {
  };
  function format2(type, msg, options22 = {}) {
    if (options22.timestamp) {
      let tag3 = "";
      if (type === "info") {
        tag3 = colors$1.cyan(colors$1.bold(prefix));
      } else if (type === "warn") {
        tag3 = colors$1.yellow(colors$1.bold(prefix));
      } else {
        tag3 = colors$1.red(colors$1.bold(prefix));
      }
      return `${colors$1.dim(getTimeFormatter().format(/* @__PURE__ */ new Date()))} ${tag3} ${msg}`;
    } else {
      return msg;
    }
  }
  function output(type, msg, options22 = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      if (options22.error) {
        loggedErrors.add(options22.error);
      }
      if (canClearScreen) {
        if (type === lastType && msg === lastMsg) {
          sameCount++;
          clear();
          console[method](
            format2(type, msg, options22),
            colors$1.yellow(`(x${sameCount + 1})`)
          );
        } else {
          sameCount = 0;
          lastMsg = msg;
          lastType = type;
          if (options22.clear) {
            clear();
          }
          console[method](format2(type, msg, options22));
        }
      } else {
        console[method](format2(type, msg, options22));
      }
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set();
  const logger = {
    hasWarned: false,
    info(msg, opts) {
      output("info", msg, opts);
    },
    warn(msg, opts) {
      logger.hasWarned = true;
      output("warn", msg, opts);
    },
    warnOnce(msg, opts) {
      if (warnedMessages.has(msg)) return;
      logger.hasWarned = true;
      output("warn", msg, opts);
      warnedMessages.add(msg);
    },
    error(msg, opts) {
      logger.hasWarned = true;
      output("error", msg, opts);
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) {
        clear();
      }
    },
    hasErrorLogged(error) {
      return loggedErrors.has(error);
    }
  };
  return logger;
}
function flatten$1(items) {
  return items.reduce((collection, item) => [].concat(collection, item), []);
}
function splitWhen(items, predicate) {
  const result = [[]];
  let groupIndex = 0;
  for (const item of items) {
    if (predicate(item)) {
      groupIndex++;
      result[groupIndex] = [];
    } else {
      result[groupIndex].push(item);
    }
  }
  return result;
}
function isEnoentCodeError(error) {
  return error.code === "ENOENT";
}
function createDirentFromStats$1(name2, stats) {
  return new DirentFromStats$1(name2, stats);
}
function unixify(filepath) {
  return filepath.replace(/\\/g, "/");
}
function makeAbsolute(cwd, filepath) {
  return path$h.resolve(cwd, filepath);
}
function removeLeadingDotSegment(entry2) {
  if (entry2.charAt(0) === ".") {
    const secondCharactery = entry2.charAt(1);
    if (secondCharactery === "/" || secondCharactery === "\\") {
      return entry2.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
    }
  }
  return entry2;
}
function escapeWindowsPath(pattern2) {
  return pattern2.replace(WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
}
function escapePosixPath(pattern2) {
  return pattern2.replace(POSIX_UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
}
function convertWindowsPathToPattern(filepath) {
  return escapeWindowsPath(filepath).replace(DOS_DEVICE_PATH_RE, "//$1").replace(WINDOWS_BACKSLASHES_RE, "/");
}
function convertPosixPathToPattern(filepath) {
  return escapePosixPath(filepath);
}
function collatePatterns(neg, pos, options2) {
  let onlyNegative = filterPatterns(neg, pos, "-", false) || [];
  let onlyPositive = filterPatterns(pos, neg, "", false) || [];
  let intersected = filterPatterns(neg, pos, "-?", true) || [];
  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
  return subpatterns.join("|");
}
function splitToRanges(min2, max) {
  let nines = 1;
  let zeros2 = 1;
  let stop = countNines(min2, nines);
  let stops = /* @__PURE__ */ new Set([max]);
  while (min2 <= stop && stop <= max) {
    stops.add(stop);
    nines += 1;
    stop = countNines(min2, nines);
  }
  stop = countZeros(max + 1, zeros2) - 1;
  while (min2 < stop && stop <= max) {
    stops.add(stop);
    zeros2 += 1;
    stop = countZeros(max + 1, zeros2) - 1;
  }
  stops = [...stops];
  stops.sort(compare);
  return stops;
}
function rangeToPattern(start, stop, options2) {
  if (start === stop) {
    return { pattern: start, count: [], digits: 0 };
  }
  let zipped = zip(start, stop);
  let digits = zipped.length;
  let pattern2 = "";
  let count = 0;
  for (let i = 0; i < digits; i++) {
    let [startDigit, stopDigit] = zipped[i];
    if (startDigit === stopDigit) {
      pattern2 += startDigit;
    } else if (startDigit !== "0" || stopDigit !== "9") {
      pattern2 += toCharacterClass(startDigit, stopDigit);
    } else {
      count++;
    }
  }
  if (count) {
    pattern2 += options2.shorthand === true ? "\\d" : "[0-9]";
  }
  return { pattern: pattern2, count: [count], digits };
}
function splitToPatterns(min2, max, tok, options2) {
  let ranges = splitToRanges(min2, max);
  let tokens = [];
  let start = min2;
  let prev;
  for (let i = 0; i < ranges.length; i++) {
    let max2 = ranges[i];
    let obj = rangeToPattern(String(start), String(max2), options2);
    let zeros2 = "";
    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
      if (prev.count.length > 1) {
        prev.count.pop();
      }
      prev.count.push(obj.count[0]);
      prev.string = prev.pattern + toQuantifier(prev.count);
      start = max2 + 1;
      continue;
    }
    if (tok.isPadded) {
      zeros2 = padZeros(max2, tok, options2);
    }
    obj.string = zeros2 + obj.pattern + toQuantifier(obj.count);
    tokens.push(obj);
    start = max2 + 1;
    prev = obj;
  }
  return tokens;
}
function filterPatterns(arr, comparison, prefix, intersection, options2) {
  let result = [];
  for (let ele of arr) {
    let { string: string4 } = ele;
    if (!intersection && !contains(comparison, "string", string4)) {
      result.push(prefix + string4);
    }
    if (intersection && contains(comparison, "string", string4)) {
      result.push(prefix + string4);
    }
  }
  return result;
}
function zip(a, b) {
  let arr = [];
  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);
  return arr;
}
function compare(a, b) {
  return a > b ? 1 : b > a ? -1 : 0;
}
function contains(arr, key, val) {
  return arr.some((ele) => ele[key] === val);
}
function countNines(min2, len) {
  return Number(String(min2).slice(0, -len) + "9".repeat(len));
}
function countZeros(integer, zeros2) {
  return integer - integer % Math.pow(10, zeros2);
}
function toQuantifier(digits) {
  let [start = 0, stop = ""] = digits;
  if (stop || start > 1) {
    return `{${start + (stop ? "," + stop : "")}}`;
  }
  return "";
}
function toCharacterClass(a, b, options2) {
  return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
}
function hasPadding(str2) {
  return /^-?(0+)\d/.test(str2);
}
function padZeros(value2, tok, options2) {
  if (!tok.isPadded) {
    return value2;
  }
  let diff = Math.abs(tok.maxLen - String(value2).length);
  let relax = options2.relaxZeros !== false;
  switch (diff) {
    case 0:
      return "";
    case 1:
      return relax ? "0?" : "0";
    case 2:
      return relax ? "0{0,2}" : "00";
    default: {
      return relax ? `0{0,${diff}}` : `0{${diff}}`;
    }
  }
}
function isStaticPattern(pattern2, options2 = {}) {
  return !isDynamicPattern(pattern2, options2);
}
function isDynamicPattern(pattern2, options2 = {}) {
  if (pattern2 === "") {
    return false;
  }
  if (options2.caseSensitiveMatch === false || pattern2.includes(ESCAPE_SYMBOL)) {
    return true;
  }
  if (COMMON_GLOB_SYMBOLS_RE.test(pattern2) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern2) || REGEX_GROUP_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options2.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern2)) {
    return true;
  }
  if (options2.braceExpansion !== false && hasBraceExpansion(pattern2)) {
    return true;
  }
  return false;
}
function hasBraceExpansion(pattern2) {
  const openingBraceIndex = pattern2.indexOf("{");
  if (openingBraceIndex === -1) {
    return false;
  }
  const closingBraceIndex = pattern2.indexOf("}", openingBraceIndex + 1);
  if (closingBraceIndex === -1) {
    return false;
  }
  const braceContent = pattern2.slice(openingBraceIndex, closingBraceIndex);
  return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
}
function convertToPositivePattern(pattern2) {
  return isNegativePattern(pattern2) ? pattern2.slice(1) : pattern2;
}
function convertToNegativePattern(pattern2) {
  return "!" + pattern2;
}
function isNegativePattern(pattern2) {
  return pattern2.startsWith("!") && pattern2[1] !== "(";
}
function isPositivePattern(pattern2) {
  return !isNegativePattern(pattern2);
}
function getNegativePatterns(patterns) {
  return patterns.filter(isNegativePattern);
}
function getPositivePatterns$1(patterns) {
  return patterns.filter(isPositivePattern);
}
function getPatternsInsideCurrentDirectory(patterns) {
  return patterns.filter((pattern2) => !isPatternRelatedToParentDirectory(pattern2));
}
function getPatternsOutsideCurrentDirectory(patterns) {
  return patterns.filter(isPatternRelatedToParentDirectory);
}
function isPatternRelatedToParentDirectory(pattern2) {
  return pattern2.startsWith("..") || pattern2.startsWith("./..");
}
function getBaseDirectory(pattern2) {
  return globParent$1(pattern2, { flipBackslashes: false });
}
function hasGlobStar(pattern2) {
  return pattern2.includes(GLOBSTAR$1);
}
function endsWithSlashGlobStar(pattern2) {
  return pattern2.endsWith("/" + GLOBSTAR$1);
}
function isAffectDepthOfReadingPattern(pattern2) {
  const basename2 = path$g.basename(pattern2);
  return endsWithSlashGlobStar(pattern2) || isStaticPattern(basename2);
}
function expandPatternsWithBraceExpansion(patterns) {
  return patterns.reduce((collection, pattern2) => {
    return collection.concat(expandBraceExpansion(pattern2));
  }, []);
}
function expandBraceExpansion(pattern2) {
  const patterns = micromatch.braces(pattern2, { expand: true, nodupes: true, keepEscaping: true });
  patterns.sort((a, b) => a.length - b.length);
  return patterns.filter((pattern3) => pattern3 !== "");
}
function getPatternParts(pattern2, options2) {
  let { parts } = micromatch.scan(pattern2, Object.assign(Object.assign({}, options2), { parts: true }));
  if (parts.length === 0) {
    parts = [pattern2];
  }
  if (parts[0].startsWith("/")) {
    parts[0] = parts[0].slice(1);
    parts.unshift("");
  }
  return parts;
}
function makeRe(pattern2, options2) {
  return micromatch.makeRe(pattern2, options2);
}
function convertPatternsToRe(patterns, options2) {
  return patterns.map((pattern2) => makeRe(pattern2, options2));
}
function matchAny(entry2, patternsRe) {
  return patternsRe.some((patternRe) => patternRe.test(entry2));
}
function removeDuplicateSlashes(pattern2) {
  return pattern2.replace(DOUBLE_SLASH_RE$1, "/");
}
function merge2$1() {
  const streamsQueue = [];
  const args = slice.call(arguments);
  let merging = false;
  let options2 = args[args.length - 1];
  if (options2 && !Array.isArray(options2) && options2.pipe == null) {
    args.pop();
  } else {
    options2 = {};
  }
  const doEnd = options2.end !== false;
  const doPipeError = options2.pipeError === true;
  if (options2.objectMode == null) {
    options2.objectMode = true;
  }
  if (options2.highWaterMark == null) {
    options2.highWaterMark = 64 * 1024;
  }
  const mergedStream = PassThrough(options2);
  function addStream() {
    for (let i = 0, len = arguments.length; i < len; i++) {
      streamsQueue.push(pauseStreams(arguments[i], options2));
    }
    mergeStream();
    return this;
  }
  function mergeStream() {
    if (merging) {
      return;
    }
    merging = true;
    let streams = streamsQueue.shift();
    if (!streams) {
      process.nextTick(endStream);
      return;
    }
    if (!Array.isArray(streams)) {
      streams = [streams];
    }
    let pipesCount = streams.length + 1;
    function next() {
      if (--pipesCount > 0) {
        return;
      }
      merging = false;
      mergeStream();
    }
    function pipe2(stream4) {
      function onend() {
        stream4.removeListener("merge2UnpipeEnd", onend);
        stream4.removeListener("end", onend);
        if (doPipeError) {
          stream4.removeListener("error", onerror);
        }
        next();
      }
      function onerror(err) {
        mergedStream.emit("error", err);
      }
      if (stream4._readableState.endEmitted) {
        return next();
      }
      stream4.on("merge2UnpipeEnd", onend);
      stream4.on("end", onend);
      if (doPipeError) {
        stream4.on("error", onerror);
      }
      stream4.pipe(mergedStream, { end: false });
      stream4.resume();
    }
    for (let i = 0; i < streams.length; i++) {
      pipe2(streams[i]);
    }
    next();
  }
  function endStream() {
    merging = false;
    mergedStream.emit("queueDrain");
    if (doEnd) {
      mergedStream.end();
    }
  }
  mergedStream.setMaxListeners(0);
  mergedStream.add = addStream;
  mergedStream.on("unpipe", function(stream4) {
    stream4.emit("merge2UnpipeEnd");
  });
  if (args.length) {
    addStream.apply(null, args);
  }
  return mergedStream;
}
function pauseStreams(streams, options2) {
  if (!Array.isArray(streams)) {
    if (!streams._readableState && streams.pipe) {
      streams = streams.pipe(PassThrough(options2));
    }
    if (!streams._readableState || !streams.pause || !streams.pipe) {
      throw new Error("Only readable stream can be merged.");
    }
    streams.pause();
  } else {
    for (let i = 0, len = streams.length; i < len; i++) {
      streams[i] = pauseStreams(streams[i], options2);
    }
  }
  return streams;
}
function merge$1(streams) {
  const mergedStream = merge22(streams);
  streams.forEach((stream4) => {
    stream4.once("error", (error) => mergedStream.emit("error", error));
  });
  mergedStream.once("close", () => propagateCloseEventToSources(streams));
  mergedStream.once("end", () => propagateCloseEventToSources(streams));
  return mergedStream;
}
function propagateCloseEventToSources(streams) {
  streams.forEach((stream4) => stream4.emit("close"));
}
function isString$1(input) {
  return typeof input === "string";
}
function isEmpty$1(input) {
  return input === "";
}
function generate(input, settings2) {
  const patterns = processPatterns(input, settings2);
  const ignore = processPatterns(settings2.ignore, settings2);
  const positivePatterns = getPositivePatterns(patterns);
  const negativePatterns = getNegativePatternsAsPositive(patterns, ignore);
  const staticPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isStaticPattern(pattern2, settings2));
  const dynamicPatterns = positivePatterns.filter((pattern2) => utils$a.pattern.isDynamicPattern(pattern2, settings2));
  const staticTasks = convertPatternsToTasks(
    staticPatterns,
    negativePatterns,
    /* dynamic */
    false
  );
  const dynamicTasks = convertPatternsToTasks(
    dynamicPatterns,
    negativePatterns,
    /* dynamic */
    true
  );
  return staticTasks.concat(dynamicTasks);
}
function processPatterns(input, settings2) {
  let patterns = input;
  if (settings2.braceExpansion) {
    patterns = utils$a.pattern.expandPatternsWithBraceExpansion(patterns);
  }
  if (settings2.baseNameMatch) {
    patterns = patterns.map((pattern2) => pattern2.includes("/") ? pattern2 : `**/${pattern2}`);
  }
  return patterns.map((pattern2) => utils$a.pattern.removeDuplicateSlashes(pattern2));
}
function convertPatternsToTasks(positive, negative, dynamic) {
  const tasks2 = [];
  const patternsOutsideCurrentDirectory = utils$a.pattern.getPatternsOutsideCurrentDirectory(positive);
  const patternsInsideCurrentDirectory = utils$a.pattern.getPatternsInsideCurrentDirectory(positive);
  const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
  const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
  tasks2.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
  if ("." in insideCurrentDirectoryGroup) {
    tasks2.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
  } else {
    tasks2.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
  }
  return tasks2;
}
function getPositivePatterns(patterns) {
  return utils$a.pattern.getPositivePatterns(patterns);
}
function getNegativePatternsAsPositive(patterns, ignore) {
  const negative = utils$a.pattern.getNegativePatterns(patterns).concat(ignore);
  const positive = negative.map(utils$a.pattern.convertToPositivePattern);
  return positive;
}
function groupPatternsByBaseDirectory(patterns) {
  const group = {};
  return patterns.reduce((collection, pattern2) => {
    const base = utils$a.pattern.getBaseDirectory(pattern2);
    if (base in collection) {
      collection[base].push(pattern2);
    } else {
      collection[base] = [pattern2];
    }
    return collection;
  }, group);
}
function convertPatternGroupsToTasks(positive, negative, dynamic) {
  return Object.keys(positive).map((base) => {
    return convertPatternGroupToTask(base, positive[base], negative, dynamic);
  });
}
function convertPatternGroupToTask(base, positive, negative, dynamic) {
  return {
    dynamic,
    positive,
    negative,
    base,
    patterns: [].concat(positive, negative.map(utils$a.pattern.convertToNegativePattern))
  };
}
function read$3(path9, settings2, callback) {
  settings2.fs.lstat(path9, (lstatError, lstat2) => {
    if (lstatError !== null) {
      callFailureCallback$2(callback, lstatError);
      return;
    }
    if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
      callSuccessCallback$2(callback, lstat2);
      return;
    }
    settings2.fs.stat(path9, (statError, stat3) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          callFailureCallback$2(callback, statError);
          return;
        }
        callSuccessCallback$2(callback, lstat2);
        return;
      }
      if (settings2.markSymbolicLink) {
        stat3.isSymbolicLink = () => true;
      }
      callSuccessCallback$2(callback, stat3);
    });
  });
}
function callFailureCallback$2(callback, error) {
  callback(error);
}
function callSuccessCallback$2(callback, result) {
  callback(null, result);
}
function read$2(path9, settings2) {
  const lstat2 = settings2.fs.lstatSync(path9);
  if (!lstat2.isSymbolicLink() || !settings2.followSymbolicLink) {
    return lstat2;
  }
  try {
    const stat3 = settings2.fs.statSync(path9);
    if (settings2.markSymbolicLink) {
      stat3.isSymbolicLink = () => true;
    }
    return stat3;
  } catch (error) {
    if (!settings2.throwErrorOnBrokenSymbolicLink) {
      return lstat2;
    }
    throw error;
  }
}
function stat$4(path9, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async$1.read(path9, getSettings$2(), optionsOrSettingsOrCallback);
    return;
  }
  async$1.read(path9, getSettings$2(optionsOrSettingsOrCallback), callback);
}
function statSync(path9, optionsOrSettings) {
  const settings2 = getSettings$2(optionsOrSettings);
  return sync$7.read(path9, settings2);
}
function getSettings$2(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$3.default) {
    return settingsOrOptions;
  }
  return new settings_1$3.default(settingsOrOptions);
}
function runParallel(tasks2, cb) {
  let results, pending, keys;
  let isSync = true;
  if (Array.isArray(tasks2)) {
    results = [];
    pending = tasks2.length;
  } else {
    keys = Object.keys(tasks2);
    results = {};
    pending = keys.length;
  }
  function done(err) {
    function end() {
      if (cb) cb(err, results);
      cb = null;
    }
    if (isSync) queueMicrotask$1(end);
    else end();
  }
  function each(i, err, result) {
    results[i] = result;
    if (--pending === 0 || err) {
      done(err);
    }
  }
  if (!pending) {
    done(null);
  } else if (keys) {
    keys.forEach(function(key) {
      tasks2[key](function(err, result) {
        each(key, err, result);
      });
    });
  } else {
    tasks2.forEach(function(task, i) {
      task(function(err, result) {
        each(i, err, result);
      });
    });
  }
  isSync = false;
}
function createDirentFromStats(name2, stats) {
  return new DirentFromStats2(name2, stats);
}
function joinPathSegments$1(a, b, separator) {
  if (a.endsWith(separator)) {
    return a + b;
  }
  return a + separator + b;
}
function read$1(directory, settings2, callback) {
  if (!settings2.stats && constants_1$1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    readdirWithFileTypes$1(directory, settings2, callback);
    return;
  }
  readdir$3(directory, settings2, callback);
}
function readdirWithFileTypes$1(directory, settings2, callback) {
  settings2.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const entries = dirents.map((dirent) => ({
      dirent,
      name: dirent.name,
      path: common$9.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    }));
    if (!settings2.followSymbolicLinks) {
      callSuccessCallback$1(callback, entries);
      return;
    }
    const tasks2 = entries.map((entry2) => makeRplTaskEntry(entry2, settings2));
    rpl(tasks2, (rplError, rplEntries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, rplEntries);
    });
  });
}
function makeRplTaskEntry(entry2, settings2) {
  return (done) => {
    if (!entry2.dirent.isSymbolicLink()) {
      done(null, entry2);
      return;
    }
    settings2.fs.stat(entry2.path, (statError, stats) => {
      if (statError !== null) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          done(statError);
          return;
        }
        done(null, entry2);
        return;
      }
      entry2.dirent = utils$8.fs.createDirentFromStats(entry2.name, stats);
      done(null, entry2);
    });
  };
}
function readdir$3(directory, settings2, callback) {
  settings2.fs.readdir(directory, (readdirError, names) => {
    if (readdirError !== null) {
      callFailureCallback$1(callback, readdirError);
      return;
    }
    const tasks2 = names.map((name2) => {
      const path9 = common$9.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
      return (done) => {
        fsStat$5.stat(path9, settings2.fsStatSettings, (error, stats) => {
          if (error !== null) {
            done(error);
            return;
          }
          const entry2 = {
            name: name2,
            path: path9,
            dirent: utils$8.fs.createDirentFromStats(name2, stats)
          };
          if (settings2.stats) {
            entry2.stats = stats;
          }
          done(null, entry2);
        });
      };
    });
    rpl(tasks2, (rplError, entries) => {
      if (rplError !== null) {
        callFailureCallback$1(callback, rplError);
        return;
      }
      callSuccessCallback$1(callback, entries);
    });
  });
}
function callFailureCallback$1(callback, error) {
  callback(error);
}
function callSuccessCallback$1(callback, result) {
  callback(null, result);
}
function read(directory, settings2) {
  if (!settings2.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
    return readdirWithFileTypes(directory, settings2);
  }
  return readdir$2(directory, settings2);
}
function readdirWithFileTypes(directory, settings2) {
  const dirents = settings2.fs.readdirSync(directory, { withFileTypes: true });
  return dirents.map((dirent) => {
    const entry2 = {
      dirent,
      name: dirent.name,
      path: common$8.joinPathSegments(directory, dirent.name, settings2.pathSegmentSeparator)
    };
    if (entry2.dirent.isSymbolicLink() && settings2.followSymbolicLinks) {
      try {
        const stats = settings2.fs.statSync(entry2.path);
        entry2.dirent = utils$7.fs.createDirentFromStats(entry2.name, stats);
      } catch (error) {
        if (settings2.throwErrorOnBrokenSymbolicLink) {
          throw error;
        }
      }
    }
    return entry2;
  });
}
function readdir$2(directory, settings2) {
  const names = settings2.fs.readdirSync(directory);
  return names.map((name2) => {
    const entryPath = common$8.joinPathSegments(directory, name2, settings2.pathSegmentSeparator);
    const stats = fsStat$4.statSync(entryPath, settings2.fsStatSettings);
    const entry2 = {
      name: name2,
      path: entryPath,
      dirent: utils$7.fs.createDirentFromStats(name2, stats)
    };
    if (settings2.stats) {
      entry2.stats = stats;
    }
    return entry2;
  });
}
function scandir(path9, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    async.read(path9, getSettings$1(), optionsOrSettingsOrCallback);
    return;
  }
  async.read(path9, getSettings$1(optionsOrSettingsOrCallback), callback);
}
function scandirSync(path9, optionsOrSettings) {
  const settings2 = getSettings$1(optionsOrSettings);
  return sync$5.read(path9, settings2);
}
function getSettings$1(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$2.default) {
    return settingsOrOptions;
  }
  return new settings_1$2.default(settingsOrOptions);
}
function reusify$1(Constructor) {
  var head = new Constructor();
  var tail = head;
  function get() {
    var current = head;
    if (current.next) {
      head = current.next;
    } else {
      head = new Constructor();
      tail = head;
    }
    current.next = null;
    return current;
  }
  function release(obj) {
    tail.next = obj;
    tail = obj;
  }
  return {
    get,
    release
  };
}
function fastqueue(context, worker, _concurrency) {
  if (typeof context === "function") {
    _concurrency = worker;
    worker = context;
    context = null;
  }
  if (!(_concurrency >= 1)) {
    throw new Error("fastqueue concurrency must be equal to or greater than 1");
  }
  var cache2 = reusify(Task);
  var queueHead = null;
  var queueTail = null;
  var _running = 0;
  var errorHandler = null;
  var self2 = {
    push: push2,
    drain: noop$4,
    saturated: noop$4,
    pause,
    paused: false,
    get concurrency() {
      return _concurrency;
    },
    set concurrency(value2) {
      if (!(value2 >= 1)) {
        throw new Error("fastqueue concurrency must be equal to or greater than 1");
      }
      _concurrency = value2;
      if (self2.paused) return;
      for (; queueHead && _running < _concurrency; ) {
        _running++;
        release();
      }
    },
    running,
    resume: resume2,
    idle,
    length,
    getQueue,
    unshift,
    empty: noop$4,
    kill,
    killAndDrain,
    error
  };
  return self2;
  function running() {
    return _running;
  }
  function pause() {
    self2.paused = true;
  }
  function length() {
    var current = queueHead;
    var counter = 0;
    while (current) {
      current = current.next;
      counter++;
    }
    return counter;
  }
  function getQueue() {
    var current = queueHead;
    var tasks2 = [];
    while (current) {
      tasks2.push(current.value);
      current = current.next;
    }
    return tasks2;
  }
  function resume2() {
    if (!self2.paused) return;
    self2.paused = false;
    if (queueHead === null) {
      _running++;
      release();
      return;
    }
    for (; queueHead && _running < _concurrency; ) {
      _running++;
      release();
    }
  }
  function idle() {
    return _running === 0 && self2.length() === 0;
  }
  function push2(value2, done) {
    var current = cache2.get();
    current.context = context;
    current.release = release;
    current.value = value2;
    current.callback = done || noop$4;
    current.errorHandler = errorHandler;
    if (_running >= _concurrency || self2.paused) {
      if (queueTail) {
        queueTail.next = current;
        queueTail = current;
      } else {
        queueHead = current;
        queueTail = current;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }
  function unshift(value2, done) {
    var current = cache2.get();
    current.context = context;
    current.release = release;
    current.value = value2;
    current.callback = done || noop$4;
    current.errorHandler = errorHandler;
    if (_running >= _concurrency || self2.paused) {
      if (queueHead) {
        current.next = queueHead;
        queueHead = current;
      } else {
        queueHead = current;
        queueTail = current;
        self2.saturated();
      }
    } else {
      _running++;
      worker.call(context, current.value, current.worked);
    }
  }
  function release(holder) {
    if (holder) {
      cache2.release(holder);
    }
    var next = queueHead;
    if (next && _running <= _concurrency) {
      if (!self2.paused) {
        if (queueTail === queueHead) {
          queueTail = null;
        }
        queueHead = next.next;
        next.next = null;
        worker.call(context, next.value, next.worked);
        if (queueTail === null) {
          self2.empty();
        }
      } else {
        _running--;
      }
    } else if (--_running === 0) {
      self2.drain();
    }
  }
  function kill() {
    queueHead = null;
    queueTail = null;
    self2.drain = noop$4;
  }
  function killAndDrain() {
    queueHead = null;
    queueTail = null;
    self2.drain();
    self2.drain = noop$4;
  }
  function error(handler) {
    errorHandler = handler;
  }
}
function noop$4() {
}
function Task() {
  this.value = null;
  this.callback = noop$4;
  this.next = null;
  this.release = noop$4;
  this.context = null;
  this.errorHandler = null;
  var self2 = this;
  this.worked = function worked(err, result) {
    var callback = self2.callback;
    var errorHandler = self2.errorHandler;
    var val = self2.value;
    self2.value = null;
    self2.callback = noop$4;
    if (self2.errorHandler) {
      errorHandler(err, val);
    }
    callback.call(self2.context, err, result);
    self2.release(self2);
  };
}
function queueAsPromised(context, worker, _concurrency) {
  if (typeof context === "function") {
    _concurrency = worker;
    worker = context;
    context = null;
  }
  function asyncWrapper(arg, cb) {
    worker.call(this, arg).then(function(res) {
      cb(null, res);
    }, cb);
  }
  var queue2 = fastqueue(context, asyncWrapper, _concurrency);
  var pushCb = queue2.push;
  var unshiftCb = queue2.unshift;
  queue2.push = push2;
  queue2.unshift = unshift;
  queue2.drained = drained;
  return queue2;
  function push2(value2) {
    var p = new Promise(function(resolve8, reject) {
      pushCb(value2, function(err, result) {
        if (err) {
          reject(err);
          return;
        }
        resolve8(result);
      });
    });
    p.catch(noop$4);
    return p;
  }
  function unshift(value2) {
    var p = new Promise(function(resolve8, reject) {
      unshiftCb(value2, function(err, result) {
        if (err) {
          reject(err);
          return;
        }
        resolve8(result);
      });
    });
    p.catch(noop$4);
    return p;
  }
  function drained() {
    if (queue2.idle()) {
      return new Promise(function(resolve8) {
        resolve8();
      });
    }
    var previousDrain = queue2.drain;
    var p = new Promise(function(resolve8) {
      queue2.drain = function() {
        previousDrain();
        resolve8();
      };
    });
    return p;
  }
}
function isFatalError(settings2, error) {
  if (settings2.errorFilter === null) {
    return true;
  }
  return !settings2.errorFilter(error);
}
function isAppliedFilter(filter2, value2) {
  return filter2 === null || filter2(value2);
}
function replacePathSegmentSeparator(filepath, separator) {
  return filepath.split(/[/\\]/).join(separator);
}
function joinPathSegments(a, b, separator) {
  if (a === "") {
    return b;
  }
  if (a.endsWith(separator)) {
    return a + b;
  }
  return a + separator + b;
}
function callFailureCallback(callback, error) {
  callback(error);
}
function callSuccessCallback(callback, entries) {
  callback(null, entries);
}
function walk$2(directory, optionsOrSettingsOrCallback, callback) {
  if (typeof optionsOrSettingsOrCallback === "function") {
    new async_1$2.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
    return;
  }
  new async_1$2.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
}
function walkSync(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new sync_1$2.default(directory, settings2);
  return provider2.read();
}
function walkStream(directory, optionsOrSettings) {
  const settings2 = getSettings(optionsOrSettings);
  const provider2 = new stream_1$4.default(directory, settings2);
  return provider2.read();
}
function getSettings(settingsOrOptions = {}) {
  if (settingsOrOptions instanceof settings_1$1.default) {
    return settingsOrOptions;
  }
  return new settings_1$1.default(settingsOrOptions);
}
async function FastGlob(source, options2) {
  assertPatternsInput(source);
  const works = getWorks(source, async_1.default, options2);
  const result = await Promise.all(works);
  return utils.array.flatten(result);
}
function getWorks(source, _Provider, options2) {
  const patterns = [].concat(source);
  const settings2 = new settings_1.default(options2);
  const tasks2 = taskManager.generate(patterns, settings2);
  const provider2 = new _Provider(settings2);
  return tasks2.map(provider2.read, provider2);
}
function assertPatternsInput(input) {
  const source = [].concat(input);
  const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
  if (!isValidSource) {
    throw new TypeError("Patterns must be a string (non empty) or an array of strings");
  }
}
function getDefaultSearchPlaces(name2, sync2) {
  return [
    "package.json",
    `.${name2}rc.json`,
    `.${name2}rc.js`,
    `.${name2}rc.cjs`,
    ...sync2 ? [] : [`.${name2}rc.mjs`],
    `.config/${name2}rc`,
    `.config/${name2}rc.json`,
    `.config/${name2}rc.js`,
    `.config/${name2}rc.cjs`,
    ...sync2 ? [] : [`.config/${name2}rc.mjs`],
    `${name2}.config.js`,
    `${name2}.config.cjs`,
    ...sync2 ? [] : [`${name2}.config.mjs`]
  ];
}
function parentDir(p) {
  return path$a.dirname(p) || path$a.sep;
}
function getOptions(name2, options2, sync2) {
  const conf = {
    stopDir: os$3.homedir(),
    searchPlaces: getDefaultSearchPlaces(name2, sync2),
    ignoreEmptySearchPlaces: true,
    cache: true,
    transform: (x) => x,
    packageProp: [name2],
    ...options2,
    loaders: {
      ...sync2 ? defaultLoadersSync : defaultLoaders,
      ...options2.loaders
    }
  };
  conf.searchPlaces.forEach((place) => {
    const key = path$a.extname(place) || "noExt";
    const loader = conf.loaders[key];
    if (!loader) {
      throw new Error(`Missing loader for extension "${place}"`);
    }
    if (typeof loader !== "function") {
      throw new Error(
        `Loader for extension "${place}" is not a function: Received ${typeof loader}.`
      );
    }
  });
  return conf;
}
function getPackageProp(props, obj) {
  if (typeof props === "string" && props in obj) return obj[props];
  return (Array.isArray(props) ? props : props.split(".")).reduce(
    (acc, prop) => acc === void 0 ? acc : acc[prop],
    obj
  ) || null;
}
function validateFilePath(filepath) {
  if (!filepath) throw new Error("load must pass a non-empty string");
}
function validateLoader(loader, ext2) {
  if (!loader) throw new Error(`No loader specified for extension "${ext2}"`);
  if (typeof loader !== "function") throw new Error("loader is not a function");
}
function isCollection$1(node3) {
  if (node3 && typeof node3 === "object")
    switch (node3[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode$1(node3) {
  if (node3 && typeof node3 === "object")
    switch (node3[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
function visit$1(node3, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node3)) {
    const cd = visit_(null, node3.contents, visitor_, Object.freeze([node3]));
    if (cd === REMOVE$1)
      node3.contents = null;
  } else
    visit_(null, node3, visitor_, Object.freeze([]));
}
function visit_(key, node3, visitor, path9) {
  const ctrl = callVisitor(key, node3, visitor, path9);
  if (isNode$1(ctrl) || isPair(ctrl)) {
    replaceNode(key, path9, ctrl);
    return visit_(key, ctrl, visitor, path9);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node3)) {
      path9 = Object.freeze(path9.concat(node3));
      for (let i = 0; i < node3.items.length; ++i) {
        const ci = visit_(i, node3.items[i], visitor, path9);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node3.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node3)) {
      path9 = Object.freeze(path9.concat(node3));
      const ck = visit_("key", node3.key, visitor, path9);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node3.key = null;
      const cv = visit_("value", node3.value, visitor, path9);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node3.value = null;
    }
  }
  return ctrl;
}
async function visitAsync(node3, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node3)) {
    const cd = await visitAsync_(null, node3.contents, visitor_, Object.freeze([node3]));
    if (cd === REMOVE$1)
      node3.contents = null;
  } else
    await visitAsync_(null, node3, visitor_, Object.freeze([]));
}
async function visitAsync_(key, node3, visitor, path9) {
  const ctrl = await callVisitor(key, node3, visitor, path9);
  if (isNode$1(ctrl) || isPair(ctrl)) {
    replaceNode(key, path9, ctrl);
    return visitAsync_(key, ctrl, visitor, path9);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection$1(node3)) {
      path9 = Object.freeze(path9.concat(node3));
      for (let i = 0; i < node3.items.length; ++i) {
        const ci = await visitAsync_(i, node3.items[i], visitor, path9);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK$1)
          return BREAK$1;
        else if (ci === REMOVE$1) {
          node3.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node3)) {
      path9 = Object.freeze(path9.concat(node3));
      const ck = await visitAsync_("key", node3.key, visitor, path9);
      if (ck === BREAK$1)
        return BREAK$1;
      else if (ck === REMOVE$1)
        node3.key = null;
      const cv = await visitAsync_("value", node3.value, visitor, path9);
      if (cv === BREAK$1)
        return BREAK$1;
      else if (cv === REMOVE$1)
        node3.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node3, visitor, path9) {
  if (typeof visitor === "function")
    return visitor(key, node3, path9);
  if (isMap(node3))
    return visitor.Map?.(key, node3, path9);
  if (isSeq(node3))
    return visitor.Seq?.(key, node3, path9);
  if (isPair(node3))
    return visitor.Pair?.(key, node3, path9);
  if (isScalar$1(node3))
    return visitor.Scalar?.(key, node3, path9);
  if (isAlias(node3))
    return visitor.Alias?.(key, node3, path9);
  return void 0;
}
function replaceNode(key, path9, node3) {
  const parent = path9[path9.length - 1];
  if (isCollection$1(parent)) {
    parent.items[key] = node3;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node3;
    else
      parent.value = node3;
  } else if (isDocument(parent)) {
    parent.contents = node3;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root4) {
  const anchors = /* @__PURE__ */ new Set();
  visit$1(root4, {
    Value(_key, node3) {
      if (node3.anchor)
        anchors.add(node3.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name2 = `${prefix}${i}`;
    if (!exclude.has(name2))
      return name2;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      if (!prevAnchors)
        prevAnchors = anchorNames(doc);
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref = sourceObjects.get(source);
        if (typeof ref === "object" && ref.anchor && (isScalar$1(ref.node) || isCollection$1(ref.node))) {
          ref.node.anchor = ref.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
function toJS(value2, arg, ctx) {
  if (Array.isArray(value2))
    return value2.map((v, i) => toJS(v, String(i), ctx));
  if (value2 && typeof value2.toJSON === "function") {
    if (!ctx || !hasAnchor(value2))
      return value2.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value2, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value2.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value2 === "bigint" && !ctx?.keep)
    return Number(value2);
  return value2;
}
function getAliasCount(doc, node3, anchors) {
  if (isAlias(node3)) {
    const source = node3.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection$1(node3)) {
    let count = 0;
    for (const item of node3.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node3)) {
    const kc = getAliasCount(doc, node3.key, anchors);
    const vc = getAliasCount(doc, node3.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
function findTagObject(value2, tagName, tags) {
  if (tagName) {
    const match2 = tags.filter((t) => t.tag === tagName);
    const tagObj = match2.find((t) => !t.format) ?? match2[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags.find((t) => t.identify?.(value2) && !t.format);
}
function createNode(value2, tagName, ctx) {
  if (isDocument(value2))
    value2 = value2.contents;
  if (isNode$1(value2))
    return value2;
  if (isPair(value2)) {
    const map = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map.items.push(value2);
    return map;
  }
  if (value2 instanceof String || value2 instanceof Number || value2 instanceof Boolean || typeof BigInt !== "undefined" && value2 instanceof BigInt) {
    value2 = value2.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref = void 0;
  if (aliasDuplicateObjects && value2 && typeof value2 === "object") {
    ref = sourceObjects.get(value2);
    if (ref) {
      if (!ref.anchor)
        ref.anchor = onAnchor(value2);
      return new Alias(ref.anchor);
    } else {
      ref = { anchor: null, node: null };
      sourceObjects.set(value2, ref);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value2, tagName, schema2.tags);
  if (!tagObj) {
    if (value2 && typeof value2.toJSON === "function") {
      value2 = value2.toJSON();
    }
    if (!value2 || typeof value2 !== "object") {
      const node4 = new Scalar(value2);
      if (ref)
        ref.node = node4;
      return node4;
    }
    tagObj = value2 instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value2) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node3 = tagObj?.createNode ? tagObj.createNode(ctx.schema, value2, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value2, ctx) : new Scalar(value2);
  if (tagName)
    node3.tag = tagName;
  else if (!tagObj.default)
    node3.tag = tagObj.tag;
  if (ref)
    ref.node = node3;
  return node3;
}
function collectionFromPath(schema2, path9, value2) {
  let v = value2;
  for (let i = path9.length - 1; i >= 0; --i) {
    const k = path9[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
function indentComment(comment4, indent) {
  if (/^\n+$/.test(comment4))
    return comment4.substring(1);
  return indent ? comment4.replace(/^(?! *$)/gm, indent) : comment4;
}
function foldFlowLines(text2, indent, mode2 = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text2;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text2.length <= endStep)
    return text2;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode2 === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text2, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text2[i += 1]; ) {
    if (mode2 === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text2[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode2 === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text2, i, indent.length);
      end = i + indent.length + endStep;
      split = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text2[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split = i;
      }
      if (i >= end) {
        if (split) {
          folds.push(split);
          end = split + endStep;
          split = void 0;
        } else if (mode2 === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text2[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text2;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text2;
  if (onFold)
    onFold();
  let res = text2.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text2.length;
    if (fold === 0)
      res = `
${indent}${text2.slice(0, end2)}`;
    else {
      if (mode2 === FOLD_QUOTED && escapedFolds[fold])
        res += `${text2[fold]}\\`;
      res += `
${indent}${text2.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text2, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text2[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text2[++i];
    } else {
      do {
        ch = text2[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text2[start];
    }
  }
  return end;
}
function lineLengthOverLimit(str2, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit = lineWidth - indentLength;
  const strLen = str2.length;
  if (strLen <= limit)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str2[i] === "\n") {
      if (i - start > limit)
        return true;
      start = i + 1;
      if (strLen - start <= limit)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value2, ctx) {
  const json = JSON.stringify(value2);
  if (ctx.options.doubleQuotedAsJSON)
    return json;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
  let str2 = "";
  let start = 0;
  for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
    if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
      str2 += json.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json[i + 1]) {
        case "u":
          {
            str2 += json.slice(start, i);
            const code = json.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str2 += "\\0";
                break;
              case "0007":
                str2 += "\\a";
                break;
              case "000b":
                str2 += "\\v";
                break;
              case "001b":
                str2 += "\\e";
                break;
              case "0085":
                str2 += "\\N";
                break;
              case "00a0":
                str2 += "\\_";
                break;
              case "2028":
                str2 += "\\L";
                break;
              case "2029":
                str2 += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str2 += "\\x" + code.substr(2);
                else
                  str2 += json.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
            i += 1;
          } else {
            str2 += json.slice(start, i) + "\n\n";
            while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
              str2 += "\n";
              i += 2;
            }
            str2 += indent;
            if (json[i + 2] === " ")
              str2 += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str2 = start ? str2 + json.slice(start) : json;
  return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value2, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value2.includes("\n") || /[ \t]\n|\n[ \t]/.test(value2))
    return doubleQuotedString(value2, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value2) ? "  " : "");
  const res = "'" + value2.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value2, ctx) {
  const { singleQuote: singleQuote3 } = ctx.options;
  let qs;
  if (singleQuote3 === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value2.includes('"');
    const hasSingle = value2.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote3 ? singleQuotedString : doubleQuotedString;
  }
  return qs(value2, ctx);
}
function blockString({ comment: comment4, type, value: value2 }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value2) || /^\s*$/.test(value2)) {
    return quotedString(value2, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value2) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value2, lineWidth, indent.length);
  if (!value2)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value2.length; endStart > 0; --endStart) {
    const ch = value2[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value2.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value2 === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value2 = value2.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value2.length; ++startEnd) {
    const ch = value2[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value2.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value2 = value2.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (literal ? "|" : ">") + (startWithSpace ? indentSize : "") + chomp;
  if (comment4) {
    header += " " + commentString(comment4.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (literal) {
    value2 = value2.replace(/\n+/g, `$&${indent}`);
    return `${header}
${indent}${start}${value2}${end}`;
  }
  value2 = value2.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
  const body = foldFlowLines(`${start}${value2}${end}`, indent, FOLD_BLOCK, getFoldOptions(ctx, true));
  return `${header}
${indent}${body}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value: value2 } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value2.includes("\n") || inFlow && /[[\]{},]/.test(value2)) {
    return quotedString(value2, ctx);
  }
  if (!value2 || /^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value2)) {
    return implicitKey || inFlow || !value2.includes("\n") ? quotedString(value2, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value2.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value2)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value2, ctx);
    }
  }
  const str2 = value2.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag3) => tag3.default && tag3.tag !== "tag:yaml.org,2002:str" && tag3.test?.test(str2);
    const { compat, tags } = ctx.doc.schema;
    if (tags.some(test) || compat?.some(test))
      return quotedString(value2, ctx);
  }
  return implicitKey ? str2 : foldFlowLines(str2, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
function createStringifyContext(doc, options2) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options2);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags, item) {
  if (item.tag) {
    const match2 = tags.filter((t) => t.tag === item.tag);
    if (match2.length > 0)
      return match2.find((t) => t.format === item.format) ?? match2[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar$1(item)) {
    obj = item.value;
    const match2 = tags.filter((t) => t.identify?.(obj));
    tagObj = match2.find((t) => t.format === item.format) ?? match2.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name2 = obj?.constructor?.name ?? typeof obj;
    throw new Error(`Tag not resolved for ${name2} value`);
  }
  return tagObj;
}
function stringifyProps(node3, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar$1(node3) || isCollection$1(node3)) && node3.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag3 = node3.tag ? node3.tag : tagObj.default ? null : tagObj.tag;
  if (tag3)
    props.push(doc.directives.tagString(tag3));
  return props.join(" ");
}
function stringify$2(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node3 = isNode$1(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  if (!tagObj)
    tagObj = getTagObject(ctx.doc.schema.tags, node3);
  const props = stringifyProps(node3, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str2 = typeof tagObj.stringify === "function" ? tagObj.stringify(node3, ctx, onComment, onChompKeep) : isScalar$1(node3) ? stringifyString(node3, ctx, onComment, onChompKeep) : node3.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str2;
  return isScalar$1(node3) || str2[0] === "{" || str2[0] === "[" ? `${props} ${str2}` : `${props}
${ctx.indent}${str2}`;
}
function stringifyPair({ key, value: value2 }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode$1(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection$1(key) || !isNode$1(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value2 == null && !ctx.inFlow || isCollection$1(key) || (isScalar$1(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str2 = stringify$2(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str2.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value2 == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str2 === "" ? "?" : explicitKey ? `? ${str2}` : str2;
    }
  } else if (allNullValues && !simpleKeys || value2 == null && explicitKey) {
    str2 = `? ${str2}`;
    if (keyComment && !keyCommentDone) {
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str2;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
    str2 = `? ${str2}
${indent}:`;
  } else {
    str2 = `${str2}:`;
    if (keyComment)
      str2 += lineComment(str2, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode$1(value2)) {
    vsb = !!value2.spaceBefore;
    vcb = value2.commentBefore;
    valueComment = value2.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value2 && typeof value2 === "object")
      value2 = doc.createNode(value2);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar$1(value2))
    ctx.indentAtStart = str2.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value2) && !value2.flow && !value2.tag && !value2.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$2(value2, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection$1(value2)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value2.flow ?? value2.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str2 += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str2 += lineComment(str2, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str2;
}
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    if (typeof process !== "undefined" && process.emitWarning)
      process.emitWarning(warning);
    else
      console.warn(warning);
  }
}
function addPairToJSMap(ctx, map, { key, value: value2 }) {
  if (ctx?.doc.schema.merge && isMergeKey(key)) {
    value2 = isAlias(value2) ? value2.resolve(ctx.doc) : value2;
    if (isSeq(value2))
      for (const it of value2.items)
        mergeToJSMap(ctx, map, it);
    else if (Array.isArray(value2))
      for (const it of value2)
        mergeToJSMap(ctx, map, it);
    else
      mergeToJSMap(ctx, map, value2);
  } else {
    const jsKey = toJS(key, "", ctx);
    if (map instanceof Map) {
      map.set(jsKey, toJS(value2, jsKey, ctx));
    } else if (map instanceof Set) {
      map.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value2, stringKey, ctx);
      if (stringKey in map)
        Object.defineProperty(map, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map[stringKey] = jsValue;
    }
  }
  return map;
}
function mergeToJSMap(ctx, map, value2) {
  const source = ctx && isAlias(value2) ? value2.resolve(ctx.doc) : value2;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value3] of srcMap) {
    if (map instanceof Map) {
      if (!map.has(key))
        map.set(key, value3);
    } else if (map instanceof Set) {
      map.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
      Object.defineProperty(map, key, {
        value: value3,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode$1(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node3 of ctx.anchors.keys())
      strCtx.anchors.add(node3.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key, value2, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value2, void 0, ctx);
  return new Pair(k, v);
}
function stringifyCollection(collection, ctx, options2) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify5 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify5(collection, ctx, options2);
}
function stringifyBlockCollection({ comment: comment4, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment5 = null;
    if (isNode$1(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment5 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode$1(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str3 = stringify$2(item, itemCtx, () => comment5 = null, () => chompKeep = true);
    if (comment5)
      str3 += lineComment(str3, itemIndent, commentString(comment5));
    if (chompKeep && comment5)
      chompKeep = false;
    lines.push(blockItemPrefix + str3);
  }
  let str2;
  if (lines.length === 0) {
    str2 = flowChars.start + flowChars.end;
  } else {
    str2 = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str2 += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment4) {
    str2 += "\n" + indentComment(commentString(comment4), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str2;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment4 = null;
    if (isNode$1(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment4 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode$1(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode$1(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment4 = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment4 = ik.comment;
      }
    }
    if (comment4)
      reqNewline = true;
    let str2 = stringify$2(item, itemCtx, () => comment4 = null);
    if (i < items.length - 1)
      str2 += ",";
    if (comment4)
      str2 += lineComment(str2, itemIndent, commentString(comment4));
    if (!reqNewline && (lines.length > linesAtValue || str2.includes("\n")))
      reqNewline = true;
    lines.push(str2);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str2 = start;
      for (const line of lines)
        str2 += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str2}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment4, chompKeep) {
  if (comment4 && chompKeep)
    comment4 = comment4.replace(/^\n+/, "");
  if (comment4) {
    const ic = indentComment(commentString(comment4), indent);
    lines.push(ic.trimStart());
  }
}
function findPair(items, key) {
  const k = isScalar$1(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar$1(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
function asItemIndex(key) {
  let idx = isScalar$1(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
function stringifyNumber({ format: format2, minFractionDigits, tag: tag3, value: value2 }) {
  if (typeof value2 === "bigint")
    return String(value2);
  const num = typeof value2 === "number" ? value2 : Number(value2);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value2);
  if (!format2 && minFractionDigits && (!tag3 || tag3 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}
function intStringify$1(node3, radix, prefix) {
  const { value: value2 } = node3;
  if (intIdentify$2(value2) && value2 >= 0)
    return prefix + value2.toString(radix);
  return stringifyNumber(node3);
}
function intIdentify$1(value2) {
  return typeof value2 === "bigint" || Number.isInteger(value2);
}
function resolvePairs(seq2, onError2) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError2("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError2("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value2;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value2 = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value2 = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value2, ctx));
    }
  return pairs2;
}
function boolStringify({ value: value2, source }, ctx) {
  const boolObj = value2 ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value2 ? ctx.options.trueStr : ctx.options.falseStr;
}
function intResolve(str2, offset, radix, { intAsBigInt }) {
  const sign = str2[0];
  if (sign === "-" || sign === "+")
    offset += 1;
  str2 = str2.substring(offset).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str2 = `0b${str2}`;
        break;
      case 8:
        str2 = `0o${str2}`;
        break;
      case 16:
        str2 = `0x${str2}`;
        break;
    }
    const n2 = BigInt(str2);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str2, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify(node3, radix, prefix) {
  const { value: value2 } = node3;
  if (intIdentify(value2)) {
    const str2 = value2.toString(radix);
    return value2 < 0 ? "-" + prefix + str2.substr(1) : prefix + str2;
  }
  return stringifyNumber(node3);
}
function parseSexagesimal(str2, asBigInt) {
  const sign = str2[0];
  const parts = sign === "-" || sign === "+" ? str2.substring(1) : str2;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node3) {
  let { value: value2 } = node3;
  let num = (n) => n;
  if (typeof value2 === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value2) || !isFinite(value2))
    return stringifyNumber(node3);
  let sign = "";
  if (value2 < 0) {
    sign = "-";
    value2 *= num(-1);
  }
  const _60 = num(60);
  const parts = [value2 % _60];
  if (value2 < 60) {
    parts.unshift(0);
  } else {
    value2 = (value2 - parts[0]) / _60;
    parts.unshift(value2 % _60);
    if (value2 >= 60) {
      value2 = (value2 - parts[0]) / _60;
      parts.unshift(value2);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
function getTags(customTags, schemaName) {
  let tags = schemas.get(schemaName);
  if (!tags) {
    if (Array.isArray(customTags))
      tags = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag3 of customTags)
      tags = tags.concat(tag3);
  } else if (typeof customTags === "function") {
    tags = customTags(tags.slice());
  }
  return tags.map((tag3) => {
    if (typeof tag3 !== "string")
      return tag3;
    const tagObj = tagsByName[tag3];
    if (tagObj)
      return tagObj;
    const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
    throw new Error(`Unknown custom tag "${tag3}"; use one of ${keys}`);
  });
}
function stringifyDocument(doc, options2) {
  const lines = [];
  let hasDirectives = options2.directives === true;
  if (options2.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options2);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode$1(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$2(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$2(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
function assertCollection(contents2) {
  if (isCollection$1(contents2))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
function resolveProps(tokens, { flow, indicator, next, offset, onError: onError2, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment4 = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab2 = null;
  let anchor = null;
  let tag3 = null;
  let newlineAfterProp = null;
  let comma5 = null;
  let found2 = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError2(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab2) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError2(tab2, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab2 = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
          tab2 = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError2(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment4)
          comment4 = cb;
        else
          comment4 += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment4)
            comment4 += token.source;
          else
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag3)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError2(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError2(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag3)
          onError2(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag3 = token;
        if (start === null)
          start = token.offset;
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag3)
          onError2(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found2)
          onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found2 = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma5)
            onError2(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma5 = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last = tokens[tokens.length - 1];
  const end = last ? last.offset + last.source.length : offset;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError2(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab2 && (atNewline && tab2.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
    onError2(tab2, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma: comma5,
    found: found2,
    spaceBefore,
    comment: comment4,
    hasNewline,
    anchor,
    tag: tag3,
    newlineAfterProp,
    end,
    start: start ?? end
  };
}
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent, fc, onError2) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError2(end, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx, items, search) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar$1(a) && isScalar$1(b) && a.value === b.value && !(a.value === "<<" && ctx.schema.merge);
  return items.some((pair) => isEqual(pair.key, search));
}
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError2, tag3) {
  const NodeClass = tag3?.nodeClass ?? YAMLMap;
  const map = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep: sep2, value: value2 } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset,
      onError: onError2,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError2(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError2(offset, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep2) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map.comment)
            map.comment += "\n" + keyProps.comment;
          else
            map.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError2(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError2(offset, "BAD_INDENT", startColMsg);
    }
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError2) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError2);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError2);
    if (mapIncludes(ctx, map.items, keyNode))
      onError2(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep2 ?? [], {
      indicator: "map-value-ind",
      next: value2,
      offset: keyNode.range[2],
      onError: onError2,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value2?.type === "block-map" && !valueProps.hasNewline)
          onError2(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError2(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value2 ? composeNode2(ctx, value2, valueProps, onError2) : composeEmptyNode2(ctx, offset, sep2, null, valueProps, onError2);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value2, onError2);
      offset = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map.items.push(pair);
    } else {
      if (implicitKey)
        onError2(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset)
    onError2(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map.range = [bm.offset, offset, commentEnd ?? offset];
  return map;
}
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError2, tag3) {
  const NodeClass = tag3?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset = bs.offset;
  let commentEnd = null;
  for (const { start, value: value2 } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value2,
      offset,
      onError: onError2,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value2) {
        if (value2 && value2.type === "block-seq")
          onError2(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError2(offset, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node3 = value2 ? composeNode2(ctx, value2, props, onError2) : composeEmptyNode2(ctx, props.end, start, null, props, onError2);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value2, onError2);
    offset = node3.range[2];
    seq2.items.push(node3);
  }
  seq2.range = [bs.offset, offset, commentEnd ?? offset];
  return seq2;
}
function resolveEnd(end, offset, reqSpace, onError2) {
  let comment4 = "";
  if (end) {
    let hasSpace = false;
    let sep2 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError2(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment4)
            comment4 = cb;
          else
            comment4 += sep2 + cb;
          sep2 = "";
          break;
        }
        case "newline":
          if (comment4)
            sep2 += source;
          hasSpace = true;
          break;
        default:
          onError2(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset += source.length;
    }
  }
  return { comment: comment4, offset };
}
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError2, tag3) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag3?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  let offset = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep: sep2, value: value2 } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset,
      onError: onError2,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep2 && !value2) {
        if (i === 0 && props.comma)
          onError2(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError2(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError2(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError2(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError2(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep2 && !props.found) {
      const valueNode = value2 ? composeNode2(ctx, value2, props, onError2) : composeEmptyNode2(ctx, props.end, sep2, null, props, onError2);
      coll.items.push(valueNode);
      offset = valueNode.range[2];
      if (isBlock$1(value2))
        onError2(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError2) : composeEmptyNode2(ctx, keyStart, start, null, props, onError2);
      if (isBlock$1(key))
        onError2(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      const valueProps = resolveProps(sep2 ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value2,
        offset: keyNode.range[2],
        onError: onError2,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep2)
            for (const st of sep2) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError2(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError2(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value2) {
        if ("source" in value2 && value2.source && value2.source[0] === ":")
          onError2(value2, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError2(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value2 ? composeNode2(ctx, value2, valueProps, onError2) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep2, null, valueProps, onError2) : null;
      if (valueNode) {
        if (isBlock$1(value2))
          onError2(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map = coll;
        if (mapIncludes(ctx, map.items, keyNode))
          onError2(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map.items.push(pair);
      } else {
        const map = new YAMLMap(ctx.schema);
        map.flow = true;
        map.items.push(pair);
        coll.items.push(map);
      }
      offset = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name2 = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name2} must end with a ${expectedEnd}` : `${name2} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError2(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError2);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function resolveCollection(CN2, ctx, token, onError2, tagName, tag3) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError2, tag3) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError2, tag3) : resolveFlowCollection(CN2, ctx, token, onError2, tag3);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError2) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message = "Missing newline after block sequence props";
      onError2(lastProp, "MISSING_CHAR", message);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError2, tagName);
  }
  let tag3 = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag3) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag3 = kt;
    } else {
      if (kt?.collection) {
        onError2(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection}`, true);
      } else {
        onError2(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError2, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError2, tagName, tag3);
  const res = tag3.resolve?.(coll, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node3 = isNode$1(res) ? res : new Scalar(res);
  node3.range = coll.range;
  node3.tag = tagName;
  if (tag3?.format)
    node3.format = tag3.format;
  return node3;
}
function resolveBlockScalar(ctx, scalar, onError2) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError2);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value3 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value3, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError2(offset + indent.length, "MISSING_CHAR", message);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message = "Block scalar values in collections must be indented";
        onError2(offset, "BAD_INDENT", message);
      }
      break;
    }
    offset += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value2 = "";
  let sep2 = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value2 += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src3 = header.indent ? "explicit indentation indicator" : "first line";
      const message = `Block scalar lines must not be less indented than their ${src3}`;
      onError2(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep2 === " ")
        sep2 = "\n";
      else if (!prevMoreIndented && sep2 === "\n")
        sep2 = "\n\n";
      value2 += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep2 === "\n")
        value2 += "\n";
      else
        sep2 = "\n";
    } else {
      value2 += sep2 + content;
      sep2 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value2 += "\n" + lines[i][0].slice(trimIndent);
      if (value2[value2.length - 1] !== "\n")
        value2 += "\n";
      break;
    default:
      value2 += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value: value2, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError2) {
  if (props[0].type !== "block-scalar-header") {
    onError2(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode2 = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset + i;
    }
  }
  if (error !== -1)
    onError2(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment4 = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message = "Comments must be separated from other tokens by white space characters";
          onError2(token, "MISSING_CHAR", message);
        }
        length += token.source.length;
        comment4 = token.source.substring(1);
        break;
      case "error":
        onError2(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message = `Unexpected token in block scalar header: ${token.type}`;
        onError2(token, "UNEXPECTED_TOKEN", message);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode: mode2, indent, chomp, comment: comment4, length };
}
function splitLines(source) {
  const split = source.split(/\n( *)/);
  const first2 = split[0];
  const m = first2.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
  const lines = [line0];
  for (let i = 1; i < split.length; i += 2)
    lines.push([split[i], split[i + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError2) {
  const { offset, type, source, end } = scalar;
  let _type;
  let value2;
  const _onError = (rel, code, msg) => onError2(offset + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value2 = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value2 = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value2 = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError2(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset, offset + source.length, offset + source.length]
      };
  }
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError2);
  return {
    value: value2,
    type: _type,
    comment: re.comment,
    range: [offset, valueEnd, re.offset]
  };
}
function plainValue(source, onError2) {
  let badChar = "";
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError2(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError2) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError2(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first2, line;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch (_) {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match2 = first2.exec(source);
  if (!match2)
    return source;
  let res = match2[1];
  let sep2 = " ";
  let pos = first2.lastIndex;
  line.lastIndex = pos;
  while (match2 = line.exec(source)) {
    if (match2[1] === "") {
      if (sep2 === "\n")
        res += sep2;
      else
        sep2 = "\n";
    } else {
      res += sep2 + match2[1];
      sep2 = " ";
    }
    pos = line.lastIndex;
  }
  const last = /[ \t]*(.*)/sy;
  last.lastIndex = pos;
  match2 = last.exec(source);
  return res + sep2 + (match2?.[1] ?? "");
}
function doubleQuotedValue(source, onError2) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset } = foldNewline(source, i);
      res += fold;
      i = offset;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError2);
        i += length;
      } else {
        const raw = source.substr(i - 1, 2);
        onError2(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        res += raw;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError2(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset) {
  let fold = "";
  let ch = source[offset + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset += 1;
    ch = source[offset + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset };
}
function parseCharCode(source, offset, length, onError2) {
  const cc = source.substr(offset, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw = source.substr(offset - 2, length + 2);
    onError2(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
    return raw;
  }
  return String.fromCodePoint(code);
}
function composeScalar(ctx, token, tagToken, onError2) {
  const { value: value2, type, comment: comment4, range: range2 } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError2) : resolveFlowScalar(token, ctx.options.strict, onError2);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError2(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  const tag3 = tagToken && tagName ? findScalarTagByName(ctx.schema, value2, tagName, tagToken, onError2) : token.type === "scalar" ? findScalarTagByTest(ctx, value2, token, onError2) : ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag3.resolve(value2, (msg) => onError2(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar$1(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError2(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value2);
  }
  scalar.range = range2;
  scalar.source = value2;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag3.format)
    scalar.format = tag3.format;
  if (comment4)
    scalar.comment = comment4;
  return scalar;
}
function findScalarTagByName(schema2, value2, tagName, tagToken, onError2) {
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag3 of schema2.tags) {
    if (!tag3.collection && tag3.tag === tagName) {
      if (tag3.default && tag3.test)
        matchWithTest.push(tag3);
      else
        return tag3;
    }
  }
  for (const tag3 of matchWithTest)
    if (tag3.test?.test(value2))
      return tag3;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError2(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
function findScalarTagByTest({ directives, schema: schema2 }, value2, token, onError2) {
  const tag3 = schema2.tags.find((tag4) => tag4.default && tag4.test?.test(value2)) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = schema2.compat.find((tag4) => tag4.default && tag4.test?.test(value2)) ?? schema2[SCALAR$1];
    if (tag3.tag !== compat.tag) {
      const ts = directives.tagString(tag3.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError2(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag3;
}
function emptyScalarPosition(offset, before, pos) {
  if (before) {
    if (pos === null)
      pos = before.length;
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset -= st.source.length;
          continue;
      }
      st = before[++i];
      while (st?.type === "space") {
        offset += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset;
}
function composeNode(ctx, token, props, onError2) {
  const { spaceBefore, comment: comment4, anchor, tag: tag3 } = props;
  let node3;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node3 = composeAlias(ctx, token, onError2);
      if (anchor || tag3)
        onError2(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node3 = composeScalar(ctx, token, tag3, onError2);
      if (anchor)
        node3.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node3 = composeCollection(CN, ctx, token, props, onError2);
      if (anchor)
        node3.anchor = anchor.source.substring(1);
      break;
    default: {
      const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError2(token, "UNEXPECTED_TOKEN", message);
      node3 = composeEmptyNode(ctx, token.offset, void 0, null, props, onError2);
      isSrcToken = false;
    }
  }
  if (anchor && node3.anchor === "")
    onError2(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (spaceBefore)
    node3.spaceBefore = true;
  if (comment4) {
    if (token.type === "scalar" && token.source === "")
      node3.comment = comment4;
    else
      node3.commentBefore = comment4;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node3.srcToken = token;
  return node3;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment: comment4, anchor, tag: tag3, end }, onError2) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset, before, pos),
    indent: -1,
    source: ""
  };
  const node3 = composeScalar(ctx, token, tag3, onError2);
  if (anchor) {
    node3.anchor = anchor.source.substring(1);
    if (node3.anchor === "")
      onError2(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node3.spaceBefore = true;
  if (comment4) {
    node3.comment = comment4;
    node3.range[2] = end;
  }
  return node3;
}
function composeAlias({ options: options2 }, { offset, source, end }, onError2) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError2(offset, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError2(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset + source.length;
  const re = resolveEnd(end, valueEnd, options2.strict, onError2);
  alias.range = [offset, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}
function composeDoc(options2, directives, { offset, start, value: value2, end }, onError2) {
  const opts = Object.assign({ _directives: directives }, options2);
  const doc = new Document2(void 0, opts);
  const ctx = {
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value2 ?? end?.[0],
    offset,
    onError: onError2,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value2 && (value2.type === "block-map" || value2.type === "block-seq") && !props.hasNewline)
      onError2(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value2 ? composeNode(ctx, value2, props, onError2) : composeEmptyNode(ctx, props.end, start, null, props, onError2);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError2);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset, contentEnd, re.offset];
  return doc;
}
function getErrorPos(src3) {
  if (typeof src3 === "number")
    return [src3, src3 + 1];
  if (Array.isArray(src3))
    return src3.length === 2 ? src3 : [src3[0], src3[1]];
  const { offset, source } = src3;
  return [offset, offset + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment4 = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment4 += (comment4 === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment: comment4, afterEmptyLine };
}
function resolveAsScalar(token, strict = true, onError2) {
  if (token) {
    const _onError = (pos, code, message) => {
      const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
      if (onError2)
        onError2(offset, code, message);
      else
        throw new YAMLParseError([offset, offset + 1], code, message);
    };
    switch (token.type) {
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return resolveFlowScalar(token, strict, _onError);
      case "block-scalar":
        return resolveBlockScalar({ options: { strict } }, token, _onError);
    }
  }
  return null;
}
function createScalarToken(value2, context) {
  const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
  const source = stringifyString({ type, value: value2 }, {
    implicitKey,
    indent: indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  const end = context.end ?? [
    { type: "newline", offset: -1, indent, source: "\n" }
  ];
  switch (source[0]) {
    case "|":
    case ">": {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      const props = [
        { type: "block-scalar-header", offset, indent, source: head }
      ];
      if (!addEndtoBlockProps(props, end))
        props.push({ type: "newline", offset: -1, indent, source: "\n" });
      return { type: "block-scalar", offset, indent, props, source: body };
    }
    case '"':
      return { type: "double-quoted-scalar", offset, indent, source, end };
    case "'":
      return { type: "single-quoted-scalar", offset, indent, source, end };
    default:
      return { type: "scalar", offset, indent, source, end };
  }
}
function setScalarValue(token, value2, context = {}) {
  let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
  let indent = "indent" in token ? token.indent : null;
  if (afterKey && typeof indent === "number")
    indent += 2;
  if (!type)
    switch (token.type) {
      case "single-quoted-scalar":
        type = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        type = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        type = "PLAIN";
    }
  const source = stringifyString({ type, value: value2 }, {
    implicitKey: implicitKey || indent === null,
    indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
    inFlow,
    options: { blockQuote: true, lineWidth: -1 }
  });
  switch (source[0]) {
    case "|":
    case ">":
      setBlockScalarValue(token, source);
      break;
    case '"':
      setFlowScalarValue(token, source, "double-quoted-scalar");
      break;
    case "'":
      setFlowScalarValue(token, source, "single-quoted-scalar");
      break;
    default:
      setFlowScalarValue(token, source, "scalar");
  }
}
function setBlockScalarValue(token, source) {
  const he = source.indexOf("\n");
  const head = source.substring(0, he);
  const body = source.substring(he + 1) + "\n";
  if (token.type === "block-scalar") {
    const header = token.props[0];
    if (header.type !== "block-scalar-header")
      throw new Error("Invalid block scalar header");
    header.source = head;
    token.source = body;
  } else {
    const { offset } = token;
    const indent = "indent" in token ? token.indent : -1;
    const props = [
      { type: "block-scalar-header", offset, indent, source: head }
    ];
    if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
      props.push({ type: "newline", offset: -1, indent, source: "\n" });
    for (const key of Object.keys(token))
      if (key !== "type" && key !== "offset")
        delete token[key];
    Object.assign(token, { type: "block-scalar", indent, props, source: body });
  }
}
function addEndtoBlockProps(props, end) {
  if (end)
    for (const st of end)
      switch (st.type) {
        case "space":
        case "comment":
          props.push(st);
          break;
        case "newline":
          props.push(st);
          return true;
      }
  return false;
}
function setFlowScalarValue(token, source, type) {
  switch (token.type) {
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      token.type = type;
      token.source = source;
      break;
    case "block-scalar": {
      const end = token.props.slice(1);
      let oa = source.length;
      if (token.props[0].type === "block-scalar-header")
        oa -= token.props[0].source.length;
      for (const tok of end)
        tok.offset += oa;
      delete token.props;
      Object.assign(token, { type, source, end });
      break;
    }
    case "block-map":
    case "block-seq": {
      const offset = token.offset + source.length;
      const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
      delete token.items;
      Object.assign(token, { type, source, end: [nl] });
      break;
    }
    default: {
      const indent = "indent" in token ? token.indent : -1;
      const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
      for (const key of Object.keys(token))
        if (key !== "type" && key !== "offset")
          delete token[key];
      Object.assign(token, { type, indent, source, end });
    }
  }
}
function stringifyToken(token) {
  switch (token.type) {
    case "block-scalar": {
      let res = "";
      for (const tok of token.props)
        res += stringifyToken(tok);
      return res + token.source;
    }
    case "block-map":
    case "block-seq": {
      let res = "";
      for (const item of token.items)
        res += stringifyItem(item);
      return res;
    }
    case "flow-collection": {
      let res = token.start.source;
      for (const item of token.items)
        res += stringifyItem(item);
      for (const st of token.end)
        res += st.source;
      return res;
    }
    case "document": {
      let res = stringifyItem(token);
      if (token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
    default: {
      let res = token.source;
      if ("end" in token && token.end)
        for (const st of token.end)
          res += st.source;
      return res;
    }
  }
}
function stringifyItem({ start, key, sep: sep2, value: value2 }) {
  let res = "";
  for (const st of start)
    res += st.source;
  if (key)
    res += stringifyToken(key);
  if (sep2)
    for (const st of sep2)
      res += st.source;
  if (value2)
    res += stringifyToken(value2);
  return res;
}
function visit(cst2, visitor) {
  if ("type" in cst2 && cst2.type === "document")
    cst2 = { start: cst2.start, value: cst2.value };
  _visit(Object.freeze([]), cst2, visitor);
}
function _visit(path9, item, visitor) {
  let ctrl = visitor(item, path9);
  if (typeof ctrl === "symbol")
    return ctrl;
  for (const field of ["key", "value"]) {
    const token = item[field];
    if (token && "items" in token) {
      for (let i = 0; i < token.items.length; ++i) {
        const ci = _visit(Object.freeze(path9.concat([[field, i]])), token.items[i], visitor);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          token.items.splice(i, 1);
          i -= 1;
        }
      }
      if (typeof ctrl === "function" && field === "key")
        ctrl = ctrl(item, path9);
    }
  }
  return typeof ctrl === "function" ? ctrl(item, path9) : ctrl;
}
function prettyToken(token) {
  switch (token) {
    case BOM:
      return "<BOM>";
    case DOCUMENT:
      return "<DOC>";
    case FLOW_END:
      return "<FLOW_END>";
    case SCALAR:
      return "<SCALAR>";
    default:
      return JSON.stringify(token);
  }
}
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function isEmpty(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
function includesToken(list2, type) {
  for (let i = 0; i < list2.length; ++i)
    if (list2[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list2) {
  for (let i = 0; i < list2.length; ++i) {
    switch (list2[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
function parseOptions(options2) {
  const prettyErrors = options2.prettyErrors !== false;
  const lineCounter = options2.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseAllDocuments(source, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser2(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  const docs = Array.from(composer.compose(parser2.parse(source)));
  if (prettyErrors && lineCounter)
    for (const doc of docs) {
      doc.errors.forEach(prettifyError(source, lineCounter));
      doc.warnings.forEach(prettifyError(source, lineCounter));
    }
  if (docs.length > 0)
    return docs;
  return Object.assign([], { empty: true }, composer.streamInfo());
}
function parseDocument(source, options2 = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options2);
  const parser2 = new Parser2(lineCounter?.addNewLine);
  const composer = new Composer(options2);
  let doc = null;
  for (const _doc of composer.compose(parser2.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse$a(src3, reviver, options2) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options2 === void 0 && reviver && typeof reviver === "object") {
    options2 = reviver;
  }
  const doc = parseDocument(src3, options2);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options2));
}
function stringify4(value2, replacer, options2) {
  let _replacer = null;
  if (typeof replacer === "function" || Array.isArray(replacer)) {
    _replacer = replacer;
  } else if (options2 === void 0 && replacer) {
    options2 = replacer;
  }
  if (typeof options2 === "string")
    options2 = options2.length;
  if (typeof options2 === "number") {
    const indent = Math.round(options2);
    options2 = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
  }
  if (value2 === void 0) {
    const { keepUndefined } = options2 ?? replacer ?? {};
    if (!keepUndefined)
      return void 0;
  }
  return new Document2(value2, _replacer, options2).toString(options2);
}
function req$2(name2, rootFile) {
  const create = createRequire || createRequireFromPath;
  const require6 = create(rootFile);
  return require6(name2);
}
function parse$9(src3) {
  const obj = {};
  let lines = src3.toString();
  lines = lines.replace(/\r\n?/mg, "\n");
  let match2;
  while ((match2 = LINE.exec(lines)) != null) {
    const key = match2[1];
    let value2 = match2[2] || "";
    value2 = value2.trim();
    const maybeQuote = value2[0];
    value2 = value2.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
    if (maybeQuote === '"') {
      value2 = value2.replace(/\\n/g, "\n");
      value2 = value2.replace(/\\r/g, "\r");
    }
    obj[key] = value2;
  }
  return obj;
}
function _parseVault(options2) {
  const vaultPath = _vaultPath(options2);
  const result = DotenvModule.configDotenv({ path: vaultPath });
  if (!result.parsed) {
    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
    err.code = "MISSING_DATA";
    throw err;
  }
  const keys = _dotenvKey(options2).split(",");
  const length = keys.length;
  let decrypted;
  for (let i = 0; i < length; i++) {
    try {
      const key = keys[i].trim();
      const attrs = _instructions(result, key);
      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
      break;
    } catch (error) {
      if (i + 1 >= length) {
        throw error;
      }
    }
  }
  return DotenvModule.parse(decrypted);
}
function _log(message) {
  console.log(`[dotenv@${version2}][INFO] ${message}`);
}
function _warn(message) {
  console.log(`[dotenv@${version2}][WARN] ${message}`);
}
function _debug(message) {
  console.log(`[dotenv@${version2}][DEBUG] ${message}`);
}
function _dotenvKey(options2) {
  if (options2 && options2.DOTENV_KEY && options2.DOTENV_KEY.length > 0) {
    return options2.DOTENV_KEY;
  }
  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
    return process.env.DOTENV_KEY;
  }
  return "";
}
function _instructions(result, dotenvKey) {
  let uri;
  try {
    uri = new URL(dotenvKey);
  } catch (error) {
    if (error.code === "ERR_INVALID_URL") {
      const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    }
    throw error;
  }
  const key = uri.password;
  if (!key) {
    const err = new Error("INVALID_DOTENV_KEY: Missing key part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environment = uri.searchParams.get("environment");
  if (!environment) {
    const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
    err.code = "INVALID_DOTENV_KEY";
    throw err;
  }
  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
  const ciphertext = result.parsed[environmentKey];
  if (!ciphertext) {
    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
    err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
    throw err;
  }
  return { ciphertext, key };
}
function _vaultPath(options2) {
  let possibleVaultPath = null;
  if (options2 && options2.path && options2.path.length > 0) {
    if (Array.isArray(options2.path)) {
      for (const filepath of options2.path) {
        if (fs$9.existsSync(filepath)) {
          possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
        }
      }
    } else {
      possibleVaultPath = options2.path.endsWith(".vault") ? options2.path : `${options2.path}.vault`;
    }
  } else {
    possibleVaultPath = path$9.resolve(process.cwd(), ".env.vault");
  }
  if (fs$9.existsSync(possibleVaultPath)) {
    return possibleVaultPath;
  }
  return null;
}
function _resolveHome(envPath) {
  return envPath[0] === "~" ? path$9.join(os$2.homedir(), envPath.slice(1)) : envPath;
}
function _configVault(options2) {
  _log("Loading env from encrypted .env.vault");
  const parsed = DotenvModule._parseVault(options2);
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsed, options2);
  return { parsed };
}
function configDotenv(options2) {
  const dotenvPath = path$9.resolve(process.cwd(), ".env");
  let encoding = "utf8";
  const debug2 = Boolean(options2 && options2.debug);
  if (options2 && options2.encoding) {
    encoding = options2.encoding;
  } else {
    if (debug2) {
      _debug("No encoding is specified. UTF-8 is used by default");
    }
  }
  let optionPaths = [dotenvPath];
  if (options2 && options2.path) {
    if (!Array.isArray(options2.path)) {
      optionPaths = [_resolveHome(options2.path)];
    } else {
      optionPaths = [];
      for (const filepath of options2.path) {
        optionPaths.push(_resolveHome(filepath));
      }
    }
  }
  let lastError;
  const parsedAll = {};
  for (const path9 of optionPaths) {
    try {
      const parsed = DotenvModule.parse(fs$9.readFileSync(path9, { encoding }));
      DotenvModule.populate(parsedAll, parsed, options2);
    } catch (e) {
      if (debug2) {
        _debug(`Failed to load ${path9} ${e.message}`);
      }
      lastError = e;
    }
  }
  let processEnv = process.env;
  if (options2 && options2.processEnv != null) {
    processEnv = options2.processEnv;
  }
  DotenvModule.populate(processEnv, parsedAll, options2);
  if (lastError) {
    return { parsed: parsedAll, error: lastError };
  } else {
    return { parsed: parsedAll };
  }
}
function config(options2) {
  if (_dotenvKey(options2).length === 0) {
    return DotenvModule.configDotenv(options2);
  }
  const vaultPath = _vaultPath(options2);
  if (!vaultPath) {
    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
    return DotenvModule.configDotenv(options2);
  }
  return DotenvModule._configVault(options2);
}
function decrypt(encrypted, keyStr) {
  const key = Buffer.from(keyStr.slice(-64), "hex");
  let ciphertext = Buffer.from(encrypted, "base64");
  const nonce = ciphertext.subarray(0, 12);
  const authTag = ciphertext.subarray(-16);
  ciphertext = ciphertext.subarray(12, -16);
  try {
    const aesgcm = crypto$1.createDecipheriv("aes-256-gcm", key, nonce);
    aesgcm.setAuthTag(authTag);
    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
  } catch (error) {
    const isRange = error instanceof RangeError;
    const invalidKeyLength = error.message === "Invalid key length";
    const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
    if (isRange || invalidKeyLength) {
      const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      err.code = "INVALID_DOTENV_KEY";
      throw err;
    } else if (decryptionFailed) {
      const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      err.code = "DECRYPTION_FAILED";
      throw err;
    } else {
      throw error;
    }
  }
}
function populate(processEnv, parsed, options2 = {}) {
  const debug2 = Boolean(options2 && options2.debug);
  const override = Boolean(options2 && options2.override);
  if (typeof parsed !== "object") {
    const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    err.code = "OBJECT_REQUIRED";
    throw err;
  }
  for (const key of Object.keys(parsed)) {
    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
      if (override === true) {
        processEnv[key] = parsed[key];
      }
      if (debug2) {
        if (override === true) {
          _debug(`"${key}" is already defined and WAS overwritten`);
        } else {
          _debug(`"${key}" is already defined and was NOT overwritten`);
        }
      }
    } else {
      processEnv[key] = parsed[key];
    }
  }
}
function createCachedImport(imp) {
  let cached;
  return () => {
    if (!cached) {
      cached = imp().then((module) => {
        cached = module;
        return module;
      });
    }
    return cached;
  };
}
function rewriteCssUrls(css, replacer) {
  return asyncReplace(css, cssUrlRE, async (match2) => {
    const [matched, rawUrl] = match2;
    return await doUrlReplace(rawUrl.trim(), matched, replacer);
  });
}
async function rewriteCssImageSet(css, replacer) {
  return await asyncReplace(css, cssImageSetRE, async (match2) => {
    const [, rawUrl] = match2;
    const url2 = await processSrcSet(rawUrl, async ({ url: url22 }) => {
      if (cssUrlRE.test(url22)) {
        return await rewriteCssUrls(url22, replacer);
      }
      if (!cssNotProcessedRE.test(url22)) {
        return await doUrlReplace(url22, url22, replacer);
      }
      return url22;
    });
    return url2;
  });
}
function skipUrlReplacer(rawUrl) {
  return isExternalUrl(rawUrl) || isDataUrl(rawUrl) || rawUrl[0] === "#" || functionCallRE.test(rawUrl);
}
async function doUrlReplace(rawUrl, matched, replacer, funcName = "url") {
  let wrap2 = "";
  const first2 = rawUrl[0];
  if (first2 === `"` || first2 === `'`) {
    wrap2 = first2;
    rawUrl = rawUrl.slice(1, -1);
  }
  if (skipUrlReplacer(rawUrl)) {
    return matched;
  }
  let newUrl = await replacer(rawUrl);
  if (wrap2 === "" && newUrl !== encodeURI(newUrl)) {
    wrap2 = '"';
  }
  if (wrap2 === "'" && newUrl.includes("'")) {
    wrap2 = '"';
  }
  if (wrap2 === '"' && newUrl.includes('"')) {
    newUrl = newUrl.replace(nonEscapedDoubleQuoteRe, '\\"');
  }
  return `${funcName}(${wrap2}${newUrl}${wrap2})`;
}
function formatList(array2, type = "and") {
  return array2.length < 3 ? array2.join(` ${type} `) : `${array2.slice(0, -1).join(", ")}, ${type} ${array2[array2.length - 1]}`;
}
function createError2(sym, value2, constructor) {
  messages.set(sym, value2);
  return makeNodeErrorWithCode(constructor, sym);
}
function makeNodeErrorWithCode(Base, key) {
  return NodeError;
  function NodeError(...parameters) {
    const limit = Error.stackTraceLimit;
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;
    const error = new Base();
    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;
    const message = getMessage(key, parameters, error);
    Object.defineProperties(error, {
      // Note: no need to implement `kIsNodeError` symbol, would be hard,
      // probably.
      message: {
        value: message,
        enumerable: false,
        writable: true,
        configurable: true
      },
      toString: {
        /** @this {Error} */
        value() {
          return `${this.name} [${key}]: ${this.message}`;
        },
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    captureLargerStackTrace(error);
    error.code = key;
    return error;
  }
}
function isErrorStackTraceLimitWritable() {
  try {
    if (v8.startupSnapshot.isBuildingSnapshot()) {
      return false;
    }
  } catch {
  }
  const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
  if (desc === void 0) {
    return Object.isExtensible(Error);
  }
  return own$1.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
}
function hideStackFrames(wrappedFunction) {
  const hidden = nodeInternalPrefix + wrappedFunction.name;
  Object.defineProperty(wrappedFunction, "name", { value: hidden });
  return wrappedFunction;
}
function getMessage(key, parameters, self2) {
  const message = messages.get(key);
  assert$1(message !== void 0, "expected `message` to be found");
  if (typeof message === "function") {
    assert$1(
      message.length <= parameters.length,
      // Default options do not count.
      `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`
    );
    return Reflect.apply(message, self2, parameters);
  }
  const regex2 = /%[dfijoOs]/g;
  let expectedLength = 0;
  while (regex2.exec(message) !== null) expectedLength++;
  assert$1(
    expectedLength === parameters.length,
    `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`
  );
  if (parameters.length === 0) return message;
  parameters.unshift(message);
  return Reflect.apply(format$2, null, parameters);
}
function determineSpecificType(value2) {
  if (value2 === null || value2 === void 0) {
    return String(value2);
  }
  if (typeof value2 === "function" && value2.name) {
    return `function ${value2.name}`;
  }
  if (typeof value2 === "object") {
    if (value2.constructor && value2.constructor.name) {
      return `an instance of ${value2.constructor.name}`;
    }
    return `${inspect(value2, { depth: -1 })}`;
  }
  let inspected = inspect(value2, { colors: false });
  if (inspected.length > 28) {
    inspected = `${inspected.slice(0, 25)}...`;
  }
  return `type ${typeof value2} (${inspected})`;
}
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;
  ms = function(val, options2) {
    options2 = options2 || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse6(val);
    } else if (type === "number" && isNaN(val) === false) {
      return options2.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse6(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type = (match2[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    if (ms2 >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (ms2 >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (ms2 >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (ms2 >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    return plural(ms2, d, "day") || plural(ms2, h, "hour") || plural(ms2, m, "minute") || plural(ms2, s, "second") || ms2 + " ms";
  }
  function plural(ms2, n, name2) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name2;
    }
    return Math.ceil(ms2 / n) + " " + name2 + "s";
  }
  return ms;
}
function requireDebug() {
  if (hasRequiredDebug) return debug$f.exports;
  hasRequiredDebug = 1;
  (function(module, exports2) {
    exports2 = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports2.coerce = coerce;
    exports2.disable = disable;
    exports2.enable = enable;
    exports2.enabled = enabled;
    exports2.humanize = requireMs();
    exports2.names = [];
    exports2.skips = [];
    exports2.formatters = {};
    var prevTime;
    function selectColor(namespace2) {
      var hash3 = 0, i;
      for (i in namespace2) {
        hash3 = (hash3 << 5) - hash3 + namespace2.charCodeAt(i);
        hash3 |= 0;
      }
      return exports2.colors[Math.abs(hash3) % exports2.colors.length];
    }
    function createDebug(namespace2) {
      function debug2() {
        if (!debug2.enabled) return;
        var self2 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports2.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index4 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%") return match2;
          index4++;
          var formatter2 = exports2.formatters[format2];
          if ("function" === typeof formatter2) {
            var val = args[index4];
            match2 = formatter2.call(self2, val);
            args.splice(index4, 1);
            index4--;
          }
          return match2;
        });
        exports2.formatArgs.call(self2, args);
        var logFn = debug2.log || exports2.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug2.namespace = namespace2;
      debug2.enabled = exports2.enabled(namespace2);
      debug2.useColors = exports2.useColors();
      debug2.color = selectColor(namespace2);
      if ("function" === typeof exports2.init) {
        exports2.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports2.save(namespaces);
      exports2.names = [];
      exports2.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports2.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports2.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports2.enable("");
    }
    function enabled(name2) {
      var i, len;
      for (i = 0, len = exports2.skips.length; i < len; i++) {
        if (exports2.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = exports2.names.length; i < len; i++) {
        if (exports2.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug$f, debug$f.exports);
  return debug$f.exports;
}
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports2) {
    exports2 = module.exports = requireDebug();
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports2.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports2.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports2.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index4 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2) return;
        index4++;
        if ("%c" === match2) {
          lastC = index4;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports2.storage.removeItem("debug");
        } else {
          exports2.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load2() {
      var r;
      try {
        r = exports2.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports2.enable(load2());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser, browser.exports);
  return browser.exports;
}
function requireNode() {
  if (hasRequiredNode) return node2.exports;
  hasRequiredNode = 1;
  (function(module, exports2) {
    var tty = require$$0$3;
    var util3 = require$$0$5;
    exports2 = module.exports = requireDebug();
    exports2.init = init2;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.colors = [6, 2, 3, 4, 5, 1];
    exports2.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util3.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream4 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(fd);
    }
    exports2.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports2.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name2 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name2 + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports2.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name2 + " " + args[0];
      }
    }
    function log2() {
      return stream4.write(util3.format.apply(util3, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream5;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream5 = new tty.WriteStream(fd2);
          stream5._type = "tty";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        case "FILE":
          var fs6 = require$$0__default3;
          stream5 = new fs6.SyncWriteStream(fd2, { autoClose: false });
          stream5._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require$$4$1;
          stream5 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream5.readable = false;
          stream5.read = null;
          stream5._type = "pipe";
          if (stream5._handle && stream5._handle.unref) {
            stream5._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream5.fd = fd2;
      stream5._isStdio = true;
      return stream5;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys = Object.keys(exports2.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    exports2.enable(load2());
  })(node2, node2.exports);
  return node2.exports;
}
function encodeUrl$1(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
function escapeHtml$1(string4) {
  var str2 = "" + string4;
  var match2 = matchHtmlRegExp.exec(str2);
  if (!match2) {
    return str2;
  }
  var escape2;
  var html = "";
  var index4 = 0;
  var lastIndex = 0;
  for (index4 = match2.index; index4 < str2.length; index4++) {
    switch (str2.charCodeAt(index4)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index4) {
      html += str2.substring(lastIndex, index4);
    }
    lastIndex = index4 + 1;
    html += escape2;
  }
  return lastIndex !== index4 ? html + str2.substring(lastIndex, index4) : html;
}
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee = arr[0];
    for (var j = 1; j < arr.length; j++) {
      var event = arr[j];
      var fn = listener(event, callback);
      ee.on(event, fn);
      cleanups.push({
        ee,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x;
    for (var i2 = 0; i2 < cleanups.length; i2++) {
      x = cleanups[i2];
      x.ee.removeListener(x.event, x.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee = this;
    var err = event === "error" ? arg1 : null;
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    done(err, ee, event, args);
  };
}
function onFinished$1(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$2(listener2, null, msg);
    return msg;
  }
  attachListener(msg, listener2);
  return msg;
}
function isFinished$1(msg) {
  var socket = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket && !socket.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket) {
    msg.removeListener("socket", onSocket);
    if (finished) return;
    if (eeMsg !== eeSocket) return;
    eeSocket = first([[socket, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err) {
    if (msg.__onFinished === listener2) msg.__onFinished = null;
    if (!listener2.queue) return;
    var queue2 = listener2.queue;
    listener2.queue = null;
    for (var i = 0; i < queue2.length; i++) {
      queue2[i](err, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res, callback) {
  var assignSocket = res.assignSocket;
  if (typeof assignSocket !== "function") return;
  res.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str2) {
  if (typeof str2 !== "string" || str2.charCodeAt(0) !== 47) {
    return parse$8(str2);
  }
  var pathname = str2;
  var query = null;
  var search = null;
  for (var i = 1; i < str2.length; i++) {
    switch (str2.charCodeAt(i)) {
      case 63:
        if (search === null) {
          pathname = str2.substring(0, i);
          query = str2.substring(i + 1);
          search = str2.substring(i);
        }
        break;
      case 9:
      /* \t */
      case 10:
      /* \n */
      case 12:
      /* \f */
      case 13:
      /* \r */
      case 32:
      /*    */
      case 35:
      /* #  */
      case 160:
      case 65279:
        return parse$8(str2);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str2;
  url2.href = str2;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query;
    url2.search = search;
  }
  return url2;
}
function fresh(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
function populateStatusesMap(statuses2, codes2) {
  var arr = [];
  Object.keys(codes2).forEach(function forEachCode(code) {
    var message = codes2[code];
    var status2 = Number(code);
    statuses2[status2] = message;
    statuses2[message] = status2;
    statuses2[message.toLowerCase()] = status2;
    arr.push(status2);
  });
  return arr;
}
function status(code) {
  if (typeof code === "number") {
    if (!status[code]) throw new Error("invalid status code: " + code);
    return code;
  }
  if (typeof code !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n = parseInt(code, 10);
  if (!isNaN(n)) {
    if (!status[n]) throw new Error("invalid status code: " + n);
    return n;
  }
  n = status[code.toLowerCase()];
  if (!n) throw new Error('invalid status message: "' + code + '"');
  return n;
}
function hasPipeDataListeners(stream4) {
  var listeners = stream4.listeners("data");
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream4) {
  if (!stream4) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream4.unpipe === "function") {
    stream4.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream4)) {
    return;
  }
  var listener2;
  var listeners = stream4.listeners("close");
  for (var i = 0; i < listeners.length; i++) {
    listener2 = listeners[i];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream4);
  }
}
function createHtmlDocument(message) {
  var body = escapeHtml(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
function finalhandler$1(req2, res, options2) {
  var opts = options2 || {};
  var env2 = opts.env || process.env.NODE_ENV || "development";
  var onerror = opts.onerror;
  return function(err) {
    var headers;
    var msg;
    var status2;
    if (!err && headersSent(res)) {
      debug$e("cannot 404 after headers sent");
      return;
    }
    if (err) {
      status2 = getErrorStatusCode(err);
      if (status2 === void 0) {
        status2 = getResponseStatusCode(res);
      } else {
        headers = getErrorHeaders(err);
      }
      msg = getErrorMessage(err, status2, env2);
    } else {
      status2 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl(getResourceName(req2));
    }
    debug$e("default %s", status2);
    if (err && onerror) {
      defer$1(onerror, err, req2, res);
    }
    if (headersSent(res)) {
      debug$e("cannot %d after headers sent", status2);
      req2.socket.destroy();
      return;
    }
    send$2(req2, res, status2, headers, msg);
  };
}
function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys = Object.keys(err.headers);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    headers[key] = err.headers[key];
  }
  return headers;
}
function getErrorMessage(err, status2, env2) {
  var msg;
  if (env2 !== "production") {
    msg = err.stack;
    if (!msg && typeof err.toString === "function") {
      msg = err.toString();
    }
  }
  return msg || statuses[status2];
}
function getErrorStatusCode(err) {
  if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
    return err.status;
  }
  if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$2.original(req2).pathname;
  } catch (e) {
    return "resource";
  }
}
function getResponseStatusCode(res) {
  var status2 = res.statusCode;
  if (typeof status2 !== "number" || status2 < 400 || status2 > 599) {
    status2 = 500;
  }
  return status2;
}
function headersSent(res) {
  return typeof res.headersSent !== "boolean" ? Boolean(res._header) : res.headersSent;
}
function send$2(req2, res, status2, headers, message) {
  function write() {
    var body = createHtmlDocument(message);
    res.statusCode = status2;
    res.statusMessage = statuses[status2];
    setHeaders(res, headers);
    res.setHeader("Content-Security-Policy", "default-src 'none'");
    res.setHeader("X-Content-Type-Options", "nosniff");
    res.setHeader("Content-Type", "text/html; charset=utf-8");
    res.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res.end();
      return;
    }
    res.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write();
    return;
  }
  unpipe(req2);
  onFinished(req2, write);
  req2.resume();
}
function setHeaders(res, headers) {
  if (!headers) {
    return;
  }
  var keys = Object.keys(headers);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    res.setHeader(key, headers[key]);
  }
}
function call(handle2, route, err, req2, res, next) {
  var arity = handle2.length;
  var error = err;
  var hasError = Boolean(err);
  debug$d("%s %s : %s", handle2.name || "<anonymous>", route, req2.originalUrl);
  try {
    if (hasError && arity === 4) {
      handle2(err, req2, res, next);
      return;
    } else if (!hasError && arity < 4) {
      handle2(req2, res, next);
      return;
    }
  } catch (e) {
    error = e;
  }
  next(error);
}
function logerror(err) {
  if (env !== "test") console.error(err.stack || err.toString());
}
function getProtohost(url2) {
  if (url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var fqdnIndex = url2.indexOf("://");
  return fqdnIndex !== -1 && url2.lastIndexOf("?", fqdnIndex) === -1 ? url2.substr(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
      return test2[n];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
function append(header, field) {
  if (typeof header !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse$7(String(field)) : field;
  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header === "*") {
    return header;
  }
  var val = header;
  var vals = parse$7(header.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i] : fields[i];
    }
  }
  return val;
}
function parse$7(header) {
  var end = 0;
  var list2 = [];
  var start = 0;
  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list2.push(header.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list2.push(header.substring(start, end));
  return list2;
}
function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res.getHeader("Vary") || "";
  var header = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header, field)) {
    res.setHeader("Vary", val);
  }
}
function createFsWatchInstance(path9, options2, listener2, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener2(path9);
    emitRaw(rawEvent, evPath, { watchedPath: path9 });
    if (evPath && path9 !== evPath) {
      fsWatchBroadcast(
        sysPath$2.resolve(path9, evPath),
        KEY_LISTENERS,
        sysPath$2.join(path9, evPath)
      );
    }
  };
  try {
    return fs$7.watch(path9, options2, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}
function setFSEventsListener(path9, realPath, listener2, rawEmitter) {
  let watchPath = sysPath$1.extname(realPath) ? sysPath$1.dirname(realPath) : realPath;
  const parentPath = sysPath$1.dirname(watchPath);
  let cont = FSEventsWatchers.get(watchPath);
  if (couldConsolidate(parentPath)) {
    watchPath = parentPath;
  }
  const resolvedPath = sysPath$1.resolve(path9);
  const hasSymlink = resolvedPath !== realPath;
  const filteredListener = (fullPath, flags, info) => {
    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);
    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath$1.sep)) listener2(fullPath, flags, info);
  };
  let watchedParent = false;
  for (const watchedPath of FSEventsWatchers.keys()) {
    if (realPath.indexOf(sysPath$1.resolve(watchedPath) + sysPath$1.sep) === 0) {
      watchPath = watchedPath;
      cont = FSEventsWatchers.get(watchPath);
      watchedParent = true;
      break;
    }
  }
  if (cont || watchedParent) {
    cont.listeners.add(filteredListener);
  } else {
    cont = {
      listeners: /* @__PURE__ */ new Set([filteredListener]),
      rawEmitter,
      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
        if (!cont.listeners.size) return;
        if (flags & FSEVENT_FLAG_MUST_SCAN_SUBDIRS) return;
        const info = fsevents.getInfo(fullPath, flags);
        cont.listeners.forEach((list2) => {
          list2(fullPath, flags, info);
        });
        cont.rawEmitter(info.event, fullPath, info);
      })
    };
    FSEventsWatchers.set(watchPath, cont);
  }
  return () => {
    const lst = cont.listeners;
    lst.delete(filteredListener);
    if (!lst.size) {
      FSEventsWatchers.delete(watchPath);
      if (cont.watcher) return cont.watcher.stop().then(() => {
        cont.rawEmitter = cont.watcher = void 0;
        Object.freeze(cont);
      });
    }
  };
}
function matchAll(s, r) {
  var origIndex = r.lastIndex;
  var matches = [];
  var matchObj;
  while (matchObj = r.exec(s)) {
    matches.push(matchObj);
    if (r.lastIndex === matchObj.index) {
      r.lastIndex += 1;
    }
  }
  r.lastIndex = origIndex;
  return matches;
}
function getVar(env2, pre, key) {
  var r = typeof env2 === "function" ? env2(key) : env2[key];
  if (typeof r === "undefined" && key != "") {
    r = "";
  } else if (typeof r === "undefined") {
    r = "$";
  }
  if (typeof r === "object") {
    return pre + TOKEN + JSON.stringify(r) + TOKEN;
  }
  return pre + r;
}
function parseInternal(string4, env2, opts) {
  if (!opts) {
    opts = {};
  }
  var BS = opts.escape || "\\";
  var BAREWORD = "(\\" + BS + `['"` + META + `]|[^\\s'"` + META + "])+";
  var chunker = new RegExp([
    "(" + CONTROL + ")",
    // control chars
    "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")+"
  ].join("|"), "g");
  var matches = matchAll(string4, chunker);
  if (matches.length === 0) {
    return [];
  }
  if (!env2) {
    env2 = {};
  }
  var commented = false;
  return matches.map(function(match2) {
    var s = match2[0];
    if (!s || commented) {
      return void 0;
    }
    if (controlRE.test(s)) {
      return { op: s };
    }
    var quote3 = false;
    var esc = false;
    var out = "";
    var isGlob3 = false;
    var i;
    function parseEnvVar() {
      i += 1;
      var varend;
      var varname;
      var char = s.charAt(i);
      if (char === "{") {
        i += 1;
        if (s.charAt(i) === "}") {
          throw new Error("Bad substitution: " + s.slice(i - 2, i + 1));
        }
        varend = s.indexOf("}", i);
        if (varend < 0) {
          throw new Error("Bad substitution: " + s.slice(i));
        }
        varname = s.slice(i, varend);
        i = varend;
      } else if (/[*@#?$!_-]/.test(char)) {
        varname = char;
        i += 1;
      } else {
        var slicedFromI = s.slice(i);
        varend = slicedFromI.match(/[^\w\d_]/);
        if (!varend) {
          varname = slicedFromI;
          i = s.length;
        } else {
          varname = slicedFromI.slice(0, varend.index);
          i += varend.index - 1;
        }
      }
      return getVar(env2, "", varname);
    }
    for (i = 0; i < s.length; i++) {
      var c = s.charAt(i);
      isGlob3 = isGlob3 || !quote3 && (c === "*" || c === "?");
      if (esc) {
        out += c;
        esc = false;
      } else if (quote3) {
        if (c === quote3) {
          quote3 = false;
        } else if (quote3 == SQ) {
          out += c;
        } else {
          if (c === BS) {
            i += 1;
            c = s.charAt(i);
            if (c === DQ || c === BS || c === DS) {
              out += c;
            } else {
              out += BS + c;
            }
          } else if (c === DS) {
            out += parseEnvVar();
          } else {
            out += c;
          }
        }
      } else if (c === DQ || c === SQ) {
        quote3 = c;
      } else if (controlRE.test(c)) {
        return { op: s };
      } else if (hash2.test(c)) {
        commented = true;
        var commentObj = { comment: string4.slice(match2.index + i + 1) };
        if (out.length) {
          return [out, commentObj];
        }
        return [commentObj];
      } else if (c === BS) {
        esc = true;
      } else if (c === DS) {
        out += parseEnvVar();
      } else {
        out += c;
      }
    }
    if (isGlob3) {
      return { op: "glob", pattern: out };
    }
    return out;
  }).reduce(function(prev, arg) {
    return typeof arg === "undefined" ? prev : prev.concat(arg);
  }, []);
}
function tryResolveRealFile(file, preserveSymlinks) {
  const stat3 = tryStatSync(file);
  if (stat3?.isFile()) return getRealPath(file, preserveSymlinks);
}
function tryResolveRealFileWithExtensions(filePath, extensions2, preserveSymlinks) {
  for (const ext2 of extensions2) {
    const res = tryResolveRealFile(filePath + ext2, preserveSymlinks);
    if (res) return res;
  }
}
function tryResolveRealFileOrType(file, preserveSymlinks) {
  const fileStat = tryStatSync(file);
  if (fileStat?.isFile()) {
    return { path: getRealPath(file, preserveSymlinks), type: "file" };
  }
  if (fileStat?.isDirectory()) {
    return { type: "directory" };
  }
  return;
}
function getRealPath(resolved, preserveSymlinks) {
  if (!preserveSymlinks) {
    resolved = safeRealpathSync(resolved);
  }
  return normalizePath$3(resolved);
}
function isDirectory(path22) {
  const stat3 = tryStatSync(path22);
  return stat3?.isDirectory() ?? false;
}
function ansiRegex({ onlyFirst = false } = {}) {
  const pattern2 = [
    "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
    "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
  ].join("|");
  return new RegExp(pattern2, onlyFirst ? void 0 : "g");
}
function hasDockerEnv() {
  try {
    fs$3.statSync("/.dockerenv");
    return true;
  } catch (_) {
    return false;
  }
}
function hasDockerCGroup() {
  try {
    return fs$3.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
  } catch (_) {
    return false;
  }
}
function isInsideContainer() {
  if (cachedResult === void 0) {
    cachedResult = hasContainerEnv() || isDocker();
  }
  return cachedResult;
}
function detectArchBinary(binary2) {
  if (typeof binary2 === "string" || Array.isArray(binary2)) {
    return binary2;
  }
  const { [arch]: archBinary } = binary2;
  if (!archBinary) {
    throw new Error(`${arch} is not supported`);
  }
  return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
  if (wsl && isWsl) {
    return detectArchBinary(wsl);
  }
  if (!platformBinary) {
    throw new Error(`${platform} is not supported`);
  }
  return detectArchBinary(platformBinary);
}
function requireWindows() {
  if (hasRequiredWindows) return windows;
  hasRequiredWindows = 1;
  windows = isexe2;
  isexe2.sync = sync2;
  var fs6 = require$$0__default3;
  function checkPathExt(path9, options2) {
    var pathext = options2.pathExt !== void 0 ? options2.pathExt : process.env.PATHEXT;
    if (!pathext) {
      return true;
    }
    pathext = pathext.split(";");
    if (pathext.indexOf("") !== -1) {
      return true;
    }
    for (var i = 0; i < pathext.length; i++) {
      var p = pathext[i].toLowerCase();
      if (p && path9.substr(-p.length).toLowerCase() === p) {
        return true;
      }
    }
    return false;
  }
  function checkStat(stat3, path9, options2) {
    if (!stat3.isSymbolicLink() && !stat3.isFile()) {
      return false;
    }
    return checkPathExt(path9, options2);
  }
  function isexe2(path9, options2, cb) {
    fs6.stat(path9, function(er, stat3) {
      cb(er, er ? false : checkStat(stat3, path9, options2));
    });
  }
  function sync2(path9, options2) {
    return checkStat(fs6.statSync(path9), path9, options2);
  }
  return windows;
}
function requireMode() {
  if (hasRequiredMode) return mode;
  hasRequiredMode = 1;
  mode = isexe2;
  isexe2.sync = sync2;
  var fs6 = require$$0__default3;
  function isexe2(path9, options2, cb) {
    fs6.stat(path9, function(er, stat3) {
      cb(er, er ? false : checkStat(stat3, options2));
    });
  }
  function sync2(path9, options2) {
    return checkStat(fs6.statSync(path9), options2);
  }
  function checkStat(stat3, options2) {
    return stat3.isFile() && checkMode(stat3, options2);
  }
  function checkMode(stat3, options2) {
    var mod = stat3.mode;
    var uid = stat3.uid;
    var gid = stat3.gid;
    var myUid = options2.uid !== void 0 ? options2.uid : process.getuid && process.getuid();
    var myGid = options2.gid !== void 0 ? options2.gid : process.getgid && process.getgid();
    var u = parseInt("100", 8);
    var g = parseInt("010", 8);
    var o = parseInt("001", 8);
    var ug = u | g;
    var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
    return ret;
  }
  return mode;
}
function isexe$1(path9, options2, cb) {
  if (typeof options2 === "function") {
    cb = options2;
    options2 = {};
  }
  if (!cb) {
    if (typeof Promise !== "function") {
      throw new TypeError("callback not provided");
    }
    return new Promise(function(resolve8, reject) {
      isexe$1(path9, options2 || {}, function(er, is) {
        if (er) {
          reject(er);
        } else {
          resolve8(is);
        }
      });
    });
  }
  core(path9, options2 || {}, function(er, is) {
    if (er) {
      if (er.code === "EACCES" || options2 && options2.ignoreErrors) {
        er = null;
        is = false;
      }
    }
    cb(er, is);
  });
}
function sync(path9, options2) {
  try {
    return core.sync(path9, options2 || {});
  } catch (er) {
    if (options2 && options2.ignoreErrors || er.code === "EACCES") {
      return false;
    } else {
      throw er;
    }
  }
}
function resolveCommandAttempt(parsed, withoutPathExt) {
  const env2 = parsed.options.env || process.env;
  const cwd = process.cwd();
  const hasCustomCwd = parsed.options.cwd != null;
  const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;
  if (shouldSwitchCwd) {
    try {
      process.chdir(parsed.options.cwd);
    } catch (err) {
    }
  }
  let resolved;
  try {
    resolved = which.sync(parsed.command, {
      path: env2[getPathKey({ env: env2 })],
      pathExt: withoutPathExt ? path$13.delimiter : void 0
    });
  } catch (e) {
  } finally {
    if (shouldSwitchCwd) {
      process.chdir(cwd);
    }
  }
  if (resolved) {
    resolved = path$13.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
  }
  return resolved;
}
function resolveCommand$1(parsed) {
  return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
}
function escapeCommand(arg) {
  arg = arg.replace(metaCharsRegExp, "^$1");
  return arg;
}
function escapeArgument(arg, doubleEscapeMetaChars) {
  arg = `${arg}`;
  arg = arg.replace(/(\\*)"/g, '$1$1\\"');
  arg = arg.replace(/(\\*)$/, "$1$1");
  arg = `"${arg}"`;
  arg = arg.replace(metaCharsRegExp, "^$1");
  if (doubleEscapeMetaChars) {
    arg = arg.replace(metaCharsRegExp, "^$1");
  }
  return arg;
}
function readShebang$1(command) {
  const size = 150;
  const buffer = Buffer.alloc(size);
  let fd;
  try {
    fd = fs3.openSync(command, "r");
    fs3.readSync(fd, buffer, 0, size, 0);
    fs3.closeSync(fd);
  } catch (e) {
  }
  return shebangCommand(buffer.toString());
}
function detectShebang(parsed) {
  parsed.file = resolveCommand(parsed);
  const shebang = parsed.file && readShebang(parsed.file);
  if (shebang) {
    parsed.args.unshift(parsed.file);
    parsed.command = shebang;
    return resolveCommand(parsed);
  }
  return parsed.file;
}
function parseNonShell(parsed) {
  if (!isWin$1) {
    return parsed;
  }
  const commandFile = detectShebang(parsed);
  const needsShell = !isExecutableRegExp.test(commandFile);
  if (parsed.options.forceShell || needsShell) {
    const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
    parsed.command = path4.normalize(parsed.command);
    parsed.command = escape$1.command(parsed.command);
    parsed.args = parsed.args.map((arg) => escape$1.argument(arg, needsDoubleEscapeMetaChars));
    const shellCommand = [parsed.command].concat(parsed.args).join(" ");
    parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
    parsed.command = process.env.comspec || "cmd.exe";
    parsed.options.windowsVerbatimArguments = true;
  }
  return parsed;
}
function parse$4(command, args, options2) {
  if (args && !Array.isArray(args)) {
    options2 = args;
    args = null;
  }
  args = args ? args.slice(0) : [];
  options2 = Object.assign({}, options2);
  const parsed = {
    command,
    args,
    options: options2,
    file: void 0,
    original: {
      command,
      args
    }
  };
  return options2.shell ? parsed : parseNonShell(parsed);
}
function notFoundError(original, syscall) {
  return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
    code: "ENOENT",
    errno: "ENOENT",
    syscall: `${syscall} ${original.command}`,
    path: original.command,
    spawnargs: original.args
  });
}
function hookChildProcess(cp2, parsed) {
  if (!isWin) {
    return;
  }
  const originalEmit = cp2.emit;
  cp2.emit = function(name2, arg1) {
    if (name2 === "exit") {
      const err = verifyENOENT(arg1, parsed);
      if (err) {
        return originalEmit.call(cp2, "error", err);
      }
    }
    return originalEmit.apply(cp2, arguments);
  };
}
function verifyENOENT(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawn");
  }
  return null;
}
function verifyENOENTSync(status2, parsed) {
  if (isWin && status2 === 1 && !parsed.file) {
    return notFoundError(parsed.original, "spawnSync");
  }
  return null;
}
function spawn(command, args, options2) {
  const parsed = parse$3(command, args, options2);
  const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
  enoent.hookChildProcess(spawned, parsed);
  return spawned;
}
function spawnSync(command, args, options2) {
  const parsed = parse$3(command, args, options2);
  const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
  result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
  return result;
}
function concat$1(list2, totalLength) {
  if (list2.length === 0) return EMPTY_BUFFER$3;
  if (list2.length === 1) return list2[0];
  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;
  for (let i = 0; i < list2.length; i++) {
    const buf = list2[i];
    target.set(buf, offset);
    offset += buf.length;
  }
  if (offset < totalLength) {
    return new FastBuffer$2(target.buffer, target.byteOffset, offset);
  }
  return target;
}
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}
function toArrayBuffer$1(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}
function toBuffer$2(data) {
  toBuffer$2.readOnly = true;
  if (Buffer.isBuffer(data)) return data;
  let buf;
  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer$2(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer$2.readOnly = false;
  }
  return buf;
}
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;
  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }
  this[kError$1] = new RangeError("Max payload size exceeded");
  this[kError$1].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
  this[kError$1][kStatusCode$2] = 1009;
  this.removeListener("data", inflateOnData);
  this.reset();
}
function inflateOnError(err) {
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode$2] = 1007;
  this[kCallback](err);
}
function isValidStatusCode$2(code) {
  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
}
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;
  while (i < len) {
    if ((buf[i] & 128) === 0) {
      i++;
    } else if ((buf[i] & 224) === 192) {
      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
        return false;
      }
      i += 2;
    } else if ((buf[i] & 240) === 224) {
      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
      buf[i] === 237 && (buf[i + 1] & 224) === 160) {
        return false;
      }
      i += 3;
    } else if ((buf[i] & 248) === 240) {
      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
        return false;
      }
      i += 4;
    } else {
      return false;
    }
  }
  return true;
}
function isBlob$2(value2) {
  return hasBlob && typeof value2 === "object" && typeof value2.arrayBuffer === "function" && typeof value2.type === "string" && typeof value2.stream === "function" && (value2[Symbol.toStringTag] === "Blob" || value2[Symbol.toStringTag] === "File");
}
function callCallbacks(sender2, err, cb) {
  if (typeof cb === "function") cb(err);
  for (let i = 0; i < sender2._queue.length; i++) {
    const params = sender2._queue[i];
    const callback = params[params.length - 1];
    if (typeof callback === "function") callback(err);
  }
}
function onError(sender2, err, cb) {
  callCallbacks(sender2, err, cb);
  sender2.onerror(err);
}
function callListener(listener2, thisArg, event) {
  if (typeof listener2 === "object" && listener2.handleEvent) {
    listener2.handleEvent.call(listener2, event);
  } else {
    listener2.call(thisArg, event);
  }
}
function push(dest, name2, elem) {
  if (dest[name2] === void 0) dest[name2] = [elem];
  else dest[name2].push(elem);
}
function parse$2(header) {
  const offers = /* @__PURE__ */ Object.create(null);
  let params = /* @__PURE__ */ Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;
  for (; i < header.length; i++) {
    code = header.charCodeAt(i);
    if (extensionName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (i !== 0 && (code === 32 || code === 9)) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1) end = i;
        const name2 = header.slice(start, end);
        if (code === 44) {
          push(offers, name2, params);
          params = /* @__PURE__ */ Object.create(null);
        } else {
          extensionName = name2;
        }
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === void 0) {
      if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 32 || code === 9) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        start = end = -1;
      } else if (code === 61 && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      if (isEscaping) {
        if (tokenChars$1[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars$1[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 34 && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 92) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
        inQuotes = true;
      } else if (end === -1 && tokenChars$1[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 32 || code === 9)) {
        if (end === -1) end = i;
      } else if (code === 59 || code === 44) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (end === -1) end = i;
        let value2 = header.slice(start, end);
        if (mustUnescape) {
          value2 = value2.replace(/\\/g, "");
          mustUnescape = false;
        }
        push(params, paramName, value2);
        if (code === 44) {
          push(offers, extensionName, params);
          params = /* @__PURE__ */ Object.create(null);
          extensionName = void 0;
        }
        paramName = void 0;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }
  if (start === -1 || inQuotes || code === 32 || code === 9) {
    throw new SyntaxError("Unexpected end of input");
  }
  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === void 0) {
    push(offers, token, params);
  } else {
    if (paramName === void 0) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ""));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }
  return offers;
}
function format$1(extensions2) {
  return Object.keys(extensions2).map((extension2) => {
    let configurations = extensions2[extension2];
    if (!Array.isArray(configurations)) configurations = [configurations];
    return configurations.map((params) => {
      return [extension2].concat(
        Object.keys(params).map((k) => {
          let values = params[k];
          if (!Array.isArray(values)) values = [values];
          return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
        })
      ).join("; ");
    }).join(", ");
  }).join(", ");
}
function initAsClient(websocket2, address, protocols, options2) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options2,
    socketPath: void 0,
    hostname: void 0,
    protocol: void 0,
    timeout: void 0,
    method: "GET",
    host: void 0,
    path: void 0,
    port: void 0
  };
  websocket2._autoPong = opts.autoPong;
  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
    );
  }
  let parsedUrl;
  if (address instanceof URL$2) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL$2(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }
  if (parsedUrl.protocol === "http:") {
    parsedUrl.protocol = "ws:";
  } else if (parsedUrl.protocol === "https:") {
    parsedUrl.protocol = "wss:";
  }
  websocket2._url = parsedUrl.href;
  const isSecure = parsedUrl.protocol === "wss:";
  const isIpcUrl = parsedUrl.protocol === "ws+unix:";
  let invalidUrlMessage;
  if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
    invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = "The URL contains a fragment identifier";
  }
  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);
    if (websocket2._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket2, err);
      return;
    }
  }
  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString("base64");
  const request = isSecure ? https$2.request : http$3.request;
  const protocolSet = /* @__PURE__ */ new Set();
  let perMessageDeflate;
  opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    "Sec-WebSocket-Version": opts.protocolVersion,
    "Sec-WebSocket-Key": key,
    Connection: "Upgrade",
    Upgrade: "websocket"
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;
  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate$1(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers["Sec-WebSocket-Extensions"] = format({
      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
        throw new SyntaxError(
          "An invalid or duplicated subprotocol was specified"
        );
      }
      protocolSet.add(protocol);
    }
    opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers["Sec-WebSocket-Origin"] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }
  if (isIpcUrl) {
    const parts = opts.path.split(":");
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }
  let req2;
  if (opts.followRedirects) {
    if (websocket2._redirects === 0) {
      websocket2._originalIpc = isIpcUrl;
      websocket2._originalSecure = isSecure;
      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
      const headers = options2 && options2.headers;
      options2 = { ...options2, headers: {} };
      if (headers) {
        for (const [key2, value2] of Object.entries(headers)) {
          options2.headers[key2.toLowerCase()] = value2;
        }
      }
    } else if (websocket2.listenerCount("redirect") === 0) {
      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;
      if (!isSameHost || websocket2._originalSecure && !isSecure) {
        delete opts.headers.authorization;
        delete opts.headers.cookie;
        if (!isSameHost) delete opts.headers.host;
        opts.auth = void 0;
      }
    }
    if (opts.auth && !options2.headers.authorization) {
      options2.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
    }
    req2 = websocket2._req = request(opts);
    if (websocket2._redirects) {
      websocket2.emit("redirect", websocket2.url, req2);
    }
  } else {
    req2 = websocket2._req = request(opts);
  }
  if (opts.timeout) {
    req2.on("timeout", () => {
      abortHandshake$1(websocket2, req2, "Opening handshake has timed out");
    });
  }
  req2.on("error", (err) => {
    if (req2 === null || req2[kAborted]) return;
    req2 = websocket2._req = null;
    emitErrorAndClose(websocket2, err);
  });
  req2.on("response", (res) => {
    const location2 = res.headers.location;
    const statusCode = res.statusCode;
    if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket2._redirects > opts.maxRedirects) {
        abortHandshake$1(websocket2, req2, "Maximum redirects exceeded");
        return;
      }
      req2.abort();
      let addr;
      try {
        addr = new URL$2(location2, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location2}`);
        emitErrorAndClose(websocket2, err);
        return;
      }
      initAsClient(websocket2, addr, protocols, options2);
    } else if (!websocket2.emit("unexpected-response", req2, res)) {
      abortHandshake$1(
        websocket2,
        req2,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });
  req2.on("upgrade", (res, socket, head) => {
    websocket2.emit("upgrade", res);
    if (websocket2.readyState !== WebSocket$1.CONNECTING) return;
    req2 = websocket2._req = null;
    const upgrade = res.headers.upgrade;
    if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
      abortHandshake$1(websocket2, socket, "Invalid Upgrade header");
      return;
    }
    const digest = createHash$1("sha1").update(key + GUID$1).digest("base64");
    if (res.headers["sec-websocket-accept"] !== digest) {
      abortHandshake$1(websocket2, socket, "Invalid Sec-WebSocket-Accept header");
      return;
    }
    const serverProt = res.headers["sec-websocket-protocol"];
    let protError;
    if (serverProt !== void 0) {
      if (!protocolSet.size) {
        protError = "Server sent a subprotocol but none was requested";
      } else if (!protocolSet.has(serverProt)) {
        protError = "Server sent an invalid subprotocol";
      }
    } else if (protocolSet.size) {
      protError = "Server sent no subprotocol";
    }
    if (protError) {
      abortHandshake$1(websocket2, socket, protError);
      return;
    }
    if (serverProt) websocket2._protocol = serverProt;
    const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
    if (secWebSocketExtensions !== void 0) {
      if (!perMessageDeflate) {
        const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      let extensions2;
      try {
        extensions2 = parse$12(secWebSocketExtensions);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      const extensionNames = Object.keys(extensions2);
      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {
        const message = "Server indicated an extension that was not requested";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      try {
        perMessageDeflate.accept(extensions2[PerMessageDeflate$1.extensionName]);
      } catch (err) {
        const message = "Invalid Sec-WebSocket-Extensions header";
        abortHandshake$1(websocket2, socket, message);
        return;
      }
      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;
    }
    websocket2.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
  if (opts.finishRequest) {
    opts.finishRequest(req2, websocket2);
  } else {
    req2.end();
  }
}
function emitErrorAndClose(websocket2, err) {
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2._errorEmitted = true;
  websocket2.emit("error", err);
  websocket2.emitClose();
}
function netConnect(options2) {
  options2.path = options2.socketPath;
  return net.connect(options2);
}
function tlsConnect(options2) {
  options2.path = void 0;
  if (!options2.servername && options2.servername !== "") {
    options2.servername = net.isIP(options2.host) ? "" : options2.host;
  }
  return tls.connect(options2);
}
function abortHandshake$1(websocket2, stream4, message) {
  websocket2._readyState = WebSocket$1.CLOSING;
  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake$1);
  if (stream4.setHeader) {
    stream4[kAborted] = true;
    stream4.abort();
    if (stream4.socket && !stream4.socket.destroyed) {
      stream4.socket.destroy();
    }
    process.nextTick(emitErrorAndClose, websocket2, err);
  } else {
    stream4.destroy(err);
    stream4.once("error", websocket2.emit.bind(websocket2, "error"));
    stream4.once("close", websocket2.emitClose.bind(websocket2));
  }
}
function sendAfterClose(websocket2, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;
    if (websocket2._socket) websocket2._sender._bufferedBytes += length;
    else websocket2._bufferedAmount += length;
  }
  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`
    );
    process.nextTick(cb, err);
  }
}
function receiverOnConclude(code, reason) {
  const websocket2 = this[kWebSocket$1];
  websocket2._closeFrameReceived = true;
  websocket2._closeMessage = reason;
  websocket2._closeCode = code;
  if (websocket2._socket[kWebSocket$1] === void 0) return;
  websocket2._socket.removeListener("data", socketOnData);
  process.nextTick(resume, websocket2._socket);
  if (code === 1005) websocket2.close();
  else websocket2.close(code, reason);
}
function receiverOnDrain() {
  const websocket2 = this[kWebSocket$1];
  if (!websocket2.isPaused) websocket2._socket.resume();
}
function receiverOnError(err) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._socket[kWebSocket$1] !== void 0) {
    websocket2._socket.removeListener("data", socketOnData);
    process.nextTick(resume, websocket2._socket);
    websocket2.close(err[kStatusCode]);
  }
  if (!websocket2._errorEmitted) {
    websocket2._errorEmitted = true;
    websocket2.emit("error", err);
  }
}
function receiverOnFinish() {
  this[kWebSocket$1].emitClose();
}
function receiverOnMessage(data, isBinary) {
  this[kWebSocket$1].emit("message", data, isBinary);
}
function receiverOnPing(data) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2._autoPong) websocket2.pong(data, !this._isServer, NOOP$1);
  websocket2.emit("ping", data);
}
function receiverOnPong(data) {
  this[kWebSocket$1].emit("pong", data);
}
function resume(stream4) {
  stream4.resume();
}
function senderOnError(err) {
  const websocket2 = this[kWebSocket$1];
  if (websocket2.readyState === WebSocket$1.CLOSED) return;
  if (websocket2.readyState === WebSocket$1.OPEN) {
    websocket2._readyState = WebSocket$1.CLOSING;
    setCloseTimer(websocket2);
  }
  this._socket.end();
  if (!websocket2._errorEmitted) {
    websocket2._errorEmitted = true;
    websocket2.emit("error", err);
  }
}
function setCloseTimer(websocket2) {
  websocket2._closeTimer = setTimeout(
    websocket2._socket.destroy.bind(websocket2._socket),
    closeTimeout
  );
}
function socketOnClose() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("close", socketOnClose);
  this.removeListener("data", socketOnData);
  this.removeListener("end", socketOnEnd);
  websocket2._readyState = WebSocket$1.CLOSING;
  let chunk;
  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {
    websocket2._receiver.write(chunk);
  }
  websocket2._receiver.end();
  this[kWebSocket$1] = void 0;
  clearTimeout(websocket2._closeTimer);
  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {
    websocket2.emitClose();
  } else {
    websocket2._receiver.on("error", receiverOnFinish);
    websocket2._receiver.on("finish", receiverOnFinish);
  }
}
function socketOnData(chunk) {
  if (!this[kWebSocket$1]._receiver.write(chunk)) {
    this.pause();
  }
}
function socketOnEnd() {
  const websocket2 = this[kWebSocket$1];
  websocket2._readyState = WebSocket$1.CLOSING;
  websocket2._receiver.end();
  this.end();
}
function socketOnError$1() {
  const websocket2 = this[kWebSocket$1];
  this.removeListener("error", socketOnError$1);
  this.on("error", NOOP$1);
  if (websocket2) {
    websocket2._readyState = WebSocket$1.CLOSING;
    this.destroy();
  }
}
function parse5(header) {
  const protocols = /* @__PURE__ */ new Set();
  let start = -1;
  let end = -1;
  let i = 0;
  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);
    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (i !== 0 && (code === 32 || code === 9)) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 44) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
      if (end === -1) end = i;
      const protocol2 = header.slice(start, end);
      if (protocols.has(protocol2)) {
        throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
      }
      protocols.add(protocol2);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }
  if (start === -1 || end !== -1) {
    throw new SyntaxError("Unexpected end of input");
  }
  const protocol = header.slice(start, i);
  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }
  protocols.add(protocol);
  return protocols;
}
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);
  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}
function emitClose(server) {
  server._state = CLOSED;
  server.emit("close");
}
function socketOnError() {
  this.destroy();
}
function abortHandshake(socket, code, message, headers) {
  message = message || http$2.STATUS_CODES[code];
  headers = {
    Connection: "close",
    "Content-Type": "text/html",
    "Content-Length": Buffer.byteLength(message),
    ...headers
  };
  socket.once("finish", socket.destroy);
  socket.end(
    `HTTP/1.1 ${code} ${http$2.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
  );
}
function abortHandshakeOrEmitwsClientError(server, req2, socket, code, message) {
  if (server.listenerCount("wsClientError")) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
    server.emit("wsClientError", err, socket, req2);
  } else {
    abortHandshake(socket, code, message);
  }
}
function RedirectableRequest(options2, responseCallback) {
  Writable.call(this);
  this._sanitizeOptions(options2);
  this._options = options2;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self2 = this;
  this._onNativeResponse = function(response) {
    try {
      self2._processResponse(response);
    } catch (cause) {
      self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
    }
  };
  this._performRequest();
}
function wrap(protocols) {
  var exports2 = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports2[scheme] = Object.create(nativeProtocol);
    function request(input, options2, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString2(input)) {
        input = spreadUrlObject(parseUrl(input));
      } else {
        callback = options2;
        options2 = validateUrl(input);
        input = { protocol };
      }
      if (isFunction(options2)) {
        callback = options2;
        options2 = null;
      }
      options2 = Object.assign({
        maxRedirects: exports2.maxRedirects,
        maxBodyLength: exports2.maxBodyLength
      }, input, options2);
      options2.nativeProtocols = nativeProtocols;
      if (!isString2(options2.host) && !isString2(options2.hostname)) {
        options2.hostname = "::1";
      }
      assert.equal(options2.protocol, protocol, "protocol mismatch");
      debug$5("options", options2);
      return new RedirectableRequest(options2, callback);
    }
    function get(input, options2, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options2, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports2;
}
function noop() {
}
function parseUrl(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$1(input);
  } else {
    parsed = validateUrl(url.parse(input));
    if (!isString2(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative2, base) {
  return useNativeURL ? new URL$1(relative2, base) : parseUrl(url.resolve(base, relative2));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
  return spread;
}
function removeMatchingHeaders(regex2, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex2.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
  function CustomError(properties) {
    Error.captureStackTrace(this, this.constructor);
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false
    }
  });
  return CustomError;
}
function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}
function isSubdomain(subdomain, domain) {
  assert(isString2(subdomain) && isString2(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString2(value2) {
  return typeof value2 === "string" || value2 instanceof String;
}
function isFunction(value2) {
  return typeof value2 === "function";
}
function isBuffer(value2) {
  return typeof value2 === "object" && "length" in value2;
}
function isURL(value2) {
  return URL$1 && value2 instanceof URL$1;
}
function createProxyServer(options2) {
  return new ProxyServer(options2);
}
function escapeId(id3) {
  if (!needsEscapeRegEx.test(id3)) return id3;
  return id3.replace(backSlashRegEx, "\\\\").replace(quoteNewlineRegEx, "\\$1");
}
function defineConfig(config2) {
  return config2;
}
var import_esbuild, __filename5, __dirname5, require5, __require3, commonjsGlobal, picocolors, argv, env$1, isColorSupported, formatter, replaceClose, createColors, picocolorsExports, colors$1, VALID_ID_PREFIX, SOURCEMAPPING_URL, isWindows$3, windowsSlashRE, postfixRE, AsyncFunction, utils$k, path$m, WIN_SLASH, WIN_NO_SLASH, DOT_LITERAL, PLUS_LITERAL, QMARK_LITERAL, SLASH_LITERAL, ONE_CHAR, QMARK, END_ANCHOR, START_ANCHOR, DOTS_SLASH, NO_DOT, NO_DOTS, NO_DOT_SLASH, NO_DOTS_SLASH, QMARK_NO_DOT, STAR$1, POSIX_CHARS, WINDOWS_CHARS, POSIX_REGEX_SOURCE$1, constants$6, utils$j, CHAR_ASTERISK, CHAR_AT, CHAR_BACKWARD_SLASH, CHAR_COMMA$1, CHAR_DOT$1, CHAR_EXCLAMATION_MARK, CHAR_FORWARD_SLASH, CHAR_LEFT_CURLY_BRACE$1, CHAR_LEFT_PARENTHESES$1, CHAR_LEFT_SQUARE_BRACKET$1, CHAR_PLUS, CHAR_QUESTION_MARK, CHAR_RIGHT_CURLY_BRACE$1, CHAR_RIGHT_PARENTHESES$1, CHAR_RIGHT_SQUARE_BRACKET$1, isPathSeparator, depth, scan$2, scan_1, constants$5, utils$i, MAX_LENGTH$1, POSIX_REGEX_SOURCE, REGEX_NON_SPECIAL_CHARS, REGEX_SPECIAL_CHARS_BACKREF, REPLACEMENTS, expandRange, syntaxError, parse$g, parse_1$3, path$l, scan$1, parse$f, utils$h, constants$4, isObject$3, picomatch$5, picomatch_1, picomatch$3, picomatch$4, normalizePath$5, createFilter$1, reservedWords, builtins, forbiddenIdentifiers, hasStringIsWellFormed, balancedMatch, balanced, braceExpansion, escSlash, escOpen, escClose, escComma, escPeriod, expand$4, MAX_PATTERN_LENGTH, assertValidPattern, posixClasses, braceEscape, regexpEscape, rangesToString, parseClass, unescape$1, types$1, isExtglobType, startNoTraversal, startNoDot, addPatternStart, justDots, reSpecials, regExpEscape$1, qmark$1, star$1, starNoEmpty, AST, escape$2, minimatch, starDotExtRE, starDotExtTest, starDotExtTestDot, starDotExtTestNocase, starDotExtTestNocaseDot, starDotStarRE, starDotStarTest, starDotStarTestDot, dotStarRE, dotStarTest, starRE, starTest, starTestDot, qmarksRE, qmarksTestNocase, qmarksTestNocaseDot, qmarksTestDot, qmarksTest, qmarksTestNoExt, qmarksTestNoExtDot, defaultPlatform$2, path$j, sep, GLOBSTAR$2, qmark, star2, twoStarDot, twoStarNoDot, filter$1, ext, defaults, braceExpand, makeRe$1, match, globMagic, regExpEscape, Minimatch, perf, warned$1, PROCESS, emitWarning, AC, AS, shouldWarn, isPosInt, getUintArray, ZeroArray, Stack, LRUCache, proc, isStream, isReadable, isWritable, EOF, MAYBE_EMIT_END, EMITTED_END, EMITTING_END, EMITTED_ERROR, CLOSED$1, READ, FLUSH, FLUSHCHUNK, ENCODING$1, DECODER, FLOWING, PAUSED, RESUME, BUFFER, PIPES, BUFFERLENGTH, BUFFERPUSH, BUFFERSHIFT, OBJECTMODE, DESTROYED, ERROR, EMITDATA, EMITEND, EMITEND2, ASYNC, ABORT, ABORTED, SIGNAL, DATALISTENERS, DISCARDED, defer$3, nodefer, isEndish, isArrayBufferLike, isArrayBufferView, Pipe, PipeProxyErrors, isObjectModeOptions, isEncodingOptions, Minipass, realpathSync, defaultFS, fsFromOption, uncDriveRegexp, uncToDrive, eitherSep, UNKNOWN, IFIFO, IFCHR, IFDIR, IFBLK, IFREG, IFLNK, IFSOCK, IFMT, IFMT_UNKNOWN, READDIR_CALLED, LSTAT_CALLED, ENOTDIR, ENOENT, ENOREADLINK, ENOREALPATH, ENOCHILD, TYPEMASK, entToType, normalizeCache, normalize, normalizeNocaseCache, normalizeNocase, ResolveCache, ChildrenCache, setAsCwd, PathBase, PathWin32, PathPosix, PathScurryBase, PathScurryWin32, PathScurryPosix, PathScurryDarwin, PathScurry, isPatternList, isGlobList, Pattern, defaultPlatform$1, Ignore, HasWalkedCache, MatchRecord, SubWalks, Processor2, makeIgnore, GlobUtil, GlobWalker, GlobStream, defaultPlatform, Glob, hasMagic, streamSync, stream$5, iterateSync, iterate, sync$9, glob$1, comma3, semicolon2, chars$1, intToChar, charToInt, bufLength, src$32, browser$3, ms$1, hasRequiredMs$1, common$b, hasRequiredCommon, hasRequiredBrowser$1, node$12, hasRequiredNode$1, srcExports$12, debug$i, pnp, createFilter2, nodeBuiltins, _require$1, rollupVersion, filter, DEBUG, urlCanParse, isCaseInsensitiveFS, externalRE, isExternalUrl, dataUrlRE, isDataUrl, internalPrefixes, InternalPrefixRE, safeRealpathSync, windowsNetworkMap, parseNetUseRE, firstSafeRealPathSyncRun, escapedSpaceCharacters, imageSetUrlRE, cleanSrcSetRE, blankReplacer, _dirname, LogLevels, lastType, lastMsg, sameCount, timeFormatter, groups, POSIX_SEP_RE, NATIVE_SEP_RE, TS_EXTENSIONS, JS_EXTENSIONS, TSJS_EXTENSIONS, TS_EXTENSIONS_RE_GROUP, TSJS_EXTENSIONS_RE_GROUP, IS_POSIX, singleComment, multiComment, debug$h, GIT_LFS_PREFIX, ImportType, A, C, init, E, convertSourceMap$1, debug$g, tasks, utils$g, array$1, errno$1, fs$i, DirentFromStats$1, path$i, os$4, path$h, IS_WINDOWS_PLATFORM, LEADING_DOT_SEGMENT_CHARACTERS_COUNT, POSIX_UNESCAPED_GLOB_SYMBOLS_RE, WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE, DOS_DEVICE_PATH_RE, WINDOWS_BACKSLASHES_RE, pattern$1, isExtglob$1, isExtglob2, chars, strictCheck, relaxedCheck, isGlob$2, isGlob$1, pathPosixDirname, isWin32, slash3, backslash3, enclosure, globby, escaped, globParent$2, utils$f, utils$e, stringify$7, isNumber$2, isNumber$1, toRegexRange$1, toRegexRange_1, util$1, toRegexRange, isObject, transform2, isValidValue, isNumber, zeros, stringify$6, pad, toMaxLen, toSequence, toRange, toRegex, rangeError, invalidRange, invalidStep, fillNumbers, fillLetters, fill$2, fillRange, fill$1, utils$d, compile$1, compile_1, fill, stringify$5, utils$c, append$1, expand$2, expand_1$1, constants$3, stringify$4, MAX_LENGTH, CHAR_BACKSLASH, CHAR_BACKTICK, CHAR_COMMA, CHAR_DOT, CHAR_LEFT_PARENTHESES, CHAR_RIGHT_PARENTHESES, CHAR_LEFT_CURLY_BRACE, CHAR_RIGHT_CURLY_BRACE, CHAR_LEFT_SQUARE_BRACKET, CHAR_RIGHT_SQUARE_BRACKET, CHAR_DOUBLE_QUOTE, CHAR_SINGLE_QUOTE, CHAR_NO_BREAK_SPACE, CHAR_ZERO_WIDTH_NOBREAK_SPACE, parse$c, parse_1$2, stringify$3, compile, expand$1, parse$b, braces$2, braces_1, util2, braces$1, picomatch$2, utils$b, isEmptyString, hasBraces, micromatch$1, micromatch_1, micromatch$2, path$g, globParent$1, micromatch, GLOBSTAR$1, ESCAPE_SYMBOL, COMMON_GLOB_SYMBOLS_RE, REGEX_CHARACTER_CLASS_SYMBOLS_RE, REGEX_GROUP_SYMBOLS_RE, GLOB_EXTENSION_SYMBOLS_RE, BRACE_EXPANSION_SEPARATORS_RE, DOUBLE_SLASH_RE$1, stream$4, Stream, PassThrough, slice, merge2_1, merge22, string$2, array, errno, fs$h, path$f, pattern, stream$3, string$12, utils$a, async$7, async$6, out$3, async$5, async$4, out$2, async$3, out$1, async$2, sync$8, settings$3, fs$g, fs$f, Settings$2, async$1, sync$7, settings_1$3, promise, queueMicrotask_1, runParallel_1, queueMicrotask$1, constants$2, NODE_PROCESS_VERSION_PARTS, MAJOR_VERSION, MINOR_VERSION, SUPPORTED_MAJOR_VERSION, SUPPORTED_MINOR_VERSION, IS_MATCHED_BY_MAJOR, IS_MATCHED_BY_MAJOR_AND_MINOR, utils$9, fs$e, DirentFromStats2, fs$d, common$a, fsStat$5, rpl, constants_1$1, utils$8, common$9, sync$6, fsStat$4, constants_1, utils$7, common$8, settings$2, fs$c, path$e, fsStat$3, fs$b, Settings$1, async, sync$5, settings_1$2, queue, reusify_1, reusify, queueExports, common$7, reader$1, common$6, Reader$1, events_1, fsScandir$2, fastq, common$5, reader_1$4, AsyncReader, async_1$4, AsyncProvider, stream$2, stream_1$5, async_1$3, StreamProvider, sync$4, sync$3, fsScandir$1, common$4, reader_1$3, SyncReader, sync_1$3, SyncProvider, settings$1, path$d, fsScandir, Settings3, async_1$2, stream_1$4, sync_1$2, settings_1$1, reader, path$c, fsStat$2, utils$6, Reader2, stream$1, stream_1$3, fsStat$1, fsWalk$2, reader_1$2, ReaderStream, fsWalk$1, reader_1$1, stream_1$2, ReaderAsync, provider, deep, partial, matcher, utils$5, Matcher, matcher_1, PartialMatcher, utils$4, partial_1, DeepFilter, entry$1, utils$3, EntryFilter, error$1, utils$2, ErrorFilter, entry, utils$1, EntryTransformer, path$b, deep_1, entry_1, error_1, entry_2, Provider, async_1$1, provider_1$2, ProviderAsync, stream, stream_1$1, stream_2, provider_1$1, ProviderStream, sync$2, sync$1, fsStat, fsWalk, reader_1, ReaderSync, sync_1$1, provider_1, ProviderSync, settings, taskManager, async_1, stream_1, sync_1, settings_1, utils, src$22, path$a, fs$a, os$3, fsReadFileAsync, jsonLoader, requireFunc, defaultLoadersSync, dynamicImport, defaultLoaders, makeEmplace, ALIAS, DOC, MAP, PAIR, SCALAR$1, SEQ, NODE_TYPE, isAlias, isDocument, isMap, isPair, isScalar$1, isSeq, hasAnchor, BREAK$1, SKIP$1, REMOVE$1, escapeChars, escapeTagName, Directives, NodeBase, Alias, isScalarValue, Scalar, defaultTagPrefix, isEmptyPath, Collection, stringifyComment, lineComment, FOLD_FLOW, FOLD_BLOCK, FOLD_QUOTED, getFoldOptions, containsDocumentMarker, blockEndNewlines, MERGE_KEY, isMergeKey, Pair, YAMLMap, map$1, YAMLSeq, seq, string3, nullTag, boolTag, floatNaN$1, floatExp$1, float$1, intIdentify$2, intResolve$1, intOct$1, int$1, intHex$1, schema$2, stringifyJSON, jsonScalars, jsonError, schema$1, binary, pairs, YAMLOMap, omap, trueTag, falseTag, floatNaN, floatExp, float, intIdentify, intBin, intOct, int, intHex, YAMLSet, set, intTime, floatTime, timestamp2, schema, schemas, tagsByName, coreKnownTags, sortMapEntriesByKey, Schema, Document2, YAMLError, YAMLParseError, YAMLWarning, prettifyError, startColMsg, blockMsg, isBlock$1, escapeCodes, CN, Composer, stringify$12, BREAK, SKIP, REMOVE, BOM, DOCUMENT, FLOW_END, SCALAR, isCollection, isScalar, cst, hexDigits, tagChars, flowIndicatorChars, invalidAnchorChars, isNotAnchorChar, Lexer, LineCounter, Parser2, YAML, browser$2, require$$32, createRequire, createRequireFromPath, req_1, req$1, options, options_1, req, load, plugins, plugins_1, resolve3, url$4, config$1, yaml, loadOptions, loadPlugins, interopRequireDefault, processResult, createContext, importDefault, addTypeScriptLoader, withTypeScriptLoader, rc, HashbangComment, Identifier, JSXIdentifier, JSXPunctuator, JSXString, JSXText, KeywordsWithExpressionAfter, KeywordsWithNoLineTerminatorAfter, LineTerminatorSequence, MultiLineComment, Newline, NumericLiteral, Punctuator, RegularExpressionLiteral, SingleLineComment, StringLiteral, Template, TokensNotPrecedingObjectLiteral, TokensPrecedingExpression, WhiteSpace, main$1, name, version$1, description, main, types2, exports, scripts, repository, funding, keywords, readmeFilename, license, devDependencies, engines, browser$1, require$$4, fs$9, path$9, os$2, crypto$1, packageJson, version2, LINE, DotenvModule, parse_1$1, modulePreloadPolyfillId, resolvedModulePreloadPolyfillId, moduleScriptRE, modulePreloadLinkRE, importMapAppendRE, decoder, cssModuleRE, functionCallRE, nonEscapedDoubleQuoteRe, importPostcssImport, importPostcssModules, importPostcss, cssUrlRE, cssImageSetRE, UrlRewritePostcssPlugin, cssNotProcessedRE, importLightningCSS, own$1, classRegExp, kTypes, messages, nodeInternalPrefix, userStackTraceLimit, captureLargerStackTrace, isMatch$1, scan, basename, dirname, relative, join, src2, browser, debug$f, ms, hasRequiredMs, hasRequiredDebug, hasRequiredBrowser, node2, hasRequiredNode, srcExports2, encodeurl, ENCODE_CHARS_REGEXP, UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE, matchHtmlRegExp, escapeHtml_1, onFinished$2, eeFirst, first, defer$2, onFinishedExports, parseurl$1, url$3, parse$8, Url, parseurlExports, require$$0$12, codes, statuses$1, unpipe_1, debug$e, encodeUrl, escapeHtml, onFinished, parseUrl$2, statuses, unpipe, DOUBLE_SPACE_REGEXP, NEWLINE_REGEXP, defer$1, isFinished, finalhandler_1, utilsMerge, utilsMergeExports, debug$d, EventEmitter$3, finalhandler, http$4, parseUrl$1, env, proto, defer, lib2, getOwnPropertySymbols, hasOwnProperty3, propIsEnumerable, objectAssign, vary$1, FIELD_NAME_REGEXP, varyExports, libExports, chokidar, fs$8, Readable, sysPath$3, promisify$3, picomatch$1, readdir$1, stat$3, lstat$2, realpath$1, BANG$2, RECURSIVE_ERROR_CODE, NORMAL_FLOW_ERRORS, FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE, ALL_TYPES, isNormalFlowError, maj, min, wantBigintFsStats, normalizeFilter, ReaddirpStream, readdirp$1, readdirpPromise, readdirp_1, anymatch$2, normalizePath$2, anymatch_1, picomatch, normalizePath$1, BANG$1, DEFAULT_OPTIONS, arrify$1, createPattern, matchPatterns, anymatch$1, anymatchExports, require$$02, binaryExtensions$1, path$8, binaryExtensions, extensions, isBinaryPath$1, constants$1, fs$7, sysPath$2, promisify$2, isBinaryPath, isWindows$2, isLinux, EMPTY_FN$2, EMPTY_STR$1, KEY_LISTENERS, KEY_ERR, KEY_RAW, HANDLER_KEYS, EV_CHANGE$2, EV_ADD$2, EV_ADD_DIR$2, EV_ERROR$2, STR_DATA$1, STR_END$2, BRACE_START$1, STAR, THROTTLE_MODE_WATCH, open$2, stat$2, lstat$1, close, fsrealpath, statMethods$1, foreach, addAndConvert, clearItem, delFromSet, isEmptySet, FsWatchInstances, fsWatchBroadcast, setFsWatchListener, FsWatchFileInstances, setFsWatchFileListener, NodeFsHandler$1, nodefsHandler, fseventsHandler, fs$6, sysPath$1, promisify$1, fsevents, EV_ADD$1, EV_CHANGE$1, EV_ADD_DIR$1, EV_UNLINK$1, EV_ERROR$1, STR_DATA, STR_END$1, FSEVENT_CREATED, FSEVENT_MODIFIED, FSEVENT_DELETED, FSEVENT_MOVED, FSEVENT_UNKNOWN, FSEVENT_FLAG_MUST_SCAN_SUBDIRS, FSEVENT_TYPE_FILE, FSEVENT_TYPE_DIRECTORY, FSEVENT_TYPE_SYMLINK, ROOT_GLOBSTAR, DIR_SUFFIX, DOT_SLASH, FUNCTION_TYPE$1, EMPTY_FN$1, IDENTITY_FN, Depth, stat$1, lstat, realpath, statMethods, FSEventsWatchers, consolidateThreshhold, wrongEventFlags, createFSEventsInstance, couldConsolidate, canUse, calcDepth, sameTypes, FsEventsHandler$1, fseventsHandlerExports, EventEmitter$2, fs$5, sysPath, promisify, readdirp, anymatch, globParent2, isGlob2, braces, normalizePath2, NodeFsHandler2, FsEventsHandler2, EV_ALL, EV_READY, EV_ADD, EV_CHANGE, EV_UNLINK, EV_ADD_DIR, EV_UNLINK_DIR, EV_RAW, EV_ERROR, STR_CLOSE, STR_END, BACK_SLASH_RE, DOUBLE_SLASH_RE, SLASH_OR_BACK_SLASH_RE, DOT_RE, REPLACER_RE, SLASH, SLASH_SLASH, BRACE_START, BANG, ONE_DOT, TWO_DOTS, GLOBSTAR, SLASH_GLOBSTAR, ANYMATCH_OPTS, STRING_TYPE, FUNCTION_TYPE, EMPTY_STR, EMPTY_FN, isWindows$1, isMacos, isIBMi, stat2, readdir, arrify, flatten, unifyPaths, toUnix, normalizePathToUnix, normalizeIgnored, getAbsolutePath, undef, DirEntry, STAT_METHOD_F, STAT_METHOD_L, WatchHelper, FSWatcher, watch, shellQuote$1, quote, CONTROL, controlRE, META, SINGLE_QUOTE, DOUBLE_QUOTE, hash2, SQ, DQ, DS, TOKEN, mult, i, startsWithToken, parse$6, commonFsUtils, Stats, normalizedClientEntry$1, normalizedEnvEntry$1, debug$c, externalTypes, debug$b, jsonLangs, jsonLangRE, debug$a, normalizedClientEntry, normalizedEnvEntry, wasmHelper, wasmHelperCode, regex, EMPTY_OBJECT2, debugSourcemapCombineFilter, debugSourcemapCombine, debugResolve, debugPluginResolve, debugPluginTransform, debug$9, debug$8, debug$7, lockfileFormats, lockfileNames, MAX_TEMP_DIR_AGE_MS, GRACEFUL_RENAME_TIMEOUT, safeRename, debugLoad, debugTransform, debugCache$1, isWsl$2, fs$3, isDocker$2, isDocker_1, os, fs$2, isDocker$1, isWsl$1, isWslExports, defineLazyProp, path$32, childProcess, fs$1, fsConstants, isWsl, isDocker, defineLazyProperty, localXdgOpenPath, platform, arch, hasContainerEnv, cachedResult, getWslDrivesMountPoint, pTryEach, baseOpen, open, openApp, apps, crossSpawn, windows, hasRequiredWindows, mode, hasRequiredMode, core, isexe_1, isWindows, path$22, COLON, isexe, getNotFoundError, getPathInfo, which$1, whichSync, which_1, pathKey$1, pathKey, pathKeyExports, path$13, which, getPathKey, resolveCommand_1, _escape, metaCharsRegExp, shebangRegex$1, shebangRegex, shebangCommand$1, fs3, shebangCommand, readShebang_1, path4, resolveCommand, escape$1, readShebang, isWin$1, isExecutableRegExp, isCmdShimRegExp, parse_1, isWin, enoent$1, cp, parse$3, enoent, crossSpawnExports, OTHER_SOURCE_MAP_REGEXP, bufferUtil$1, BINARY_TYPES$2, hasBlob$1, constants, EMPTY_BUFFER$3, FastBuffer$2, bufferUtilExports, kDone, kRun, Limiter$1, limiter, zlib, bufferUtil, Limiter2, kStatusCode$2, FastBuffer$1, TRAILER, kPerMessageDeflate, kTotalLength, kCallback, kBuffers, kError$1, zlibLimiter, PerMessageDeflate$4, permessageDeflate, validation, isUtf8, hasBlob, tokenChars$2, validationExports, Writable$1, PerMessageDeflate$3, BINARY_TYPES$1, EMPTY_BUFFER$2, kStatusCode$1, kWebSocket$3, concat, toArrayBuffer, unmask, isValidStatusCode$1, isValidUTF8, FastBuffer, GET_INFO, GET_PAYLOAD_LENGTH_16, GET_PAYLOAD_LENGTH_64, GET_MASK, GET_DATA, INFLATING, DEFER_EVENT, Receiver$1, receiver, randomFillSync, PerMessageDeflate$2, EMPTY_BUFFER$1, kWebSocket$2, NOOP$2, isBlob$1, isValidStatusCode, applyMask, toBuffer$1, kByteLength, maskBuffer, RANDOM_POOL_SIZE, randomPool, randomPoolPointer, DEFAULT, DEFLATING, GET_BLOB_DATA, Sender$1, sender, kForOnEventAttribute$1, kListener$1, kCode, kData, kError, kMessage, kReason, kTarget, kType, kWasClean, Event$1, CloseEvent, ErrorEvent, MessageEvent, EventTarget, eventTarget, tokenChars$1, extension$1, EventEmitter$1, https$2, http$3, net, tls, randomBytes, createHash$1, URL$2, PerMessageDeflate$1, Receiver2, Sender2, isBlob, BINARY_TYPES, EMPTY_BUFFER, GUID$1, kForOnEventAttribute, kListener, kStatusCode, kWebSocket$1, NOOP$1, addEventListener, removeEventListener, format, parse$12, toBuffer, closeTimeout, kAborted, protocolVersions, readyStates, subprotocolRegex, WebSocket$1, websocket, tokenChars, subprotocol$1, EventEmitter, http$2, createHash, extension, PerMessageDeflate2, subprotocol, WebSocket2, GUID, kWebSocket, keyRegex, RUNNING, CLOSING, CLOSED, WebSocketServer, websocketServer, WebSocketServerRaw_, WebSocketServerRaw, httpProxy$3, eventemitter3, eventemitter3Exports, common$3, requiresPort, url$1, common$2, redirectRegex, webOutgoing, followRedirects$1, debug$6, debug_1, url, URL$1, http$1, https$1, Writable, assert, debug$5, useNativeURL, preservedUrlFields, events, eventHandlers, InvalidUrlError, RedirectionError, TooManyRedirectsError, MaxBodyLengthExceededError, WriteAfterEndError, destroy, followRedirectsExports, httpNative, httpsNative, web_o, common$1, followRedirects, nativeAgents, webIncoming, http, https, common, wsIncoming, httpProxyExports, ProxyServer, debug$4, debug$3, debug$2, debugCache, logTime, debugHmr, normalizedClientDir, debug$1, clientDir, preloadMarker, preloadMarkerRE, needsEscapeRegEx, quoteNewlineRegEx, backSlashRegEx, getResolveUrl, getRelativeUrlFromDocument, getFileUrlFromFullPath, getFileUrlFromRelativePath, relativeUrlMechanisms, customRelativeUrlMechanisms, debug, promisifiedRealpath, _require;
var init_dep_C6uTJdX2 = __esm({
  "node_modules/vite/dist/node/chunks/dep-C6uTJdX2.js"() {
    import_esbuild = __toESM(require_main(), 1);
    init_constants();
    init_parseAst2();
    __filename5 = __cjs_fileURLToPath4(import.meta.url);
    __dirname5 = __cjs_dirname4(__filename5);
    require5 = __cjs_createRequire4(import.meta.url);
    __require3 = require5;
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    picocolors = { exports: {} };
    argv = process.argv || [];
    env$1 = process.env;
    isColorSupported = !("NO_COLOR" in env$1 || argv.includes("--no-color")) && ("FORCE_COLOR" in env$1 || argv.includes("--color") || process.platform === "win32" || commonjsRequire != null && require$$0$3.isatty(1) && env$1.TERM !== "dumb" || "CI" in env$1);
    formatter = (open2, close2, replace = open2) => (input) => {
      let string4 = "" + input;
      let index4 = string4.indexOf(close2, open2.length);
      return ~index4 ? open2 + replaceClose(string4, close2, replace, index4) + close2 : open2 + string4 + close2;
    };
    replaceClose = (string4, close2, replace, index4) => {
      let result = "";
      let cursor = 0;
      do {
        result += string4.substring(cursor, index4) + replace;
        cursor = index4 + close2.length;
        index4 = string4.indexOf(close2, cursor);
      } while (~index4);
      return result + string4.substring(cursor);
    };
    createColors = (enabled = isColorSupported) => {
      let init2 = enabled ? formatter : () => String;
      return {
        isColorSupported: enabled,
        reset: init2("\x1B[0m", "\x1B[0m"),
        bold: init2("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m"),
        dim: init2("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m"),
        italic: init2("\x1B[3m", "\x1B[23m"),
        underline: init2("\x1B[4m", "\x1B[24m"),
        inverse: init2("\x1B[7m", "\x1B[27m"),
        hidden: init2("\x1B[8m", "\x1B[28m"),
        strikethrough: init2("\x1B[9m", "\x1B[29m"),
        black: init2("\x1B[30m", "\x1B[39m"),
        red: init2("\x1B[31m", "\x1B[39m"),
        green: init2("\x1B[32m", "\x1B[39m"),
        yellow: init2("\x1B[33m", "\x1B[39m"),
        blue: init2("\x1B[34m", "\x1B[39m"),
        magenta: init2("\x1B[35m", "\x1B[39m"),
        cyan: init2("\x1B[36m", "\x1B[39m"),
        white: init2("\x1B[37m", "\x1B[39m"),
        gray: init2("\x1B[90m", "\x1B[39m"),
        bgBlack: init2("\x1B[40m", "\x1B[49m"),
        bgRed: init2("\x1B[41m", "\x1B[49m"),
        bgGreen: init2("\x1B[42m", "\x1B[49m"),
        bgYellow: init2("\x1B[43m", "\x1B[49m"),
        bgBlue: init2("\x1B[44m", "\x1B[49m"),
        bgMagenta: init2("\x1B[45m", "\x1B[49m"),
        bgCyan: init2("\x1B[46m", "\x1B[49m"),
        bgWhite: init2("\x1B[47m", "\x1B[49m")
      };
    };
    picocolors.exports = createColors();
    picocolors.exports.createColors = createColors;
    picocolorsExports = picocolors.exports;
    colors$1 = /* @__PURE__ */ getDefaultExportFromCjs(picocolorsExports);
    VALID_ID_PREFIX = `/@id/`;
    SOURCEMAPPING_URL = "sourceMa";
    SOURCEMAPPING_URL += "ppingURL";
    isWindows$3 = typeof process !== "undefined" && process.platform === "win32";
    windowsSlashRE = /\\/g;
    postfixRE = /[?#].*$/;
    AsyncFunction = async function() {
    }.constructor;
    utils$k = {};
    path$m = require$$0$4;
    WIN_SLASH = "\\\\/";
    WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    DOT_LITERAL = "\\.";
    PLUS_LITERAL = "\\+";
    QMARK_LITERAL = "\\?";
    SLASH_LITERAL = "\\/";
    ONE_CHAR = "(?=.)";
    QMARK = "[^/]";
    END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    NO_DOT = `(?!${DOT_LITERAL})`;
    NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    STAR$1 = `${QMARK}*?`;
    POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR: STAR$1,
      START_ANCHOR
    };
    WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    POSIX_REGEX_SOURCE$1 = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    constants$6 = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path$m.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars4) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars4.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win322) {
        return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
    (function(exports2) {
      const path9 = require$$0$4;
      const win322 = process.platform === "win32";
      const {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = constants$6;
      exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports2.hasRegexChars = (str2) => REGEX_SPECIAL_CHARS.test(str2);
      exports2.isRegexChar = (str2) => str2.length === 1 && exports2.hasRegexChars(str2);
      exports2.escapeRegex = (str2) => str2.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports2.toPosixSlashes = (str2) => str2.replace(REGEX_BACKSLASH, "/");
      exports2.removeBackslashes = (str2) => {
        return str2.replace(REGEX_REMOVE_BACKSLASH, (match2) => {
          return match2 === "\\" ? "" : match2;
        });
      };
      exports2.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports2.isWindows = (options2) => {
        if (options2 && typeof options2.windows === "boolean") {
          return options2.windows;
        }
        return win322 === true || path9.sep === "\\";
      };
      exports2.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1) return input;
        if (input[idx - 1] === "\\") return exports2.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports2.removePrefix = (input, state = {}) => {
        let output = input;
        if (output.startsWith("./")) {
          output = output.slice(2);
          state.prefix = "./";
        }
        return output;
      };
      exports2.wrapOutput = (input, state = {}, options2 = {}) => {
        const prepend = options2.contains ? "" : "^";
        const append2 = options2.contains ? "" : "$";
        let output = `${prepend}(?:${input})${append2}`;
        if (state.negated === true) {
          output = `(?:^(?!${output}).*$)`;
        }
        return output;
      };
    })(utils$k);
    utils$j = utils$k;
    ({
      CHAR_ASTERISK,
      CHAR_AT: (
        /* * */
        CHAR_AT
      ),
      CHAR_BACKWARD_SLASH: (
        /* @ */
        CHAR_BACKWARD_SLASH
      ),
      CHAR_COMMA: CHAR_COMMA$1,
      CHAR_DOT: CHAR_DOT$1,
      CHAR_EXCLAMATION_MARK: (
        /* . */
        CHAR_EXCLAMATION_MARK
      ),
      CHAR_FORWARD_SLASH: (
        /* ! */
        CHAR_FORWARD_SLASH
      ),
      CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,
      CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,
      CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,
      CHAR_PLUS: (
        /* [ */
        CHAR_PLUS
      ),
      CHAR_QUESTION_MARK: (
        /* + */
        CHAR_QUESTION_MARK
      ),
      CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,
      CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,
      CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1
    } = constants$6);
    isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    scan$2 = (input, options2) => {
      const opts = options2 || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str2 = input;
      let index4 = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob3 = false;
      let isExtglob3 = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces2 = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index4 >= length;
      const peek = () => str2.charCodeAt(index4 + 1);
      const advance = () => {
        prev = code;
        return str2.charCodeAt(++index4);
      };
      while (index4 < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE$1) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {
          braces2++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE$1) {
              braces2++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT$1 && (code = advance()) === CHAR_DOT$1) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA$1) {
              isBrace = token.isBrace = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE$1) {
              braces2--;
              if (braces2 === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index4);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true) continue;
          if (prev === CHAR_DOT$1 && index4 === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index4 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES$1) {
            isGlob3 = token.isGlob = true;
            isExtglob3 = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index4 === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES$1) {
                  isGlob3 = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob3 = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET$1) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {
              isBracket = token.isBracket = true;
              isGlob3 = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index4 === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$1) {
          isGlob3 = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES$1) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES$1) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob3 === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob3 = false;
        isGlob3 = false;
      }
      let base = str2;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str2.slice(0, start);
        str2 = str2.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob3 === true && lastIndex > 0) {
        base = str2.slice(0, lastIndex);
        glob = str2.slice(lastIndex);
      } else if (isGlob3 === true) {
        base = "";
        glob = str2;
      } else {
        base = str2;
      }
      if (base && base !== "" && base !== "/" && base !== str2) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob) glob = utils$j.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils$j.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob: isGlob3,
        isExtglob: isExtglob3,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value2 = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value2;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value2 !== "") {
            parts.push(value2);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value2 = input.slice(prevIndex + 1);
          parts.push(value2);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value2;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    scan_1 = scan$2;
    constants$5 = constants$6;
    utils$i = utils$k;
    ({
      MAX_LENGTH: MAX_LENGTH$1,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants$5);
    expandRange = (args, options2) => {
      if (typeof options2.expandRange === "function") {
        return options2.expandRange(...args, options2);
      }
      args.sort();
      const value2 = `[${args.join("-")}]`;
      return value2;
    };
    syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    parse$g = (input, options2) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options2 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win322 = utils$i.isWindows(options2);
      const PLATFORM_CHARS = constants$5.globChars(win322);
      const EXTGLOB_CHARS = constants$5.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        PLUS_LITERAL: PLUS_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOT_SLASH: NO_DOT_SLASH2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        QMARK: QMARK2,
        QMARK_NO_DOT: QMARK_NO_DOT2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT2;
      const qmarkNoDot = opts.dot ? QMARK2 : QMARK_NO_DOT2;
      let star3 = opts.bash === true ? globstar(opts) : STAR2;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils$i.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces2 = [];
      const stack = [];
      let prev = bos;
      let value2;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value3 = "", num = 0) => {
        state.consumed += value3;
        state.index += num;
      };
      const append2 = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push2 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob3 = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob3) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star3;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output) append2(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value3) => {
        const token = { ...EXTGLOB_CHARS[value3], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push2({ type, value: value3, output: state.output ? "" : ONE_CHAR2 });
        push2({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star3;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse$g(rest, { ...options2, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push2({ type: "paren", extglob: true, value: value2, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars4, first2, rest, index4) => {
          if (first2 === "\\") {
            backslashes = true;
            return m;
          }
          if (first2 === "?") {
            if (esc) {
              return esc + first2 + (rest ? QMARK2.repeat(rest.length) : "");
            }
            if (index4 === 0) {
              return qmarkNoDot + (rest ? QMARK2.repeat(rest.length) : "");
            }
            return QMARK2.repeat(chars4.length);
          }
          if (first2 === ".") {
            return DOT_LITERAL2.repeat(chars4.length);
          }
          if (first2 === "*") {
            if (esc) {
              return esc + first2 + (rest ? star3 : "");
            }
            return star3;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils$i.wrapOutput(output, state, options2);
        return state;
      }
      while (!eos()) {
        value2 = advance();
        if (value2 === "\0") {
          continue;
        }
        if (value2 === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value2 += "\\";
            push2({ type: "text", value: value2 });
            continue;
          }
          const match2 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match2 && match2[0].length > 2) {
            slashes = match2[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value2 += "\\";
            }
          }
          if (opts.unescape === true) {
            value2 = advance();
          } else {
            value2 += advance();
          }
          if (state.brackets === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
        }
        if (state.brackets > 0 && (value2 !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value2 === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix2 = POSIX_REGEX_SOURCE[rest2];
                if (posix2) {
                  prev.value = pre + posix2;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR2;
                  }
                  continue;
                }
              }
            }
          }
          if (value2 === "[" && peek() !== ":" || value2 === "-" && peek() === "]") {
            value2 = `\\${value2}`;
          }
          if (value2 === "]" && (prev.value === "[" || prev.value === "[^")) {
            value2 = `\\${value2}`;
          }
          if (opts.posix === true && value2 === "!" && prev.value === "[") {
            value2 = "^";
          }
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (state.quotes === 1 && value2 !== '"') {
          value2 = utils$i.escapeRegex(value2);
          prev.value += value2;
          append2({ value: value2 });
          continue;
        }
        if (value2 === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push2({ type: "text", value: value2 });
          }
          continue;
        }
        if (value2 === "(") {
          increment("parens");
          push2({ type: "paren", value: value2 });
          continue;
        }
        if (value2 === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push2({ type: "paren", value: value2, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value2 === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value2 = `\\${value2}`;
          } else {
            increment("brackets");
          }
          push2({ type: "bracket", value: value2 });
          continue;
        }
        if (value2 === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push2({ type: "text", value: value2, output: `\\${value2}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value2 = `/${value2}`;
          }
          prev.value += value2;
          append2({ value: value2 });
          if (opts.literalBrackets === false || utils$i.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped2 = utils$i.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped2;
            prev.value = escaped2;
            continue;
          }
          prev.value = `(${capture}${escaped2}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value2 === "{" && opts.nobrace !== true) {
          increment("braces");
          const open2 = {
            type: "brace",
            value: value2,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces2.push(open2);
          push2(open2);
          continue;
        }
        if (value2 === "}") {
          const brace = braces2[braces2.length - 1];
          if (opts.nobrace === true || !brace) {
            push2({ type: "text", value: value2, output: value2 });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range2 = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range2.unshift(arr[i].value);
              }
            }
            output = expandRange(range2, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value2 = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push2({ type: "brace", value: value2, output });
          decrement("braces");
          braces2.pop();
          continue;
        }
        if (value2 === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === ",") {
          let output = value2;
          const brace = braces2[braces2.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push2({ type: "comma", value: value2, output });
          continue;
        }
        if (value2 === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push2({ type: "slash", value: value2, output: SLASH_LITERAL2 });
          continue;
        }
        if (value2 === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".") prev.output = DOT_LITERAL2;
            const brace = braces2[braces2.length - 1];
            prev.type = "dots";
            prev.output += value2;
            prev.value += value2;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push2({ type: "text", value: value2, output: DOT_LITERAL2 });
            continue;
          }
          push2({ type: "dot", value: value2, output: DOT_LITERAL2 });
          continue;
        }
        if (value2 === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value2);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value2;
            if (next === "<" && !utils$i.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value2}`;
            }
            push2({ type: "text", value: value2, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push2({ type: "qmark", value: value2, output: QMARK_NO_DOT2 });
            continue;
          }
          push2({ type: "qmark", value: value2, output: QMARK2 });
          continue;
        }
        if (value2 === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value2);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value2 === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value2);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push2({ type: "plus", value: value2, output: PLUS_LITERAL2 });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push2({ type: "plus", value: value2 });
            continue;
          }
          push2({ type: "plus", value: PLUS_LITERAL2 });
          continue;
        }
        if (value2 === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push2({ type: "at", extglob: true, value: value2, output: "" });
            continue;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 !== "*") {
          if (value2 === "$" || value2 === "^") {
            value2 = `\\${value2}`;
          }
          const match2 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match2) {
            value2 += match2[0];
            state.index += match2[0].length;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value2;
          prev.output = star3;
          state.backtrack = true;
          state.globstar = true;
          consume(value2);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value2);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value2);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob3 = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob3) {
            push2({ type: "star", value: value2, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value2;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value2);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL2}|${SLASH_LITERAL2}${end})`;
            prev.value += value2;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value2 + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value2;
            prev.output = `(?:^|${SLASH_LITERAL2}|${globstar(opts)}${SLASH_LITERAL2})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value2 + advance());
            push2({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value2;
          state.output += prev.output;
          state.globstar = true;
          consume(value2);
          continue;
        }
        const token = { type: "star", value: value2, output: star3 };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push2(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value2;
          push2(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH2;
            prev.output += NO_DOT_SLASH2;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH2;
            prev.output += NO_DOTS_SLASH2;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR2;
            prev.output += ONE_CHAR2;
          }
        }
        push2(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils$i.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils$i.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true) throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils$i.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push2({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL2}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse$g.fastpaths = (input, options2) => {
      const opts = { ...options2 };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win322 = utils$i.isWindows(options2);
      const {
        DOT_LITERAL: DOT_LITERAL2,
        SLASH_LITERAL: SLASH_LITERAL2,
        ONE_CHAR: ONE_CHAR2,
        DOTS_SLASH: DOTS_SLASH2,
        NO_DOT: NO_DOT2,
        NO_DOTS: NO_DOTS2,
        NO_DOTS_SLASH: NO_DOTS_SLASH2,
        STAR: STAR2,
        START_ANCHOR: START_ANCHOR2
      } = constants$5.globChars(win322);
      const nodot = opts.dot ? NO_DOTS2 : NO_DOT2;
      const slashDot = opts.dot ? NO_DOTS_SLASH2 : NO_DOT2;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star3 = opts.bash === true ? ".*?" : STAR2;
      if (opts.capture) {
        star3 = `(${star3})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true) return star3;
        return `(${capture}(?:(?!${START_ANCHOR2}${opts2.dot ? DOTS_SLASH2 : DOT_LITERAL2}).)*?)`;
      };
      const create = (str2) => {
        switch (str2) {
          case "*":
            return `${nodot}${ONE_CHAR2}${star3}`;
          case ".*":
            return `${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
          case "*.*":
            return `${nodot}${star3}${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
          case "*/*":
            return `${nodot}${star3}${SLASH_LITERAL2}${ONE_CHAR2}${slashDot}${star3}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${ONE_CHAR2}${star3}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${slashDot}${star3}${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL2})?${DOT_LITERAL2}${ONE_CHAR2}${star3}`;
          default: {
            const match2 = /^(.*?)\.(\w+)$/.exec(str2);
            if (!match2) return;
            const source2 = create(match2[1]);
            if (!source2) return;
            return source2 + DOT_LITERAL2 + match2[2];
          }
        }
      };
      const output = utils$i.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL2}?`;
      }
      return source;
    };
    parse_1$3 = parse$g;
    path$l = require$$0$4;
    scan$1 = scan_1;
    parse$f = parse_1$3;
    utils$h = utils$k;
    constants$4 = constants$6;
    isObject$3 = (val) => val && typeof val === "object" && !Array.isArray(val);
    picomatch$5 = (glob, options2, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch$5(input, options2, returnState));
        const arrayMatcher = (str2) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str2);
            if (state2) return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject$3(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options2 || {};
      const posix2 = utils$h.isWindows(options2);
      const regex2 = isState ? picomatch$5.compileRe(glob, options2) : picomatch$5.makeRe(glob, options2, false, true);
      const state = regex2.state;
      delete regex2.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options2, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch$5(opts.ignore, ignoreOpts, returnState);
      }
      const matcher2 = (input, returnObject = false) => {
        const { isMatch, match: match2, output } = picomatch$5.test(input, regex2, options2, { glob, posix: posix2 });
        const result = { glob, state, regex: regex2, posix: posix2, input, output, match: match2, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher2.state = state;
      }
      return matcher2;
    };
    picomatch$5.test = (input, regex2, options2, { glob, posix: posix2 } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options2 || {};
      const format2 = opts.format || (posix2 ? utils$h.toPosixSlashes : null);
      let match2 = input === glob;
      let output = match2 && format2 ? format2(input) : input;
      if (match2 === false) {
        output = format2 ? format2(input) : input;
        match2 = output === glob;
      }
      if (match2 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match2 = picomatch$5.matchBase(input, regex2, options2, posix2);
        } else {
          match2 = regex2.exec(output);
        }
      }
      return { isMatch: Boolean(match2), match: match2, output };
    };
    picomatch$5.matchBase = (input, glob, options2, posix2 = utils$h.isWindows(options2)) => {
      const regex2 = glob instanceof RegExp ? glob : picomatch$5.makeRe(glob, options2);
      return regex2.test(path$l.basename(input));
    };
    picomatch$5.isMatch = (str2, patterns, options2) => picomatch$5(patterns, options2)(str2);
    picomatch$5.parse = (pattern2, options2) => {
      if (Array.isArray(pattern2)) return pattern2.map((p) => picomatch$5.parse(p, options2));
      return parse$f(pattern2, { ...options2, fastpaths: false });
    };
    picomatch$5.scan = (input, options2) => scan$1(input, options2);
    picomatch$5.compileRe = (state, options2, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options2 || {};
      const prepend = opts.contains ? "" : "^";
      const append2 = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append2}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex2 = picomatch$5.toRegex(source, options2);
      if (returnState === true) {
        regex2.state = state;
      }
      return regex2;
    };
    picomatch$5.makeRe = (input, options2 = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options2.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse$f.fastpaths(input, options2);
      }
      if (!parsed.output) {
        parsed = parse$f(input, options2);
      }
      return picomatch$5.compileRe(parsed, options2, returnOutput, returnState);
    };
    picomatch$5.toRegex = (source, options2) => {
      try {
        const opts = options2 || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options2 && options2.debug === true) throw err;
        return /$^/;
      }
    };
    picomatch$5.constants = constants$4;
    picomatch_1 = picomatch$5;
    picomatch$3 = picomatch_1;
    picomatch$4 = /* @__PURE__ */ getDefaultExportFromCjs(picomatch$3);
    normalizePath$5 = function normalizePath(filename) {
      return filename.split(win32.sep).join(posix.sep);
    };
    createFilter$1 = function createFilter(include, exclude, options2) {
      const resolutionBase = options2 && options2.resolve;
      const getMatcher = (id3) => id3 instanceof RegExp ? id3 : {
        test: (what) => {
          const pattern2 = getMatcherString(id3, resolutionBase);
          const fn = picomatch$4(pattern2, { dot: true });
          const result = fn(what);
          return result;
        }
      };
      const includeMatchers = ensureArray(include).map(getMatcher);
      const excludeMatchers = ensureArray(exclude).map(getMatcher);
      return function result(id3) {
        if (typeof id3 !== "string")
          return false;
        if (/\0/.test(id3))
          return false;
        const pathId = normalizePath$5(id3);
        for (let i = 0; i < excludeMatchers.length; ++i) {
          const matcher2 = excludeMatchers[i];
          if (matcher2.test(pathId))
            return false;
        }
        for (let i = 0; i < includeMatchers.length; ++i) {
          const matcher2 = includeMatchers[i];
          if (matcher2.test(pathId))
            return true;
        }
        return !includeMatchers.length;
      };
    };
    reservedWords = "break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof let new return super switch this throw try typeof var void while with yield enum await implements package protected static interface private public";
    builtins = "arguments Infinity NaN undefined null true false eval uneval isFinite isNaN parseFloat parseInt decodeURI decodeURIComponent encodeURI encodeURIComponent escape unescape Object Function Boolean Symbol Error EvalError InternalError RangeError ReferenceError SyntaxError TypeError URIError Number Math Date String RegExp Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array Map Set WeakMap WeakSet SIMD ArrayBuffer DataView JSON Promise Generator GeneratorFunction Reflect Proxy Intl";
    forbiddenIdentifiers = new Set(`${reservedWords} ${builtins}`.split(" "));
    forbiddenIdentifiers.add("");
    hasStringIsWellFormed = "isWellFormed" in String.prototype;
    balancedMatch = balanced$1;
    balanced$1.range = range$1;
    balanced = balancedMatch;
    braceExpansion = expandTop;
    escSlash = "\0SLASH" + Math.random() + "\0";
    escOpen = "\0OPEN" + Math.random() + "\0";
    escClose = "\0CLOSE" + Math.random() + "\0";
    escComma = "\0COMMA" + Math.random() + "\0";
    escPeriod = "\0PERIOD" + Math.random() + "\0";
    expand$4 = /* @__PURE__ */ getDefaultExportFromCjs(braceExpansion);
    MAX_PATTERN_LENGTH = 1024 * 64;
    assertValidPattern = (pattern2) => {
      if (typeof pattern2 !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern2.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    posixClasses = {
      "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
      "[:alpha:]": ["\\p{L}\\p{Nl}", true],
      "[:ascii:]": ["\\x00-\\x7f", false],
      "[:blank:]": ["\\p{Zs}\\t", true],
      "[:cntrl:]": ["\\p{Cc}", true],
      "[:digit:]": ["\\p{Nd}", true],
      "[:graph:]": ["\\p{Z}\\p{C}", true, true],
      "[:lower:]": ["\\p{Ll}", true],
      "[:print:]": ["\\p{C}", true],
      "[:punct:]": ["\\p{P}", true],
      "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
      "[:upper:]": ["\\p{Lu}", true],
      "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
      "[:xdigit:]": ["A-Fa-f0-9", false]
    };
    braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
    regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    rangesToString = (ranges) => ranges.join("");
    parseClass = (glob, position) => {
      const pos = position;
      if (glob.charAt(pos) !== "[") {
        throw new Error("not in a brace expression");
      }
      const ranges = [];
      const negs = [];
      let i = pos + 1;
      let sawStart = false;
      let uflag = false;
      let escaping = false;
      let negate = false;
      let endPos = pos;
      let rangeStart = "";
      WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
      if (endPos < i) {
        return ["", false, 0, false];
      }
      if (!ranges.length && !negs.length) {
        return ["$.", false, glob.length - pos, true];
      }
      if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
      }
      const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
      const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
      const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
      return [comb, uflag, endPos - pos, true];
    };
    unescape$1 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
    };
    types$1 = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
    isExtglobType = (c) => types$1.has(c);
    startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
    startNoDot = "(?!\\.)";
    addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
    justDots = /* @__PURE__ */ new Set(["..", "."]);
    reSpecials = new Set("().*{}+?[]^$\\!");
    regExpEscape$1 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    qmark$1 = "[^/]";
    star$1 = qmark$1 + "*?";
    starNoEmpty = qmark$1 + "+?";
    AST = class _AST {
      type;
      #root;
      #hasMagic;
      #uflag = false;
      #parts = [];
      #parent;
      #parentIndex;
      #negs;
      #filledNegs = false;
      #options;
      #toString;
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      #emptyExt = false;
      constructor(type, parent, options2 = {}) {
        this.type = type;
        if (type)
          this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options2 : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === "!" && !this.#root.#filledNegs)
          this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
      }
      get hasMagic() {
        if (this.#hasMagic !== void 0)
          return this.#hasMagic;
        for (const p of this.#parts) {
          if (typeof p === "string")
            continue;
          if (p.type || p.hasMagic)
            return this.#hasMagic = true;
        }
        return this.#hasMagic;
      }
      // reconstructs the pattern
      toString() {
        if (this.#toString !== void 0)
          return this.#toString;
        if (!this.type) {
          return this.#toString = this.#parts.map((p) => String(p)).join("");
        } else {
          return this.#toString = this.type + "(" + this.#parts.map((p) => String(p)).join("|") + ")";
        }
      }
      #fillNegs() {
        if (this !== this.#root)
          throw new Error("should only call on root");
        if (this.#filledNegs)
          return this;
        this.toString();
        this.#filledNegs = true;
        let n;
        while (n = this.#negs.pop()) {
          if (n.type !== "!")
            continue;
          let p = n;
          let pp = p.#parent;
          while (pp) {
            for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
              for (const part of n.#parts) {
                if (typeof part === "string") {
                  throw new Error("string part in extglob AST??");
                }
                part.copyIn(pp.#parts[i]);
              }
            }
            p = pp;
            pp = p.#parent;
          }
        }
        return this;
      }
      push(...parts) {
        for (const p of parts) {
          if (p === "")
            continue;
          if (typeof p !== "string" && !(p instanceof _AST && p.#parent === this)) {
            throw new Error("invalid part: " + p);
          }
          this.#parts.push(p);
        }
      }
      toJSON() {
        const ret = this.type === null ? this.#parts.slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...this.#parts.map((p) => p.toJSON())];
        if (this.isStart() && !this.type)
          ret.unshift([]);
        if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === "!")) {
          ret.push({});
        }
        return ret;
      }
      isStart() {
        if (this.#root === this)
          return true;
        if (!this.#parent?.isStart())
          return false;
        if (this.#parentIndex === 0)
          return true;
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
          const pp = p.#parts[i];
          if (!(pp instanceof _AST && pp.type === "!")) {
            return false;
          }
        }
        return true;
      }
      isEnd() {
        if (this.#root === this)
          return true;
        if (this.#parent?.type === "!")
          return true;
        if (!this.#parent?.isEnd())
          return false;
        if (!this.type)
          return this.#parent?.isEnd();
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        return this.#parentIndex === pl - 1;
      }
      copyIn(part) {
        if (typeof part === "string")
          this.push(part);
        else
          this.push(part.clone(this));
      }
      clone(parent) {
        const c = new _AST(this.type, parent);
        for (const p of this.#parts) {
          c.copyIn(p);
        }
        return c;
      }
      static #parseAST(str2, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
          let i2 = pos;
          let acc2 = "";
          while (i2 < str2.length) {
            const c = str2.charAt(i2++);
            if (escaping || c === "\\") {
              escaping = !escaping;
              acc2 += c;
              continue;
            }
            if (inBrace) {
              if (i2 === braceStart + 1) {
                if (c === "^" || c === "!") {
                  braceNeg = true;
                }
              } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc2 += c;
              continue;
            } else if (c === "[") {
              inBrace = true;
              braceStart = i2;
              braceNeg = false;
              acc2 += c;
              continue;
            }
            if (!opt.noext && isExtglobType(c) && str2.charAt(i2) === "(") {
              ast.push(acc2);
              acc2 = "";
              const ext2 = new _AST(c, ast);
              i2 = _AST.#parseAST(str2, ext2, i2, opt);
              ast.push(ext2);
              continue;
            }
            acc2 += c;
          }
          ast.push(acc2);
          return i2;
        }
        let i = pos + 1;
        let part = new _AST(null, ast);
        const parts = [];
        let acc = "";
        while (i < str2.length) {
          const c = str2.charAt(i++);
          if (escaping || c === "\\") {
            escaping = !escaping;
            acc += c;
            continue;
          }
          if (inBrace) {
            if (i === braceStart + 1) {
              if (c === "^" || c === "!") {
                braceNeg = true;
              }
            } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
              inBrace = false;
            }
            acc += c;
            continue;
          } else if (c === "[") {
            inBrace = true;
            braceStart = i;
            braceNeg = false;
            acc += c;
            continue;
          }
          if (isExtglobType(c) && str2.charAt(i) === "(") {
            part.push(acc);
            acc = "";
            const ext2 = new _AST(c, part);
            part.push(ext2);
            i = _AST.#parseAST(str2, ext2, i, opt);
            continue;
          }
          if (c === "|") {
            part.push(acc);
            acc = "";
            parts.push(part);
            part = new _AST(null, ast);
            continue;
          }
          if (c === ")") {
            if (acc === "" && ast.#parts.length === 0) {
              ast.#emptyExt = true;
            }
            part.push(acc);
            acc = "";
            ast.push(...parts, part);
            return i;
          }
          acc += c;
        }
        ast.type = null;
        ast.#hasMagic = void 0;
        ast.#parts = [str2.substring(pos - 1)];
        return i;
      }
      static fromGlob(pattern2, options2 = {}) {
        const ast = new _AST(null, void 0, options2);
        _AST.#parseAST(pattern2, ast, 0, options2);
        return ast;
      }
      // returns the regular expression if there's magic, or the unescaped
      // string if not.
      toMMPattern() {
        if (this !== this.#root)
          return this.#root.toMMPattern();
        const glob = this.toString();
        const [re, body, hasMagic2, uflag] = this.toRegExpSource();
        const anyMagic = hasMagic2 || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();
        if (!anyMagic) {
          return body;
        }
        const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
        return Object.assign(new RegExp(`^${re}$`, flags), {
          _src: re,
          _glob: glob
        });
      }
      get options() {
        return this.#options;
      }
      // returns the string match, the regexp source, whether there's magic
      // in the regexp (so a regular expression is required) and whether or
      // not the uflag is needed for the regular expression (for posix classes)
      // TODO: instead of injecting the start/end at this point, just return
      // the BODY of the regexp, along with the start/end portions suitable
      // for binding the start/end in either a joined full-path makeRe context
      // (where we bind to (^|/), or a standalone matchPart context (where
      // we bind to ^, and not /).  Otherwise slashes get duped!
      //
      // In part-matching mode, the start is:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: ^(?!\.\.?$)
      // - if dots allowed or not possible: ^
      // - if dots possible and not allowed: ^(?!\.)
      // end is:
      // - if not isEnd(): nothing
      // - else: $
      //
      // In full-path matching mode, we put the slash at the START of the
      // pattern, so start is:
      // - if first pattern: same as part-matching mode
      // - if not isStart(): nothing
      // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
      // - if dots allowed or not possible: /
      // - if dots possible and not allowed: /(?!\.)
      // end is:
      // - if last pattern, same as part-matching mode
      // - else nothing
      //
      // Always put the (?:$|/) on negated tails, though, because that has to be
      // there to bind the end of the negated pattern portion, and it's easier to
      // just stick it in now rather than try to inject it later in the middle of
      // the pattern.
      //
      // We can just always return the same end, and leave it up to the caller
      // to know whether it's going to be used joined or in parts.
      // And, if the start is adjusted slightly, can do the same there:
      // - if not isStart: nothing
      // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
      // - if dots allowed or not possible: (?:/|^)
      // - if dots possible and not allowed: (?:/|^)(?!\.)
      //
      // But it's better to have a simpler binding without a conditional, for
      // performance, so probably better to return both start options.
      //
      // Then the caller just ignores the end if it's not the first pattern,
      // and the start always gets applied.
      //
      // But that's always going to be $ if it's the ending pattern, or nothing,
      // so the caller can just attach $ at the end of the pattern when building.
      //
      // So the todo is:
      // - better detect what kind of start is needed
      // - return both flavors of starting pattern
      // - attach $ at the end of the pattern when creating the actual RegExp
      //
      // Ah, but wait, no, that all only applies to the root when the first pattern
      // is not an extglob. If the first pattern IS an extglob, then we need all
      // that dot prevention biz to live in the extglob portions, because eg
      // +(*|.x*) can match .xy but not .yx.
      //
      // So, return the two flavors if it's #root and the first child is not an
      // AST, otherwise leave it to the child AST to handle it, and there,
      // use the (?:^|/) style of start binding.
      //
      // Even simplified further:
      // - Since the start for a join is eg /(?!\.) and the start for a part
      // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
      // or start or whatever) and prepend ^ or / at the Regexp construction.
      toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
          this.#fillNegs();
        if (!this.type) {
          const noEmpty = this.isStart() && this.isEnd();
          const src3 = this.#parts.map((p) => {
            const [re, _, hasMagic2, uflag] = typeof p === "string" ? _AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);
            this.#hasMagic = this.#hasMagic || hasMagic2;
            this.#uflag = this.#uflag || uflag;
            return re;
          }).join("");
          let start2 = "";
          if (this.isStart()) {
            if (typeof this.#parts[0] === "string") {
              const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
              if (!dotTravAllowed) {
                const aps = addPatternStart;
                const needNoTrav = (
                  // dots are allowed, and the pattern starts with [ or .
                  dot && aps.has(src3.charAt(0)) || // the pattern starts with \., and then [ or .
                  src3.startsWith("\\.") && aps.has(src3.charAt(2)) || // the pattern starts with \.\., and then [ or .
                  src3.startsWith("\\.\\.") && aps.has(src3.charAt(4))
                );
                const needNoDot = !dot && !allowDot && aps.has(src3.charAt(0));
                start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
              }
            }
          }
          let end = "";
          if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === "!") {
            end = "(?:$|\\/)";
          }
          const final2 = start2 + src3 + end;
          return [
            final2,
            unescape$1(src3),
            this.#hasMagic = !!this.#hasMagic,
            this.#uflag
          ];
        }
        const repeated = this.type === "*" || this.type === "+";
        const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
          const s = this.toString();
          this.#parts = [s];
          this.type = null;
          this.#hasMagic = void 0;
          return [s, unescape$1(this.toString()), false, false];
        }
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
          bodyDotAllowed = "";
        }
        if (bodyDotAllowed) {
          body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        let final = "";
        if (this.type === "!" && this.#emptyExt) {
          final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
        } else {
          const close2 = this.type === "!" ? (
            // !() must match something,but !(x) can match ''
            "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star$1 + ")"
          ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
          final = start + body + close2;
        }
        return [
          final,
          unescape$1(body),
          this.#hasMagic = !!this.#hasMagic,
          this.#uflag
        ];
      }
      #partsToRegExp(dot) {
        return this.#parts.map((p) => {
          if (typeof p === "string") {
            throw new Error("string type in extglob ast??");
          }
          const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
          this.#uflag = this.#uflag || uflag;
          return re;
        }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
      }
      static #parseGlob(glob, hasMagic2, noEmpty = false) {
        let escaping = false;
        let re = "";
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
          const c = glob.charAt(i);
          if (escaping) {
            escaping = false;
            re += (reSpecials.has(c) ? "\\" : "") + c;
            continue;
          }
          if (c === "\\") {
            if (i === glob.length - 1) {
              re += "\\\\";
            } else {
              escaping = true;
            }
            continue;
          }
          if (c === "[") {
            const [src3, needUflag, consumed, magic] = parseClass(glob, i);
            if (consumed) {
              re += src3;
              uflag = uflag || needUflag;
              i += consumed - 1;
              hasMagic2 = hasMagic2 || magic;
              continue;
            }
          }
          if (c === "*") {
            if (noEmpty && glob === "*")
              re += starNoEmpty;
            else
              re += star$1;
            hasMagic2 = true;
            continue;
          }
          if (c === "?") {
            re += qmark$1;
            hasMagic2 = true;
            continue;
          }
          re += regExpEscape$1(c);
        }
        return [re, unescape$1(glob), !!hasMagic2, uflag];
      }
    };
    escape$2 = (s, { windowsPathsNoEscape = false } = {}) => {
      return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
    };
    minimatch = (p, pattern2, options2 = {}) => {
      assertValidPattern(pattern2);
      if (!options2.nocomment && pattern2.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern2, options2).match(p);
    };
    starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
    starDotExtTest = (ext2) => (f) => !f.startsWith(".") && f.endsWith(ext2);
    starDotExtTestDot = (ext2) => (f) => f.endsWith(ext2);
    starDotExtTestNocase = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext2);
    };
    starDotExtTestNocaseDot = (ext2) => {
      ext2 = ext2.toLowerCase();
      return (f) => f.toLowerCase().endsWith(ext2);
    };
    starDotStarRE = /^\*+\.\*+$/;
    starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
    starDotStarTestDot = (f) => f !== "." && f !== ".." && f.includes(".");
    dotStarRE = /^\.\*+$/;
    dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
    starRE = /^\*+$/;
    starTest = (f) => f.length !== 0 && !f.startsWith(".");
    starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
    qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
    qmarksTestNocase = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      if (!ext2)
        return noext;
      ext2 = ext2.toLowerCase();
      return (f) => noext(f) && f.toLowerCase().endsWith(ext2);
    };
    qmarksTestDot = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExtDot([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    qmarksTest = ([$0, ext2 = ""]) => {
      const noext = qmarksTestNoExt([$0]);
      return !ext2 ? noext : (f) => noext(f) && f.endsWith(ext2);
    };
    qmarksTestNoExt = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && !f.startsWith(".");
    };
    qmarksTestNoExtDot = ([$0]) => {
      const len = $0.length;
      return (f) => f.length === len && f !== "." && f !== "..";
    };
    defaultPlatform$2 = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
    path$j = {
      win32: { sep: "\\" },
      posix: { sep: "/" }
    };
    sep = defaultPlatform$2 === "win32" ? path$j.win32.sep : path$j.posix.sep;
    minimatch.sep = sep;
    GLOBSTAR$2 = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR$2;
    qmark = "[^/]";
    star2 = qmark + "*?";
    twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    filter$1 = (pattern2, options2 = {}) => (p) => minimatch(p, pattern2, options2);
    minimatch.filter = filter$1;
    ext = (a, b = {}) => Object.assign({}, a, b);
    defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern2, options2 = {}) => orig(p, pattern2, ext(def, options2));
      return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
          constructor(pattern2, options2 = {}) {
            super(pattern2, ext(def, options2));
          }
          static defaults(options2) {
            return orig.defaults(ext(def, options2)).Minimatch;
          }
        },
        AST: class AST extends orig.AST {
          /* c8 ignore start */
          constructor(type, parent, options2 = {}) {
            super(type, parent, ext(def, options2));
          }
          /* c8 ignore stop */
          static fromGlob(pattern2, options2 = {}) {
            return orig.AST.fromGlob(pattern2, ext(def, options2));
          }
        },
        unescape: (s, options2 = {}) => orig.unescape(s, ext(def, options2)),
        escape: (s, options2 = {}) => orig.escape(s, ext(def, options2)),
        filter: (pattern2, options2 = {}) => orig.filter(pattern2, ext(def, options2)),
        defaults: (options2) => orig.defaults(ext(def, options2)),
        makeRe: (pattern2, options2 = {}) => orig.makeRe(pattern2, ext(def, options2)),
        braceExpand: (pattern2, options2 = {}) => orig.braceExpand(pattern2, ext(def, options2)),
        match: (list2, pattern2, options2 = {}) => orig.match(list2, pattern2, ext(def, options2)),
        sep: orig.sep,
        GLOBSTAR: GLOBSTAR$2
      });
    };
    minimatch.defaults = defaults;
    braceExpand = (pattern2, options2 = {}) => {
      assertValidPattern(pattern2);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern2)) {
        return [pattern2];
      }
      return expand$4(pattern2);
    };
    minimatch.braceExpand = braceExpand;
    makeRe$1 = (pattern2, options2 = {}) => new Minimatch(pattern2, options2).makeRe();
    minimatch.makeRe = makeRe$1;
    match = (list2, pattern2, options2 = {}) => {
      const mm = new Minimatch(pattern2, options2);
      list2 = list2.filter((f) => mm.match(f));
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern2);
      }
      return list2;
    };
    minimatch.match = match;
    globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
    regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    Minimatch = class {
      options;
      set;
      pattern;
      windowsPathsNoEscape;
      nonegate;
      negate;
      comment;
      empty;
      preserveMultipleSlashes;
      partial;
      globSet;
      globParts;
      nocase;
      isWindows;
      platform;
      windowsNoMagicRoot;
      regexp;
      constructor(pattern2, options2 = {}) {
        assertValidPattern(pattern2);
        options2 = options2 || {};
        this.options = options2;
        this.pattern = pattern2;
        this.platform = options2.platform || defaultPlatform$2;
        this.isWindows = this.platform === "win32";
        this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.preserveMultipleSlashes = !!options2.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options2.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options2.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot = options2.windowsNoMagicRoot !== void 0 ? options2.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        this.make();
      }
      hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
          return true;
        }
        for (const pattern2 of this.set) {
          for (const part of pattern2) {
            if (typeof part !== "string")
              return true;
          }
        }
        return false;
      }
      debug(..._) {
      }
      make() {
        const pattern2 = this.pattern;
        const options2 = this.options;
        if (!options2.nocomment && pattern2.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern2) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        this.globSet = [...new Set(this.braceExpand())];
        if (options2.debug) {
          this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        let set2 = this.globParts.map((s, _, __) => {
          if (this.isWindows && this.windowsNoMagicRoot) {
            const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
            const isDrive = /^[a-z]:/i.test(s[0]);
            if (isUNC) {
              return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
            } else if (isDrive) {
              return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
            }
          }
          return s.map((ss) => this.parse(ss));
        });
        this.debug(this.pattern, set2);
        this.set = set2.filter((s) => s.indexOf(false) === -1);
        if (this.isWindows) {
          for (let i = 0; i < this.set.length; i++) {
            const p = this.set[i];
            if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
              p[2] = "?";
            }
          }
        }
        this.debug(this.pattern, this.set);
      }
      // various transforms to equivalent pattern sets that are
      // faster to process in a filesystem walk.  The goal is to
      // eliminate what we can, and push all ** patterns as far
      // to the right as possible, even if it increases the number
      // of patterns that we have to process.
      preprocess(globParts) {
        if (this.options.noglobstar) {
          for (let i = 0; i < globParts.length; i++) {
            for (let j = 0; j < globParts[i].length; j++) {
              if (globParts[i][j] === "**") {
                globParts[i][j] = "*";
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          globParts = this.firstPhasePreProcess(globParts);
          globParts = this.secondPhasePreProcess(globParts);
        } else if (optimizationLevel >= 1) {
          globParts = this.levelOneOptimize(globParts);
        } else {
          globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
      }
      // just get rid of adjascent ** portions
      adjascentGlobstarOptimize(globParts) {
        return globParts.map((parts) => {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let i = gs;
            while (parts[i + 1] === "**") {
              i++;
            }
            if (i !== gs) {
              parts.splice(gs, i - gs);
            }
          }
          return parts;
        });
      }
      // get rid of adjascent ** and resolve .. portions
      levelOneOptimize(globParts) {
        return globParts.map((parts) => {
          parts = parts.reduce((set2, part) => {
            const prev = set2[set2.length - 1];
            if (part === "**" && prev === "**") {
              return set2;
            }
            if (part === "..") {
              if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                set2.pop();
                return set2;
              }
            }
            set2.push(part);
            return set2;
          }, []);
          return parts.length === 0 ? [""] : parts;
        });
      }
      levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
          parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
          didSomething = false;
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              parts.splice(dd - 1, 2);
              dd -= 2;
            }
          }
        } while (didSomething);
        return parts.length === 0 ? [""] : parts;
      }
      // First phase: single-pattern processing
      // <pre> is 1 or more portions
      // <rest> is 1 or more portions
      // <p> is any portion other than ., .., '', or **
      // <e> is . or ''
      //
      // **/.. is *brutal* for filesystem walking performance, because
      // it effectively resets the recursive walk each time it occurs,
      // and ** cannot be reduced out by a .. pattern part like a regexp
      // or most strings (other than .., ., and '') can be.
      //
      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
      // <pre>/<e>/<rest> -> <pre>/<rest>
      // <pre>/<p>/../<rest> -> <pre>/<rest>
      // **/**/<rest> -> **/<rest>
      //
      // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
      // this WOULD be allowed if ** did follow symlinks, or * didn't
      firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
          didSomething = false;
          for (let parts of globParts) {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let gss = gs;
              while (parts[gss + 1] === "**") {
                gss++;
              }
              if (gss > gs) {
                parts.splice(gs + 1, gss - gs);
              }
              let next = parts[gs + 1];
              const p = parts[gs + 2];
              const p2 = parts[gs + 3];
              if (next !== "..")
                continue;
              if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
                continue;
              }
              didSomething = true;
              parts.splice(gs, 1);
              const other = parts.slice(0);
              other[gs] = "**";
              globParts.push(other);
              gs--;
            }
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p = parts[i];
                if (i === 1 && p === "" && parts[0] === "")
                  continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p = parts[dd - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                const needDot = dd === 1 && parts[dd + 1] === "**";
                const splin = needDot ? ["."] : [];
                parts.splice(dd - 1, 2, ...splin);
                if (parts.length === 0)
                  parts.push("");
                dd -= 2;
              }
            }
          }
        } while (didSomething);
        return globParts;
      }
      // second phase: multi-pattern dedupes
      // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
      // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
      // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
      //
      // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
      // ^-- not valid because ** doens't follow symlinks
      secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
          for (let j = i + 1; j < globParts.length; j++) {
            const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
            if (matched) {
              globParts[i] = [];
              globParts[j] = matched;
              break;
            }
          }
        }
        return globParts.filter((gs) => gs.length);
      }
      partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which2 = "";
        while (ai < a.length && bi < b.length) {
          if (a[ai] === b[bi]) {
            result.push(which2 === "b" ? b[bi] : a[ai]);
            ai++;
            bi++;
          } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
            result.push(a[ai]);
            ai++;
          } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
            result.push(b[bi]);
            bi++;
          } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
            if (which2 === "b")
              return false;
            which2 = "a";
            result.push(a[ai]);
            ai++;
            bi++;
          } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
            if (which2 === "a")
              return false;
            which2 = "b";
            result.push(b[bi]);
            ai++;
            bi++;
          } else {
            return false;
          }
        }
        return a.length === b.length && result;
      }
      parseNegate() {
        if (this.nonegate)
          return;
        const pattern2 = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern2.length && pattern2.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern2.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern2, partial2 = false) {
        const options2 = this.options;
        if (this.isWindows) {
          const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
          const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
          const patternDrive = typeof pattern2[0] === "string" && /^[a-z]:$/i.test(pattern2[0]);
          const patternUNC = !patternDrive && pattern2[0] === "" && pattern2[1] === "" && pattern2[2] === "?" && typeof pattern2[3] === "string" && /^[a-z]:$/i.test(pattern2[3]);
          const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
          const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
          if (typeof fdi === "number" && typeof pdi === "number") {
            const [fd, pd] = [file[fdi], pattern2[pdi]];
            if (fd.toLowerCase() === pd.toLowerCase()) {
              pattern2[pdi] = fd;
              if (pdi > fdi) {
                pattern2 = pattern2.slice(pdi);
              } else if (fdi > pdi) {
                file = file.slice(fdi);
              }
            }
          }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
          file = this.levelTwoFileOptimize(file);
        }
        this.debug("matchOne", this, { file, pattern: pattern2 });
        this.debug("matchOne", file.length, pattern2.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern2.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern2[pi];
          var f = file[fi];
          this.debug(pattern2, p, f);
          if (p === false) {
            return false;
          }
          if (p === GLOBSTAR$2) {
            this.debug("GLOBSTAR", [pattern2, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern2, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern2.slice(pr), partial2)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern2, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial2) {
              this.debug("\n>>> no match, partial?", file, fr, pattern2, pr);
              if (fr === fl) {
                return true;
              }
            }
            return false;
          }
          let hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = p.test(f);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial2;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        } else {
          throw new Error("wtf?");
        }
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern2) {
        assertValidPattern(pattern2);
        const options2 = this.options;
        if (pattern2 === "**")
          return GLOBSTAR$2;
        if (pattern2 === "")
          return "";
        let m;
        let fastTest = null;
        if (m = pattern2.match(starRE)) {
          fastTest = options2.dot ? starTestDot : starTest;
        } else if (m = pattern2.match(starDotExtRE)) {
          fastTest = (options2.nocase ? options2.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options2.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
        } else if (m = pattern2.match(qmarksRE)) {
          fastTest = (options2.nocase ? options2.dot ? qmarksTestNocaseDot : qmarksTestNocase : options2.dot ? qmarksTestDot : qmarksTest)(m);
        } else if (m = pattern2.match(starDotStarRE)) {
          fastTest = options2.dot ? starDotStarTestDot : starDotStarTest;
        } else if (m = pattern2.match(dotStarRE)) {
          fastTest = dotStarTest;
        }
        const re = AST.fromGlob(pattern2, this.options).toMMPattern();
        if (fastTest && typeof re === "object") {
          Reflect.defineProperty(re, "test", { value: fastTest });
        }
        return re;
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set2 = this.set;
        if (!set2.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options2 = this.options;
        const twoStar = options2.noglobstar ? star2 : options2.dot ? twoStarDot : twoStarNoDot;
        const flags = new Set(options2.nocase ? ["i"] : []);
        let re = set2.map((pattern2) => {
          const pp = pattern2.map((p) => {
            if (p instanceof RegExp) {
              for (const f of p.flags.split(""))
                flags.add(f);
            }
            return typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR$2 ? GLOBSTAR$2 : p._src;
          });
          pp.forEach((p, i) => {
            const next = pp[i + 1];
            const prev = pp[i - 1];
            if (p !== GLOBSTAR$2 || prev === GLOBSTAR$2) {
              return;
            }
            if (prev === void 0) {
              if (next !== void 0 && next !== GLOBSTAR$2) {
                pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
              } else {
                pp[i] = twoStar;
              }
            } else if (next === void 0) {
              pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
            } else if (next !== GLOBSTAR$2) {
              pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
              pp[i + 1] = GLOBSTAR$2;
            }
          });
          return pp.filter((p) => p !== GLOBSTAR$2).join("/");
        }).join("|");
        const [open2, close2] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
        re = "^" + open2 + re + close2 + "$";
        if (this.negate)
          re = "^(?!" + re + ").+$";
        try {
          this.regexp = new RegExp(re, [...flags].join(""));
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      slashSplit(p) {
        if (this.preserveMultipleSlashes) {
          return p.split("/");
        } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
          return ["", ...p.split(/\/+/)];
        } else {
          return p.split(/\/+/);
        }
      }
      match(f, partial2 = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment) {
          return false;
        }
        if (this.empty) {
          return f === "";
        }
        if (f === "/" && partial2) {
          return true;
        }
        const options2 = this.options;
        if (this.isWindows) {
          f = f.split("\\").join("/");
        }
        const ff = this.slashSplit(f);
        this.debug(this.pattern, "split", ff);
        const set2 = this.set;
        this.debug(this.pattern, "set", set2);
        let filename = ff[ff.length - 1];
        if (!filename) {
          for (let i = ff.length - 2; !filename && i >= 0; i--) {
            filename = ff[i];
          }
        }
        for (let i = 0; i < set2.length; i++) {
          const pattern2 = set2[i];
          let file = ff;
          if (options2.matchBase && pattern2.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern2, partial2);
          if (hit) {
            if (options2.flipNegate) {
              return true;
            }
            return !this.negate;
          }
        }
        if (options2.flipNegate) {
          return false;
        }
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.AST = AST;
    minimatch.Minimatch = Minimatch;
    minimatch.escape = escape$2;
    minimatch.unescape = unescape$1;
    perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    warned$1 = /* @__PURE__ */ new Set();
    PROCESS = typeof process === "object" && !!process ? process : {};
    emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    AC = globalThis.AbortController;
    AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    shouldWarn = (code) => !warned$1.has(code);
    isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index4, options2, context) => c.#backgroundFetch(k, index4, options2, context),
          moveToTail: (index4) => c.#moveToTail(index4),
          indexes: (options2) => c.#indexes(options2),
          rindexes: (options2) => c.#rindexes(options2),
          isStale: (index4) => c.#isStale(index4)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options2) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options2;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned$1.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index4, ttl, start = perf.now()) => {
          starts[index4] = ttl !== 0 ? start : 0;
          ttls[index4] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index4)) {
                this.#delete(this.#keyList[index4], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index4) => {
          starts[index4] = ttls[index4] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status2, index4) => {
          if (ttls[index4]) {
            const ttl = ttls[index4];
            const start = starts[index4];
            if (!ttl || !start)
              return;
            status2.ttl = ttl;
            status2.start = start;
            status2.now = cachedNow || getNow();
            const age = status2.now - start;
            status2.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index4 = this.#keyMap.get(key);
          if (index4 === void 0) {
            return 0;
          }
          const ttl = ttls[index4];
          const start = starts[index4];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index4) => {
          const s = starts[index4];
          const t = ttls[index4];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index4) => {
          this.#calculatedSize -= sizes[index4];
          sizes[index4] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index4, size, status2) => {
          sizes[index4] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index4];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index4];
          if (status2) {
            status2.entrySize = size;
            status2.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index4) {
        return index4 !== void 0 && this.#keyMap.get(this.#keyList[index4]) === index4;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions2 = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value2 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value2 === void 0)
            continue;
          if (fn(value2, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions2);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value2 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value2 === void 0)
            continue;
          fn.call(thisp, value2, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value2 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value2 === void 0)
            continue;
          fn.call(thisp, value2, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.#delete(this.#keyList[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value2 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value2 === void 0)
          return void 0;
        const entry2 = { value: value2 };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry2.ttl = remain;
            entry2.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry2.size = this.#sizes[i];
        }
        return entry2;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value2 = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value2 === void 0 || key === void 0)
            continue;
          const entry2 = { value: value2 };
          if (this.#ttls && this.#starts) {
            entry2.ttl = this.#ttls[i];
            const age = perf.now() - this.#starts[i];
            entry2.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry2.size = this.#sizes[i];
          }
          arr.unshift([key, entry2]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry2] of arr) {
          if (entry2.start) {
            const age = Date.now() - entry2.start;
            entry2.start = perf.now() - age;
          }
          this.set(key, entry2.value, entry2);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status: status2 } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status2) {
            status2.set = "miss";
            status2.maxEntrySizeExceeded = true;
          }
          this.#delete(k, "set");
          return this;
        }
        let index4 = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index4 === void 0) {
          index4 = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index4] = k;
          this.#valList[index4] = v;
          this.#keyMap.set(k, index4);
          this.#next[this.#tail] = index4;
          this.#prev[index4] = this.#tail;
          this.#tail = index4;
          this.#size++;
          this.#addItemSize(index4, size, status2);
          if (status2)
            status2.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index4);
          const oldVal = this.#valList[index4];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index4);
            this.#addItemSize(index4, size, status2);
            this.#valList[index4] = v;
            if (status2) {
              status2.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status2.oldValue = oldValue;
            }
          } else if (status2) {
            status2.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index4, ttl, start);
          }
          if (status2)
            this.#statusTTL(status2, index4);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status: status2 } = hasOptions;
        const index4 = this.#keyMap.get(k);
        if (index4 !== void 0) {
          const v = this.#valList[index4];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index4)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index4);
            }
            if (status2) {
              status2.has = "hit";
              this.#statusTTL(status2, index4);
            }
            return true;
          } else if (status2) {
            status2.has = "stale";
            this.#statusTTL(status2, index4);
          }
        } else if (status2) {
          status2.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index4 = this.#keyMap.get(k);
        if (index4 === void 0 || !allowStale && this.#isStale(index4)) {
          return;
        }
        const v = this.#valList[index4];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index4, options2, context) {
        const v = index4 === void 0 ? void 0 : this.#valList[index4];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options2;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options: options2,
          context
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options2.ignoreFetchAbort && v2 !== void 0;
          if (options2.status) {
            if (aborted && !updateCache) {
              options2.status.fetchAborted = true;
              options2.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options2.status.fetchAbortIgnored = true;
            } else {
              options2.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index4] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index4] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k, "fetch");
              }
            } else {
              if (options2.status)
                options2.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options2.status) {
            options2.status.fetchRejected = true;
            options2.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options2.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options2.allowStaleOnFetchRejection;
          const noDelete = allowStale || options2.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index4] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index4] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options2.status && bf2.__staleWhileFetching !== void 0) {
              options2.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options2.ignoreFetchAbort || options2.allowStaleOnFetchAbort) {
              res(void 0);
              if (options2.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options2.status)
          options2.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index4 === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index4 = this.#keyMap.get(k);
        } else {
          this.#valList[index4] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status: status2,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status2)
            status2.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status: status2
          });
        }
        const options2 = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status: status2,
          signal
        };
        let index4 = this.#keyMap.get(k);
        if (index4 === void 0) {
          if (status2)
            status2.fetch = "miss";
          const p = this.#backgroundFetch(k, index4, options2, context);
          return p.__returned = p;
        } else {
          const v = this.#valList[index4];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status2) {
              status2.fetch = "inflight";
              if (stale)
                status2.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index4);
          if (!forceRefresh && !isStale) {
            if (status2)
              status2.fetch = "hit";
            this.#moveToTail(index4);
            if (updateAgeOnGet) {
              this.#updateItemAge(index4);
            }
            if (status2)
              this.#statusTTL(status2, index4);
            return v;
          }
          const p = this.#backgroundFetch(k, index4, options2, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status2) {
            status2.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status2.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options2 } = memoOptions;
        const v = this.get(k, options2);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options: options2,
          context
        });
        this.set(k, vv, options2);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions2 = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status: status2 } = getOptions2;
        const index4 = this.#keyMap.get(k);
        if (index4 !== void 0) {
          const value2 = this.#valList[index4];
          const fetching = this.#isBackgroundFetch(value2);
          if (status2)
            this.#statusTTL(status2, index4);
          if (this.#isStale(index4)) {
            if (status2)
              status2.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k, "expire");
              }
              if (status2 && allowStale)
                status2.returnedStale = true;
              return allowStale ? value2 : void 0;
            } else {
              if (status2 && allowStale && value2.__staleWhileFetching !== void 0) {
                status2.returnedStale = true;
              }
              return allowStale ? value2.__staleWhileFetching : void 0;
            }
          } else {
            if (status2)
              status2.get = "hit";
            if (fetching) {
              return value2.__staleWhileFetching;
            }
            this.#moveToTail(index4);
            if (updateAgeOnGet) {
              this.#updateItemAge(index4);
            }
            return value2;
          }
        } else if (status2) {
          status2.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index4) {
        if (index4 !== this.#tail) {
          if (index4 === this.#head) {
            this.#head = this.#next[index4];
          } else {
            this.#connect(this.#prev[index4], this.#next[index4]);
          }
          this.#connect(this.#tail, index4);
          this.#tail = index4;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return this.#delete(k, "delete");
      }
      #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index4 = this.#keyMap.get(k);
          if (index4 !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index4);
              const v = this.#valList[index4];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, reason]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index4] = void 0;
              this.#valList[index4] = void 0;
              if (index4 === this.#tail) {
                this.#tail = this.#prev[index4];
              } else if (index4 === this.#head) {
                this.#head = this.#next[index4];
              } else {
                const pi = this.#prev[index4];
                this.#next[pi] = this.#next[index4];
                const ni = this.#next[index4];
                this.#prev[ni] = this.#prev[index4];
              }
              this.#size--;
              this.#free.push(index4);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index4 of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index4];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index4];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    proc = typeof process === "object" && process ? process : {
      stdout: null,
      stderr: null
    };
    isStream = (s) => !!s && typeof s === "object" && (s instanceof Minipass || s instanceof Stream$1 || isReadable(s) || isWritable(s));
    isReadable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter$4 && typeof s.pipe === "function" && // node core Writable streams have a pipe() method, but it throws
    s.pipe !== Stream$1.Writable.prototype.pipe;
    isWritable = (s) => !!s && typeof s === "object" && s instanceof EventEmitter$4 && typeof s.write === "function" && typeof s.end === "function";
    EOF = Symbol("EOF");
    MAYBE_EMIT_END = Symbol("maybeEmitEnd");
    EMITTED_END = Symbol("emittedEnd");
    EMITTING_END = Symbol("emittingEnd");
    EMITTED_ERROR = Symbol("emittedError");
    CLOSED$1 = Symbol("closed");
    READ = Symbol("read");
    FLUSH = Symbol("flush");
    FLUSHCHUNK = Symbol("flushChunk");
    ENCODING$1 = Symbol("encoding");
    DECODER = Symbol("decoder");
    FLOWING = Symbol("flowing");
    PAUSED = Symbol("paused");
    RESUME = Symbol("resume");
    BUFFER = Symbol("buffer");
    PIPES = Symbol("pipes");
    BUFFERLENGTH = Symbol("bufferLength");
    BUFFERPUSH = Symbol("bufferPush");
    BUFFERSHIFT = Symbol("bufferShift");
    OBJECTMODE = Symbol("objectMode");
    DESTROYED = Symbol("destroyed");
    ERROR = Symbol("error");
    EMITDATA = Symbol("emitData");
    EMITEND = Symbol("emitEnd");
    EMITEND2 = Symbol("emitEnd2");
    ASYNC = Symbol("async");
    ABORT = Symbol("abort");
    ABORTED = Symbol("aborted");
    SIGNAL = Symbol("signal");
    DATALISTENERS = Symbol("dataListeners");
    DISCARDED = Symbol("discarded");
    defer$3 = (fn) => Promise.resolve().then(fn);
    nodefer = (fn) => fn();
    isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
    isArrayBufferLike = (b) => b instanceof ArrayBuffer || !!b && typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
    isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
    Pipe = class {
      src;
      dest;
      opts;
      ondrain;
      constructor(src3, dest, opts) {
        this.src = src3;
        this.dest = dest;
        this.opts = opts;
        this.ondrain = () => src3[RESUME]();
        this.dest.on("drain", this.ondrain);
      }
      unpipe() {
        this.dest.removeListener("drain", this.ondrain);
      }
      // only here for the prototype
      /* c8 ignore start */
      proxyErrors(_er) {
      }
      /* c8 ignore stop */
      end() {
        this.unpipe();
        if (this.opts.end)
          this.dest.end();
      }
    };
    PipeProxyErrors = class extends Pipe {
      unpipe() {
        this.src.removeListener("error", this.proxyErrors);
        super.unpipe();
      }
      constructor(src3, dest, opts) {
        super(src3, dest, opts);
        this.proxyErrors = (er) => dest.emit("error", er);
        src3.on("error", this.proxyErrors);
      }
    };
    isObjectModeOptions = (o) => !!o.objectMode;
    isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== "buffer";
    Minipass = class extends EventEmitter$4 {
      [FLOWING] = false;
      [PAUSED] = false;
      [PIPES] = [];
      [BUFFER] = [];
      [OBJECTMODE];
      [ENCODING$1];
      [ASYNC];
      [DECODER];
      [EOF] = false;
      [EMITTED_END] = false;
      [EMITTING_END] = false;
      [CLOSED$1] = false;
      [EMITTED_ERROR] = null;
      [BUFFERLENGTH] = 0;
      [DESTROYED] = false;
      [SIGNAL];
      [ABORTED] = false;
      [DATALISTENERS] = 0;
      [DISCARDED] = false;
      /**
       * true if the stream can be written
       */
      writable = true;
      /**
       * true if the stream can be read
       */
      readable = true;
      /**
       * If `RType` is Buffer, then options do not need to be provided.
       * Otherwise, an options object must be provided to specify either
       * {@link Minipass.SharedOptions.objectMode} or
       * {@link Minipass.SharedOptions.encoding}, as appropriate.
       */
      constructor(...args) {
        const options2 = args[0] || {};
        super();
        if (options2.objectMode && typeof options2.encoding === "string") {
          throw new TypeError("Encoding and objectMode may not be used together");
        }
        if (isObjectModeOptions(options2)) {
          this[OBJECTMODE] = true;
          this[ENCODING$1] = null;
        } else if (isEncodingOptions(options2)) {
          this[ENCODING$1] = options2.encoding;
          this[OBJECTMODE] = false;
        } else {
          this[OBJECTMODE] = false;
          this[ENCODING$1] = null;
        }
        this[ASYNC] = !!options2.async;
        this[DECODER] = this[ENCODING$1] ? new StringDecoder(this[ENCODING$1]) : null;
        if (options2 && options2.debugExposeBuffer === true) {
          Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
        }
        if (options2 && options2.debugExposePipes === true) {
          Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
        }
        const { signal } = options2;
        if (signal) {
          this[SIGNAL] = signal;
          if (signal.aborted) {
            this[ABORT]();
          } else {
            signal.addEventListener("abort", () => this[ABORT]());
          }
        }
      }
      /**
       * The amount of data stored in the buffer waiting to be read.
       *
       * For Buffer strings, this will be the total byte length.
       * For string encoding streams, this will be the string character length,
       * according to JavaScript's `string.length` logic.
       * For objectMode streams, this is a count of the items waiting to be
       * emitted.
       */
      get bufferLength() {
        return this[BUFFERLENGTH];
      }
      /**
       * The `BufferEncoding` currently in use, or `null`
       */
      get encoding() {
        return this[ENCODING$1];
      }
      /**
       * @deprecated - This is a read only property
       */
      set encoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * @deprecated - Encoding may only be set at instantiation time
       */
      setEncoding(_enc) {
        throw new Error("Encoding must be set at instantiation time");
      }
      /**
       * True if this is an objectMode stream
       */
      get objectMode() {
        return this[OBJECTMODE];
      }
      /**
       * @deprecated - This is a read-only property
       */
      set objectMode(_om) {
        throw new Error("objectMode must be set at instantiation time");
      }
      /**
       * true if this is an async stream
       */
      get ["async"]() {
        return this[ASYNC];
      }
      /**
       * Set to true to make this stream async.
       *
       * Once set, it cannot be unset, as this would potentially cause incorrect
       * behavior.  Ie, a sync stream can be made async, but an async stream
       * cannot be safely made sync.
       */
      set ["async"](a) {
        this[ASYNC] = this[ASYNC] || !!a;
      }
      // drop everything and get out of the flow completely
      [ABORT]() {
        this[ABORTED] = true;
        this.emit("abort", this[SIGNAL]?.reason);
        this.destroy(this[SIGNAL]?.reason);
      }
      /**
       * True if the stream has been aborted.
       */
      get aborted() {
        return this[ABORTED];
      }
      /**
       * No-op setter. Stream aborted status is set via the AbortSignal provided
       * in the constructor options.
       */
      set aborted(_) {
      }
      write(chunk, encoding, cb) {
        if (this[ABORTED])
          return false;
        if (this[EOF])
          throw new Error("write after end");
        if (this[DESTROYED]) {
          this.emit("error", Object.assign(new Error("Cannot call write after a stream was destroyed"), { code: "ERR_STREAM_DESTROYED" }));
          return true;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (!encoding)
          encoding = "utf8";
        const fn = this[ASYNC] ? defer$3 : nodefer;
        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
          if (isArrayBufferView(chunk)) {
            chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
          } else if (isArrayBufferLike(chunk)) {
            chunk = Buffer.from(chunk);
          } else if (typeof chunk !== "string") {
            throw new Error("Non-contiguous data written to non-objectMode stream");
          }
        }
        if (this[OBJECTMODE]) {
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
            this[FLUSH](true);
          if (this[FLOWING])
            this.emit("data", chunk);
          else
            this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (!chunk.length) {
          if (this[BUFFERLENGTH] !== 0)
            this.emit("readable");
          if (cb)
            fn(cb);
          return this[FLOWING];
        }
        if (typeof chunk === "string" && // unless it is a string already ready for us to use
        !(encoding === this[ENCODING$1] && !this[DECODER]?.lastNeed)) {
          chunk = Buffer.from(chunk, encoding);
        }
        if (Buffer.isBuffer(chunk) && this[ENCODING$1]) {
          chunk = this[DECODER].write(chunk);
        }
        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this[FLOWING])
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this[FLOWING];
      }
      /**
       * Low-level explicit read method.
       *
       * In objectMode, the argument is ignored, and one item is returned if
       * available.
       *
       * `n` is the number of bytes (or in the case of encoding streams,
       * characters) to consume. If `n` is not provided, then the entire buffer
       * is returned, or `null` is returned if no data is available.
       *
       * If `n` is greater that the amount of data in the internal buffer,
       * then `null` is returned.
       */
      read(n) {
        if (this[DESTROYED])
          return null;
        this[DISCARDED] = false;
        if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {
          this[MAYBE_EMIT_END]();
          return null;
        }
        if (this[OBJECTMODE])
          n = null;
        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
          this[BUFFER] = [
            this[ENCODING$1] ? this[BUFFER].join("") : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])
          ];
        }
        const ret = this[READ](n || null, this[BUFFER][0]);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [READ](n, chunk) {
        if (this[OBJECTMODE])
          this[BUFFERSHIFT]();
        else {
          const c = chunk;
          if (n === c.length || n === null)
            this[BUFFERSHIFT]();
          else if (typeof c === "string") {
            this[BUFFER][0] = c.slice(n);
            chunk = c.slice(0, n);
            this[BUFFERLENGTH] -= n;
          } else {
            this[BUFFER][0] = c.subarray(n);
            chunk = c.subarray(0, n);
            this[BUFFERLENGTH] -= n;
          }
        }
        this.emit("data", chunk);
        if (!this[BUFFER].length && !this[EOF])
          this.emit("drain");
        return chunk;
      }
      end(chunk, encoding, cb) {
        if (typeof chunk === "function") {
          cb = chunk;
          chunk = void 0;
        }
        if (typeof encoding === "function") {
          cb = encoding;
          encoding = "utf8";
        }
        if (chunk !== void 0)
          this.write(chunk, encoding);
        if (cb)
          this.once("end", cb);
        this[EOF] = true;
        this.writable = false;
        if (this[FLOWING] || !this[PAUSED])
          this[MAYBE_EMIT_END]();
        return this;
      }
      // don't let the internal resume be overwritten
      [RESUME]() {
        if (this[DESTROYED])
          return;
        if (!this[DATALISTENERS] && !this[PIPES].length) {
          this[DISCARDED] = true;
        }
        this[PAUSED] = false;
        this[FLOWING] = true;
        this.emit("resume");
        if (this[BUFFER].length)
          this[FLUSH]();
        else if (this[EOF])
          this[MAYBE_EMIT_END]();
        else
          this.emit("drain");
      }
      /**
       * Resume the stream if it is currently in a paused state
       *
       * If called when there are no pipe destinations or `data` event listeners,
       * this will place the stream in a "discarded" state, where all data will
       * be thrown away. The discarded state is removed if a pipe destination or
       * data handler is added, if pause() is called, or if any synchronous or
       * asynchronous iteration is started.
       */
      resume() {
        return this[RESUME]();
      }
      /**
       * Pause the stream
       */
      pause() {
        this[FLOWING] = false;
        this[PAUSED] = true;
        this[DISCARDED] = false;
      }
      /**
       * true if the stream has been forcibly destroyed
       */
      get destroyed() {
        return this[DESTROYED];
      }
      /**
       * true if the stream is currently in a flowing state, meaning that
       * any writes will be immediately emitted.
       */
      get flowing() {
        return this[FLOWING];
      }
      /**
       * true if the stream is currently in a paused state
       */
      get paused() {
        return this[PAUSED];
      }
      [BUFFERPUSH](chunk) {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] += 1;
        else
          this[BUFFERLENGTH] += chunk.length;
        this[BUFFER].push(chunk);
      }
      [BUFFERSHIFT]() {
        if (this[OBJECTMODE])
          this[BUFFERLENGTH] -= 1;
        else
          this[BUFFERLENGTH] -= this[BUFFER][0].length;
        return this[BUFFER].shift();
      }
      [FLUSH](noDrain = false) {
        do {
        } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
        if (!noDrain && !this[BUFFER].length && !this[EOF])
          this.emit("drain");
      }
      [FLUSHCHUNK](chunk) {
        this.emit("data", chunk);
        return this[FLOWING];
      }
      /**
       * Pipe all data emitted by this stream into the destination provided.
       *
       * Triggers the flow of data.
       */
      pipe(dest, opts) {
        if (this[DESTROYED])
          return dest;
        this[DISCARDED] = false;
        const ended = this[EMITTED_END];
        opts = opts || {};
        if (dest === proc.stdout || dest === proc.stderr)
          opts.end = false;
        else
          opts.end = opts.end !== false;
        opts.proxyErrors = !!opts.proxyErrors;
        if (ended) {
          if (opts.end)
            dest.end();
        } else {
          this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));
          if (this[ASYNC])
            defer$3(() => this[RESUME]());
          else
            this[RESUME]();
        }
        return dest;
      }
      /**
       * Fully unhook a piped destination stream.
       *
       * If the destination stream was the only consumer of this stream (ie,
       * there are no other piped destinations or `'data'` event listeners)
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      unpipe(dest) {
        const p = this[PIPES].find((p2) => p2.dest === dest);
        if (p) {
          if (this[PIPES].length === 1) {
            if (this[FLOWING] && this[DATALISTENERS] === 0) {
              this[FLOWING] = false;
            }
            this[PIPES] = [];
          } else
            this[PIPES].splice(this[PIPES].indexOf(p), 1);
          p.unpipe();
        }
      }
      /**
       * Alias for {@link Minipass#on}
       */
      addListener(ev, handler) {
        return this.on(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.on`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * - Adding a 'data' event handler will trigger the flow of data
       *
       * - Adding a 'readable' event handler when there is data waiting to be read
       *   will cause 'readable' to be emitted immediately.
       *
       * - Adding an 'endish' event handler ('end', 'finish', etc.) which has
       *   already passed will cause the event to be emitted immediately and all
       *   handlers removed.
       *
       * - Adding an 'error' event handler after an error has been emitted will
       *   cause the event to be re-emitted immediately with the error previously
       *   raised.
       */
      on(ev, handler) {
        const ret = super.on(ev, handler);
        if (ev === "data") {
          this[DISCARDED] = false;
          this[DATALISTENERS]++;
          if (!this[PIPES].length && !this[FLOWING]) {
            this[RESUME]();
          }
        } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
          super.emit("readable");
        } else if (isEndish(ev) && this[EMITTED_END]) {
          super.emit(ev);
          this.removeAllListeners(ev);
        } else if (ev === "error" && this[EMITTED_ERROR]) {
          const h = handler;
          if (this[ASYNC])
            defer$3(() => h.call(this, this[EMITTED_ERROR]));
          else
            h.call(this, this[EMITTED_ERROR]);
        }
        return ret;
      }
      /**
       * Alias for {@link Minipass#off}
       */
      removeListener(ev, handler) {
        return this.off(ev, handler);
      }
      /**
       * Mostly identical to `EventEmitter.off`
       *
       * If a 'data' event handler is removed, and it was the last consumer
       * (ie, there are no pipe destinations or other 'data' event listeners),
       * then the flow of data will stop until there is another consumer or
       * {@link Minipass#resume} is explicitly called.
       */
      off(ev, handler) {
        const ret = super.off(ev, handler);
        if (ev === "data") {
          this[DATALISTENERS] = this.listeners("data").length;
          if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * Mostly identical to `EventEmitter.removeAllListeners`
       *
       * If all 'data' event handlers are removed, and they were the last consumer
       * (ie, there are no pipe destinations), then the flow of data will stop
       * until there is another consumer or {@link Minipass#resume} is explicitly
       * called.
       */
      removeAllListeners(ev) {
        const ret = super.removeAllListeners(ev);
        if (ev === "data" || ev === void 0) {
          this[DATALISTENERS] = 0;
          if (!this[DISCARDED] && !this[PIPES].length) {
            this[FLOWING] = false;
          }
        }
        return ret;
      }
      /**
       * true if the 'end' event has been emitted
       */
      get emittedEnd() {
        return this[EMITTED_END];
      }
      [MAYBE_EMIT_END]() {
        if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
          this[EMITTING_END] = true;
          this.emit("end");
          this.emit("prefinish");
          this.emit("finish");
          if (this[CLOSED$1])
            this.emit("close");
          this[EMITTING_END] = false;
        }
      }
      /**
       * Mostly identical to `EventEmitter.emit`, with the following
       * behavior differences to prevent data loss and unnecessary hangs:
       *
       * If the stream has been destroyed, and the event is something other
       * than 'close' or 'error', then `false` is returned and no handlers
       * are called.
       *
       * If the event is 'end', and has already been emitted, then the event
       * is ignored. If the stream is in a paused or non-flowing state, then
       * the event will be deferred until data flow resumes. If the stream is
       * async, then handlers will be called on the next tick rather than
       * immediately.
       *
       * If the event is 'close', and 'end' has not yet been emitted, then
       * the event will be deferred until after 'end' is emitted.
       *
       * If the event is 'error', and an AbortSignal was provided for the stream,
       * and there are no listeners, then the event is ignored, matching the
       * behavior of node core streams in the presense of an AbortSignal.
       *
       * If the event is 'finish' or 'prefinish', then all listeners will be
       * removed after emitting the event, to prevent double-firing.
       */
      emit(ev, ...args) {
        const data = args[0];
        if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED]) {
          return false;
        } else if (ev === "data") {
          return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer$3(() => this[EMITDATA](data)), true) : this[EMITDATA](data);
        } else if (ev === "end") {
          return this[EMITEND]();
        } else if (ev === "close") {
          this[CLOSED$1] = true;
          if (!this[EMITTED_END] && !this[DESTROYED])
            return false;
          const ret2 = super.emit("close");
          this.removeAllListeners("close");
          return ret2;
        } else if (ev === "error") {
          this[EMITTED_ERROR] = data;
          super.emit(ERROR, data);
          const ret2 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "resume") {
          const ret2 = super.emit("resume");
          this[MAYBE_EMIT_END]();
          return ret2;
        } else if (ev === "finish" || ev === "prefinish") {
          const ret2 = super.emit(ev);
          this.removeAllListeners(ev);
          return ret2;
        }
        const ret = super.emit(ev, ...args);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITDATA](data) {
        for (const p of this[PIPES]) {
          if (p.dest.write(data) === false)
            this.pause();
        }
        const ret = this[DISCARDED] ? false : super.emit("data", data);
        this[MAYBE_EMIT_END]();
        return ret;
      }
      [EMITEND]() {
        if (this[EMITTED_END])
          return false;
        this[EMITTED_END] = true;
        this.readable = false;
        return this[ASYNC] ? (defer$3(() => this[EMITEND2]()), true) : this[EMITEND2]();
      }
      [EMITEND2]() {
        if (this[DECODER]) {
          const data = this[DECODER].end();
          if (data) {
            for (const p of this[PIPES]) {
              p.dest.write(data);
            }
            if (!this[DISCARDED])
              super.emit("data", data);
          }
        }
        for (const p of this[PIPES]) {
          p.end();
        }
        const ret = super.emit("end");
        this.removeAllListeners("end");
        return ret;
      }
      /**
       * Return a Promise that resolves to an array of all emitted data once
       * the stream ends.
       */
      async collect() {
        const buf = Object.assign([], {
          dataLength: 0
        });
        if (!this[OBJECTMODE])
          buf.dataLength = 0;
        const p = this.promise();
        this.on("data", (c) => {
          buf.push(c);
          if (!this[OBJECTMODE])
            buf.dataLength += c.length;
        });
        await p;
        return buf;
      }
      /**
       * Return a Promise that resolves to the concatenation of all emitted data
       * once the stream ends.
       *
       * Not allowed on objectMode streams.
       */
      async concat() {
        if (this[OBJECTMODE]) {
          throw new Error("cannot concat in objectMode");
        }
        const buf = await this.collect();
        return this[ENCODING$1] ? buf.join("") : Buffer.concat(buf, buf.dataLength);
      }
      /**
       * Return a void Promise that resolves once the stream ends.
       */
      async promise() {
        return new Promise((resolve8, reject) => {
          this.on(DESTROYED, () => reject(new Error("stream destroyed")));
          this.on("error", (er) => reject(er));
          this.on("end", () => resolve8());
        });
      }
      /**
       * Asynchronous `for await of` iteration.
       *
       * This will continue emitting all chunks until the stream terminates.
       */
      [Symbol.asyncIterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = async () => {
          this.pause();
          stopped = true;
          return { value: void 0, done: true };
        };
        const next = () => {
          if (stopped)
            return stop();
          const res = this.read();
          if (res !== null)
            return Promise.resolve({ done: false, value: res });
          if (this[EOF])
            return stop();
          let resolve8;
          let reject;
          const onerr = (er) => {
            this.off("data", ondata);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            stop();
            reject(er);
          };
          const ondata = (value2) => {
            this.off("error", onerr);
            this.off("end", onend);
            this.off(DESTROYED, ondestroy);
            this.pause();
            resolve8({ value: value2, done: !!this[EOF] });
          };
          const onend = () => {
            this.off("error", onerr);
            this.off("data", ondata);
            this.off(DESTROYED, ondestroy);
            stop();
            resolve8({ done: true, value: void 0 });
          };
          const ondestroy = () => onerr(new Error("stream destroyed"));
          return new Promise((res2, rej) => {
            reject = rej;
            resolve8 = res2;
            this.once(DESTROYED, ondestroy);
            this.once("error", onerr);
            this.once("end", onend);
            this.once("data", ondata);
          });
        };
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.asyncIterator]() {
            return this;
          }
        };
      }
      /**
       * Synchronous `for of` iteration.
       *
       * The iteration will terminate when the internal buffer runs out, even
       * if the stream has not yet terminated.
       */
      [Symbol.iterator]() {
        this[DISCARDED] = false;
        let stopped = false;
        const stop = () => {
          this.pause();
          this.off(ERROR, stop);
          this.off(DESTROYED, stop);
          this.off("end", stop);
          stopped = true;
          return { done: true, value: void 0 };
        };
        const next = () => {
          if (stopped)
            return stop();
          const value2 = this.read();
          return value2 === null ? stop() : { done: false, value: value2 };
        };
        this.once("end", stop);
        this.once(ERROR, stop);
        this.once(DESTROYED, stop);
        return {
          next,
          throw: stop,
          return: stop,
          [Symbol.iterator]() {
            return this;
          }
        };
      }
      /**
       * Destroy a stream, preventing it from being used for any further purpose.
       *
       * If the stream has a `close()` method, then it will be called on
       * destruction.
       *
       * After destruction, any attempt to write data, read data, or emit most
       * events will be ignored.
       *
       * If an error argument is provided, then it will be emitted in an
       * 'error' event.
       */
      destroy(er) {
        if (this[DESTROYED]) {
          if (er)
            this.emit("error", er);
          else
            this.emit(DESTROYED);
          return this;
        }
        this[DESTROYED] = true;
        this[DISCARDED] = true;
        this[BUFFER].length = 0;
        this[BUFFERLENGTH] = 0;
        const wc = this;
        if (typeof wc.close === "function" && !this[CLOSED$1])
          wc.close();
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      /**
       * Alias for {@link isStream}
       *
       * Former export location, maintained for backwards compatibility.
       *
       * @deprecated
       */
      static get isStream() {
        return isStream;
      }
    };
    realpathSync = realpathSync$1.native;
    defaultFS = {
      lstatSync,
      readdir: readdir$4,
      readdirSync,
      readlinkSync,
      realpathSync,
      promises: {
        lstat: lstat$3,
        readdir: readdir$5,
        readlink,
        realpath: realpath$2
      }
    };
    fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === fs$j ? defaultFS : {
      ...defaultFS,
      ...fsOption,
      promises: {
        ...defaultFS.promises,
        ...fsOption.promises || {}
      }
    };
    uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
    uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
    eitherSep = /[\\\/]/;
    UNKNOWN = 0;
    IFIFO = 1;
    IFCHR = 2;
    IFDIR = 4;
    IFBLK = 6;
    IFREG = 8;
    IFLNK = 10;
    IFSOCK = 12;
    IFMT = 15;
    IFMT_UNKNOWN = ~IFMT;
    READDIR_CALLED = 16;
    LSTAT_CALLED = 32;
    ENOTDIR = 64;
    ENOENT = 128;
    ENOREADLINK = 256;
    ENOREALPATH = 512;
    ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
    TYPEMASK = 1023;
    entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
    normalizeCache = /* @__PURE__ */ new Map();
    normalize = (s) => {
      const c = normalizeCache.get(s);
      if (c)
        return c;
      const n = s.normalize("NFKD");
      normalizeCache.set(s, n);
      return n;
    };
    normalizeNocaseCache = /* @__PURE__ */ new Map();
    normalizeNocase = (s) => {
      const c = normalizeNocaseCache.get(s);
      if (c)
        return c;
      const n = normalize(s.toLowerCase());
      normalizeNocaseCache.set(s, n);
      return n;
    };
    ResolveCache = class extends LRUCache {
      constructor() {
        super({ max: 256 });
      }
    };
    ChildrenCache = class extends LRUCache {
      constructor(maxSize = 16 * 1024) {
        super({
          maxSize,
          // parent + children
          sizeCalculation: (a) => a.length + 1
        });
      }
    };
    setAsCwd = Symbol("PathScurry setAsCwd");
    PathBase = class {
      /**
       * the basename of this path
       *
       * **Important**: *always* test the path name against any test string
       * usingthe {@link isNamed} method, and not by directly comparing this
       * string. Otherwise, unicode path strings that the system sees as identical
       * will not be properly treated as the same path, leading to incorrect
       * behavior and possible security issues.
       */
      name;
      /**
       * the Path entry corresponding to the path root.
       *
       * @internal
       */
      root;
      /**
       * All roots found within the current PathScurry family
       *
       * @internal
       */
      roots;
      /**
       * a reference to the parent path, or undefined in the case of root entries
       *
       * @internal
       */
      parent;
      /**
       * boolean indicating whether paths are compared case-insensitively
       * @internal
       */
      nocase;
      /**
       * boolean indicating that this path is the current working directory
       * of the PathScurry collection that contains it.
       */
      isCWD = false;
      // potential default fs override
      #fs;
      // Stats fields
      #dev;
      get dev() {
        return this.#dev;
      }
      #mode;
      get mode() {
        return this.#mode;
      }
      #nlink;
      get nlink() {
        return this.#nlink;
      }
      #uid;
      get uid() {
        return this.#uid;
      }
      #gid;
      get gid() {
        return this.#gid;
      }
      #rdev;
      get rdev() {
        return this.#rdev;
      }
      #blksize;
      get blksize() {
        return this.#blksize;
      }
      #ino;
      get ino() {
        return this.#ino;
      }
      #size;
      get size() {
        return this.#size;
      }
      #blocks;
      get blocks() {
        return this.#blocks;
      }
      #atimeMs;
      get atimeMs() {
        return this.#atimeMs;
      }
      #mtimeMs;
      get mtimeMs() {
        return this.#mtimeMs;
      }
      #ctimeMs;
      get ctimeMs() {
        return this.#ctimeMs;
      }
      #birthtimeMs;
      get birthtimeMs() {
        return this.#birthtimeMs;
      }
      #atime;
      get atime() {
        return this.#atime;
      }
      #mtime;
      get mtime() {
        return this.#mtime;
      }
      #ctime;
      get ctime() {
        return this.#ctime;
      }
      #birthtime;
      get birthtime() {
        return this.#birthtime;
      }
      #matchName;
      #depth;
      #fullpath;
      #fullpathPosix;
      #relative;
      #relativePosix;
      #type;
      #children;
      #linkTarget;
      #realpath;
      /**
       * This property is for compatibility with the Dirent class as of
       * Node v20, where Dirent['parentPath'] refers to the path of the
       * directory that was passed to readdir. For root entries, it's the path
       * to the entry itself.
       */
      get parentPath() {
        return (this.parent || this).fullpath();
      }
      /**
       * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,
       * this property refers to the *parent* path, not the path object itself.
       */
      get path() {
        return this.parentPath;
      }
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root4, roots, nocase, children, opts) {
        this.name = name2;
        this.#matchName = nocase ? normalizeNocase(name2) : normalize(name2);
        this.#type = type & TYPEMASK;
        this.nocase = nocase;
        this.roots = roots;
        this.root = root4 || this;
        this.#children = children;
        this.#fullpath = opts.fullpath;
        this.#relative = opts.relative;
        this.#relativePosix = opts.relativePosix;
        this.parent = opts.parent;
        if (this.parent) {
          this.#fs = this.parent.#fs;
        } else {
          this.#fs = fsFromOption(opts.fs);
        }
      }
      /**
       * Returns the depth of the Path object from its root.
       *
       * For example, a path at `/foo/bar` would have a depth of 2.
       */
      depth() {
        if (this.#depth !== void 0)
          return this.#depth;
        if (!this.parent)
          return this.#depth = 0;
        return this.#depth = this.parent.depth() + 1;
      }
      /**
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Get the Path object referenced by the string path, resolved from this Path
       */
      resolve(path9) {
        if (!path9) {
          return this;
        }
        const rootPath = this.getRootString(path9);
        const dir = path9.substring(rootPath.length);
        const dirParts = dir.split(this.splitSep);
        const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
        return result;
      }
      #resolveParts(dirParts) {
        let p = this;
        for (const part of dirParts) {
          p = p.child(part);
        }
        return p;
      }
      /**
       * Returns the cached children Path objects, if still available.  If they
       * have fallen out of the cache, then returns an empty array, and resets the
       * READDIR_CALLED bit, so that future calls to readdir() will require an fs
       * lookup.
       *
       * @internal
       */
      children() {
        const cached = this.#children.get(this);
        if (cached) {
          return cached;
        }
        const children = Object.assign([], { provisional: 0 });
        this.#children.set(this, children);
        this.#type &= ~READDIR_CALLED;
        return children;
      }
      /**
       * Resolves a path portion and returns or creates the child Path.
       *
       * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
       * `'..'`.
       *
       * This should not be called directly.  If `pathPart` contains any path
       * separators, it will lead to unsafe undefined behavior.
       *
       * Use `Path.resolve()` instead.
       *
       * @internal
       */
      child(pathPart, opts) {
        if (pathPart === "" || pathPart === ".") {
          return this;
        }
        if (pathPart === "..") {
          return this.parent || this;
        }
        const children = this.children();
        const name2 = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
        for (const p of children) {
          if (p.#matchName === name2) {
            return p;
          }
        }
        const s = this.parent ? this.sep : "";
        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
        const pchild = this.newChild(pathPart, UNKNOWN, {
          ...opts,
          parent: this,
          fullpath
        });
        if (!this.canReaddir()) {
          pchild.#type |= ENOENT;
        }
        children.push(pchild);
        return pchild;
      }
      /**
       * The relative path from the cwd. If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpath()
       */
      relative() {
        if (this.isCWD)
          return "";
        if (this.#relative !== void 0) {
          return this.#relative;
        }
        const name2 = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relative = this.name;
        }
        const pv = p.relative();
        return pv + (!pv || !p.parent ? "" : this.sep) + name2;
      }
      /**
       * The relative path from the cwd, using / as the path separator.
       * If it does not share an ancestor with
       * the cwd, then this ends up being equivalent to the fullpathPosix()
       * On posix systems, this is identical to relative().
       */
      relativePosix() {
        if (this.sep === "/")
          return this.relative();
        if (this.isCWD)
          return "";
        if (this.#relativePosix !== void 0)
          return this.#relativePosix;
        const name2 = this.name;
        const p = this.parent;
        if (!p) {
          return this.#relativePosix = this.fullpathPosix();
        }
        const pv = p.relativePosix();
        return pv + (!pv || !p.parent ? "" : "/") + name2;
      }
      /**
       * The fully resolved path string for this Path entry
       */
      fullpath() {
        if (this.#fullpath !== void 0) {
          return this.#fullpath;
        }
        const name2 = this.name;
        const p = this.parent;
        if (!p) {
          return this.#fullpath = this.name;
        }
        const pv = p.fullpath();
        const fp = pv + (!p.parent ? "" : this.sep) + name2;
        return this.#fullpath = fp;
      }
      /**
       * On platforms other than windows, this is identical to fullpath.
       *
       * On windows, this is overridden to return the forward-slash form of the
       * full UNC path.
       */
      fullpathPosix() {
        if (this.#fullpathPosix !== void 0)
          return this.#fullpathPosix;
        if (this.sep === "/")
          return this.#fullpathPosix = this.fullpath();
        if (!this.parent) {
          const p2 = this.fullpath().replace(/\\/g, "/");
          if (/^[a-z]:\//i.test(p2)) {
            return this.#fullpathPosix = `//?/${p2}`;
          } else {
            return this.#fullpathPosix = p2;
          }
        }
        const p = this.parent;
        const pfpp = p.fullpathPosix();
        const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
        return this.#fullpathPosix = fpp;
      }
      /**
       * Is the Path of an unknown type?
       *
       * Note that we might know *something* about it if there has been a previous
       * filesystem operation, for example that it does not exist, or is not a
       * link, or whether it has child entries.
       */
      isUnknown() {
        return (this.#type & IFMT) === UNKNOWN;
      }
      isType(type) {
        return this[`is${type}`]();
      }
      getType() {
        return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
          /* c8 ignore start */
          this.isSocket() ? "Socket" : "Unknown"
        );
      }
      /**
       * Is the Path a regular file?
       */
      isFile() {
        return (this.#type & IFMT) === IFREG;
      }
      /**
       * Is the Path a directory?
       */
      isDirectory() {
        return (this.#type & IFMT) === IFDIR;
      }
      /**
       * Is the path a character device?
       */
      isCharacterDevice() {
        return (this.#type & IFMT) === IFCHR;
      }
      /**
       * Is the path a block device?
       */
      isBlockDevice() {
        return (this.#type & IFMT) === IFBLK;
      }
      /**
       * Is the path a FIFO pipe?
       */
      isFIFO() {
        return (this.#type & IFMT) === IFIFO;
      }
      /**
       * Is the path a socket?
       */
      isSocket() {
        return (this.#type & IFMT) === IFSOCK;
      }
      /**
       * Is the path a symbolic link?
       */
      isSymbolicLink() {
        return (this.#type & IFLNK) === IFLNK;
      }
      /**
       * Return the entry if it has been subject of a successful lstat, or
       * undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* simply
       * mean that we haven't called lstat on it.
       */
      lstatCached() {
        return this.#type & LSTAT_CALLED ? this : void 0;
      }
      /**
       * Return the cached link target if the entry has been the subject of a
       * successful readlink, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readlink() has been called at some point.
       */
      readlinkCached() {
        return this.#linkTarget;
      }
      /**
       * Returns the cached realpath target if the entry has been the subject
       * of a successful realpath, or undefined otherwise.
       *
       * Does not read the filesystem, so an undefined result *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * realpath() has been called at some point.
       */
      realpathCached() {
        return this.#realpath;
      }
      /**
       * Returns the cached child Path entries array if the entry has been the
       * subject of a successful readdir(), or [] otherwise.
       *
       * Does not read the filesystem, so an empty array *could* just mean we
       * don't have any cached data. Only use it if you are very sure that a
       * readdir() has been called recently enough to still be valid.
       */
      readdirCached() {
        const children = this.children();
        return children.slice(0, children.provisional);
      }
      /**
       * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
       * any indication that readlink will definitely fail.
       *
       * Returns false if the path is known to not be a symlink, if a previous
       * readlink failed, or if the entry does not exist.
       */
      canReadlink() {
        if (this.#linkTarget)
          return true;
        if (!this.parent)
          return false;
        const ifmt = this.#type & IFMT;
        return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
      }
      /**
       * Return true if readdir has previously been successfully called on this
       * path, indicating that cachedReaddir() is likely valid.
       */
      calledReaddir() {
        return !!(this.#type & READDIR_CALLED);
      }
      /**
       * Returns true if the path is known to not exist. That is, a previous lstat
       * or readdir failed to verify its existence when that would have been
       * expected, or a parent entry was marked either enoent or enotdir.
       */
      isENOENT() {
        return !!(this.#type & ENOENT);
      }
      /**
       * Return true if the path is a match for the given path name.  This handles
       * case sensitivity and unicode normalization.
       *
       * Note: even on case-sensitive systems, it is **not** safe to test the
       * equality of the `.name` property to determine whether a given pathname
       * matches, due to unicode normalization mismatches.
       *
       * Always use this method instead of testing the `path.name` property
       * directly.
       */
      isNamed(n) {
        return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
      }
      /**
       * Return the Path object corresponding to the target of a symbolic link.
       *
       * If the Path is not a symbolic link, or if the readlink call fails for any
       * reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       */
      async readlink() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read2 = await this.#fs.promises.readlink(this.fullpath());
          const linkTarget = (await this.parent.realpath())?.resolve(read2);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      /**
       * Synchronous {@link PathBase.readlink}
       */
      readlinkSync() {
        const target = this.#linkTarget;
        if (target) {
          return target;
        }
        if (!this.canReadlink()) {
          return void 0;
        }
        if (!this.parent) {
          return void 0;
        }
        try {
          const read2 = this.#fs.readlinkSync(this.fullpath());
          const linkTarget = this.parent.realpathSync()?.resolve(read2);
          if (linkTarget) {
            return this.#linkTarget = linkTarget;
          }
        } catch (er) {
          this.#readlinkFail(er.code);
          return void 0;
        }
      }
      #readdirSuccess(children) {
        this.#type |= READDIR_CALLED;
        for (let p = children.provisional; p < children.length; p++) {
          const c = children[p];
          if (c)
            c.#markENOENT();
        }
      }
      #markENOENT() {
        if (this.#type & ENOENT)
          return;
        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
        this.#markChildrenENOENT();
      }
      #markChildrenENOENT() {
        const children = this.children();
        children.provisional = 0;
        for (const p of children) {
          p.#markENOENT();
        }
      }
      #markENOREALPATH() {
        this.#type |= ENOREALPATH;
        this.#markENOTDIR();
      }
      // save the information when we know the entry is not a dir
      #markENOTDIR() {
        if (this.#type & ENOTDIR)
          return;
        let t = this.#type;
        if ((t & IFMT) === IFDIR)
          t &= IFMT_UNKNOWN;
        this.#type = t | ENOTDIR;
        this.#markChildrenENOENT();
      }
      #readdirFail(code = "") {
        if (code === "ENOTDIR" || code === "EPERM") {
          this.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        } else {
          this.children().provisional = 0;
        }
      }
      #lstatFail(code = "") {
        if (code === "ENOTDIR") {
          const p = this.parent;
          p.#markENOTDIR();
        } else if (code === "ENOENT") {
          this.#markENOENT();
        }
      }
      #readlinkFail(code = "") {
        let ter = this.#type;
        ter |= ENOREADLINK;
        if (code === "ENOENT")
          ter |= ENOENT;
        if (code === "EINVAL" || code === "UNKNOWN") {
          ter &= IFMT_UNKNOWN;
        }
        this.#type = ter;
        if (code === "ENOTDIR" && this.parent) {
          this.parent.#markENOTDIR();
        }
      }
      #readdirAddChild(e, c) {
        return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
      }
      #readdirAddNewChild(e, c) {
        const type = entToType(e);
        const child = this.newChild(e.name, type, { parent: this });
        const ifmt = child.#type & IFMT;
        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
          child.#type |= ENOTDIR;
        }
        c.unshift(child);
        c.provisional++;
        return child;
      }
      #readdirMaybePromoteChild(e, c) {
        for (let p = c.provisional; p < c.length; p++) {
          const pchild = c[p];
          const name2 = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
          if (name2 !== pchild.#matchName) {
            continue;
          }
          return this.#readdirPromoteChild(e, pchild, p, c);
        }
      }
      #readdirPromoteChild(e, p, index4, c) {
        const v = p.name;
        p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
        if (v !== e.name)
          p.name = e.name;
        if (index4 !== c.provisional) {
          if (index4 === c.length - 1)
            c.pop();
          else
            c.splice(index4, 1);
          c.unshift(p);
        }
        c.provisional++;
        return p;
      }
      /**
       * Call lstat() on this Path, and update all known information that can be
       * determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      /**
       * synchronous {@link PathBase.lstat}
       */
      lstatSync() {
        if ((this.#type & ENOENT) === 0) {
          try {
            this.#applyStat(this.#fs.lstatSync(this.fullpath()));
            return this;
          } catch (er) {
            this.#lstatFail(er.code);
          }
        }
      }
      #applyStat(st) {
        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode: mode2, mtime, mtimeMs, nlink, rdev, size, uid } = st;
        this.#atime = atime;
        this.#atimeMs = atimeMs;
        this.#birthtime = birthtime;
        this.#birthtimeMs = birthtimeMs;
        this.#blksize = blksize;
        this.#blocks = blocks;
        this.#ctime = ctime;
        this.#ctimeMs = ctimeMs;
        this.#dev = dev;
        this.#gid = gid;
        this.#ino = ino;
        this.#mode = mode2;
        this.#mtime = mtime;
        this.#mtimeMs = mtimeMs;
        this.#nlink = nlink;
        this.#rdev = rdev;
        this.#size = size;
        this.#uid = uid;
        const ifmt = entToType(st);
        this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
          this.#type |= ENOTDIR;
        }
      }
      #onReaddirCB = [];
      #readdirCBInFlight = false;
      #callOnReaddirCB(children) {
        this.#readdirCBInFlight = false;
        const cbs = this.#onReaddirCB.slice();
        this.#onReaddirCB.length = 0;
        cbs.forEach((cb) => cb(null, children));
      }
      /**
       * Standard node-style callback interface to get list of directory entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       *
       * @param cb The callback called with (er, entries).  Note that the `er`
       * param is somewhat extraneous, as all readdir() errors are handled and
       * simply result in an empty set of entries being returned.
       * @param allowZalgo Boolean indicating that immediately known results should
       * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
       * zalgo at your peril, the dark pony lord is devious and unforgiving.
       */
      readdirCB(cb, allowZalgo = false) {
        if (!this.canReaddir()) {
          if (allowZalgo)
            cb(null, []);
          else
            queueMicrotask(() => cb(null, []));
          return;
        }
        const children = this.children();
        if (this.calledReaddir()) {
          const c = children.slice(0, children.provisional);
          if (allowZalgo)
            cb(null, c);
          else
            queueMicrotask(() => cb(null, c));
          return;
        }
        this.#onReaddirCB.push(cb);
        if (this.#readdirCBInFlight) {
          return;
        }
        this.#readdirCBInFlight = true;
        const fullpath = this.fullpath();
        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
          if (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          } else {
            for (const e of entries) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          }
          this.#callOnReaddirCB(children.slice(0, children.provisional));
          return;
        });
      }
      #asyncReaddirInFlight;
      /**
       * Return an array of known child entries.
       *
       * If the Path cannot or does not contain any children, then an empty array
       * is returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async readdir() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        if (this.#asyncReaddirInFlight) {
          await this.#asyncReaddirInFlight;
        } else {
          let resolve8 = () => {
          };
          this.#asyncReaddirInFlight = new Promise((res) => resolve8 = res);
          try {
            for (const e of await this.#fs.promises.readdir(fullpath, {
              withFileTypes: true
            })) {
              this.#readdirAddChild(e, children);
            }
            this.#readdirSuccess(children);
          } catch (er) {
            this.#readdirFail(er.code);
            children.provisional = 0;
          }
          this.#asyncReaddirInFlight = void 0;
          resolve8();
        }
        return children.slice(0, children.provisional);
      }
      /**
       * synchronous {@link PathBase.readdir}
       */
      readdirSync() {
        if (!this.canReaddir()) {
          return [];
        }
        const children = this.children();
        if (this.calledReaddir()) {
          return children.slice(0, children.provisional);
        }
        const fullpath = this.fullpath();
        try {
          for (const e of this.#fs.readdirSync(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        return children.slice(0, children.provisional);
      }
      canReaddir() {
        if (this.#type & ENOCHILD)
          return false;
        const ifmt = IFMT & this.#type;
        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
          return false;
        }
        return true;
      }
      shouldWalk(dirs, walkFilter) {
        return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
      }
      /**
       * Return the Path object corresponding to path as resolved
       * by realpath(3).
       *
       * If the realpath call fails for any reason, `undefined` is returned.
       *
       * Result is cached, and thus may be outdated if the filesystem is mutated.
       * On success, returns a Path object.
       */
      async realpath() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = await this.#fs.promises.realpath(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Synchronous {@link realpath}
       */
      realpathSync() {
        if (this.#realpath)
          return this.#realpath;
        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
          return void 0;
        try {
          const rp = this.#fs.realpathSync(this.fullpath());
          return this.#realpath = this.resolve(rp);
        } catch (_) {
          this.#markENOREALPATH();
        }
      }
      /**
       * Internal method to mark this Path object as the scurry cwd,
       * called by {@link PathScurry#chdir}
       *
       * @internal
       */
      [setAsCwd](oldCwd) {
        if (oldCwd === this)
          return;
        oldCwd.isCWD = false;
        this.isCWD = true;
        const changed = /* @__PURE__ */ new Set([]);
        let rp = [];
        let p = this;
        while (p && p.parent) {
          changed.add(p);
          p.#relative = rp.join(this.sep);
          p.#relativePosix = rp.join("/");
          p = p.parent;
          rp.push("..");
        }
        p = oldCwd;
        while (p && p.parent && !changed.has(p)) {
          p.#relative = void 0;
          p.#relativePosix = void 0;
          p = p.parent;
        }
      }
    };
    PathWin32 = class _PathWin32 extends PathBase {
      /**
       * Separator for generating path strings.
       */
      sep = "\\";
      /**
       * Separator for parsing path strings.
       */
      splitSep = eitherSep;
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root4, roots, nocase, children, opts) {
        super(name2, type, root4, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      newChild(name2, type = UNKNOWN, opts = {}) {
        return new _PathWin32(name2, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
      /**
       * @internal
       */
      getRootString(path9) {
        return win32$1.parse(path9).root;
      }
      /**
       * @internal
       */
      getRoot(rootPath) {
        rootPath = uncToDrive(rootPath.toUpperCase());
        if (rootPath === this.root.name) {
          return this.root;
        }
        for (const [compare2, root4] of Object.entries(this.roots)) {
          if (this.sameRoot(rootPath, compare2)) {
            return this.roots[rootPath] = root4;
          }
        }
        return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
      }
      /**
       * @internal
       */
      sameRoot(rootPath, compare2 = this.root.name) {
        rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
        return rootPath === compare2;
      }
    };
    PathPosix = class _PathPosix extends PathBase {
      /**
       * separator for parsing path strings
       */
      splitSep = "/";
      /**
       * separator for generating path strings
       */
      sep = "/";
      /**
       * Do not create new Path objects directly.  They should always be accessed
       * via the PathScurry class or other methods on the Path class.
       *
       * @internal
       */
      constructor(name2, type = UNKNOWN, root4, roots, nocase, children, opts) {
        super(name2, type, root4, roots, nocase, children, opts);
      }
      /**
       * @internal
       */
      getRootString(path9) {
        return path9.startsWith("/") ? "/" : "";
      }
      /**
       * @internal
       */
      getRoot(_rootPath) {
        return this.root;
      }
      /**
       * @internal
       */
      newChild(name2, type = UNKNOWN, opts = {}) {
        return new _PathPosix(name2, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);
      }
    };
    PathScurryBase = class {
      /**
       * The root Path entry for the current working directory of this Scurry
       */
      root;
      /**
       * The string path for the root of this Scurry's current working directory
       */
      rootPath;
      /**
       * A collection of all roots encountered, referenced by rootPath
       */
      roots;
      /**
       * The Path entry corresponding to this PathScurry's current working directory.
       */
      cwd;
      #resolveCache;
      #resolvePosixCache;
      #children;
      /**
       * Perform path comparisons case-insensitively.
       *
       * Defaults true on Darwin and Windows systems, false elsewhere.
       */
      nocase;
      #fs;
      /**
       * This class should not be instantiated directly.
       *
       * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
       *
       * @internal
       */
      constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs6 = defaultFS } = {}) {
        this.#fs = fsFromOption(fs6);
        if (cwd instanceof URL || cwd.startsWith("file://")) {
          cwd = fileURLToPath2(cwd);
        }
        const cwdPath = pathImpl.resolve(cwd);
        this.roots = /* @__PURE__ */ Object.create(null);
        this.rootPath = this.parseRootPath(cwdPath);
        this.#resolveCache = new ResolveCache();
        this.#resolvePosixCache = new ResolveCache();
        this.#children = new ChildrenCache(childrenCacheSize);
        const split = cwdPath.substring(this.rootPath.length).split(sep2);
        if (split.length === 1 && !split[0]) {
          split.pop();
        }
        if (nocase === void 0) {
          throw new TypeError("must provide nocase setting to PathScurryBase ctor");
        }
        this.nocase = nocase;
        this.root = this.newRoot(this.#fs);
        this.roots[this.rootPath] = this.root;
        let prev = this.root;
        let len = split.length - 1;
        const joinSep = pathImpl.sep;
        let abs = this.rootPath;
        let sawFirst = false;
        for (const part of split) {
          const l = len--;
          prev = prev.child(part, {
            relative: new Array(l).fill("..").join(joinSep),
            relativePosix: new Array(l).fill("..").join("/"),
            fullpath: abs += (sawFirst ? "" : joinSep) + part
          });
          sawFirst = true;
        }
        this.cwd = prev;
      }
      /**
       * Get the depth of a provided path, string, or the cwd
       */
      depth(path9 = this.cwd) {
        if (typeof path9 === "string") {
          path9 = this.cwd.resolve(path9);
        }
        return path9.depth();
      }
      /**
       * Return the cache of child entries.  Exposed so subclasses can create
       * child Path objects in a platform-specific way.
       *
       * @internal
       */
      childrenCache() {
        return this.#children;
      }
      /**
       * Resolve one or more path strings to a resolved string
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolve(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolveCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpath();
        this.#resolveCache.set(r, result);
        return result;
      }
      /**
       * Resolve one or more path strings to a resolved string, returning
       * the posix path.  Identical to .resolve() on posix systems, but on
       * windows will return a forward-slash separated UNC path.
       *
       * Same interface as require('path').resolve.
       *
       * Much faster than path.resolve() when called multiple times for the same
       * path, because the resolved Path objects are cached.  Much slower
       * otherwise.
       */
      resolvePosix(...paths) {
        let r = "";
        for (let i = paths.length - 1; i >= 0; i--) {
          const p = paths[i];
          if (!p || p === ".")
            continue;
          r = r ? `${p}/${r}` : p;
          if (this.isAbsolute(p)) {
            break;
          }
        }
        const cached = this.#resolvePosixCache.get(r);
        if (cached !== void 0) {
          return cached;
        }
        const result = this.cwd.resolve(r).fullpathPosix();
        this.#resolvePosixCache.set(r, result);
        return result;
      }
      /**
       * find the relative path from the cwd to the supplied path string or entry
       */
      relative(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.relative();
      }
      /**
       * find the relative path from the cwd to the supplied path string or
       * entry, using / as the path delimiter, even on Windows.
       */
      relativePosix(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.relativePosix();
      }
      /**
       * Return the basename for the provided string or Path object
       */
      basename(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.name;
      }
      /**
       * Return the dirname for the provided string or Path object
       */
      dirname(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return (entry2.parent || entry2).fullpath();
      }
      async readdir(entry2 = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes } = opts;
        if (!entry2.canReaddir()) {
          return [];
        } else {
          const p = await entry2.readdir();
          return withFileTypes ? p : p.map((e) => e.name);
        }
      }
      readdirSync(entry2 = this.cwd, opts = {
        withFileTypes: true
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true } = opts;
        if (!entry2.canReaddir()) {
          return [];
        } else if (withFileTypes) {
          return entry2.readdirSync();
        } else {
          return entry2.readdirSync().map((e) => e.name);
        }
      }
      /**
       * Call lstat() on the string or Path object, and update all known
       * information that can be determined.
       *
       * Note that unlike `fs.lstat()`, the returned value does not contain some
       * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
       * information is required, you will need to call `fs.lstat` yourself.
       *
       * If the Path refers to a nonexistent file, or if the lstat call fails for
       * any reason, `undefined` is returned.  Otherwise the updated Path object is
       * returned.
       *
       * Results are cached, and thus may be out of date if the filesystem is
       * mutated.
       */
      async lstat(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.lstat();
      }
      /**
       * synchronous {@link PathScurryBase.lstat}
       */
      lstatSync(entry2 = this.cwd) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        }
        return entry2.lstatSync();
      }
      async readlink(entry2 = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          withFileTypes = entry2.withFileTypes;
          entry2 = this.cwd;
        }
        const e = await entry2.readlink();
        return withFileTypes ? e : e?.fullpath();
      }
      readlinkSync(entry2 = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          withFileTypes = entry2.withFileTypes;
          entry2 = this.cwd;
        }
        const e = entry2.readlinkSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async realpath(entry2 = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          withFileTypes = entry2.withFileTypes;
          entry2 = this.cwd;
        }
        const e = await entry2.realpath();
        return withFileTypes ? e : e?.fullpath();
      }
      realpathSync(entry2 = this.cwd, { withFileTypes } = {
        withFileTypes: false
      }) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          withFileTypes = entry2.withFileTypes;
          entry2 = this.cwd;
        }
        const e = entry2.realpathSync();
        return withFileTypes ? e : e?.fullpath();
      }
      async walk(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = [];
        if (!filter2 || filter2(entry2)) {
          results.push(withFileTypes ? entry2 : entry2.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const walk3 = (dir, cb) => {
          dirs.add(dir);
          dir.readdirCB((er, entries) => {
            if (er) {
              return cb(er);
            }
            let len = entries.length;
            if (!len)
              return cb();
            const next = () => {
              if (--len === 0) {
                cb();
              }
            };
            for (const e of entries) {
              if (!filter2 || filter2(e)) {
                results.push(withFileTypes ? e : e.fullpath());
              }
              if (follow && e.isSymbolicLink()) {
                e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk3(r, next) : next());
              } else {
                if (e.shouldWalk(dirs, walkFilter)) {
                  walk3(e, next);
                } else {
                  next();
                }
              }
            }
          }, true);
        };
        const start = entry2;
        return new Promise((res, rej) => {
          walk3(start, (er) => {
            if (er)
              return rej(er);
            res(results);
          });
        });
      }
      walkSync(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = [];
        if (!filter2 || filter2(entry2)) {
          results.push(withFileTypes ? entry2 : entry2.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set([entry2]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
        return results;
      }
      /**
       * Support for `for await`
       *
       * Alias for {@link PathScurryBase.iterate}
       *
       * Note: As of Node 19, this is very slow, compared to other methods of
       * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
       * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
       */
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      iterate(entry2 = this.cwd, options2 = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          options2 = entry2;
          entry2 = this.cwd;
        }
        return this.stream(entry2, options2)[Symbol.asyncIterator]();
      }
      /**
       * Iterating over a PathScurry performs a synchronous walk.
       *
       * Alias for {@link PathScurryBase.iterateSync}
       */
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      *iterateSync(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        if (!filter2 || filter2(entry2)) {
          yield withFileTypes ? entry2 : entry2.fullpath();
        }
        const dirs = /* @__PURE__ */ new Set([entry2]);
        for (const dir of dirs) {
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              yield withFileTypes ? e : e.fullpath();
            }
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              dirs.add(r);
            }
          }
        }
      }
      stream(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = new Minipass({ objectMode: true });
        if (!filter2 || filter2(entry2)) {
          results.write(withFileTypes ? entry2 : entry2.fullpath());
        }
        const dirs = /* @__PURE__ */ new Set();
        const queue2 = [entry2];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue2.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const onReaddir = (er, entries, didRealpaths = false) => {
              if (er)
                return results.emit("error", er);
              if (follow && !didRealpaths) {
                const promises = [];
                for (const e of entries) {
                  if (e.isSymbolicLink()) {
                    promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                  }
                }
                if (promises.length) {
                  Promise.all(promises).then(() => onReaddir(null, entries, true));
                  return;
                }
              }
              for (const e of entries) {
                if (e && (!filter2 || filter2(e))) {
                  if (!results.write(withFileTypes ? e : e.fullpath())) {
                    paused = true;
                  }
                }
              }
              processing--;
              for (const e of entries) {
                const r = e.realpathCached() || e;
                if (r.shouldWalk(dirs, walkFilter)) {
                  queue2.push(r);
                }
              }
              if (paused && !results.flowing) {
                results.once("drain", process2);
              } else if (!sync2) {
                process2();
              }
            };
            let sync2 = true;
            dir.readdirCB(onReaddir, true);
            sync2 = false;
          }
        };
        process2();
        return results;
      }
      streamSync(entry2 = this.cwd, opts = {}) {
        if (typeof entry2 === "string") {
          entry2 = this.cwd.resolve(entry2);
        } else if (!(entry2 instanceof PathBase)) {
          opts = entry2;
          entry2 = this.cwd;
        }
        const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
        const results = new Minipass({ objectMode: true });
        const dirs = /* @__PURE__ */ new Set();
        if (!filter2 || filter2(entry2)) {
          results.write(withFileTypes ? entry2 : entry2.fullpath());
        }
        const queue2 = [entry2];
        let processing = 0;
        const process2 = () => {
          let paused = false;
          while (!paused) {
            const dir = queue2.shift();
            if (!dir) {
              if (processing === 0)
                results.end();
              return;
            }
            processing++;
            dirs.add(dir);
            const entries = dir.readdirSync();
            for (const e of entries) {
              if (!filter2 || filter2(e)) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              let r = e;
              if (e.isSymbolicLink()) {
                if (!(follow && (r = e.realpathSync())))
                  continue;
                if (r.isUnknown())
                  r.lstatSync();
              }
              if (r.shouldWalk(dirs, walkFilter)) {
                queue2.push(r);
              }
            }
          }
          if (paused && !results.flowing)
            results.once("drain", process2);
        };
        process2();
        return results;
      }
      chdir(path9 = this.cwd) {
        const oldCwd = this.cwd;
        this.cwd = typeof path9 === "string" ? this.cwd.resolve(path9) : path9;
        this.cwd[setAsCwd](oldCwd);
      }
    };
    PathScurryWin32 = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "\\";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, win32$1, "\\", { ...opts, nocase });
        this.nocase = nocase;
        for (let p = this.cwd; p; p = p.parent) {
          p.nocase = this.nocase;
        }
      }
      /**
       * @internal
       */
      parseRootPath(dir) {
        return win32$1.parse(dir).root.toUpperCase();
      }
      /**
       * @internal
       */
      newRoot(fs6) {
        return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs6 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
      }
    };
    PathScurryPosix = class extends PathScurryBase {
      /**
       * separator for generating path strings
       */
      sep = "/";
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = false } = opts;
        super(cwd, posix$1, "/", { ...opts, nocase });
        this.nocase = nocase;
      }
      /**
       * @internal
       */
      parseRootPath(_dir) {
        return "/";
      }
      /**
       * @internal
       */
      newRoot(fs6) {
        return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs6 });
      }
      /**
       * Return true if the provided path string is an absolute path
       */
      isAbsolute(p) {
        return p.startsWith("/");
      }
    };
    PathScurryDarwin = class extends PathScurryPosix {
      constructor(cwd = process.cwd(), opts = {}) {
        const { nocase = true } = opts;
        super(cwd, { ...opts, nocase });
      }
    };
    process.platform === "win32" ? PathWin32 : PathPosix;
    PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;
    isPatternList = (pl) => pl.length >= 1;
    isGlobList = (gl) => gl.length >= 1;
    Pattern = class _Pattern {
      #patternList;
      #globList;
      #index;
      length;
      #platform;
      #rest;
      #globString;
      #isDrive;
      #isUNC;
      #isAbsolute;
      #followGlobstar = true;
      constructor(patternList, globList, index4, platform2) {
        if (!isPatternList(patternList)) {
          throw new TypeError("empty pattern list");
        }
        if (!isGlobList(globList)) {
          throw new TypeError("empty glob list");
        }
        if (globList.length !== patternList.length) {
          throw new TypeError("mismatched pattern list and glob list lengths");
        }
        this.length = patternList.length;
        if (index4 < 0 || index4 >= this.length) {
          throw new TypeError("index out of range");
        }
        this.#patternList = patternList;
        this.#globList = globList;
        this.#index = index4;
        this.#platform = platform2;
        if (this.#index === 0) {
          if (this.isUNC()) {
            const [p0, p1, p2, p3, ...prest] = this.#patternList;
            const [g0, g1, g2, g3, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = [p0, p1, p2, p3, ""].join("/");
            const g = [g0, g1, g2, g3, ""].join("/");
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          } else if (this.isDrive() || this.isAbsolute()) {
            const [p1, ...prest] = this.#patternList;
            const [g1, ...grest] = this.#globList;
            if (prest[0] === "") {
              prest.shift();
              grest.shift();
            }
            const p = p1 + "/";
            const g = g1 + "/";
            this.#patternList = [p, ...prest];
            this.#globList = [g, ...grest];
            this.length = this.#patternList.length;
          }
        }
      }
      /**
       * The first entry in the parsed list of patterns
       */
      pattern() {
        return this.#patternList[this.#index];
      }
      /**
       * true of if pattern() returns a string
       */
      isString() {
        return typeof this.#patternList[this.#index] === "string";
      }
      /**
       * true of if pattern() returns GLOBSTAR
       */
      isGlobstar() {
        return this.#patternList[this.#index] === GLOBSTAR$2;
      }
      /**
       * true if pattern() returns a regexp
       */
      isRegExp() {
        return this.#patternList[this.#index] instanceof RegExp;
      }
      /**
       * The /-joined set of glob parts that make up this pattern
       */
      globString() {
        return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
      }
      /**
       * true if there are more pattern parts after this one
       */
      hasMore() {
        return this.length > this.#index + 1;
      }
      /**
       * The rest of the pattern after this part, or null if this is the end
       */
      rest() {
        if (this.#rest !== void 0)
          return this.#rest;
        if (!this.hasMore())
          return this.#rest = null;
        this.#rest = new _Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
        this.#rest.#isAbsolute = this.#isAbsolute;
        this.#rest.#isUNC = this.#isUNC;
        this.#rest.#isDrive = this.#isDrive;
        return this.#rest;
      }
      /**
       * true if the pattern represents a //unc/path/ on windows
       */
      isUNC() {
        const pl = this.#patternList;
        return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
      }
      // pattern like C:/...
      // split = ['C:', ...]
      // XXX: would be nice to handle patterns like `c:*` to test the cwd
      // in c: for *, but I don't know of a way to even figure out what that
      // cwd is without actually chdir'ing into it?
      /**
       * True if the pattern starts with a drive letter on Windows
       */
      isDrive() {
        const pl = this.#patternList;
        return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
      }
      // pattern = '/' or '/...' or '/x/...'
      // split = ['', ''] or ['', ...] or ['', 'x', ...]
      // Drive and UNC both considered absolute on windows
      /**
       * True if the pattern is rooted on an absolute path
       */
      isAbsolute() {
        const pl = this.#patternList;
        return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
      }
      /**
       * consume the root of the pattern, and return it
       */
      root() {
        const p = this.#patternList[0];
        return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
      }
      /**
       * Check to see if the current globstar pattern is allowed to follow
       * a symbolic link.
       */
      checkFollowGlobstar() {
        return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
      }
      /**
       * Mark that the current globstar pattern is following a symbolic link
       */
      markFollowGlobstar() {
        if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
          return false;
        this.#followGlobstar = false;
        return true;
      }
    };
    defaultPlatform$1 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    Ignore = class {
      relative;
      relativeChildren;
      absolute;
      absoluteChildren;
      platform;
      mmopts;
      constructor(ignored, { nobrace, nocase, noext, noglobstar, platform: platform2 = defaultPlatform$1 }) {
        this.relative = [];
        this.absolute = [];
        this.relativeChildren = [];
        this.absoluteChildren = [];
        this.platform = platform2;
        this.mmopts = {
          dot: true,
          nobrace,
          nocase,
          noext,
          noglobstar,
          optimizationLevel: 2,
          platform: platform2,
          nocomment: true,
          nonegate: true
        };
        for (const ign of ignored)
          this.add(ign);
      }
      add(ign) {
        const mm = new Minimatch(ign, this.mmopts);
        for (let i = 0; i < mm.set.length; i++) {
          const parsed = mm.set[i];
          const globParts = mm.globParts[i];
          if (!parsed || !globParts) {
            throw new Error("invalid pattern object");
          }
          while (parsed[0] === "." && globParts[0] === ".") {
            parsed.shift();
            globParts.shift();
          }
          const p = new Pattern(parsed, globParts, 0, this.platform);
          const m = new Minimatch(p.globString(), this.mmopts);
          const children = globParts[globParts.length - 1] === "**";
          const absolute = p.isAbsolute();
          if (absolute)
            this.absolute.push(m);
          else
            this.relative.push(m);
          if (children) {
            if (absolute)
              this.absoluteChildren.push(m);
            else
              this.relativeChildren.push(m);
          }
        }
      }
      ignored(p) {
        const fullpath = p.fullpath();
        const fullpaths = `${fullpath}/`;
        const relative2 = p.relative() || ".";
        const relatives = `${relative2}/`;
        for (const m of this.relative) {
          if (m.match(relative2) || m.match(relatives))
            return true;
        }
        for (const m of this.absolute) {
          if (m.match(fullpath) || m.match(fullpaths))
            return true;
        }
        return false;
      }
      childrenIgnored(p) {
        const fullpath = p.fullpath() + "/";
        const relative2 = (p.relative() || ".") + "/";
        for (const m of this.relativeChildren) {
          if (m.match(relative2))
            return true;
        }
        for (const m of this.absoluteChildren) {
          if (m.match(fullpath))
            return true;
        }
        return false;
      }
    };
    HasWalkedCache = class _HasWalkedCache {
      store;
      constructor(store = /* @__PURE__ */ new Map()) {
        this.store = store;
      }
      copy() {
        return new _HasWalkedCache(new Map(this.store));
      }
      hasWalked(target, pattern2) {
        return this.store.get(target.fullpath())?.has(pattern2.globString());
      }
      storeWalked(target, pattern2) {
        const fullpath = target.fullpath();
        const cached = this.store.get(fullpath);
        if (cached)
          cached.add(pattern2.globString());
        else
          this.store.set(fullpath, /* @__PURE__ */ new Set([pattern2.globString()]));
      }
    };
    MatchRecord = class {
      store = /* @__PURE__ */ new Map();
      add(target, absolute, ifDir) {
        const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
        const current = this.store.get(target);
        this.store.set(target, current === void 0 ? n : n & current);
      }
      // match, absolute, ifdir
      entries() {
        return [...this.store.entries()].map(([path9, n]) => [
          path9,
          !!(n & 2),
          !!(n & 1)
        ]);
      }
    };
    SubWalks = class {
      store = /* @__PURE__ */ new Map();
      add(target, pattern2) {
        if (!target.canReaddir()) {
          return;
        }
        const subs = this.store.get(target);
        if (subs) {
          if (!subs.find((p) => p.globString() === pattern2.globString())) {
            subs.push(pattern2);
          }
        } else
          this.store.set(target, [pattern2]);
      }
      get(target) {
        const subs = this.store.get(target);
        if (!subs) {
          throw new Error("attempting to walk unknown path");
        }
        return subs;
      }
      entries() {
        return this.keys().map((k) => [k, this.store.get(k)]);
      }
      keys() {
        return [...this.store.keys()].filter((t) => t.canReaddir());
      }
    };
    Processor2 = class _Processor {
      hasWalkedCache;
      matches = new MatchRecord();
      subwalks = new SubWalks();
      patterns;
      follow;
      dot;
      opts;
      constructor(opts, hasWalkedCache) {
        this.opts = opts;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
      }
      processPatterns(target, patterns) {
        this.patterns = patterns;
        const processingSet = patterns.map((p) => [target, p]);
        for (let [t, pattern2] of processingSet) {
          this.hasWalkedCache.storeWalked(t, pattern2);
          const root4 = pattern2.root();
          const absolute = pattern2.isAbsolute() && this.opts.absolute !== false;
          if (root4) {
            t = t.resolve(root4 === "/" && this.opts.root !== void 0 ? this.opts.root : root4);
            const rest2 = pattern2.rest();
            if (!rest2) {
              this.matches.add(t, true, false);
              continue;
            } else {
              pattern2 = rest2;
            }
          }
          if (t.isENOENT())
            continue;
          let p;
          let rest;
          let changed = false;
          while (typeof (p = pattern2.pattern()) === "string" && (rest = pattern2.rest())) {
            const c = t.resolve(p);
            t = c;
            pattern2 = rest;
            changed = true;
          }
          p = pattern2.pattern();
          rest = pattern2.rest();
          if (changed) {
            if (this.hasWalkedCache.hasWalked(t, pattern2))
              continue;
            this.hasWalkedCache.storeWalked(t, pattern2);
          }
          if (typeof p === "string") {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
            continue;
          } else if (p === GLOBSTAR$2) {
            if (!t.isSymbolicLink() || this.follow || pattern2.checkFollowGlobstar()) {
              this.subwalks.add(t, pattern2);
            }
            const rp = rest?.pattern();
            const rrest = rest?.rest();
            if (!rest || (rp === "" || rp === ".") && !rrest) {
              this.matches.add(t, absolute, rp === "" || rp === ".");
            } else {
              if (rp === "..") {
                const tp = t.parent || t;
                if (!rrest)
                  this.matches.add(tp, absolute, true);
                else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                  this.subwalks.add(tp, rrest);
                }
              }
            }
          } else if (p instanceof RegExp) {
            this.subwalks.add(t, pattern2);
          }
        }
        return this;
      }
      subwalkTargets() {
        return this.subwalks.keys();
      }
      child() {
        return new _Processor(this.opts, this.hasWalkedCache);
      }
      // return a new Processor containing the subwalks for each
      // child entry, and a set of matches, and
      // a hasWalkedCache that's a copy of this one
      // then we're going to call
      filterEntries(parent, entries) {
        const patterns = this.subwalks.get(parent);
        const results = this.child();
        for (const e of entries) {
          for (const pattern2 of patterns) {
            const absolute = pattern2.isAbsolute();
            const p = pattern2.pattern();
            const rest = pattern2.rest();
            if (p === GLOBSTAR$2) {
              results.testGlobstar(e, pattern2, rest, absolute);
            } else if (p instanceof RegExp) {
              results.testRegExp(e, p, rest, absolute);
            } else {
              results.testString(e, p, rest, absolute);
            }
          }
        }
        return results;
      }
      testGlobstar(e, pattern2, rest, absolute) {
        if (this.dot || !e.name.startsWith(".")) {
          if (!pattern2.hasMore()) {
            this.matches.add(e, absolute, false);
          }
          if (e.canReaddir()) {
            if (this.follow || !e.isSymbolicLink()) {
              this.subwalks.add(e, pattern2);
            } else if (e.isSymbolicLink()) {
              if (rest && pattern2.checkFollowGlobstar()) {
                this.subwalks.add(e, rest);
              } else if (pattern2.markFollowGlobstar()) {
                this.subwalks.add(e, pattern2);
              }
            }
          }
        }
        if (rest) {
          const rp = rest.pattern();
          if (typeof rp === "string" && // dots and empty were handled already
          rp !== ".." && rp !== "" && rp !== ".") {
            this.testString(e, rp, rest.rest(), absolute);
          } else if (rp === "..") {
            const ep = e.parent || e;
            this.subwalks.add(ep, rest);
          } else if (rp instanceof RegExp) {
            this.testRegExp(e, rp, rest.rest(), absolute);
          }
        }
      }
      testRegExp(e, p, rest, absolute) {
        if (!p.test(e.name))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
      testString(e, p, rest, absolute) {
        if (!e.isNamed(p))
          return;
        if (!rest) {
          this.matches.add(e, absolute, false);
        } else {
          this.subwalks.add(e, rest);
        }
      }
    };
    makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
    GlobUtil = class {
      path;
      patterns;
      opts;
      seen = /* @__PURE__ */ new Set();
      paused = false;
      aborted = false;
      #onResume = [];
      #ignore;
      #sep;
      signal;
      maxDepth;
      includeChildMatches;
      constructor(patterns, path9, opts) {
        this.patterns = patterns;
        this.path = path9;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
        this.includeChildMatches = opts.includeChildMatches !== false;
        if (opts.ignore || !this.includeChildMatches) {
          this.#ignore = makeIgnore(opts.ignore ?? [], opts);
          if (!this.includeChildMatches && typeof this.#ignore.add !== "function") {
            const m = "cannot ignore child matches, ignore lacks add() method.";
            throw new Error(m);
          }
        }
        this.maxDepth = opts.maxDepth || Infinity;
        if (opts.signal) {
          this.signal = opts.signal;
          this.signal.addEventListener("abort", () => {
            this.#onResume.length = 0;
          });
        }
      }
      #ignored(path9) {
        return this.seen.has(path9) || !!this.#ignore?.ignored?.(path9);
      }
      #childrenIgnored(path9) {
        return !!this.#ignore?.childrenIgnored?.(path9);
      }
      // backpressure mechanism
      pause() {
        this.paused = true;
      }
      resume() {
        if (this.signal?.aborted)
          return;
        this.paused = false;
        let fn = void 0;
        while (!this.paused && (fn = this.#onResume.shift())) {
          fn();
        }
      }
      onResume(fn) {
        if (this.signal?.aborted)
          return;
        if (!this.paused) {
          fn();
        } else {
          this.#onResume.push(fn);
        }
      }
      // do the requisite realpath/stat checking, and return the path
      // to add or undefined to filter it out.
      async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || await e.realpath();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = await s.realpath();
          if (target && (target.isUnknown() || this.opts.stat)) {
            await target.lstat();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchCheckTest(e, ifDir) {
        return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : void 0;
      }
      matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
          return void 0;
        let rpc;
        if (this.opts.realpath) {
          rpc = e.realpathCached() || e.realpathSync();
          if (!rpc)
            return void 0;
          e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
          const target = s.realpathSync();
          if (target && (target?.isUnknown() || this.opts.stat)) {
            target.lstatSync();
          }
        }
        return this.matchCheckTest(s, ifDir);
      }
      matchFinish(e, absolute) {
        if (this.#ignored(e))
          return;
        if (!this.includeChildMatches && this.#ignore?.add) {
          const ign = `${e.relativePosix()}/**`;
          this.#ignore.add(ign);
        }
        const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
        if (this.opts.withFileTypes) {
          this.matchEmit(e);
        } else if (abs) {
          const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
          this.matchEmit(abs2 + mark);
        } else {
          const rel = this.opts.posix ? e.relativePosix() : e.relative();
          const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
          this.matchEmit(!rel ? "." + mark : pre + rel + mark);
        }
      }
      async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
          this.matchFinish(p, absolute);
      }
      walkCB(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2(target, patterns, new Processor2(this.opts), cb);
      }
      walkCB2(target, patterns, processor2, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2(target, patterns, processor2, cb));
          return;
        }
        processor2.processPatterns(target, patterns);
        let tasks2 = 1;
        const next = () => {
          if (--tasks2 === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor2.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks2++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor2.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks2++;
          const childrenCached = t.readdirCached();
          if (t.calledReaddir())
            this.walkCB3(t, childrenCached, processor2, next);
          else {
            t.readdirCB((_, entries) => this.walkCB3(t, entries, processor2, next), true);
          }
        }
        next();
      }
      walkCB3(target, entries, processor2, cb) {
        processor2 = processor2.filterEntries(target, entries);
        let tasks2 = 1;
        const next = () => {
          if (--tasks2 === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor2.matches.entries()) {
          if (this.#ignored(m))
            continue;
          tasks2++;
          this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target2, patterns] of processor2.subwalks.entries()) {
          tasks2++;
          this.walkCB2(target2, patterns, processor2.child(), next);
        }
        next();
      }
      walkCBSync(target, patterns, cb) {
        if (this.signal?.aborted)
          cb();
        this.walkCB2Sync(target, patterns, new Processor2(this.opts), cb);
      }
      walkCB2Sync(target, patterns, processor2, cb) {
        if (this.#childrenIgnored(target))
          return cb();
        if (this.signal?.aborted)
          cb();
        if (this.paused) {
          this.onResume(() => this.walkCB2Sync(target, patterns, processor2, cb));
          return;
        }
        processor2.processPatterns(target, patterns);
        let tasks2 = 1;
        const next = () => {
          if (--tasks2 === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor2.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const t of processor2.subwalkTargets()) {
          if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
            continue;
          }
          tasks2++;
          const children = t.readdirSync();
          this.walkCB3Sync(t, children, processor2, next);
        }
        next();
      }
      walkCB3Sync(target, entries, processor2, cb) {
        processor2 = processor2.filterEntries(target, entries);
        let tasks2 = 1;
        const next = () => {
          if (--tasks2 === 0)
            cb();
        };
        for (const [m, absolute, ifDir] of processor2.matches.entries()) {
          if (this.#ignored(m))
            continue;
          this.matchSync(m, absolute, ifDir);
        }
        for (const [target2, patterns] of processor2.subwalks.entries()) {
          tasks2++;
          this.walkCB2Sync(target2, patterns, processor2.child(), next);
        }
        next();
      }
    };
    GlobWalker = class extends GlobUtil {
      matches = /* @__PURE__ */ new Set();
      constructor(patterns, path9, opts) {
        super(patterns, path9, opts);
      }
      matchEmit(e) {
        this.matches.add(e);
      }
      async walk() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          await this.path.lstat();
        }
        await new Promise((res, rej) => {
          this.walkCB(this.path, this.patterns, () => {
            if (this.signal?.aborted) {
              rej(this.signal.reason);
            } else {
              res(this.matches);
            }
          });
        });
        return this.matches;
      }
      walkSync() {
        if (this.signal?.aborted)
          throw this.signal.reason;
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => {
          if (this.signal?.aborted)
            throw this.signal.reason;
        });
        return this.matches;
      }
    };
    GlobStream = class extends GlobUtil {
      results;
      constructor(patterns, path9, opts) {
        super(patterns, path9, opts);
        this.results = new Minipass({
          signal: this.signal,
          objectMode: true
        });
        this.results.on("drain", () => this.resume());
        this.results.on("resume", () => this.resume());
      }
      matchEmit(e) {
        this.results.write(e);
        if (!this.results.flowing)
          this.pause();
      }
      stream() {
        const target = this.path;
        if (target.isUnknown()) {
          target.lstat().then(() => {
            this.walkCB(target, this.patterns, () => this.results.end());
          });
        } else {
          this.walkCB(target, this.patterns, () => this.results.end());
        }
        return this.results;
      }
      streamSync() {
        if (this.path.isUnknown()) {
          this.path.lstatSync();
        }
        this.walkCBSync(this.path, this.patterns, () => this.results.end());
        return this.results;
      }
    };
    defaultPlatform = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
    Glob = class {
      absolute;
      cwd;
      root;
      dot;
      dotRelative;
      follow;
      ignore;
      magicalBraces;
      mark;
      matchBase;
      maxDepth;
      nobrace;
      nocase;
      nodir;
      noext;
      noglobstar;
      pattern;
      platform;
      realpath;
      scurry;
      stat;
      signal;
      windowsPathsNoEscape;
      withFileTypes;
      includeChildMatches;
      /**
       * The options provided to the constructor.
       */
      opts;
      /**
       * An array of parsed immutable {@link Pattern} objects.
       */
      patterns;
      /**
       * All options are stored as properties on the `Glob` object.
       *
       * See {@link GlobOptions} for full options descriptions.
       *
       * Note that a previous `Glob` object can be passed as the
       * `GlobOptions` to another `Glob` instantiation to re-use settings
       * and caches with a new pattern.
       *
       * Traversal functions can be called multiple times to run the walk
       * again.
       */
      constructor(pattern2, opts) {
        if (!opts)
          throw new TypeError("glob options required");
        this.withFileTypes = !!opts.withFileTypes;
        this.signal = opts.signal;
        this.follow = !!opts.follow;
        this.dot = !!opts.dot;
        this.dotRelative = !!opts.dotRelative;
        this.nodir = !!opts.nodir;
        this.mark = !!opts.mark;
        if (!opts.cwd) {
          this.cwd = "";
        } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
          opts.cwd = fileURLToPath2(opts.cwd);
        }
        this.cwd = opts.cwd || "";
        this.root = opts.root;
        this.magicalBraces = !!opts.magicalBraces;
        this.nobrace = !!opts.nobrace;
        this.noext = !!opts.noext;
        this.realpath = !!opts.realpath;
        this.absolute = opts.absolute;
        this.includeChildMatches = opts.includeChildMatches !== false;
        this.noglobstar = !!opts.noglobstar;
        this.matchBase = !!opts.matchBase;
        this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
        this.stat = !!opts.stat;
        this.ignore = opts.ignore;
        if (this.withFileTypes && this.absolute !== void 0) {
          throw new Error("cannot set absolute and withFileTypes:true");
        }
        if (typeof pattern2 === "string") {
          pattern2 = [pattern2];
        }
        this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          pattern2 = pattern2.map((p) => p.replace(/\\/g, "/"));
        }
        if (this.matchBase) {
          if (opts.noglobstar) {
            throw new TypeError("base matching requires globstar");
          }
          pattern2 = pattern2.map((p) => p.includes("/") ? p : `./**/${p}`);
        }
        this.pattern = pattern2;
        this.platform = opts.platform || defaultPlatform;
        this.opts = { ...opts, platform: this.platform };
        if (opts.scurry) {
          this.scurry = opts.scurry;
          if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
            throw new Error("nocase option contradicts provided scurry option");
          }
        } else {
          const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
          this.scurry = new Scurry(this.cwd, {
            nocase: opts.nocase,
            fs: opts.fs
          });
        }
        this.nocase = this.scurry.nocase;
        const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
        const mmo = {
          // default nocase based on platform
          ...opts,
          dot: this.dot,
          matchBase: this.matchBase,
          nobrace: this.nobrace,
          nocase: this.nocase,
          nocaseMagicOnly,
          nocomment: true,
          noext: this.noext,
          nonegate: true,
          optimizationLevel: 2,
          platform: this.platform,
          windowsPathsNoEscape: this.windowsPathsNoEscape,
          debug: !!this.opts.debug
        };
        const mms = this.pattern.map((p) => new Minimatch(p, mmo));
        const [matchSet, globParts] = mms.reduce((set2, m) => {
          set2[0].push(...m.set);
          set2[1].push(...m.globParts);
          return set2;
        }, [[], []]);
        this.patterns = matchSet.map((set2, i) => {
          const g = globParts[i];
          if (!g)
            throw new Error("invalid pattern object");
          return new Pattern(set2, g, 0, this.platform);
        });
      }
      async walk() {
        return [
          ...await new GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walk()
        ];
      }
      walkSync() {
        return [
          ...new GlobWalker(this.patterns, this.scurry.cwd, {
            ...this.opts,
            maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
            platform: this.platform,
            nocase: this.nocase,
            includeChildMatches: this.includeChildMatches
          }).walkSync()
        ];
      }
      stream() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).stream();
      }
      streamSync() {
        return new GlobStream(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase,
          includeChildMatches: this.includeChildMatches
        }).streamSync();
      }
      /**
       * Default sync iteration function. Returns a Generator that
       * iterates over the results.
       */
      iterateSync() {
        return this.streamSync()[Symbol.iterator]();
      }
      [Symbol.iterator]() {
        return this.iterateSync();
      }
      /**
       * Default async iteration function. Returns an AsyncGenerator that
       * iterates over the results.
       */
      iterate() {
        return this.stream()[Symbol.asyncIterator]();
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
    };
    hasMagic = (pattern2, options2 = {}) => {
      if (!Array.isArray(pattern2)) {
        pattern2 = [pattern2];
      }
      for (const p of pattern2) {
        if (new Minimatch(p, options2).hasMagic())
          return true;
      }
      return false;
    };
    streamSync = globStreamSync;
    stream$5 = Object.assign(globStream, { sync: globStreamSync });
    iterateSync = globIterateSync;
    iterate = Object.assign(globIterate, {
      sync: globIterateSync
    });
    sync$9 = Object.assign(globSync, {
      stream: globStreamSync,
      iterate: globIterateSync
    });
    glob$1 = Object.assign(glob_, {
      glob: glob_,
      globSync,
      sync: sync$9,
      globStream,
      stream: stream$5,
      globStreamSync,
      streamSync,
      globIterate,
      iterate,
      globIterateSync,
      iterateSync,
      Glob,
      hasMagic,
      escape: escape$2,
      unescape: unescape$1
    });
    glob$1.glob = glob$1;
    comma3 = ",".charCodeAt(0);
    semicolon2 = ";".charCodeAt(0);
    chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    intToChar = new Uint8Array(64);
    charToInt = new Uint8Array(128);
    for (let i = 0; i < chars$1.length; i++) {
      const c = chars$1.charCodeAt(i);
      intToChar[i] = c;
      charToInt[c] = i;
    }
    bufLength = 1024 * 16;
    src$32 = { exports: {} };
    browser$3 = { exports: {} };
    node$12 = { exports: {} };
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      src$32.exports = requireBrowser$1();
    } else {
      src$32.exports = requireNode$1();
    }
    srcExports$12 = src$32.exports;
    debug$i = /* @__PURE__ */ getDefaultExportFromCjs(srcExports$12);
    if (process.versions.pnp) {
      try {
        pnp = createRequire$1(import.meta.url)("pnpapi");
      } catch {
      }
    }
    createFilter2 = createFilter$1;
    nodeBuiltins = builtinModules.filter((id3) => !id3.includes(":"));
    _require$1 = createRequire$1(import.meta.url);
    rollupVersion = resolveDependencyVersion("rollup");
    filter = process.env.VITE_DEBUG_FILTER;
    DEBUG = process.env.DEBUG;
    urlCanParse = // eslint-disable-next-line n/no-unsupported-features/node-builtins
    URL$3.canParse ?? // URL.canParse is supported from Node.js 18.17.0+, 20.0.0+
    ((path22, base) => {
      try {
        new URL$3(path22, base);
        return true;
      } catch {
        return false;
      }
    });
    isCaseInsensitiveFS = testCaseInsensitiveFS();
    externalRE = /^(https?:)?\/\//;
    isExternalUrl = (url2) => externalRE.test(url2);
    dataUrlRE = /^\s*data:/i;
    isDataUrl = (url2) => dataUrlRE.test(url2);
    internalPrefixes = [
      FS_PREFIX,
      VALID_ID_PREFIX,
      CLIENT_PUBLIC_PATH,
      ENV_PUBLIC_PATH
    ];
    InternalPrefixRE = new RegExp(`^(?:${internalPrefixes.join("|")})`);
    safeRealpathSync = isWindows$3 ? windowsSafeRealPathSync : fs__default.realpathSync.native;
    windowsNetworkMap = /* @__PURE__ */ new Map();
    parseNetUseRE = /^\w* +(\w:) +([^ ]+)\s/;
    firstSafeRealPathSyncRun = false;
    escapedSpaceCharacters = /(?: |\\t|\\n|\\f|\\r)+/g;
    imageSetUrlRE = /^(?:[\w\-]+\(.*?\)|'.*?'|".*?"|\S*)/;
    cleanSrcSetRE = /(?:url|image|gradient|cross-fade)\([^)]*\)|"([^"]|(?<=\\)")*"|'([^']|(?<=\\)')*'|data:\w+\/[\w.+\-]+;base64,[\w+/=]+|\?\S+,/g;
    blankReplacer = (match2) => " ".repeat(match2.length);
    _dirname = path$n.dirname(fileURLToPath2(import.meta.url));
    LogLevels = {
      silent: 0,
      error: 1,
      warn: 2,
      info: 3
    };
    sameCount = 0;
    groups = [
      { name: "Assets", color: colors$1.green },
      { name: "CSS", color: colors$1.magenta },
      { name: "JS", color: colors$1.cyan }
    ];
    POSIX_SEP_RE = new RegExp("\\" + path$n.posix.sep, "g");
    NATIVE_SEP_RE = new RegExp("\\" + path$n.sep, "g");
    TS_EXTENSIONS = [".ts", ".tsx", ".mts", ".cts"];
    JS_EXTENSIONS = [".js", ".jsx", ".mjs", ".cjs"];
    TSJS_EXTENSIONS = TS_EXTENSIONS.concat(JS_EXTENSIONS);
    TS_EXTENSIONS_RE_GROUP = `\\.(?:${TS_EXTENSIONS.map((ext2) => ext2.substring(1)).join("|")})`;
    TSJS_EXTENSIONS_RE_GROUP = `\\.(?:${TSJS_EXTENSIONS.map((ext2) => ext2.substring(1)).join(
      "|"
    )})`;
    IS_POSIX = path$n.posix.sep === path$n.sep;
    singleComment = Symbol("singleComment");
    multiComment = Symbol("multiComment");
    debug$h = createDebugger("vite:esbuild");
    GIT_LFS_PREFIX = Buffer$1.from("version https://git-lfs.github.com");
    !function(A2) {
      A2[A2.Static = 1] = "Static", A2[A2.Dynamic = 2] = "Dynamic", A2[A2.ImportMeta = 3] = "ImportMeta", A2[A2.StaticSourcePhase = 4] = "StaticSourcePhase", A2[A2.DynamicSourcePhase = 5] = "DynamicSourcePhase";
    }(ImportType || (ImportType = {}));
    A = 1 === new Uint8Array(new Uint16Array([1]).buffer)[0];
    init = WebAssembly.compile((E = "AGFzbQEAAAABKwhgAX8Bf2AEf39/fwBgAAF/YAAAYAF/AGADf39/AX9gAn9/AX9gA39/fwADMTAAAQECAgICAgICAgICAgICAgICAgIAAwMDBAQAAAUAAAAAAAMDAwAGAAAABwAGAgUEBQFwAQEBBQMBAAEGDwJ/AUHA8gALfwBBwPIACwd6FQZtZW1vcnkCAAJzYQAAAWUAAwJpcwAEAmllAAUCc3MABgJzZQAHAml0AAgCYWkACQJpZAAKAmlwAAsCZXMADAJlZQANA2VscwAOA2VsZQAPAnJpABACcmUAEQFmABICbXMAEwVwYXJzZQAUC19faGVhcF9iYXNlAwEKm0EwaAEBf0EAIAA2AoAKQQAoAtwJIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgKECkEAIAA2AogKQQBBADYC4AlBAEEANgLwCUEAQQA2AugJQQBBADYC5AlBAEEANgL4CUEAQQA2AuwJIAEL0wEBA39BACgC8AkhBEEAQQAoAogKIgU2AvAJQQAgBDYC9AlBACAFQSRqNgKICiAEQSBqQeAJIAQbIAU2AgBBACgC1AkhBEEAKALQCSEGIAUgATYCACAFIAA2AgggBSACIAJBAmpBACAGIANGIgAbIAQgA0YiBBs2AgwgBSADNgIUIAVBADYCECAFIAI2AgQgBUEANgIgIAVBA0EBQQIgABsgBBs2AhwgBUEAKALQCSADRiICOgAYAkACQCACDQBBACgC1AkgA0cNAQtBAEEBOgCMCgsLXgEBf0EAKAL4CSIEQRBqQeQJIAQbQQAoAogKIgQ2AgBBACAENgL4CUEAIARBFGo2AogKQQBBAToAjAogBEEANgIQIAQgAzYCDCAEIAI2AgggBCABNgIEIAQgADYCAAsIAEEAKAKQCgsVAEEAKALoCSgCAEEAKALcCWtBAXULHgEBf0EAKALoCSgCBCIAQQAoAtwJa0EBdUF/IAAbCxUAQQAoAugJKAIIQQAoAtwJa0EBdQseAQF/QQAoAugJKAIMIgBBACgC3AlrQQF1QX8gABsLCwBBACgC6AkoAhwLHgEBf0EAKALoCSgCECIAQQAoAtwJa0EBdUF/IAAbCzsBAX8CQEEAKALoCSgCFCIAQQAoAtAJRw0AQX8PCwJAIABBACgC1AlHDQBBfg8LIABBACgC3AlrQQF1CwsAQQAoAugJLQAYCxUAQQAoAuwJKAIAQQAoAtwJa0EBdQsVAEEAKALsCSgCBEEAKALcCWtBAXULHgEBf0EAKALsCSgCCCIAQQAoAtwJa0EBdUF/IAAbCx4BAX9BACgC7AkoAgwiAEEAKALcCWtBAXVBfyAAGwslAQF/QQBBACgC6AkiAEEgakHgCSAAGygCACIANgLoCSAAQQBHCyUBAX9BAEEAKALsCSIAQRBqQeQJIAAbKAIAIgA2AuwJIABBAEcLCABBAC0AlAoLCABBAC0AjAoL3Q0BBX8jAEGA0ABrIgAkAEEAQQE6AJQKQQBBACgC2Ak2ApwKQQBBACgC3AlBfmoiATYCsApBACABQQAoAoAKQQF0aiICNgK0CkEAQQA6AIwKQQBBADsBlgpBAEEAOwGYCkEAQQA6AKAKQQBBADYCkApBAEEAOgD8CUEAIABBgBBqNgKkCkEAIAA2AqgKQQBBADoArAoCQAJAAkACQANAQQAgAUECaiIDNgKwCiABIAJPDQECQCADLwEAIgJBd2pBBUkNAAJAAkACQAJAAkAgAkGbf2oOBQEICAgCAAsgAkEgRg0EIAJBL0YNAyACQTtGDQIMBwtBAC8BmAoNASADEBVFDQEgAUEEakGCCEEKEC8NARAWQQAtAJQKDQFBAEEAKAKwCiIBNgKcCgwHCyADEBVFDQAgAUEEakGMCEEKEC8NABAXC0EAQQAoArAKNgKcCgwBCwJAIAEvAQQiA0EqRg0AIANBL0cNBBAYDAELQQEQGQtBACgCtAohAkEAKAKwCiEBDAALC0EAIQIgAyEBQQAtAPwJDQIMAQtBACABNgKwCkEAQQA6AJQKCwNAQQAgAUECaiIDNgKwCgJAAkACQAJAAkACQAJAIAFBACgCtApPDQAgAy8BACICQXdqQQVJDQYCQAJAAkACQAJAAkACQAJAAkACQCACQWBqDgoQDwYPDw8PBQECAAsCQAJAAkACQCACQaB/ag4KCxISAxIBEhISAgALIAJBhX9qDgMFEQYJC0EALwGYCg0QIAMQFUUNECABQQRqQYIIQQoQLw0QEBYMEAsgAxAVRQ0PIAFBBGpBjAhBChAvDQ8QFwwPCyADEBVFDQ4gASkABELsgISDsI7AOVINDiABLwEMIgNBd2oiAUEXSw0MQQEgAXRBn4CABHFFDQwMDQtBAEEALwGYCiIBQQFqOwGYCkEAKAKkCiABQQN0aiIBQQE2AgAgAUEAKAKcCjYCBAwNC0EALwGYCiIDRQ0JQQAgA0F/aiIDOwGYCkEALwGWCiICRQ0MQQAoAqQKIANB//8DcUEDdGooAgBBBUcNDAJAIAJBAnRBACgCqApqQXxqKAIAIgMoAgQNACADQQAoApwKQQJqNgIEC0EAIAJBf2o7AZYKIAMgAUEEajYCDAwMCwJAQQAoApwKIgEvAQBBKUcNAEEAKALwCSIDRQ0AIAMoAgQgAUcNAEEAQQAoAvQJIgM2AvAJAkAgA0UNACADQQA2AiAMAQtBAEEANgLgCQtBAEEALwGYCiIDQQFqOwGYCkEAKAKkCiADQQN0aiIDQQZBAkEALQCsChs2AgAgAyABNgIEQQBBADoArAoMCwtBAC8BmAoiAUUNB0EAIAFBf2oiATsBmApBACgCpAogAUH//wNxQQN0aigCAEEERg0EDAoLQScQGgwJC0EiEBoMCAsgAkEvRw0HAkACQCABLwEEIgFBKkYNACABQS9HDQEQGAwKC0EBEBkMCQsCQAJAAkACQEEAKAKcCiIBLwEAIgMQG0UNAAJAAkAgA0FVag4EAAkBAwkLIAFBfmovAQBBK0YNAwwICyABQX5qLwEAQS1GDQIMBwsgA0EpRw0BQQAoAqQKQQAvAZgKIgJBA3RqKAIEEBxFDQIMBgsgAUF+ai8BAEFQakH//wNxQQpPDQULQQAvAZgKIQILAkACQCACQf//A3EiAkUNACADQeYARw0AQQAoAqQKIAJBf2pBA3RqIgQoAgBBAUcNACABQX5qLwEAQe8ARw0BIAQoAgRBlghBAxAdRQ0BDAULIANB/QBHDQBBACgCpAogAkEDdGoiAigCBBAeDQQgAigCAEEGRg0ECyABEB8NAyADRQ0DIANBL0ZBAC0AoApBAEdxDQMCQEEAKAL4CSICRQ0AIAEgAigCAEkNACABIAIoAgRNDQQLIAFBfmohAUEAKALcCSECAkADQCABQQJqIgQgAk0NAUEAIAE2ApwKIAEvAQAhAyABQX5qIgQhASADECBFDQALIARBAmohBAsCQCADQf//A3EQIUUNACAEQX5qIQECQANAIAFBAmoiAyACTQ0BQQAgATYCnAogAS8BACEDIAFBfmoiBCEBIAMQIQ0ACyAEQQJqIQMLIAMQIg0EC0EAQQE6AKAKDAcLQQAoAqQKQQAvAZgKIgFBA3QiA2pBACgCnAo2AgRBACABQQFqOwGYCkEAKAKkCiADakEDNgIACxAjDAULQQAtAPwJQQAvAZYKQQAvAZgKcnJFIQIMBwsQJEEAQQA6AKAKDAMLECVBACECDAULIANBoAFHDQELQQBBAToArAoLQQBBACgCsAo2ApwKC0EAKAKwCiEBDAALCyAAQYDQAGokACACCxoAAkBBACgC3AkgAEcNAEEBDwsgAEF+ahAmC/4KAQZ/QQBBACgCsAoiAEEMaiIBNgKwCkEAKAL4CSECQQEQKSEDAkACQAJAAkACQAJAAkACQAJAQQAoArAKIgQgAUcNACADEChFDQELAkACQAJAAkACQAJAAkAgA0EqRg0AIANB+wBHDQFBACAEQQJqNgKwCkEBECkhA0EAKAKwCiEEA0ACQAJAIANB//8DcSIDQSJGDQAgA0EnRg0AIAMQLBpBACgCsAohAwwBCyADEBpBAEEAKAKwCkECaiIDNgKwCgtBARApGgJAIAQgAxAtIgNBLEcNAEEAQQAoArAKQQJqNgKwCkEBECkhAwsgA0H9AEYNA0EAKAKwCiIFIARGDQ8gBSEEIAVBACgCtApNDQAMDwsLQQAgBEECajYCsApBARApGkEAKAKwCiIDIAMQLRoMAgtBAEEAOgCUCgJAAkACQAJAAkACQCADQZ9/ag4MAgsEAQsDCwsLCwsFAAsgA0H2AEYNBAwKC0EAIARBDmoiAzYCsAoCQAJAAkBBARApQZ9/ag4GABICEhIBEgtBACgCsAoiBSkAAkLzgOSD4I3AMVINESAFLwEKECFFDRFBACAFQQpqNgKwCkEAECkaC0EAKAKwCiIFQQJqQbIIQQ4QLw0QIAUvARAiAkF3aiIBQRdLDQ1BASABdEGfgIAEcUUNDQwOC0EAKAKwCiIFKQACQuyAhIOwjsA5Ug0PIAUvAQoiAkF3aiIBQRdNDQYMCgtBACAEQQpqNgKwCkEAECkaQQAoArAKIQQLQQAgBEEQajYCsAoCQEEBECkiBEEqRw0AQQBBACgCsApBAmo2ArAKQQEQKSEEC0EAKAKwCiEDIAQQLBogA0EAKAKwCiIEIAMgBBACQQBBACgCsApBfmo2ArAKDwsCQCAEKQACQuyAhIOwjsA5Ug0AIAQvAQoQIEUNAEEAIARBCmo2ArAKQQEQKSEEQQAoArAKIQMgBBAsGiADQQAoArAKIgQgAyAEEAJBAEEAKAKwCkF+ajYCsAoPC0EAIARBBGoiBDYCsAoLQQAgBEEGajYCsApBAEEAOgCUCkEBECkhBEEAKAKwCiEDIAQQLCEEQQAoArAKIQIgBEHf/wNxIgFB2wBHDQNBACACQQJqNgKwCkEBECkhBUEAKAKwCiEDQQAhBAwEC0EAQQE6AIwKQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0AQQAgA0EIajYCsAogAEEBEClBABArIAJBEGpB5AkgAhshAwNAIAMoAgAiA0UNBSADQgA3AgggA0EQaiEDDAALC0EAIANBfmo2ArAKDAMLQQEgAXRBn4CABHFFDQMMBAtBASEECwNAAkACQCAEDgIAAQELIAVB//8DcRAsGkEBIQQMAQsCQAJAQQAoArAKIgQgA0YNACADIAQgAyAEEAJBARApIQQCQCABQdsARw0AIARBIHJB/QBGDQQLQQAoArAKIQMCQCAEQSxHDQBBACADQQJqNgKwCkEBECkhBUEAKAKwCiEDIAVBIHJB+wBHDQILQQAgA0F+ajYCsAoLIAFB2wBHDQJBACACQX5qNgKwCg8LQQAhBAwACwsPCyACQaABRg0AIAJB+wBHDQQLQQAgBUEKajYCsApBARApIgVB+wBGDQMMAgsCQCACQVhqDgMBAwEACyACQaABRw0CC0EAIAVBEGo2ArAKAkBBARApIgVBKkcNAEEAQQAoArAKQQJqNgKwCkEBECkhBQsgBUEoRg0BC0EAKAKwCiEBIAUQLBpBACgCsAoiBSABTQ0AIAQgAyABIAUQAkEAQQAoArAKQX5qNgKwCg8LIAQgA0EAQQAQAkEAIARBDGo2ArAKDwsQJQvcCAEGf0EAIQBBAEEAKAKwCiIBQQxqIgI2ArAKQQEQKSEDQQAoArAKIQQCQAJAAkACQAJAAkACQAJAIANBLkcNAEEAIARBAmo2ArAKAkBBARApIgNB8wBGDQAgA0HtAEcNB0EAKAKwCiIDQQJqQZwIQQYQLw0HAkBBACgCnAoiBBAqDQAgBC8BAEEuRg0ICyABIAEgA0EIakEAKALUCRABDwtBACgCsAoiA0ECakGiCEEKEC8NBgJAQQAoApwKIgQQKg0AIAQvAQBBLkYNBwsgA0EMaiEDDAELIANB8wBHDQEgBCACTQ0BQQYhAEEAIQIgBEECakGiCEEKEC8NAiAEQQxqIQMCQCAELwEMIgVBd2oiBEEXSw0AQQEgBHRBn4CABHENAQsgBUGgAUcNAgtBACADNgKwCkEBIQBBARApIQMLAkACQAJAAkAgA0H7AEYNACADQShHDQFBACgCpApBAC8BmAoiA0EDdGoiBEEAKAKwCjYCBEEAIANBAWo7AZgKIARBBTYCAEEAKAKcCi8BAEEuRg0HQQBBACgCsAoiBEECajYCsApBARApIQMgAUEAKAKwCkEAIAQQAQJAAkAgAA0AQQAoAvAJIQQMAQtBACgC8AkiBEEFNgIcC0EAQQAvAZYKIgBBAWo7AZYKQQAoAqgKIABBAnRqIAQ2AgACQCADQSJGDQAgA0EnRg0AQQBBACgCsApBfmo2ArAKDwsgAxAaQQBBACgCsApBAmoiAzYCsAoCQAJAAkBBARApQVdqDgQBAgIAAgtBAEEAKAKwCkECajYCsApBARApGkEAKALwCSIEIAM2AgQgBEEBOgAYIARBACgCsAoiAzYCEEEAIANBfmo2ArAKDwtBACgC8AkiBCADNgIEIARBAToAGEEAQQAvAZgKQX9qOwGYCiAEQQAoArAKQQJqNgIMQQBBAC8BlgpBf2o7AZYKDwtBAEEAKAKwCkF+ajYCsAoPCyAADQJBACgCsAohA0EALwGYCg0BA0ACQAJAAkAgA0EAKAK0Ck8NAEEBECkiA0EiRg0BIANBJ0YNASADQf0ARw0CQQBBACgCsApBAmo2ArAKC0EBECkhBEEAKAKwCiEDAkAgBEHmAEcNACADQQJqQawIQQYQLw0JC0EAIANBCGo2ArAKAkBBARApIgNBIkYNACADQSdHDQkLIAEgA0EAECsPCyADEBoLQQBBACgCsApBAmoiAzYCsAoMAAsLIAANAUEGIQBBACECAkAgA0FZag4EBAMDBAALIANBIkYNAwwCC0EAIANBfmo2ArAKDwtBDCEAQQEhAgtBACgCsAoiAyABIABBAXRqRw0AQQAgA0F+ajYCsAoPC0EALwGYCg0CQQAoArAKIQNBACgCtAohAANAIAMgAE8NAQJAAkAgAy8BACIEQSdGDQAgBEEiRw0BCyABIAQgAhArDwtBACADQQJqIgM2ArAKDAALCxAlCw8LQQBBACgCsApBfmo2ArAKC0cBA39BACgCsApBAmohAEEAKAK0CiEBAkADQCAAIgJBfmogAU8NASACQQJqIQAgAi8BAEF2ag4EAQAAAQALC0EAIAI2ArAKC5gBAQN/QQBBACgCsAoiAUECajYCsAogAUEGaiEBQQAoArQKIQIDQAJAAkACQCABQXxqIAJPDQAgAUF+ai8BACEDAkACQCAADQAgA0EqRg0BIANBdmoOBAIEBAIECyADQSpHDQMLIAEvAQBBL0cNAkEAIAFBfmo2ArAKDAELIAFBfmohAQtBACABNgKwCg8LIAFBAmohAQwACwuIAQEEf0EAKAKwCiEBQQAoArQKIQICQAJAA0AgASIDQQJqIQEgAyACTw0BIAEvAQAiBCAARg0CAkAgBEHcAEYNACAEQXZqDgQCAQECAQsgA0EEaiEBIAMvAQRBDUcNACADQQZqIAEgAy8BBkEKRhshAQwACwtBACABNgKwChAlDwtBACABNgKwCgtsAQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBKUcgAEFYakH//wNxQQdJcQ0AAkAgAEGlf2oOBAEAAAEACyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELLgEBf0EBIQECQCAAQaYJQQUQHQ0AIABBlghBAxAdDQAgAEGwCUECEB0hAQsgAQtGAQN/QQAhAwJAIAAgAkEBdCICayIEQQJqIgBBACgC3AkiBUkNACAAIAEgAhAvDQACQCAAIAVHDQBBAQ8LIAQQJiEDCyADC4MBAQJ/QQEhAQJAAkACQAJAAkACQCAALwEAIgJBRWoOBAUEBAEACwJAIAJBm39qDgQDBAQCAAsgAkEpRg0EIAJB+QBHDQMgAEF+akG8CUEGEB0PCyAAQX5qLwEAQT1GDwsgAEF+akG0CUEEEB0PCyAAQX5qQcgJQQMQHQ8LQQAhAQsgAQu0AwECf0EAIQECQAJAAkACQAJAAkACQAJAAkACQCAALwEAQZx/ag4UAAECCQkJCQMJCQQFCQkGCQcJCQgJCwJAAkAgAEF+ai8BAEGXf2oOBAAKCgEKCyAAQXxqQcoIQQIQHQ8LIABBfGpBzghBAxAdDwsCQAJAAkAgAEF+ai8BAEGNf2oOAwABAgoLAkAgAEF8ai8BACICQeEARg0AIAJB7ABHDQogAEF6akHlABAnDwsgAEF6akHjABAnDwsgAEF8akHUCEEEEB0PCyAAQXxqQdwIQQYQHQ8LIABBfmovAQBB7wBHDQYgAEF8ai8BAEHlAEcNBgJAIABBemovAQAiAkHwAEYNACACQeMARw0HIABBeGpB6AhBBhAdDwsgAEF4akH0CEECEB0PCyAAQX5qQfgIQQQQHQ8LQQEhASAAQX5qIgBB6QAQJw0EIABBgAlBBRAdDwsgAEF+akHkABAnDwsgAEF+akGKCUEHEB0PCyAAQX5qQZgJQQQQHQ8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABAnDwsgAEF8akGgCUEDEB0hAQsgAQs0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABAocSEBCyABCzABAX8CQAJAIABBd2oiAUEXSw0AQQEgAXRBjYCABHENAQsgAEGgAUYNAEEADwtBAQtOAQJ/QQAhAQJAAkAgAC8BACICQeUARg0AIAJB6wBHDQEgAEF+akH4CEEEEB0PCyAAQX5qLwEAQfUARw0AIABBfGpB3AhBBhAdIQELIAEL3gEBBH9BACgCsAohAEEAKAK0CiEBAkACQAJAA0AgACICQQJqIQAgAiABTw0BAkACQAJAIAAvAQAiA0Gkf2oOBQIDAwMBAAsgA0EkRw0CIAIvAQRB+wBHDQJBACACQQRqIgA2ArAKQQBBAC8BmAoiAkEBajsBmApBACgCpAogAkEDdGoiAkEENgIAIAIgADYCBA8LQQAgADYCsApBAEEALwGYCkF/aiIAOwGYCkEAKAKkCiAAQf//A3FBA3RqKAIAQQNHDQMMBAsgAkEEaiEADAALC0EAIAA2ArAKCxAlCwtwAQJ/AkACQANAQQBBACgCsAoiAEECaiIBNgKwCiAAQQAoArQKTw0BAkACQAJAIAEvAQAiAUGlf2oOAgECAAsCQCABQXZqDgQEAwMEAAsgAUEvRw0CDAQLEC4aDAELQQAgAEEEajYCsAoMAAsLECULCzUBAX9BAEEBOgD8CUEAKAKwCiEAQQBBACgCtApBAmo2ArAKQQAgAEEAKALcCWtBAXU2ApAKC0MBAn9BASEBAkAgAC8BACICQXdqQf//A3FBBUkNACACQYABckGgAUYNAEEAIQEgAhAoRQ0AIAJBLkcgABAqcg8LIAELPQECf0EAIQICQEEAKALcCSIDIABLDQAgAC8BACABRw0AAkAgAyAARw0AQQEPCyAAQX5qLwEAECAhAgsgAgtoAQJ/QQEhAQJAAkAgAEFfaiICQQVLDQBBASACdEExcQ0BCyAAQfj/A3FBKEYNACAAQUZqQf//A3FBBkkNAAJAIABBpX9qIgJBA0sNACACQQFHDQELIABBhX9qQf//A3FBBEkhAQsgAQucAQEDf0EAKAKwCiEBAkADQAJAAkAgAS8BACICQS9HDQACQCABLwECIgFBKkYNACABQS9HDQQQGAwCCyAAEBkMAQsCQAJAIABFDQAgAkF3aiIBQRdLDQFBASABdEGfgIAEcUUNAQwCCyACECFFDQMMAQsgAkGgAUcNAgtBAEEAKAKwCiIDQQJqIgE2ArAKIANBACgCtApJDQALCyACCzEBAX9BACEBAkAgAC8BAEEuRw0AIABBfmovAQBBLkcNACAAQXxqLwEAQS5GIQELIAELnAQBAX8CQCABQSJGDQAgAUEnRg0AECUPC0EAKAKwCiEDIAEQGiAAIANBAmpBACgCsApBACgC0AkQAQJAIAJFDQBBACgC8AlBBDYCHAtBAEEAKAKwCkECajYCsAoCQAJAAkACQEEAECkiAUHhAEYNACABQfcARg0BQQAoArAKIQEMAgtBACgCsAoiAUECakHACEEKEC8NAUEGIQAMAgtBACgCsAoiAS8BAkHpAEcNACABLwEEQfQARw0AQQQhACABLwEGQegARg0BC0EAIAFBfmo2ArAKDwtBACABIABBAXRqNgKwCgJAQQEQKUH7AEYNAEEAIAE2ArAKDwtBACgCsAoiAiEAA0BBACAAQQJqNgKwCgJAAkACQEEBECkiAEEiRg0AIABBJ0cNAUEnEBpBAEEAKAKwCkECajYCsApBARApIQAMAgtBIhAaQQBBACgCsApBAmo2ArAKQQEQKSEADAELIAAQLCEACwJAIABBOkYNAEEAIAE2ArAKDwtBAEEAKAKwCkECajYCsAoCQEEBECkiAEEiRg0AIABBJ0YNAEEAIAE2ArAKDwsgABAaQQBBACgCsApBAmo2ArAKAkACQEEBECkiAEEsRg0AIABB/QBGDQFBACABNgKwCg8LQQBBACgCsApBAmo2ArAKQQEQKUH9AEYNAEEAKAKwCiEADAELC0EAKALwCSIBIAI2AhAgAUEAKAKwCkECajYCDAttAQJ/AkACQANAAkAgAEH//wNxIgFBd2oiAkEXSw0AQQEgAnRBn4CABHENAgsgAUGgAUYNASAAIQIgARAoDQJBACECQQBBACgCsAoiAEECajYCsAogAC8BAiIADQAMAgsLIAAhAgsgAkH//wNxC6sBAQR/AkACQEEAKAKwCiICLwEAIgNB4QBGDQAgASEEIAAhBQwBC0EAIAJBBGo2ArAKQQEQKSECQQAoArAKIQUCQAJAIAJBIkYNACACQSdGDQAgAhAsGkEAKAKwCiEEDAELIAIQGkEAQQAoArAKQQJqIgQ2ArAKC0EBECkhA0EAKAKwCiECCwJAIAIgBUYNACAFIARBACAAIAAgAUYiAhtBACABIAIbEAILIAMLcgEEf0EAKAKwCiEAQQAoArQKIQECQAJAA0AgAEECaiECIAAgAU8NAQJAAkAgAi8BACIDQaR/ag4CAQQACyACIQAgA0F2ag4EAgEBAgELIABBBGohAAwACwtBACACNgKwChAlQQAPC0EAIAI2ArAKQd0AC0kBA39BACEDAkAgAkUNAAJAA0AgAC0AACIEIAEtAAAiBUcNASABQQFqIQEgAEEBaiEAIAJBf2oiAg0ADAILCyAEIAVrIQMLIAMLC+wBAgBBgAgLzgEAAHgAcABvAHIAdABtAHAAbwByAHQAZgBvAHIAZQB0AGEAbwB1AHIAYwBlAHIAbwBtAHUAbgBjAHQAaQBvAG4AcwBzAGUAcgB0AHYAbwB5AGkAZQBkAGUAbABlAGMAbwBuAHQAaQBuAGkAbgBzAHQAYQBuAHQAeQBiAHIAZQBhAHIAZQB0AHUAcgBkAGUAYgB1AGcAZwBlAGEAdwBhAGkAdABoAHIAdwBoAGkAbABlAGkAZgBjAGEAdABjAGYAaQBuAGEAbABsAGUAbABzAABB0AkLEAEAAAACAAAAAAQAAEA5AAA=", "undefined" != typeof Buffer ? Buffer.from(E, "base64") : Uint8Array.from(atob(E), (A2) => A2.charCodeAt(0)))).then(WebAssembly.instantiate).then(({ exports: A2 }) => {
      C = A2;
    });
    convertSourceMap$1 = {};
    (function(exports2) {
      Object.defineProperty(exports2, "commentRegex", {
        get: function getCommentRegex() {
          return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
        }
      });
      Object.defineProperty(exports2, "mapFileCommentRegex", {
        get: function getMapFileCommentRegex() {
          return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
        }
      });
      var decodeBase64;
      if (typeof Buffer !== "undefined") {
        if (typeof Buffer.from === "function") {
          decodeBase64 = decodeBase64WithBufferFrom;
        } else {
          decodeBase64 = decodeBase64WithNewBuffer;
        }
      } else {
        decodeBase64 = decodeBase64WithAtob;
      }
      function decodeBase64WithBufferFrom(base64) {
        return Buffer.from(base64, "base64").toString();
      }
      function decodeBase64WithNewBuffer(base64) {
        if (typeof value === "number") {
          throw new TypeError("The value to decode must not be of type number.");
        }
        return new Buffer(base64, "base64").toString();
      }
      function decodeBase64WithAtob(base64) {
        return decodeURIComponent(escape(atob(base64)));
      }
      function stripComment(sm) {
        return sm.split(",").pop();
      }
      function readFromFileMap(sm, read2) {
        var r = exports2.mapFileCommentRegex.exec(sm);
        var filename = r[1] || r[2];
        try {
          var sm = read2(filename);
          if (sm != null && typeof sm.catch === "function") {
            return sm.catch(throwError);
          } else {
            return sm;
          }
        } catch (e) {
          throwError(e);
        }
        function throwError(e) {
          throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e.stack);
        }
      }
      function Converter(sm, opts) {
        opts = opts || {};
        if (opts.hasComment) {
          sm = stripComment(sm);
        }
        if (opts.encoding === "base64") {
          sm = decodeBase64(sm);
        } else if (opts.encoding === "uri") {
          sm = decodeURIComponent(sm);
        }
        if (opts.isJSON || opts.encoding) {
          sm = JSON.parse(sm);
        }
        this.sourcemap = sm;
      }
      Converter.prototype.toJSON = function(space2) {
        return JSON.stringify(this.sourcemap, null, space2);
      };
      if (typeof Buffer !== "undefined") {
        if (typeof Buffer.from === "function") {
          Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
        } else {
          Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
        }
      } else {
        Converter.prototype.toBase64 = encodeBase64WithBtoa;
      }
      function encodeBase64WithBufferFrom() {
        var json = this.toJSON();
        return Buffer.from(json, "utf8").toString("base64");
      }
      function encodeBase64WithNewBuffer() {
        var json = this.toJSON();
        if (typeof json === "number") {
          throw new TypeError("The json to encode must not be of type number.");
        }
        return new Buffer(json, "utf8").toString("base64");
      }
      function encodeBase64WithBtoa() {
        var json = this.toJSON();
        return btoa(unescape(encodeURIComponent(json)));
      }
      Converter.prototype.toURI = function() {
        var json = this.toJSON();
        return encodeURIComponent(json);
      };
      Converter.prototype.toComment = function(options2) {
        var encoding, content, data;
        if (options2 != null && options2.encoding === "uri") {
          encoding = "";
          content = this.toURI();
        } else {
          encoding = ";base64";
          content = this.toBase64();
        }
        data = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
        return options2 != null && options2.multiline ? "/*# " + data + " */" : "//# " + data;
      };
      Converter.prototype.toObject = function() {
        return JSON.parse(this.toJSON());
      };
      Converter.prototype.addProperty = function(key, value2) {
        if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
        return this.setProperty(key, value2);
      };
      Converter.prototype.setProperty = function(key, value2) {
        this.sourcemap[key] = value2;
        return this;
      };
      Converter.prototype.getProperty = function(key) {
        return this.sourcemap[key];
      };
      exports2.fromObject = function(obj) {
        return new Converter(obj);
      };
      exports2.fromJSON = function(json) {
        return new Converter(json, { isJSON: true });
      };
      exports2.fromURI = function(uri) {
        return new Converter(uri, { encoding: "uri" });
      };
      exports2.fromBase64 = function(base64) {
        return new Converter(base64, { encoding: "base64" });
      };
      exports2.fromComment = function(comment4) {
        var m, encoding;
        comment4 = comment4.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
        m = exports2.commentRegex.exec(comment4);
        encoding = m && m[4] || "uri";
        return new Converter(comment4, { encoding, hasComment: true });
      };
      function makeConverter(sm) {
        return new Converter(sm, { isJSON: true });
      }
      exports2.fromMapFileComment = function(comment4, read2) {
        if (typeof read2 === "string") {
          throw new Error(
            "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
          );
        }
        var sm = readFromFileMap(comment4, read2);
        if (sm != null && typeof sm.then === "function") {
          return sm.then(makeConverter);
        } else {
          return makeConverter(sm);
        }
      };
      exports2.fromSource = function(content) {
        var m = content.match(exports2.commentRegex);
        return m ? exports2.fromComment(m.pop()) : null;
      };
      exports2.fromMapFileSource = function(content, read2) {
        if (typeof read2 === "string") {
          throw new Error(
            "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
          );
        }
        var m = content.match(exports2.mapFileCommentRegex);
        return m ? exports2.fromMapFileComment(m.pop(), read2) : null;
      };
      exports2.removeComments = function(src3) {
        return src3.replace(exports2.commentRegex, "");
      };
      exports2.removeMapFileComments = function(src3) {
        return src3.replace(exports2.mapFileCommentRegex, "");
      };
      exports2.generateMapFileComment = function(file, options2) {
        var data = "sourceMappingURL=" + file;
        return options2 && options2.multiline ? "/*# " + data + " */" : "//# " + data;
      };
    })(convertSourceMap$1);
    debug$g = createDebugger("vite:sourcemap", {
      onlyWhenFocused: true
    });
    tasks = {};
    utils$g = {};
    array$1 = {};
    Object.defineProperty(array$1, "__esModule", { value: true });
    array$1.splitWhen = array$1.flatten = void 0;
    array$1.flatten = flatten$1;
    array$1.splitWhen = splitWhen;
    errno$1 = {};
    Object.defineProperty(errno$1, "__esModule", { value: true });
    errno$1.isEnoentCodeError = void 0;
    errno$1.isEnoentCodeError = isEnoentCodeError;
    fs$i = {};
    Object.defineProperty(fs$i, "__esModule", { value: true });
    fs$i.createDirentFromStats = void 0;
    DirentFromStats$1 = class DirentFromStats {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    fs$i.createDirentFromStats = createDirentFromStats$1;
    path$i = {};
    Object.defineProperty(path$i, "__esModule", { value: true });
    path$i.convertPosixPathToPattern = path$i.convertWindowsPathToPattern = path$i.convertPathToPattern = path$i.escapePosixPath = path$i.escapeWindowsPath = path$i.escape = path$i.removeLeadingDotSegment = path$i.makeAbsolute = path$i.unixify = void 0;
    os$4 = require$$2;
    path$h = require$$0$4;
    IS_WINDOWS_PLATFORM = os$4.platform() === "win32";
    LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    POSIX_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\()|\\(?![!()*+?@[\]{|}]))/g;
    WINDOWS_UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()[\]{}]|^!|[!+@](?=\())/g;
    DOS_DEVICE_PATH_RE = /^\\\\([.?])/;
    WINDOWS_BACKSLASHES_RE = /\\(?![!()+@[\]{}])/g;
    path$i.unixify = unixify;
    path$i.makeAbsolute = makeAbsolute;
    path$i.removeLeadingDotSegment = removeLeadingDotSegment;
    path$i.escape = IS_WINDOWS_PLATFORM ? escapeWindowsPath : escapePosixPath;
    path$i.escapeWindowsPath = escapeWindowsPath;
    path$i.escapePosixPath = escapePosixPath;
    path$i.convertPathToPattern = IS_WINDOWS_PLATFORM ? convertWindowsPathToPattern : convertPosixPathToPattern;
    path$i.convertWindowsPathToPattern = convertWindowsPathToPattern;
    path$i.convertPosixPathToPattern = convertPosixPathToPattern;
    pattern$1 = {};
    isExtglob$1 = function isExtglob(str2) {
      if (typeof str2 !== "string" || str2 === "") {
        return false;
      }
      var match2;
      while (match2 = /(\\).|([@?!+*]\(.*\))/g.exec(str2)) {
        if (match2[2]) return true;
        str2 = str2.slice(match2.index + match2[0].length);
      }
      return false;
    };
    isExtglob2 = isExtglob$1;
    chars = { "{": "}", "(": ")", "[": "]" };
    strictCheck = function(str2) {
      if (str2[0] === "!") {
        return true;
      }
      var index4 = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index4 < str2.length) {
        if (str2[index4] === "*") {
          return true;
        }
        if (str2[index4 + 1] === "?" && /[\].+)]/.test(str2[index4])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str2[index4] === "[" && str2[index4 + 1] !== "]") {
          if (closeSquareIndex < index4) {
            closeSquareIndex = str2.indexOf("]", index4);
          }
          if (closeSquareIndex > index4) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str2.indexOf("\\", index4);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str2[index4] === "{" && str2[index4 + 1] !== "}") {
          closeCurlyIndex = str2.indexOf("}", index4);
          if (closeCurlyIndex > index4) {
            backSlashIndex = str2.indexOf("\\", index4);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str2[index4] === "(" && str2[index4 + 1] === "?" && /[:!=]/.test(str2[index4 + 2]) && str2[index4 + 3] !== ")") {
          closeParenIndex = str2.indexOf(")", index4);
          if (closeParenIndex > index4) {
            backSlashIndex = str2.indexOf("\\", index4);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str2[index4] === "(" && str2[index4 + 1] !== "|") {
          if (pipeIndex < index4) {
            pipeIndex = str2.indexOf("|", index4);
          }
          if (pipeIndex !== -1 && str2[pipeIndex + 1] !== ")") {
            closeParenIndex = str2.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str2.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str2[index4] === "\\") {
          var open2 = str2[index4 + 1];
          index4 += 2;
          var close2 = chars[open2];
          if (close2) {
            var n = str2.indexOf(close2, index4);
            if (n !== -1) {
              index4 = n + 1;
            }
          }
          if (str2[index4] === "!") {
            return true;
          }
        } else {
          index4++;
        }
      }
      return false;
    };
    relaxedCheck = function(str2) {
      if (str2[0] === "!") {
        return true;
      }
      var index4 = 0;
      while (index4 < str2.length) {
        if (/[*?{}()[\]]/.test(str2[index4])) {
          return true;
        }
        if (str2[index4] === "\\") {
          var open2 = str2[index4 + 1];
          index4 += 2;
          var close2 = chars[open2];
          if (close2) {
            var n = str2.indexOf(close2, index4);
            if (n !== -1) {
              index4 = n + 1;
            }
          }
          if (str2[index4] === "!") {
            return true;
          }
        } else {
          index4++;
        }
      }
      return false;
    };
    isGlob$2 = function isGlob(str2, options2) {
      if (typeof str2 !== "string" || str2 === "") {
        return false;
      }
      if (isExtglob2(str2)) {
        return true;
      }
      var check = strictCheck;
      if (options2 && options2.strict === false) {
        check = relaxedCheck;
      }
      return check(str2);
    };
    isGlob$1 = isGlob$2;
    pathPosixDirname = require$$0$4.posix.dirname;
    isWin32 = require$$2.platform() === "win32";
    slash3 = "/";
    backslash3 = /\\/g;
    enclosure = /[\{\[].*[\}\]]$/;
    globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    globParent$2 = function globParent(str2, opts) {
      var options2 = Object.assign({ flipBackslashes: true }, opts);
      if (options2.flipBackslashes && isWin32 && str2.indexOf(slash3) < 0) {
        str2 = str2.replace(backslash3, slash3);
      }
      if (enclosure.test(str2)) {
        str2 += slash3;
      }
      str2 += "a";
      do {
        str2 = pathPosixDirname(str2);
      } while (isGlob$1(str2) || globby.test(str2));
      return str2.replace(escaped, "$1");
    };
    utils$f = {};
    (function(exports2) {
      exports2.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports2.find = (node3, type) => node3.nodes.find((node4) => node4.type === type);
      exports2.exceedsLimit = (min2, max, step = 1, limit) => {
        if (limit === false) return false;
        if (!exports2.isInteger(min2) || !exports2.isInteger(max)) return false;
        return (Number(max) - Number(min2)) / Number(step) >= limit;
      };
      exports2.escapeNode = (block, n = 0, type) => {
        const node3 = block.nodes[n];
        if (!node3) return;
        if (type && node3.type === type || node3.type === "open" || node3.type === "close") {
          if (node3.escaped !== true) {
            node3.value = "\\" + node3.value;
            node3.escaped = true;
          }
        }
      };
      exports2.encloseBrace = (node3) => {
        if (node3.type !== "brace") return false;
        if (node3.commas >> 0 + node3.ranges >> 0 === 0) {
          node3.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isInvalidBrace = (block) => {
        if (block.type !== "brace") return false;
        if (block.invalid === true || block.dollar) return true;
        if (block.commas >> 0 + block.ranges >> 0 === 0) {
          block.invalid = true;
          return true;
        }
        if (block.open !== true || block.close !== true) {
          block.invalid = true;
          return true;
        }
        return false;
      };
      exports2.isOpenOrClose = (node3) => {
        if (node3.type === "open" || node3.type === "close") {
          return true;
        }
        return node3.open === true || node3.close === true;
      };
      exports2.reduce = (nodes) => nodes.reduce((acc, node3) => {
        if (node3.type === "text") acc.push(node3.value);
        if (node3.type === "range") node3.type = "text";
        return acc;
      }, []);
      exports2.flatten = (...args) => {
        const result = [];
        const flat = (arr) => {
          for (let i = 0; i < arr.length; i++) {
            const ele = arr[i];
            if (Array.isArray(ele)) {
              flat(ele);
              continue;
            }
            if (ele !== void 0) {
              result.push(ele);
            }
          }
          return result;
        };
        flat(args);
        return result;
      };
    })(utils$f);
    utils$e = utils$f;
    stringify$7 = (ast, options2 = {}) => {
      const stringify5 = (node3, parent = {}) => {
        const invalidBlock = options2.escapeInvalid && utils$e.isInvalidBrace(parent);
        const invalidNode = node3.invalid === true && options2.escapeInvalid === true;
        let output = "";
        if (node3.value) {
          if ((invalidBlock || invalidNode) && utils$e.isOpenOrClose(node3)) {
            return "\\" + node3.value;
          }
          return node3.value;
        }
        if (node3.value) {
          return node3.value;
        }
        if (node3.nodes) {
          for (const child of node3.nodes) {
            output += stringify5(child);
          }
        }
        return output;
      };
      return stringify5(ast);
    };
    isNumber$2 = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
    isNumber$1 = isNumber$2;
    toRegexRange$1 = (min2, max, options2) => {
      if (isNumber$1(min2) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min2 === max) {
        return String(min2);
      }
      if (isNumber$1(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options2 };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap2 = String(opts.wrap);
      let cacheKey = min2 + ":" + max + "=" + relax + shorthand + capture + wrap2;
      if (toRegexRange$1.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange$1.cache[cacheKey].result;
      }
      let a = Math.min(min2, max);
      let b = Math.max(min2, max);
      if (Math.abs(a - b) === 1) {
        let result = min2 + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded2 = hasPadding(min2) || hasPadding(max);
      let state = { min: min2, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded2) {
        state.isPadded = isPadded2;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange$1.cache[cacheKey] = state;
      return state.result;
    };
    toRegexRange$1.cache = {};
    toRegexRange$1.clearCache = () => toRegexRange$1.cache = {};
    toRegexRange_1 = toRegexRange$1;
    util$1 = require$$0$5;
    toRegexRange = toRegexRange_1;
    isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    transform2 = (toNumber) => {
      return (value2) => toNumber === true ? Number(value2) : String(value2);
    };
    isValidValue = (value2) => {
      return typeof value2 === "number" || typeof value2 === "string" && value2 !== "";
    };
    isNumber = (num) => Number.isInteger(+num);
    zeros = (input) => {
      let value2 = `${input}`;
      let index4 = -1;
      if (value2[0] === "-") value2 = value2.slice(1);
      if (value2 === "0") return false;
      while (value2[++index4] === "0") ;
      return index4 > 0;
    };
    stringify$6 = (start, end, options2) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options2.stringify === true;
    };
    pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash) input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength) input = "0" + input;
      return negative ? "-" + input : input;
    };
    toSequence = (parts, options2, maxLen) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options2.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.map((v) => toMaxLen(String(v), maxLen)).join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.map((v) => toMaxLen(String(v), maxLen)).join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options2.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    toRange = (a, b, isNumbers, options2) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options2 });
      }
      let start = String.fromCharCode(a);
      if (a === b) return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    toRegex = (start, end, options2) => {
      if (Array.isArray(start)) {
        let wrap2 = options2.wrap === true;
        let prefix = options2.capture ? "" : "?:";
        return wrap2 ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options2);
    };
    rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util$1.inspect(...args));
    };
    invalidRange = (start, end, options2) => {
      if (options2.strictRanges === true) throw rangeError([start, end]);
      return [];
    };
    invalidStep = (step, options2) => {
      if (options2.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    fillNumbers = (start, end, step = 1, options2 = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options2.strictRanges === true) throw rangeError([start, end]);
        return [];
      }
      if (a === 0) a = 0;
      if (b === 0) b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify$6(start, end, options2) === false;
      let format2 = options2.transform || transform2(toNumber);
      if (options2.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options2);
      }
      let parts = { negatives: [], positives: [] };
      let push2 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range2 = [];
      let index4 = 0;
      while (descending ? a >= b : a <= b) {
        if (options2.toRegex === true && step > 1) {
          push2(a);
        } else {
          range2.push(pad(format2(a, index4), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index4++;
      }
      if (options2.toRegex === true) {
        return step > 1 ? toSequence(parts, options2, maxLen) : toRegex(range2, null, { wrap: false, ...options2 });
      }
      return range2;
    };
    fillLetters = (start, end, step = 1, options2 = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options2);
      }
      let format2 = options2.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min2 = Math.min(a, b);
      let max = Math.max(a, b);
      if (options2.toRegex && step === 1) {
        return toRange(min2, max, false, options2);
      }
      let range2 = [];
      let index4 = 0;
      while (descending ? a >= b : a <= b) {
        range2.push(format2(a, index4));
        a = descending ? a - step : a + step;
        index4++;
      }
      if (options2.toRegex === true) {
        return toRegex(range2, null, { wrap: false, options: options2 });
      }
      return range2;
    };
    fill$2 = (start, end, step, options2 = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options2);
      }
      if (typeof step === "function") {
        return fill$2(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill$2(start, end, 0, step);
      }
      let opts = { ...options2 };
      if (opts.capture === true) opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step)) return invalidStep(step, opts);
        return fill$2(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    fillRange = fill$2;
    fill$1 = fillRange;
    utils$d = utils$f;
    compile$1 = (ast, options2 = {}) => {
      const walk3 = (node3, parent = {}) => {
        const invalidBlock = utils$d.isInvalidBrace(parent);
        const invalidNode = node3.invalid === true && options2.escapeInvalid === true;
        const invalid = invalidBlock === true || invalidNode === true;
        const prefix = options2.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node3.isOpen === true) {
          return prefix + node3.value;
        }
        if (node3.isClose === true) {
          console.log("node.isClose", prefix, node3.value);
          return prefix + node3.value;
        }
        if (node3.type === "open") {
          return invalid ? prefix + node3.value : "(";
        }
        if (node3.type === "close") {
          return invalid ? prefix + node3.value : ")";
        }
        if (node3.type === "comma") {
          return node3.prev.type === "comma" ? "" : invalid ? node3.value : "|";
        }
        if (node3.value) {
          return node3.value;
        }
        if (node3.nodes && node3.ranges > 0) {
          const args = utils$d.reduce(node3.nodes);
          const range2 = fill$1(...args, { ...options2, wrap: false, toRegex: true, strictZeros: true });
          if (range2.length !== 0) {
            return args.length > 1 && range2.length > 1 ? `(${range2})` : range2;
          }
        }
        if (node3.nodes) {
          for (const child of node3.nodes) {
            output += walk3(child, node3);
          }
        }
        return output;
      };
      return walk3(ast);
    };
    compile_1 = compile$1;
    fill = fillRange;
    stringify$5 = stringify$7;
    utils$c = utils$f;
    append$1 = (queue2 = "", stash = "", enclose = false) => {
      const result = [];
      queue2 = [].concat(queue2);
      stash = [].concat(stash);
      if (!stash.length) return queue2;
      if (!queue2.length) {
        return enclose ? utils$c.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (const item of queue2) {
        if (Array.isArray(item)) {
          for (const value2 of item) {
            result.push(append$1(value2, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string") ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append$1(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils$c.flatten(result);
    };
    expand$2 = (ast, options2 = {}) => {
      const rangeLimit = options2.rangeLimit === void 0 ? 1e3 : options2.rangeLimit;
      const walk3 = (node3, parent = {}) => {
        node3.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node3.invalid || node3.dollar) {
          q.push(append$1(q.pop(), stringify$5(node3, options2)));
          return;
        }
        if (node3.type === "brace" && node3.invalid !== true && node3.nodes.length === 2) {
          q.push(append$1(q.pop(), ["{}"]));
          return;
        }
        if (node3.nodes && node3.ranges > 0) {
          const args = utils$c.reduce(node3.nodes);
          if (utils$c.exceedsLimit(...args, options2.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range2 = fill(...args, options2);
          if (range2.length === 0) {
            range2 = stringify$5(node3, options2);
          }
          q.push(append$1(q.pop(), range2));
          node3.nodes = [];
          return;
        }
        const enclose = utils$c.encloseBrace(node3);
        let queue2 = node3.queue;
        let block = node3;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue2 = block.queue;
        }
        for (let i = 0; i < node3.nodes.length; i++) {
          const child = node3.nodes[i];
          if (child.type === "comma" && node3.type === "brace") {
            if (i === 1) queue2.push("");
            queue2.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append$1(q.pop(), queue2, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue2.push(append$1(queue2.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk3(child, node3);
          }
        }
        return queue2;
      };
      return utils$c.flatten(walk3(ast));
    };
    expand_1$1 = expand$2;
    constants$3 = {
      MAX_LENGTH: 1e4,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: "\xA0",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
    stringify$4 = stringify$7;
    ({
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK: (
        /* \ */
        CHAR_BACKTICK
      ),
      CHAR_COMMA: (
        /* ` */
        CHAR_COMMA
      ),
      CHAR_DOT: (
        /* , */
        CHAR_DOT
      ),
      CHAR_LEFT_PARENTHESES: (
        /* . */
        CHAR_LEFT_PARENTHESES
      ),
      CHAR_RIGHT_PARENTHESES: (
        /* ( */
        CHAR_RIGHT_PARENTHESES
      ),
      CHAR_LEFT_CURLY_BRACE: (
        /* ) */
        CHAR_LEFT_CURLY_BRACE
      ),
      CHAR_RIGHT_CURLY_BRACE: (
        /* { */
        CHAR_RIGHT_CURLY_BRACE
      ),
      CHAR_LEFT_SQUARE_BRACKET: (
        /* } */
        CHAR_LEFT_SQUARE_BRACKET
      ),
      CHAR_RIGHT_SQUARE_BRACKET: (
        /* [ */
        CHAR_RIGHT_SQUARE_BRACKET
      ),
      CHAR_DOUBLE_QUOTE: (
        /* ] */
        CHAR_DOUBLE_QUOTE
      ),
      CHAR_SINGLE_QUOTE: (
        /* " */
        CHAR_SINGLE_QUOTE
      ),
      CHAR_NO_BREAK_SPACE: (
        /* ' */
        CHAR_NO_BREAK_SPACE
      ),
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = constants$3);
    parse$c = (input, options2 = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      const opts = options2 || {};
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      const ast = { type: "root", input, nodes: [] };
      const stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      const length = input.length;
      let index4 = 0;
      let depth2 = 0;
      let value2;
      const advance = () => input[index4++];
      const push2 = (node3) => {
        if (node3.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node3.type === "text") {
          prev.value += node3.value;
          return;
        }
        block.nodes.push(node3);
        node3.parent = block;
        node3.prev = prev;
        prev = node3;
        return node3;
      };
      push2({ type: "bos" });
      while (index4 < length) {
        block = stack[stack.length - 1];
        value2 = advance();
        if (value2 === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value2 === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value2 === CHAR_BACKSLASH) {
          push2({ type: "text", value: (options2.keepEscaping ? value2 : "") + advance() });
          continue;
        }
        if (value2 === CHAR_RIGHT_SQUARE_BRACKET) {
          push2({ type: "text", value: "\\" + value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let next;
          while (index4 < length && (next = advance())) {
            value2 += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value2 += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_PARENTHESES) {
          block = push2({ type: "paren", nodes: [] });
          stack.push(block);
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push2({ type: "text", value: value2 });
            continue;
          }
          block = stack.pop();
          push2({ type: "text", value: value2 });
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_DOUBLE_QUOTE || value2 === CHAR_SINGLE_QUOTE || value2 === CHAR_BACKTICK) {
          const open2 = value2;
          let next;
          if (options2.keepQuotes !== true) {
            value2 = "";
          }
          while (index4 < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value2 += next + advance();
              continue;
            }
            if (next === open2) {
              if (options2.keepQuotes === true) value2 += next;
              break;
            }
            value2 += next;
          }
          push2({ type: "text", value: value2 });
          continue;
        }
        if (value2 === CHAR_LEFT_CURLY_BRACE) {
          depth2++;
          const dollar2 = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          const brace = {
            type: "brace",
            open: true,
            close: false,
            dollar: dollar2,
            depth: depth2,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push2(brace);
          stack.push(block);
          push2({ type: "open", value: value2 });
          continue;
        }
        if (value2 === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push2({ type: "text", value: value2 });
            continue;
          }
          const type = "close";
          block = stack.pop();
          block.close = true;
          push2({ type, value: value2 });
          depth2--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value2 === CHAR_COMMA && depth2 > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            const open2 = block.nodes.shift();
            block.nodes = [open2, { type: "text", value: stringify$4(block) }];
          }
          push2({ type: "comma", value: value2 });
          block.commas++;
          continue;
        }
        if (value2 === CHAR_DOT && depth2 > 0 && block.commas === 0) {
          const siblings = block.nodes;
          if (depth2 === 0 || siblings.length === 0) {
            push2({ type: "text", value: value2 });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value2;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            const before = siblings[siblings.length - 1];
            before.value += prev.value + value2;
            prev = before;
            block.ranges--;
            continue;
          }
          push2({ type: "dot", value: value2 });
          continue;
        }
        push2({ type: "text", value: value2 });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node3) => {
            if (!node3.nodes) {
              if (node3.type === "open") node3.isOpen = true;
              if (node3.type === "close") node3.isClose = true;
              if (!node3.nodes) node3.type = "text";
              node3.invalid = true;
            }
          });
          const parent = stack[stack.length - 1];
          const index5 = parent.nodes.indexOf(block);
          parent.nodes.splice(index5, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push2({ type: "eos" });
      return ast;
    };
    parse_1$2 = parse$c;
    stringify$3 = stringify$7;
    compile = compile_1;
    expand$1 = expand_1$1;
    parse$b = parse_1$2;
    braces$2 = (input, options2 = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (const pattern2 of input) {
          const result = braces$2.create(pattern2, options2);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces$2.create(input, options2));
      }
      if (options2 && options2.expand === true && options2.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces$2.parse = (input, options2 = {}) => parse$b(input, options2);
    braces$2.stringify = (input, options2 = {}) => {
      if (typeof input === "string") {
        return stringify$3(braces$2.parse(input, options2), options2);
      }
      return stringify$3(input, options2);
    };
    braces$2.compile = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$2.parse(input, options2);
      }
      return compile(input, options2);
    };
    braces$2.expand = (input, options2 = {}) => {
      if (typeof input === "string") {
        input = braces$2.parse(input, options2);
      }
      let result = expand$1(input, options2);
      if (options2.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options2.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces$2.create = (input, options2 = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options2.expand !== true ? braces$2.compile(input, options2) : braces$2.expand(input, options2);
    };
    braces_1 = braces$2;
    util2 = require$$0$5;
    braces$1 = braces_1;
    picomatch$2 = picomatch$3;
    utils$b = utils$k;
    isEmptyString = (v) => v === "" || v === "./";
    hasBraces = (v) => {
      const index4 = v.indexOf("{");
      return index4 > -1 && v.indexOf("}", index4) > -1;
    };
    micromatch$1 = (list2, patterns, options2) => {
      patterns = [].concat(patterns);
      list2 = [].concat(list2);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options2 && options2.onResult) {
          options2.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch$2(String(patterns[i]), { ...options2, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated) negatives++;
        for (let item of list2) {
          let matched = isMatch(item, true);
          let match2 = negated ? !matched.isMatch : matched.isMatch;
          if (!match2) continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options2 && matches.length === 0) {
        if (options2.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options2.nonull === true || options2.nullglob === true) {
          return options2.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch$1.match = micromatch$1;
    micromatch$1.matcher = (pattern2, options2) => picomatch$2(pattern2, options2);
    micromatch$1.isMatch = (str2, patterns, options2) => picomatch$2(patterns, options2)(str2);
    micromatch$1.any = micromatch$1.isMatch;
    micromatch$1.not = (list2, patterns, options2 = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options2.onResult) options2.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch$1(list2, patterns, { ...options2, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch$1.contains = (str2, pattern2, options2) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
      }
      if (Array.isArray(pattern2)) {
        return pattern2.some((p) => micromatch$1.contains(str2, p, options2));
      }
      if (typeof pattern2 === "string") {
        if (isEmptyString(str2) || isEmptyString(pattern2)) {
          return false;
        }
        if (str2.includes(pattern2) || str2.startsWith("./") && str2.slice(2).includes(pattern2)) {
          return true;
        }
      }
      return micromatch$1.isMatch(str2, pattern2, { ...options2, contains: true });
    };
    micromatch$1.matchKeys = (obj, patterns, options2) => {
      if (!utils$b.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch$1(Object.keys(obj), patterns, options2);
      let res = {};
      for (let key of keys) res[key] = obj[key];
      return res;
    };
    micromatch$1.some = (list2, patterns, options2) => {
      let items = [].concat(list2);
      for (let pattern2 of [].concat(patterns)) {
        let isMatch = picomatch$2(String(pattern2), options2);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch$1.every = (list2, patterns, options2) => {
      let items = [].concat(list2);
      for (let pattern2 of [].concat(patterns)) {
        let isMatch = picomatch$2(String(pattern2), options2);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch$1.all = (str2, patterns, options2) => {
      if (typeof str2 !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str2)}"`);
      }
      return [].concat(patterns).every((p) => picomatch$2(p, options2)(str2));
    };
    micromatch$1.capture = (glob, input, options2) => {
      let posix2 = utils$b.isWindows(options2);
      let regex2 = picomatch$2.makeRe(String(glob), { ...options2, capture: true });
      let match2 = regex2.exec(posix2 ? utils$b.toPosixSlashes(input) : input);
      if (match2) {
        return match2.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch$1.makeRe = (...args) => picomatch$2.makeRe(...args);
    micromatch$1.scan = (...args) => picomatch$2.scan(...args);
    micromatch$1.parse = (patterns, options2) => {
      let res = [];
      for (let pattern2 of [].concat(patterns || [])) {
        for (let str2 of braces$1(String(pattern2), options2)) {
          res.push(picomatch$2.parse(str2, options2));
        }
      }
      return res;
    };
    micromatch$1.braces = (pattern2, options2) => {
      if (typeof pattern2 !== "string") throw new TypeError("Expected a string");
      if (options2 && options2.nobrace === true || !hasBraces(pattern2)) {
        return [pattern2];
      }
      return braces$1(pattern2, options2);
    };
    micromatch$1.braceExpand = (pattern2, options2) => {
      if (typeof pattern2 !== "string") throw new TypeError("Expected a string");
      return micromatch$1.braces(pattern2, { ...options2, expand: true });
    };
    micromatch$1.hasBraces = hasBraces;
    micromatch_1 = micromatch$1;
    micromatch$2 = /* @__PURE__ */ getDefaultExportFromCjs(micromatch_1);
    Object.defineProperty(pattern$1, "__esModule", { value: true });
    pattern$1.removeDuplicateSlashes = pattern$1.matchAny = pattern$1.convertPatternsToRe = pattern$1.makeRe = pattern$1.getPatternParts = pattern$1.expandBraceExpansion = pattern$1.expandPatternsWithBraceExpansion = pattern$1.isAffectDepthOfReadingPattern = pattern$1.endsWithSlashGlobStar = pattern$1.hasGlobStar = pattern$1.getBaseDirectory = pattern$1.isPatternRelatedToParentDirectory = pattern$1.getPatternsOutsideCurrentDirectory = pattern$1.getPatternsInsideCurrentDirectory = pattern$1.getPositivePatterns = pattern$1.getNegativePatterns = pattern$1.isPositivePattern = pattern$1.isNegativePattern = pattern$1.convertToNegativePattern = pattern$1.convertToPositivePattern = pattern$1.isDynamicPattern = pattern$1.isStaticPattern = void 0;
    path$g = require$$0$4;
    globParent$1 = globParent$2;
    micromatch = micromatch_1;
    GLOBSTAR$1 = "**";
    ESCAPE_SYMBOL = "\\";
    COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    DOUBLE_SLASH_RE$1 = /(?!^)\/{2,}/g;
    pattern$1.isStaticPattern = isStaticPattern;
    pattern$1.isDynamicPattern = isDynamicPattern;
    pattern$1.convertToPositivePattern = convertToPositivePattern;
    pattern$1.convertToNegativePattern = convertToNegativePattern;
    pattern$1.isNegativePattern = isNegativePattern;
    pattern$1.isPositivePattern = isPositivePattern;
    pattern$1.getNegativePatterns = getNegativePatterns;
    pattern$1.getPositivePatterns = getPositivePatterns$1;
    pattern$1.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    pattern$1.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    pattern$1.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    pattern$1.getBaseDirectory = getBaseDirectory;
    pattern$1.hasGlobStar = hasGlobStar;
    pattern$1.endsWithSlashGlobStar = endsWithSlashGlobStar;
    pattern$1.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    pattern$1.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    pattern$1.expandBraceExpansion = expandBraceExpansion;
    pattern$1.getPatternParts = getPatternParts;
    pattern$1.makeRe = makeRe;
    pattern$1.convertPatternsToRe = convertPatternsToRe;
    pattern$1.matchAny = matchAny;
    pattern$1.removeDuplicateSlashes = removeDuplicateSlashes;
    stream$4 = {};
    Stream = require$$0$6;
    PassThrough = Stream.PassThrough;
    slice = Array.prototype.slice;
    merge2_1 = merge2$1;
    Object.defineProperty(stream$4, "__esModule", { value: true });
    stream$4.merge = void 0;
    merge22 = merge2_1;
    stream$4.merge = merge$1;
    string$2 = {};
    Object.defineProperty(string$2, "__esModule", { value: true });
    string$2.isEmpty = string$2.isString = void 0;
    string$2.isString = isString$1;
    string$2.isEmpty = isEmpty$1;
    Object.defineProperty(utils$g, "__esModule", { value: true });
    utils$g.string = utils$g.stream = utils$g.pattern = utils$g.path = utils$g.fs = utils$g.errno = utils$g.array = void 0;
    array = array$1;
    utils$g.array = array;
    errno = errno$1;
    utils$g.errno = errno;
    fs$h = fs$i;
    utils$g.fs = fs$h;
    path$f = path$i;
    utils$g.path = path$f;
    pattern = pattern$1;
    utils$g.pattern = pattern;
    stream$3 = stream$4;
    utils$g.stream = stream$3;
    string$12 = string$2;
    utils$g.string = string$12;
    Object.defineProperty(tasks, "__esModule", { value: true });
    tasks.convertPatternGroupToTask = tasks.convertPatternGroupsToTasks = tasks.groupPatternsByBaseDirectory = tasks.getNegativePatternsAsPositive = tasks.getPositivePatterns = tasks.convertPatternsToTasks = tasks.generate = void 0;
    utils$a = utils$g;
    tasks.generate = generate;
    tasks.convertPatternsToTasks = convertPatternsToTasks;
    tasks.getPositivePatterns = getPositivePatterns;
    tasks.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    tasks.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    tasks.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    tasks.convertPatternGroupToTask = convertPatternGroupToTask;
    async$7 = {};
    async$6 = {};
    out$3 = {};
    async$5 = {};
    async$4 = {};
    out$2 = {};
    async$3 = {};
    out$1 = {};
    async$2 = {};
    Object.defineProperty(async$2, "__esModule", { value: true });
    async$2.read = void 0;
    async$2.read = read$3;
    sync$8 = {};
    Object.defineProperty(sync$8, "__esModule", { value: true });
    sync$8.read = void 0;
    sync$8.read = read$2;
    settings$3 = {};
    fs$g = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      const fs6 = require$$0__default3;
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs6.lstat,
        stat: fs6.stat,
        lstatSync: fs6.lstatSync,
        statSync: fs6.statSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$g);
    Object.defineProperty(settings$3, "__esModule", { value: true });
    fs$f = fs$g;
    Settings$2 = class Settings {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs$f.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$3.default = Settings$2;
    Object.defineProperty(out$1, "__esModule", { value: true });
    out$1.statSync = out$1.stat = out$1.Settings = void 0;
    async$1 = async$2;
    sync$7 = sync$8;
    settings_1$3 = settings$3;
    out$1.Settings = settings_1$3.default;
    out$1.stat = stat$4;
    out$1.statSync = statSync;
    queueMicrotask_1 = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : commonjsGlobal) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
    runParallel_1 = runParallel;
    queueMicrotask$1 = queueMicrotask_1;
    constants$2 = {};
    Object.defineProperty(constants$2, "__esModule", { value: true });
    constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    SUPPORTED_MAJOR_VERSION = 10;
    SUPPORTED_MINOR_VERSION = 10;
    IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    constants$2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
    utils$9 = {};
    fs$e = {};
    Object.defineProperty(fs$e, "__esModule", { value: true });
    fs$e.createDirentFromStats = void 0;
    DirentFromStats2 = class {
      constructor(name2, stats) {
        this.name = name2;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    fs$e.createDirentFromStats = createDirentFromStats;
    Object.defineProperty(utils$9, "__esModule", { value: true });
    utils$9.fs = void 0;
    fs$d = fs$e;
    utils$9.fs = fs$d;
    common$a = {};
    Object.defineProperty(common$a, "__esModule", { value: true });
    common$a.joinPathSegments = void 0;
    common$a.joinPathSegments = joinPathSegments$1;
    Object.defineProperty(async$3, "__esModule", { value: true });
    async$3.readdir = async$3.readdirWithFileTypes = async$3.read = void 0;
    fsStat$5 = out$1;
    rpl = runParallel_1;
    constants_1$1 = constants$2;
    utils$8 = utils$9;
    common$9 = common$a;
    async$3.read = read$1;
    async$3.readdirWithFileTypes = readdirWithFileTypes$1;
    async$3.readdir = readdir$3;
    sync$6 = {};
    Object.defineProperty(sync$6, "__esModule", { value: true });
    sync$6.readdir = sync$6.readdirWithFileTypes = sync$6.read = void 0;
    fsStat$4 = out$1;
    constants_1 = constants$2;
    utils$7 = utils$9;
    common$8 = common$a;
    sync$6.read = read;
    sync$6.readdirWithFileTypes = readdirWithFileTypes;
    sync$6.readdir = readdir$2;
    settings$2 = {};
    fs$c = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
      const fs6 = require$$0__default3;
      exports2.FILE_SYSTEM_ADAPTER = {
        lstat: fs6.lstat,
        stat: fs6.stat,
        lstatSync: fs6.lstatSync,
        statSync: fs6.statSync,
        readdir: fs6.readdir,
        readdirSync: fs6.readdirSync
      };
      function createFileSystemAdapter(fsMethods) {
        if (fsMethods === void 0) {
          return exports2.FILE_SYSTEM_ADAPTER;
        }
        return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
      }
      exports2.createFileSystemAdapter = createFileSystemAdapter;
    })(fs$c);
    Object.defineProperty(settings$2, "__esModule", { value: true });
    path$e = require$$0$4;
    fsStat$3 = out$1;
    fs$b = fs$c;
    Settings$1 = class Settings2 {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs$b.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$e.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat$3.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$2.default = Settings$1;
    Object.defineProperty(out$2, "__esModule", { value: true });
    out$2.Settings = out$2.scandirSync = out$2.scandir = void 0;
    async = async$3;
    sync$5 = sync$6;
    settings_1$2 = settings$2;
    out$2.Settings = settings_1$2.default;
    out$2.scandir = scandir;
    out$2.scandirSync = scandirSync;
    queue = { exports: {} };
    reusify_1 = reusify$1;
    reusify = reusify_1;
    queue.exports = fastqueue;
    queue.exports.promise = queueAsPromised;
    queueExports = queue.exports;
    common$7 = {};
    Object.defineProperty(common$7, "__esModule", { value: true });
    common$7.joinPathSegments = common$7.replacePathSegmentSeparator = common$7.isAppliedFilter = common$7.isFatalError = void 0;
    common$7.isFatalError = isFatalError;
    common$7.isAppliedFilter = isAppliedFilter;
    common$7.replacePathSegmentSeparator = replacePathSegmentSeparator;
    common$7.joinPathSegments = joinPathSegments;
    reader$1 = {};
    Object.defineProperty(reader$1, "__esModule", { value: true });
    common$6 = common$7;
    Reader$1 = class Reader {
      constructor(_root2, _settings) {
        this._root = _root2;
        this._settings = _settings;
        this._root = common$6.replacePathSegmentSeparator(_root2, _settings.pathSegmentSeparator);
      }
    };
    reader$1.default = Reader$1;
    Object.defineProperty(async$4, "__esModule", { value: true });
    events_1 = require$$0$7;
    fsScandir$2 = out$2;
    fastq = queueExports;
    common$5 = common$7;
    reader_1$4 = reader$1;
    AsyncReader = class extends reader_1$4.default {
      constructor(_root2, _settings) {
        super(_root2, _settings);
        this._settings = _settings;
        this._scandir = fsScandir$2.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry2 of entries) {
            this._handleEntry(entry2, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common$5.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry2, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry2.path;
        if (base !== void 0) {
          entry2.path = common$5.joinPathSegments(base, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$5.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._emitEntry(entry2);
        }
        if (entry2.dirent.isDirectory() && common$5.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry2.path);
        }
      }
      _emitEntry(entry2) {
        this._emitter.emit("entry", entry2);
      }
    };
    async$4.default = AsyncReader;
    Object.defineProperty(async$5, "__esModule", { value: true });
    async_1$4 = async$4;
    AsyncProvider = class {
      constructor(_root2, _settings) {
        this._root = _root2;
        this._settings = _settings;
        this._reader = new async_1$4.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry2) => {
          this._storage.push(entry2);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    async$5.default = AsyncProvider;
    stream$2 = {};
    Object.defineProperty(stream$2, "__esModule", { value: true });
    stream_1$5 = require$$0$6;
    async_1$3 = async$4;
    StreamProvider = class {
      constructor(_root2, _settings) {
        this._root = _root2;
        this._settings = _settings;
        this._reader = new async_1$3.default(this._root, this._settings);
        this._stream = new stream_1$5.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry2) => {
          this._stream.push(entry2);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    stream$2.default = StreamProvider;
    sync$4 = {};
    sync$3 = {};
    Object.defineProperty(sync$3, "__esModule", { value: true });
    fsScandir$1 = out$2;
    common$4 = common$7;
    reader_1$3 = reader$1;
    SyncReader = class extends reader_1$3.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir$1.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry2 of entries) {
            this._handleEntry(entry2, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common$4.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry2, base) {
        const fullpath = entry2.path;
        if (base !== void 0) {
          entry2.path = common$4.joinPathSegments(base, entry2.name, this._settings.pathSegmentSeparator);
        }
        if (common$4.isAppliedFilter(this._settings.entryFilter, entry2)) {
          this._pushToStorage(entry2);
        }
        if (entry2.dirent.isDirectory() && common$4.isAppliedFilter(this._settings.deepFilter, entry2)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry2.path);
        }
      }
      _pushToStorage(entry2) {
        this._storage.push(entry2);
      }
    };
    sync$3.default = SyncReader;
    Object.defineProperty(sync$4, "__esModule", { value: true });
    sync_1$3 = sync$3;
    SyncProvider = class {
      constructor(_root2, _settings) {
        this._root = _root2;
        this._settings = _settings;
        this._reader = new sync_1$3.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    sync$4.default = SyncProvider;
    settings$1 = {};
    Object.defineProperty(settings$1, "__esModule", { value: true });
    path$d = require$$0$4;
    fsScandir = out$2;
    Settings3 = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path$d.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value2) {
        return option !== null && option !== void 0 ? option : value2;
      }
    };
    settings$1.default = Settings3;
    Object.defineProperty(out$3, "__esModule", { value: true });
    out$3.Settings = out$3.walkStream = out$3.walkSync = out$3.walk = void 0;
    async_1$2 = async$5;
    stream_1$4 = stream$2;
    sync_1$2 = sync$4;
    settings_1$1 = settings$1;
    out$3.Settings = settings_1$1.default;
    out$3.walk = walk$2;
    out$3.walkSync = walkSync;
    out$3.walkStream = walkStream;
    reader = {};
    Object.defineProperty(reader, "__esModule", { value: true });
    path$c = require$$0$4;
    fsStat$2 = out$1;
    utils$6 = utils$g;
    Reader2 = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat$2.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path$c.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern2) {
        const entry2 = {
          name: pattern2,
          path: pattern2,
          dirent: utils$6.fs.createDirentFromStats(pattern2, stats)
        };
        if (this._settings.stats) {
          entry2.stats = stats;
        }
        return entry2;
      }
      _isFatalError(error) {
        return !utils$6.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    reader.default = Reader2;
    stream$1 = {};
    Object.defineProperty(stream$1, "__esModule", { value: true });
    stream_1$3 = require$$0$6;
    fsStat$1 = out$1;
    fsWalk$2 = out$3;
    reader_1$2 = reader;
    ReaderStream = class extends reader_1$2.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk$2.walkStream;
        this._stat = fsStat$1.stat;
      }
      dynamic(root4, options2) {
        return this._walkStream(root4, options2);
      }
      static(patterns, options2) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream4 = new stream_1$3.PassThrough({ objectMode: true });
        stream4._write = (index4, _enc, done) => {
          return this._getEntry(filepaths[index4], patterns[index4], options2).then((entry2) => {
            if (entry2 !== null && options2.entryFilter(entry2)) {
              stream4.push(entry2);
            }
            if (index4 === filepaths.length - 1) {
              stream4.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream4.write(i);
        }
        return stream4;
      }
      _getEntry(filepath, pattern2, options2) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern2)).catch((error) => {
          if (options2.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve8, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve8(stats) : reject(error);
          });
        });
      }
    };
    stream$1.default = ReaderStream;
    Object.defineProperty(async$6, "__esModule", { value: true });
    fsWalk$1 = out$3;
    reader_1$1 = reader;
    stream_1$2 = stream$1;
    ReaderAsync = class extends reader_1$1.default {
      constructor() {
        super(...arguments);
        this._walkAsync = fsWalk$1.walk;
        this._readerStream = new stream_1$2.default(this._settings);
      }
      dynamic(root4, options2) {
        return new Promise((resolve8, reject) => {
          this._walkAsync(root4, options2, (error, entries) => {
            if (error === null) {
              resolve8(entries);
            } else {
              reject(error);
            }
          });
        });
      }
      async static(patterns, options2) {
        const entries = [];
        const stream4 = this._readerStream.static(patterns, options2);
        return new Promise((resolve8, reject) => {
          stream4.once("error", reject);
          stream4.on("data", (entry2) => entries.push(entry2));
          stream4.once("end", () => resolve8(entries));
        });
      }
    };
    async$6.default = ReaderAsync;
    provider = {};
    deep = {};
    partial = {};
    matcher = {};
    Object.defineProperty(matcher, "__esModule", { value: true });
    utils$5 = utils$g;
    Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        for (const pattern2 of this._patterns) {
          const segments = this._getPatternSegments(pattern2);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern: pattern2,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern2) {
        const parts = utils$5.pattern.getPatternParts(pattern2, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils$5.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils$5.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils$5.array.splitWhen(segments, (segment) => segment.dynamic && utils$5.pattern.hasGlobStar(segment.pattern));
      }
    };
    matcher.default = Matcher;
    Object.defineProperty(partial, "__esModule", { value: true });
    matcher_1 = matcher;
    PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern2 of patterns) {
          const section = pattern2.sections[0];
          if (!pattern2.complete && levels > section.length) {
            return true;
          }
          const match2 = parts.every((part, index4) => {
            const segment = pattern2.segments[index4];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match2) {
            return true;
          }
        }
        return false;
      }
    };
    partial.default = PartialMatcher;
    Object.defineProperty(deep, "__esModule", { value: true });
    utils$4 = utils$g;
    partial_1 = partial;
    DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher2 = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry2) => this._filter(basePath, entry2, matcher2, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils$4.pattern.isAffectDepthOfReadingPattern);
        return utils$4.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry2, matcher2, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry2.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry2)) {
          return false;
        }
        const filepath = utils$4.path.removeLeadingDotSegment(entry2.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher2)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry2) {
        return !this._settings.followSymbolicLinks && entry2.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher2) {
        return !this._settings.baseNameMatch && !matcher2.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils$4.pattern.matchAny(entryPath, patternsRe);
      }
    };
    deep.default = DeepFilter;
    entry$1 = {};
    Object.defineProperty(entry$1, "__esModule", { value: true });
    utils$3 = utils$g;
    EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils$3.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils$3.pattern.convertPatternsToRe(negative, Object.assign(Object.assign({}, this._micromatchOptions), { dot: true }));
        return (entry2) => this._filter(entry2, positiveRe, negativeRe);
      }
      _filter(entry2, positiveRe, negativeRe) {
        const filepath = utils$3.path.removeLeadingDotSegment(entry2.path);
        if (this._settings.unique && this._isDuplicateEntry(filepath)) {
          return false;
        }
        if (this._onlyFileFilter(entry2) || this._onlyDirectoryFilter(entry2)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(filepath, negativeRe)) {
          return false;
        }
        const isDirectory2 = entry2.dirent.isDirectory();
        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory2) && !this._isMatchToPatterns(filepath, negativeRe, isDirectory2);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(filepath);
        }
        return isMatched;
      }
      _isDuplicateEntry(filepath) {
        return this.index.has(filepath);
      }
      _createIndexRecord(filepath) {
        this.index.set(filepath, void 0);
      }
      _onlyFileFilter(entry2) {
        return this._settings.onlyFiles && !entry2.dirent.isFile();
      }
      _onlyDirectoryFilter(entry2) {
        return this._settings.onlyDirectories && !entry2.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils$3.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils$3.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(filepath, patternsRe, isDirectory2) {
        const isMatched = utils$3.pattern.matchAny(filepath, patternsRe);
        if (!isMatched && isDirectory2) {
          return utils$3.pattern.matchAny(filepath + "/", patternsRe);
        }
        return isMatched;
      }
    };
    entry$1.default = EntryFilter;
    error$1 = {};
    Object.defineProperty(error$1, "__esModule", { value: true });
    utils$2 = utils$g;
    ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils$2.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    error$1.default = ErrorFilter;
    entry = {};
    Object.defineProperty(entry, "__esModule", { value: true });
    utils$1 = utils$g;
    EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry2) => this._transform(entry2);
      }
      _transform(entry2) {
        let filepath = entry2.path;
        if (this._settings.absolute) {
          filepath = utils$1.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils$1.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry2.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry2), { path: filepath });
      }
    };
    entry.default = EntryTransformer;
    Object.defineProperty(provider, "__esModule", { value: true });
    path$b = require$$0$4;
    deep_1 = deep;
    entry_1 = entry$1;
    error_1 = error$1;
    entry_2 = entry;
    Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path$b.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    provider.default = Provider;
    Object.defineProperty(async$7, "__esModule", { value: true });
    async_1$1 = async$6;
    provider_1$2 = provider;
    ProviderAsync = class extends provider_1$2.default {
      constructor() {
        super(...arguments);
        this._reader = new async_1$1.default(this._settings);
      }
      async read(task) {
        const root4 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = await this.api(root4, task, options2);
        return entries.map((entry2) => options2.transform(entry2));
      }
      api(root4, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root4, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    async$7.default = ProviderAsync;
    stream = {};
    Object.defineProperty(stream, "__esModule", { value: true });
    stream_1$1 = require$$0$6;
    stream_2 = stream$1;
    provider_1$1 = provider;
    ProviderStream = class extends provider_1$1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root4 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const source = this.api(root4, task, options2);
        const destination = new stream_1$1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry2) => destination.emit("data", options2.transform(entry2))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root4, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root4, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    stream.default = ProviderStream;
    sync$2 = {};
    sync$1 = {};
    Object.defineProperty(sync$1, "__esModule", { value: true });
    fsStat = out$1;
    fsWalk = out$3;
    reader_1 = reader;
    ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root4, options2) {
        return this._walkSync(root4, options2);
      }
      static(patterns, options2) {
        const entries = [];
        for (const pattern2 of patterns) {
          const filepath = this._getFullEntryPath(pattern2);
          const entry2 = this._getEntry(filepath, pattern2, options2);
          if (entry2 === null || !options2.entryFilter(entry2)) {
            continue;
          }
          entries.push(entry2);
        }
        return entries;
      }
      _getEntry(filepath, pattern2, options2) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern2);
        } catch (error) {
          if (options2.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    sync$1.default = ReaderSync;
    Object.defineProperty(sync$2, "__esModule", { value: true });
    sync_1$1 = sync$1;
    provider_1 = provider;
    ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1$1.default(this._settings);
      }
      read(task) {
        const root4 = this._getRootDirectory(task);
        const options2 = this._getReaderOptions(task);
        const entries = this.api(root4, task, options2);
        return entries.map(options2.transform);
      }
      api(root4, task, options2) {
        if (task.dynamic) {
          return this._reader.dynamic(root4, options2);
        }
        return this._reader.static(task.patterns, options2);
      }
    };
    sync$2.default = ProviderSync;
    settings = {};
    (function(exports2) {
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
      const fs6 = require$$0__default3;
      const os2 = require$$2;
      const CPU_COUNT = Math.max(os2.cpus().length, 1);
      exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
        lstat: fs6.lstat,
        lstatSync: fs6.lstatSync,
        stat: fs6.stat,
        statSync: fs6.statSync,
        readdir: fs6.readdir,
        readdirSync: fs6.readdirSync
      };
      class Settings4 {
        constructor(_options = {}) {
          this._options = _options;
          this.absolute = this._getValue(this._options.absolute, false);
          this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
          this.braceExpansion = this._getValue(this._options.braceExpansion, true);
          this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
          this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
          this.cwd = this._getValue(this._options.cwd, process.cwd());
          this.deep = this._getValue(this._options.deep, Infinity);
          this.dot = this._getValue(this._options.dot, false);
          this.extglob = this._getValue(this._options.extglob, true);
          this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
          this.fs = this._getFileSystemMethods(this._options.fs);
          this.globstar = this._getValue(this._options.globstar, true);
          this.ignore = this._getValue(this._options.ignore, []);
          this.markDirectories = this._getValue(this._options.markDirectories, false);
          this.objectMode = this._getValue(this._options.objectMode, false);
          this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
          this.onlyFiles = this._getValue(this._options.onlyFiles, true);
          this.stats = this._getValue(this._options.stats, false);
          this.suppressErrors = this._getValue(this._options.suppressErrors, false);
          this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
          this.unique = this._getValue(this._options.unique, true);
          if (this.onlyDirectories) {
            this.onlyFiles = false;
          }
          if (this.stats) {
            this.objectMode = true;
          }
          this.ignore = [].concat(this.ignore);
        }
        _getValue(option, value2) {
          return option === void 0 ? value2 : option;
        }
        _getFileSystemMethods(methods = {}) {
          return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
        }
      }
      exports2.default = Settings4;
    })(settings);
    taskManager = tasks;
    async_1 = async$7;
    stream_1 = stream;
    sync_1 = sync$2;
    settings_1 = settings;
    utils = utils$g;
    (function(FastGlob2) {
      FastGlob2.glob = FastGlob2;
      FastGlob2.globSync = sync2;
      FastGlob2.globStream = stream4;
      FastGlob2.async = FastGlob2;
      function sync2(source, options2) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options2);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync2;
      function stream4(source, options2) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options2);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream4;
      function generateTasks(source, options2) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings2 = new settings_1.default(options2);
        return taskManager.generate(patterns, settings2);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern2(source, options2) {
        assertPatternsInput(source);
        const settings2 = new settings_1.default(options2);
        return utils.pattern.isDynamicPattern(source, settings2);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern2;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
      function convertPathToPattern(source) {
        assertPatternsInput(source);
        return utils.path.convertPathToPattern(source);
      }
      FastGlob2.convertPathToPattern = convertPathToPattern;
      (function(posix2) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapePosixPath(source);
        }
        posix2.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertPosixPathToPattern(source);
        }
        posix2.convertPathToPattern = convertPathToPattern2;
      })(FastGlob2.posix || (FastGlob2.posix = {}));
      (function(win322) {
        function escapePath2(source) {
          assertPatternsInput(source);
          return utils.path.escapeWindowsPath(source);
        }
        win322.escapePath = escapePath2;
        function convertPathToPattern2(source) {
          assertPatternsInput(source);
          return utils.path.convertWindowsPathToPattern(source);
        }
        win322.convertPathToPattern = convertPathToPattern2;
      })(FastGlob2.win32 || (FastGlob2.win32 = {}));
    })(FastGlob || (FastGlob = {}));
    src$22 = {};
    path$a = require$$0$4;
    fs$a = require$$0__default3;
    os$3 = require$$2;
    fsReadFileAsync = fs$a.promises.readFile;
    jsonLoader = (_, content) => JSON.parse(content);
    requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require3;
    defaultLoadersSync = Object.freeze({
      ".js": requireFunc,
      ".json": requireFunc,
      ".cjs": requireFunc,
      noExt: jsonLoader
    });
    src$22.defaultLoadersSync = defaultLoadersSync;
    dynamicImport = async (id3) => {
      try {
        const mod = await import(
          /* webpackIgnore: true */
          id3
        );
        return mod.default;
      } catch (e) {
        try {
          return requireFunc(id3);
        } catch (requireE) {
          if (requireE.code === "ERR_REQUIRE_ESM" || requireE instanceof SyntaxError && requireE.toString().includes("Cannot use import statement outside a module")) {
            throw e;
          }
          throw requireE;
        }
      }
    };
    defaultLoaders = Object.freeze({
      ".js": dynamicImport,
      ".mjs": dynamicImport,
      ".cjs": dynamicImport,
      ".json": jsonLoader,
      noExt: jsonLoader
    });
    src$22.defaultLoaders = defaultLoaders;
    makeEmplace = (enableCache) => (c, filepath, res) => {
      if (enableCache) c.set(filepath, res);
      return res;
    };
    src$22.lilconfig = function lilconfig(name2, options2) {
      const {
        ignoreEmptySearchPlaces,
        loaders,
        packageProp,
        searchPlaces,
        stopDir,
        transform: transform3,
        cache: cache2
      } = getOptions(name2, options2 ?? {}, false);
      const searchCache = /* @__PURE__ */ new Map();
      const loadCache = /* @__PURE__ */ new Map();
      const emplace = makeEmplace(cache2);
      return {
        async search(searchFrom = process.cwd()) {
          const result = {
            config: null,
            filepath: ""
          };
          const visited = /* @__PURE__ */ new Set();
          let dir = searchFrom;
          dirLoop: while (true) {
            if (cache2) {
              const r = searchCache.get(dir);
              if (r !== void 0) {
                for (const p of visited) searchCache.set(p, r);
                return r;
              }
              visited.add(dir);
            }
            for (const searchPlace of searchPlaces) {
              const filepath = path$a.join(dir, searchPlace);
              try {
                await fs$a.promises.access(filepath);
              } catch {
                continue;
              }
              const content = String(await fsReadFileAsync(filepath));
              const loaderKey = path$a.extname(searchPlace) || "noExt";
              const loader = loaders[loaderKey];
              if (searchPlace === "package.json") {
                const pkg = await loader(filepath, content);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result.config = maybeConfig;
                  result.filepath = filepath;
                  break dirLoop;
                }
                continue;
              }
              const isEmpty2 = content.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces) continue;
              if (isEmpty2) {
                result.isEmpty = true;
                result.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result.config = await loader(filepath, content);
              }
              result.filepath = filepath;
              break dirLoop;
            }
            if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
            dir = parentDir(dir);
          }
          const transformed = (
            // not found
            result.filepath === "" && result.config === null ? transform3(null) : transform3(result)
          );
          if (cache2) {
            for (const p of visited) searchCache.set(p, transformed);
          }
          return transformed;
        },
        async load(filepath) {
          validateFilePath(filepath);
          const absPath = path$a.resolve(process.cwd(), filepath);
          if (cache2 && loadCache.has(absPath)) {
            return loadCache.get(absPath);
          }
          const { base, ext: ext2 } = path$a.parse(absPath);
          const loaderKey = ext2 || "noExt";
          const loader = loaders[loaderKey];
          validateLoader(loader, loaderKey);
          const content = String(await fsReadFileAsync(absPath));
          if (base === "package.json") {
            const pkg = await loader(absPath, content);
            return emplace(
              loadCache,
              absPath,
              transform3({
                config: getPackageProp(packageProp, pkg),
                filepath: absPath
              })
            );
          }
          const result = {
            config: null,
            filepath: absPath
          };
          const isEmpty2 = content.trim() === "";
          if (isEmpty2 && ignoreEmptySearchPlaces)
            return emplace(
              loadCache,
              absPath,
              transform3({
                config: void 0,
                filepath: absPath,
                isEmpty: true
              })
            );
          result.config = isEmpty2 ? void 0 : await loader(absPath, content);
          return emplace(
            loadCache,
            absPath,
            transform3(isEmpty2 ? { ...result, isEmpty: isEmpty2, config: void 0 } : result)
          );
        },
        clearLoadCache() {
          if (cache2) loadCache.clear();
        },
        clearSearchCache() {
          if (cache2) searchCache.clear();
        },
        clearCaches() {
          if (cache2) {
            loadCache.clear();
            searchCache.clear();
          }
        }
      };
    };
    src$22.lilconfigSync = function lilconfigSync(name2, options2) {
      const {
        ignoreEmptySearchPlaces,
        loaders,
        packageProp,
        searchPlaces,
        stopDir,
        transform: transform3,
        cache: cache2
      } = getOptions(name2, options2 ?? {}, true);
      const searchCache = /* @__PURE__ */ new Map();
      const loadCache = /* @__PURE__ */ new Map();
      const emplace = makeEmplace(cache2);
      return {
        search(searchFrom = process.cwd()) {
          const result = {
            config: null,
            filepath: ""
          };
          const visited = /* @__PURE__ */ new Set();
          let dir = searchFrom;
          dirLoop: while (true) {
            if (cache2) {
              const r = searchCache.get(dir);
              if (r !== void 0) {
                for (const p of visited) searchCache.set(p, r);
                return r;
              }
              visited.add(dir);
            }
            for (const searchPlace of searchPlaces) {
              const filepath = path$a.join(dir, searchPlace);
              try {
                fs$a.accessSync(filepath);
              } catch {
                continue;
              }
              const loaderKey = path$a.extname(searchPlace) || "noExt";
              const loader = loaders[loaderKey];
              const content = String(fs$a.readFileSync(filepath));
              if (searchPlace === "package.json") {
                const pkg = loader(filepath, content);
                const maybeConfig = getPackageProp(packageProp, pkg);
                if (maybeConfig != null) {
                  result.config = maybeConfig;
                  result.filepath = filepath;
                  break dirLoop;
                }
                continue;
              }
              const isEmpty2 = content.trim() === "";
              if (isEmpty2 && ignoreEmptySearchPlaces) continue;
              if (isEmpty2) {
                result.isEmpty = true;
                result.config = void 0;
              } else {
                validateLoader(loader, loaderKey);
                result.config = loader(filepath, content);
              }
              result.filepath = filepath;
              break dirLoop;
            }
            if (dir === stopDir || dir === parentDir(dir)) break dirLoop;
            dir = parentDir(dir);
          }
          const transformed = (
            // not found
            result.filepath === "" && result.config === null ? transform3(null) : transform3(result)
          );
          if (cache2) {
            for (const p of visited) searchCache.set(p, transformed);
          }
          return transformed;
        },
        load(filepath) {
          validateFilePath(filepath);
          const absPath = path$a.resolve(process.cwd(), filepath);
          if (cache2 && loadCache.has(absPath)) {
            return loadCache.get(absPath);
          }
          const { base, ext: ext2 } = path$a.parse(absPath);
          const loaderKey = ext2 || "noExt";
          const loader = loaders[loaderKey];
          validateLoader(loader, loaderKey);
          const content = String(fs$a.readFileSync(absPath));
          if (base === "package.json") {
            const pkg = loader(absPath, content);
            return transform3({
              config: getPackageProp(packageProp, pkg),
              filepath: absPath
            });
          }
          const result = {
            config: null,
            filepath: absPath
          };
          const isEmpty2 = content.trim() === "";
          if (isEmpty2 && ignoreEmptySearchPlaces)
            return emplace(
              loadCache,
              absPath,
              transform3({
                filepath: absPath,
                config: void 0,
                isEmpty: true
              })
            );
          result.config = isEmpty2 ? void 0 : loader(absPath, content);
          return emplace(
            loadCache,
            absPath,
            transform3(isEmpty2 ? { ...result, isEmpty: isEmpty2, config: void 0 } : result)
          );
        },
        clearLoadCache() {
          if (cache2) loadCache.clear();
        },
        clearSearchCache() {
          if (cache2) searchCache.clear();
        },
        clearCaches() {
          if (cache2) {
            loadCache.clear();
            searchCache.clear();
          }
        }
      };
    };
    ALIAS = Symbol.for("yaml.alias");
    DOC = Symbol.for("yaml.document");
    MAP = Symbol.for("yaml.map");
    PAIR = Symbol.for("yaml.pair");
    SCALAR$1 = Symbol.for("yaml.scalar");
    SEQ = Symbol.for("yaml.seq");
    NODE_TYPE = Symbol.for("yaml.node.type");
    isAlias = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === ALIAS;
    isDocument = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === DOC;
    isMap = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === MAP;
    isPair = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === PAIR;
    isScalar$1 = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === SCALAR$1;
    isSeq = (node3) => !!node3 && typeof node3 === "object" && node3[NODE_TYPE] === SEQ;
    hasAnchor = (node3) => (isScalar$1(node3) || isCollection$1(node3)) && !!node3.anchor;
    BREAK$1 = Symbol("break visit");
    SKIP$1 = Symbol("skip children");
    REMOVE$1 = Symbol("remove node");
    visit$1.BREAK = BREAK$1;
    visit$1.SKIP = SKIP$1;
    visit$1.REMOVE = REMOVE$1;
    visitAsync.BREAK = BREAK$1;
    visitAsync.SKIP = SKIP$1;
    visitAsync.REMOVE = REMOVE$1;
    escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    Directives = class _Directives {
      constructor(yaml2, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml2);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError2) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name2 = parts.shift();
        switch (name2) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError2(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle2, prefix] = parts;
            this.tags[handle2] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError2(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version4] = parts;
            if (version4 === "1.1" || version4 === "1.2") {
              this.yaml.version = version4;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version4);
              onError2(6, `Unsupported YAML version ${version4}`, isValid2);
              return false;
            }
          }
          default:
            onError2(0, `Unknown directive ${name2}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError2) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError2(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError2(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError2("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle2, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError2(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle2];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError2(String(error));
            return null;
          }
        }
        if (handle2 === "!")
          return source;
        onError2(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag3) {
        for (const [handle2, prefix] of Object.entries(this.tags)) {
          if (tag3.startsWith(prefix))
            return handle2 + escapeTagName(tag3.substring(prefix.length));
        }
        return tag3[0] === "!" ? tag3 : `!<${tag3}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && isNode$1(doc.contents)) {
          const tags = {};
          visit$1(doc.contents, (_key, node3) => {
            if (isNode$1(node3) && node3.tag)
              tags[node3.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle2, prefix] of tagEntries) {
          if (handle2 === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle2} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    Alias = class extends NodeBase {
      constructor(source) {
        super(ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc) {
        let found2 = void 0;
        visit$1(doc, {
          Node: (_key, node3) => {
            if (node3 === this)
              return visit$1.BREAK;
            if (node3.anchor === this.source)
              found2 = node3;
          }
        });
        return found2;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
          toJS(source, null, ctx);
          data = anchors.get(source);
        }
        if (!data || data.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src3 = `*${this.source}`;
        if (ctx) {
          anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src3} `;
        }
        return src3;
      }
    };
    isScalarValue = (value2) => !value2 || typeof value2 !== "function" && typeof value2 !== "object";
    Scalar = class extends NodeBase {
      constructor(value2) {
        super(SCALAR$1);
        this.value = value2;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    defaultTagPrefix = "tag:yaml.org,2002:";
    isEmptyPath = (path9) => path9 == null || typeof path9 === "object" && !!path9[Symbol.iterator]().next().done;
    Collection = class extends NodeBase {
      constructor(type, schema2) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema2,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema2) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema2)
          copy.schema = schema2;
        copy.items = copy.items.map((it) => isNode$1(it) || isPair(it) ? it.clone(schema2) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path9, value2) {
        if (isEmptyPath(path9))
          this.add(value2);
        else {
          const [key, ...rest] = path9;
          const node3 = this.get(key, true);
          if (isCollection$1(node3))
            node3.addIn(rest, value2);
          else if (node3 === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path9) {
        const [key, ...rest] = path9;
        if (rest.length === 0)
          return this.delete(key);
        const node3 = this.get(key, true);
        if (isCollection$1(node3))
          return node3.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path9, keepScalar) {
        const [key, ...rest] = path9;
        const node3 = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && isScalar$1(node3) ? node3.value : node3;
        else
          return isCollection$1(node3) ? node3.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node3) => {
          if (!isPair(node3))
            return false;
          const n = node3.value;
          return n == null || allowScalar && isScalar$1(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path9) {
        const [key, ...rest] = path9;
        if (rest.length === 0)
          return this.has(key);
        const node3 = this.get(key, true);
        return isCollection$1(node3) ? node3.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path9, value2) {
        const [key, ...rest] = path9;
        if (rest.length === 0) {
          this.set(key, value2);
        } else {
          const node3 = this.get(key, true);
          if (isCollection$1(node3))
            node3.setIn(rest, value2);
          else if (node3 === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value2));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    stringifyComment = (str2) => str2.replace(/^(?!$)(?: $)?/gm, "#");
    lineComment = (str2, indent, comment4) => str2.endsWith("\n") ? indentComment(comment4, indent) : comment4.includes("\n") ? "\n" + indentComment(comment4, indent) : (str2.endsWith(" ") ? "" : " ") + comment4;
    FOLD_FLOW = "flow";
    FOLD_BLOCK = "block";
    FOLD_QUOTED = "quoted";
    getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    containsDocumentMarker = (str2) => /^(%|---|\.\.\.)/m.test(str2);
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    MERGE_KEY = "<<";
    isMergeKey = (key) => key === MERGE_KEY || isScalar$1(key) && key.value === MERGE_KEY && (!key.type || key.type === Scalar.PLAIN);
    Pair = class _Pair {
      constructor(key, value2 = null) {
        Object.defineProperty(this, NODE_TYPE, { value: PAIR });
        this.key = key;
        this.value = value2;
      }
      clone(schema2) {
        let { key, value: value2 } = this;
        if (isNode$1(key))
          key = key.clone(schema2);
        if (isNode$1(value2))
          value2 = value2.clone(schema2);
        return new _Pair(key, value2);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    YAMLMap = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema2) {
        super(MAP, schema2);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema2, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema2);
        const add = (key, value2) => {
          if (typeof replacer === "function")
            value2 = replacer.call(obj, key, value2);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value2 !== void 0 || keepUndefined)
            map.items.push(createPair(key, value2, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value2] of obj)
            add(key, value2);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema2.sortMapEntries === "function") {
          map.items.sort(schema2.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair(pair, pair?.value);
        } else
          _pair = new Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (isScalar$1(prev.value) && isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node3 = it?.value;
        return (!keepScalar && isScalar$1(node3) ? node3.value : node3) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value2) {
        this.add(new Pair(key, value2), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    map$1 = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map, onError2) {
        if (!isMap(map))
          onError2("Expected a mapping for this tag");
        return map;
      },
      createNode: (schema2, obj, ctx) => YAMLMap.from(schema2, obj, ctx)
    };
    YAMLSeq = class extends Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema2) {
        super(SEQ, schema2);
        this.items = [];
      }
      add(value2) {
        this.items.push(value2);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && isScalar$1(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value2) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (isScalar$1(prev) && isScalarValue(value2))
          prev.value = value2;
        else
          this.items[idx] = value2;
      }
      toJSON(_, ctx) {
        const seq2 = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq2);
        let i = 0;
        for (const item of this.items)
          seq2.push(toJS(item, String(i++), ctx));
        return seq2;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema2, obj, ctx) {
        const { replacer } = ctx;
        const seq2 = new this(schema2);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq2.items.push(createNode(it, void 0, ctx));
          }
        }
        return seq2;
      }
    };
    seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError2) {
        if (!isSeq(seq2))
          onError2("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema2, obj, ctx) => YAMLSeq.from(schema2, obj, ctx)
    };
    string3 = {
      identify: (value2) => typeof value2 === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str2) => str2,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    nullTag = {
      identify: (value2) => value2 == null,
      createNode: () => new Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    boolTag = {
      identify: (value2) => typeof value2 === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str2) => new Scalar(str2[0] === "t" || str2[0] === "T"),
      stringify({ source, value: value2 }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value2 === sv)
            return source;
        }
        return value2 ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    floatNaN$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2),
      stringify(node3) {
        const num = Number(node3.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node3);
      }
    };
    float$1 = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str2) {
        const node3 = new Scalar(parseFloat(str2));
        const dot = str2.indexOf(".");
        if (dot !== -1 && str2[str2.length - 1] === "0")
          node3.minFractionDigits = str2.length - dot - 1;
        return node3;
      },
      stringify: stringifyNumber
    };
    intIdentify$2 = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    intResolve$1 = (str2, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2.substring(offset), radix);
    intOct$1 = {
      identify: (value2) => intIdentify$2(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str2, _onError, opt) => intResolve$1(str2, 2, 8, opt),
      stringify: (node3) => intStringify$1(node3, 8, "0o")
    };
    int$1 = {
      identify: intIdentify$2,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str2, _onError, opt) => intResolve$1(str2, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex$1 = {
      identify: (value2) => intIdentify$2(value2) && value2 >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str2, _onError, opt) => intResolve$1(str2, 2, 16, opt),
      stringify: (node3) => intStringify$1(node3, 16, "0x")
    };
    schema$2 = [
      map$1,
      seq,
      string3,
      nullTag,
      boolTag,
      intOct$1,
      int$1,
      intHex$1,
      floatNaN$1,
      floatExp$1,
      float$1
    ];
    stringifyJSON = ({ value: value2 }) => JSON.stringify(value2);
    jsonScalars = [
      {
        identify: (value2) => typeof value2 === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str2) => str2,
        stringify: stringifyJSON
      },
      {
        identify: (value2) => value2 == null,
        createNode: () => new Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value2) => typeof value2 === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true|false$/,
        resolve: (str2) => str2 === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify$1,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str2, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str2) : parseInt(str2, 10),
        stringify: ({ value: value2 }) => intIdentify$1(value2) ? value2.toString() : JSON.stringify(value2)
      },
      {
        identify: (value2) => typeof value2 === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str2) => parseFloat(str2),
        stringify: stringifyJSON
      }
    ];
    jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str2, onError2) {
        onError2(`Unresolved plain scalar ${JSON.stringify(str2)}`);
        return str2;
      }
    };
    schema$1 = [map$1, seq].concat(jsonScalars, jsonError);
    binary = {
      identify: (value2) => value2 instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src3, onError2) {
        if (typeof Buffer === "function") {
          return Buffer.from(src3, "base64");
        } else if (typeof atob === "function") {
          const str2 = atob(src3.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str2.length);
          for (let i = 0; i < str2.length; ++i)
            buffer[i] = str2.charCodeAt(i);
          return buffer;
        } else {
          onError2("This environment does not support reading binary tags; either Buffer or atob is required");
          return src3;
        }
      },
      stringify({ comment: comment4, type, value: value2 }, ctx, onComment, onChompKeep) {
        const buf = value2;
        let str2;
        if (typeof Buffer === "function") {
          str2 = buf instanceof Buffer ? buf.toString("base64") : Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str2 = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        if (!type)
          type = Scalar.BLOCK_LITERAL;
        if (type !== Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n = Math.ceil(str2.length / lineWidth);
          const lines = new Array(n);
          for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
            lines[i] = str2.substr(o, lineWidth);
          }
          str2 = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString({ comment: comment4, type, value: str2 }, ctx, onComment, onChompKeep);
      }
    };
    pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    YAMLOMap = class _YAMLOMap extends YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value2;
          if (isPair(pair)) {
            key = toJS(pair.key, "", ctx);
            value2 = toJS(pair.value, key, ctx);
          } else {
            key = toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value2);
        }
        return map;
      }
      static from(schema2, iterable, ctx) {
        const pairs2 = createPairs(schema2, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs2.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    omap = {
      collection: "seq",
      identify: (value2) => value2 instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq2, onError2) {
        const pairs2 = resolvePairs(seq2, onError2);
        const seenKeys = [];
        for (const { key } of pairs2.items) {
          if (isScalar$1(key)) {
            if (seenKeys.includes(key.value)) {
              onError2(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs2);
      },
      createNode: (schema2, iterable, ctx) => YAMLOMap.from(schema2, iterable, ctx)
    };
    trueTag = {
      identify: (value2) => value2 === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar(true),
      stringify: boolStringify
    };
    falseTag = {
      identify: (value2) => value2 === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar(false),
      stringify: boolStringify
    };
    floatNaN = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str2) => str2.slice(-3).toLowerCase() === "nan" ? NaN : str2[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber
    };
    floatExp = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str2) => parseFloat(str2.replace(/_/g, "")),
      stringify(node3) {
        const num = Number(node3.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber(node3);
      }
    };
    float = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str2) {
        const node3 = new Scalar(parseFloat(str2.replace(/_/g, "")));
        const dot = str2.indexOf(".");
        if (dot !== -1) {
          const f = str2.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node3.minFractionDigits = f.length;
        }
        return node3;
      },
      stringify: stringifyNumber
    };
    intIdentify = (value2) => typeof value2 === "bigint" || Number.isInteger(value2);
    intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 2, opt),
      stringify: (node3) => intStringify(node3, 2, "0b")
    };
    intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 1, 8, opt),
      stringify: (node3) => intStringify(node3, 8, "0")
    };
    int = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 0, 10, opt),
      stringify: stringifyNumber
    };
    intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str2, _onError, opt) => intResolve(str2, 2, 16, opt),
      stringify: (node3) => intStringify(node3, 16, "0x")
    };
    YAMLSet = class _YAMLSet extends YAMLMap {
      constructor(schema2) {
        super(schema2);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair(key.key, null);
        else
          pair = new Pair(key, null);
        const prev = findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = findPair(this.items, key);
        return !keepPair && isPair(pair) ? isScalar$1(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value2) {
        if (typeof value2 !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value2}`);
        const prev = findPair(this.items, key);
        if (prev && !value2) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value2) {
          this.items.push(new Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema2, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema2);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value2 of iterable) {
            if (typeof replacer === "function")
              value2 = replacer.call(iterable, value2, value2);
            set2.items.push(createPair(value2, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    set = {
      collection: "map",
      identify: (value2) => value2 instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema2, iterable, ctx) => YAMLSet.from(schema2, iterable, ctx),
      resolve(map, onError2) {
        if (isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError2("Set items must all have null values");
        } else
          onError2("Expected a mapping for this tag");
        return map;
      }
    };
    intTime = {
      identify: (value2) => typeof value2 === "bigint" || Number.isInteger(value2),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str2, _onError, { intAsBigInt }) => parseSexagesimal(str2, intAsBigInt),
      stringify: stringifySexagesimal
    };
    floatTime = {
      identify: (value2) => typeof value2 === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str2) => parseSexagesimal(str2, false),
      stringify: stringifySexagesimal
    };
    timestamp2 = {
      identify: (value2) => value2 instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str2) {
        const match2 = str2.match(timestamp2.test);
        if (!match2)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match2.map(Number);
        const millisec = match2[7] ? Number((match2[7] + "00").substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match2[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date -= 6e4 * d;
        }
        return new Date(date);
      },
      stringify: ({ value: value2 }) => value2.toISOString().replace(/((T00:00)?:00)?\.000Z$/, "")
    };
    schema = [
      map$1,
      seq,
      string3,
      nullTag,
      trueTag,
      falseTag,
      intBin,
      intOct,
      int,
      intHex,
      floatNaN,
      floatExp,
      float,
      binary,
      omap,
      pairs,
      set,
      intTime,
      floatTime,
      timestamp2
    ];
    schemas = /* @__PURE__ */ new Map([
      ["core", schema$2],
      ["failsafe", [map$1, seq, string3]],
      ["json", schema$1],
      ["yaml11", schema],
      ["yaml-1.1", schema]
    ]);
    tagsByName = {
      binary,
      bool: boolTag,
      float: float$1,
      floatExp: floatExp$1,
      floatNaN: floatNaN$1,
      floatTime,
      int: int$1,
      intHex: intHex$1,
      intOct: intOct$1,
      intTime,
      map: map$1,
      null: nullTag,
      omap,
      pairs,
      seq,
      set,
      timestamp: timestamp2
    };
    coreKnownTags = {
      "tag:yaml.org,2002:binary": binary,
      "tag:yaml.org,2002:omap": omap,
      "tag:yaml.org,2002:pairs": pairs,
      "tag:yaml.org,2002:set": set,
      "tag:yaml.org,2002:timestamp": timestamp2
    };
    sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    Schema = class _Schema {
      constructor({ compat, customTags, merge: merge3, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
        this.merge = !!merge3;
        this.name = typeof schema2 === "string" && schema2 || "core";
        this.knownTags = resolveKnownTags ? coreKnownTags : {};
        this.tags = getTags(customTags, this.name);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, MAP, { value: map$1 });
        Object.defineProperty(this, SCALAR$1, { value: string3 });
        Object.defineProperty(this, SEQ, { value: seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    Document2 = class _Document {
      constructor(value2, replacer, options2) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options2 === void 0 && replacer) {
          options2 = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          uniqueKeys: true,
          version: "1.2"
        }, options2);
        this.options = opt;
        let { version: version4 } = opt;
        if (options2?._directives) {
          this.directives = options2._directives.atDocument();
          if (this.directives.yaml.explicit)
            version4 = this.directives.yaml.version;
        } else
          this.directives = new Directives({ version: version4 });
        this.setSchema(version4, options2);
        this.contents = value2 === void 0 ? null : this.createNode(value2, _replacer, options2);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = isNode$1(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value2) {
        if (assertCollection(this.contents))
          this.contents.add(value2);
      }
      /** Adds a value to the document. */
      addIn(path9, value2) {
        if (assertCollection(this.contents))
          this.contents.addIn(path9, value2);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node3, name2) {
        if (!node3.anchor) {
          const prev = anchorNames(this);
          node3.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name2 || prev.has(name2) ? findNewAnchor(name2 || "a", prev) : name2;
        }
        return new Alias(node3.anchor);
      }
      createNode(value2, replacer, options2) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value2 = replacer.call({ "": value2 }, "", value2);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options2 === void 0 && replacer) {
          options2 = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag3 } = options2 ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node3 = createNode(value2, tag3, ctx);
        if (flow && isCollection$1(node3))
          node3.flow = true;
        setAnchors();
        return node3;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value2, options2 = {}) {
        const k = this.createNode(key, null, options2);
        const v = this.createNode(value2, null, options2);
        return new Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path9) {
        if (isEmptyPath(path9)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path9) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return isCollection$1(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path9, keepScalar) {
        if (isEmptyPath(path9))
          return !keepScalar && isScalar$1(this.contents) ? this.contents.value : this.contents;
        return isCollection$1(this.contents) ? this.contents.getIn(path9, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return isCollection$1(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path9) {
        if (isEmptyPath(path9))
          return this.contents !== void 0;
        return isCollection$1(this.contents) ? this.contents.hasIn(path9) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value2) {
        if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, [key], value2);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value2);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path9, value2) {
        if (isEmptyPath(path9)) {
          this.contents = value2;
        } else if (this.contents == null) {
          this.contents = collectionFromPath(this.schema, Array.from(path9), value2);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path9, value2);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version4, options2 = {}) {
        if (typeof version4 === "number")
          version4 = String(version4);
        let opt;
        switch (version4) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new Directives({ version: "1.1" });
            opt = { merge: true, resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version4;
            else
              this.directives = new Directives({ version: version4 });
            opt = { merge: false, resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version4);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options2.schema instanceof Object)
          this.schema = options2.schema;
        else if (opt)
          this.schema = new Schema(Object.assign(opt, options2));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options2 = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options2 && (!Number.isInteger(options2.indent) || Number(options2.indent) <= 0)) {
          const s = JSON.stringify(options2.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options2);
      }
    };
    YAMLError = class extends Error {
      constructor(name2, pos, code, message) {
        super();
        this.name = name2;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    prettifyError = (src3, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src3.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src3.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    startColMsg = "All mapping items must start at the same column";
    blockMsg = "Block collections are not allowed within flow collections";
    isBlock$1 = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    CN = { composeNode, composeEmptyNode };
    Composer = class {
      constructor(options2 = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new YAMLWarning(pos, code, message));
          else
            this.errors.push(new YAMLParseError(pos, code, message));
        };
        this.directives = new Directives({ version: options2.version || "1.2" });
        this.options = options2;
      }
      decorate(doc, afterDoc) {
        const { comment: comment4, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment4) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment4}` : comment4;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment4;
          } else if (isCollection$1(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment4}
${cb}` : comment4;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment4}
${cb}` : comment4;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document2(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    stringify$12 = (cst2) => "type" in cst2 ? stringifyToken(cst2) : stringifyItem(cst2);
    BREAK = Symbol("break visit");
    SKIP = Symbol("skip children");
    REMOVE = Symbol("remove item");
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst2, path9) => {
      let item = cst2;
      for (const [field, index4] of path9) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index4];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst2, path9) => {
      const parent = visit.itemAtPath(cst2, path9.slice(0, -1));
      const field = path9[path9.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    BOM = "\uFEFF";
    DOCUMENT = "";
    FLOW_END = "";
    SCALAR = "";
    isCollection = (token) => !!token && "items" in token;
    isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    cst = {
      __proto__: null,
      BOM,
      DOCUMENT,
      FLOW_END,
      SCALAR,
      createScalarToken,
      isCollection,
      isScalar,
      prettyToken,
      resolveAsScalar,
      setScalarValue,
      stringify: stringify$12,
      tokenType,
      visit
    };
    hexDigits = new Set("0123456789ABCDEFabcdef");
    tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    flowIndicatorChars = new Set(",[]{}");
    invalidAnchorChars = new Set(" ,[]{}\n\r	");
    isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n) {
        return this.buffer[this.pos + n];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n) {
        return this.pos + n <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n) {
        return this.buffer.substr(this.pos, n);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n = yield* this.pushIndicators();
        switch (line[n]) {
          case "#":
            yield* this.pushCount(line.length - n);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n += yield* this.parseBlockScalarHeader();
            n += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n = 0;
        while (line[n] === ",") {
          n += yield* this.pushCount(1);
          n += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote3 = this.charAt(0);
        let end = this.buffer.indexOf(quote3, this.pos + 1);
        if (quote3 === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n = 0;
            while (this.buffer[end - 1 - n] === "\\")
              n += 1;
            if (n % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n) {
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos += n;
          return n;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n = i - this.pos;
        if (n > 0) {
          yield this.buffer.substr(this.pos, n);
          this.pos = i;
        }
        return n;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    Parser2 = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n) {
        return this.stack[this.stack.length - n];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep2;
          if (scalar.end) {
            sep2 = scalar.end;
            sep2.push(this.sourceToken);
            delete scalar.end;
          } else
            sep2 = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep: sep2 }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep2 = it.sep;
                  sep2.push(this.sourceToken);
                  delete it.key, delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep: sep2 }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs6 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start, key: fs6, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs6);
              } else {
                Object.assign(it, { key: fs6, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (atMapIndent && bv.type !== "block-seq") {
                  map.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq2) {
        const it = seq2.items[seq2.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq2.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq2.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq2.indent)) {
                const prev = seq2.items[seq2.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq2.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq2.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq2.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq2.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq2.indent) {
          const bv = this.startBlockValue(seq2);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top && top.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs6 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs6, sep: [] });
              else if (it.sep)
                this.stack.push(fs6);
              else
                Object.assign(it, { key: fs6, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep2 = fc.end.splice(1, fc.end.length);
            sep2.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep: sep2 }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    YAML = {
      __proto__: null,
      Alias,
      CST: cst,
      Composer,
      Document: Document2,
      Lexer,
      LineCounter,
      Pair,
      Parser: Parser2,
      Scalar,
      Schema,
      YAMLError,
      YAMLMap,
      YAMLParseError,
      YAMLSeq,
      YAMLWarning,
      isAlias,
      isCollection: isCollection$1,
      isDocument,
      isMap,
      isNode: isNode$1,
      isPair,
      isScalar: isScalar$1,
      isSeq,
      parse: parse$a,
      parseAllDocuments,
      parseDocument,
      stringify: stringify4,
      visit: visit$1,
      visitAsync
    };
    browser$2 = {
      __proto__: null,
      Alias,
      CST: cst,
      Composer,
      Document: Document2,
      Lexer,
      LineCounter,
      Pair,
      Parser: Parser2,
      Scalar,
      Schema,
      YAMLError,
      YAMLMap,
      YAMLParseError,
      YAMLSeq,
      YAMLWarning,
      default: YAML,
      isAlias,
      isCollection: isCollection$1,
      isDocument,
      isMap,
      isNode: isNode$1,
      isPair,
      isScalar: isScalar$1,
      isSeq,
      parse: parse$a,
      parseAllDocuments,
      parseDocument,
      stringify: stringify4,
      visit: visit$1,
      visitAsync
    };
    require$$32 = /* @__PURE__ */ getAugmentedNamespace(browser$2);
    ({ createRequire, createRequireFromPath } = require$$0$8);
    req_1 = req$2;
    req$1 = req_1;
    options = (config2, file) => {
      if (config2.parser && typeof config2.parser === "string") {
        try {
          config2.parser = req$1(config2.parser, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Parser failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.syntax && typeof config2.syntax === "string") {
        try {
          config2.syntax = req$1(config2.syntax, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Syntax failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.stringifier && typeof config2.stringifier === "string") {
        try {
          config2.stringifier = req$1(config2.stringifier, file);
        } catch (err) {
          throw new Error(`Loading PostCSS Stringifier failed: ${err.message}

(@${file})`);
        }
      }
      if (config2.plugins) {
        delete config2.plugins;
      }
      return config2;
    };
    options_1 = options;
    req = req_1;
    load = (plugin3, options2, file) => {
      try {
        if (options2 === null || options2 === void 0 || Object.keys(options2).length === 0) {
          return req(plugin3, file);
        } else {
          return req(plugin3, file)(options2);
        }
      } catch (err) {
        throw new Error(`Loading PostCSS Plugin failed: ${err.message}

(@${file})`);
      }
    };
    plugins = (config2, file) => {
      let plugins2 = [];
      if (Array.isArray(config2.plugins)) {
        plugins2 = config2.plugins.filter(Boolean);
      } else {
        plugins2 = Object.keys(config2.plugins).filter((plugin3) => {
          return config2.plugins[plugin3] !== false ? plugin3 : "";
        }).map((plugin3) => {
          return load(plugin3, config2.plugins[plugin3], file);
        });
      }
      if (plugins2.length && plugins2.length > 0) {
        plugins2.forEach((plugin3, i) => {
          if (plugin3.default) {
            plugin3 = plugin3.default;
          }
          if (plugin3.postcss === true) {
            plugin3 = plugin3();
          } else if (plugin3.postcss) {
            plugin3 = plugin3.postcss;
          }
          if (
            // eslint-disable-next-line
            !(typeof plugin3 === "object" && Array.isArray(plugin3.plugins) || typeof plugin3 === "object" && plugin3.postcssPlugin || typeof plugin3 === "function")
          ) {
            throw new TypeError(`Invalid PostCSS Plugin found at: plugins[${i}]

(@${file})`);
          }
        });
      }
      return plugins2;
    };
    plugins_1 = plugins;
    resolve3 = require$$0$4.resolve;
    url$4 = require$$0$9;
    config$1 = src$22;
    yaml = require$$32;
    loadOptions = options_1;
    loadPlugins = plugins_1;
    interopRequireDefault = (obj) => obj && obj.__esModule ? obj : { default: obj };
    processResult = (ctx, result) => {
      const file = result.filepath || "";
      let config2 = interopRequireDefault(result.config).default || {};
      if (typeof config2 === "function") {
        config2 = config2(ctx);
      } else {
        config2 = Object.assign({}, config2, ctx);
      }
      if (!config2.plugins) {
        config2.plugins = [];
      }
      return {
        plugins: loadPlugins(config2, file),
        options: loadOptions(config2, file),
        file
      };
    };
    createContext = (ctx) => {
      ctx = Object.assign({
        cwd: process.cwd(),
        env: process.env.NODE_ENV
      }, ctx);
      if (!ctx.env) {
        process.env.NODE_ENV = "development";
      }
      return ctx;
    };
    importDefault = async (filepath) => {
      const module = await import(url$4.pathToFileURL(filepath).href);
      return module.default;
    };
    addTypeScriptLoader = (options2 = {}, loader) => {
      const moduleName = "postcss";
      return {
        ...options2,
        searchPlaces: [
          ...options2.searchPlaces || [],
          "package.json",
          `.${moduleName}rc`,
          `.${moduleName}rc.json`,
          `.${moduleName}rc.yaml`,
          `.${moduleName}rc.yml`,
          `.${moduleName}rc.ts`,
          `.${moduleName}rc.cts`,
          `.${moduleName}rc.js`,
          `.${moduleName}rc.cjs`,
          `.${moduleName}rc.mjs`,
          `${moduleName}.config.ts`,
          `${moduleName}.config.cts`,
          `${moduleName}.config.js`,
          `${moduleName}.config.cjs`,
          `${moduleName}.config.mjs`
        ],
        loaders: {
          ...options2.loaders,
          ".yaml": (filepath, content) => yaml.parse(content),
          ".yml": (filepath, content) => yaml.parse(content),
          ".js": importDefault,
          ".cjs": importDefault,
          ".mjs": importDefault,
          ".ts": loader,
          ".cts": loader
        }
      };
    };
    withTypeScriptLoader = (rcFunc) => {
      return (ctx, path9, options2) => {
        return rcFunc(ctx, path9, addTypeScriptLoader(options2, (configFile) => {
          let registerer = { enabled() {
          } };
          try {
            registerer = __require3("ts-node").register({
              // transpile to cjs even if compilerOptions.module in tsconfig is not Node16/NodeNext.
              moduleTypes: { "**/*.cts": "cjs" }
            });
            return __require3(configFile);
          } catch (err) {
            if (err.code === "MODULE_NOT_FOUND") {
              throw new Error(
                `'ts-node' is required for the TypeScript configuration files. Make sure it is installed
Error: ${err.message}`
              );
            }
            throw err;
          } finally {
            registerer.enabled(false);
          }
        }));
      };
    };
    rc = withTypeScriptLoader((ctx, path9, options2) => {
      ctx = createContext(ctx);
      path9 = path9 ? resolve3(path9) : process.cwd();
      return config$1.lilconfig("postcss", options2).search(path9).then((result) => {
        if (!result) {
          throw new Error(`No PostCSS Config found in: ${path9}`);
        }
        return processResult(ctx, result);
      });
    });
    RegularExpressionLiteral = /\/(?![*\/])(?:\[(?:[^\]\\\n\r\u2028\u2029]+|\\.)*\]|[^\/\\\n\r\u2028\u2029]+|\\.)*(\/[$_\u200C\u200D\p{ID_Continue}]*|\\)?/yu;
    Punctuator = /--|\+\+|=>|\.{3}|\??\.(?!\d)|(?:&&|\|\||\?\?|[+\-%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2}|\/(?![\/*]))=?|[?~,:;[\](){}]/y;
    Identifier = /(\x23?)(?=[$_\p{ID_Start}\\])(?:[$_\u200C\u200D\p{ID_Continue}]+|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+/yu;
    StringLiteral = /(['"])(?:[^'"\\\n\r]+|(?!\1)['"]|\\(?:\r\n|[^]))*(\1)?/y;
    NumericLiteral = /(?:0[xX][\da-fA-F](?:_?[\da-fA-F])*|0[oO][0-7](?:_?[0-7])*|0[bB][01](?:_?[01])*)n?|0n|[1-9](?:_?\d)*n|(?:(?:0(?!\d)|0\d*[89]\d*|[1-9](?:_?\d)*)(?:\.(?:\d(?:_?\d)*)?)?|\.\d(?:_?\d)*)(?:[eE][+-]?\d(?:_?\d)*)?|0[0-7]+/y;
    Template = /[`}](?:[^`\\$]+|\\[^]|\$(?!\{))*(`|\$\{)?/y;
    WhiteSpace = /[\t\v\f\ufeff\p{Zs}]+/yu;
    LineTerminatorSequence = /\r?\n|[\r\u2028\u2029]/y;
    MultiLineComment = /\/\*(?:[^*]+|\*(?!\/))*(\*\/)?/y;
    SingleLineComment = /\/\/.*/y;
    HashbangComment = /^#!.*/;
    JSXPunctuator = /[<>.:={}]|\/(?![\/*])/y;
    JSXIdentifier = /[$_\p{ID_Start}][$_\u200C\u200D\p{ID_Continue}-]*/yu;
    JSXString = /(['"])(?:[^'"]+|(?!\1)['"])*(\1)?/y;
    JSXText = /[^<>{}]+/y;
    TokensPrecedingExpression = /^(?:[\/+-]|\.{3}|\?(?:InterpolationIn(?:JSX|Template)|NoLineTerminatorHere|NonExpressionParenEnd|UnaryIncDec))?$|[{}([,;<>=*%&|^!~?:]$/;
    TokensNotPrecedingObjectLiteral = /^(?:=>|[;\]){}]|else|\?(?:NoLineTerminatorHere|NonExpressionParenEnd))?$/;
    KeywordsWithExpressionAfter = /^(?:await|case|default|delete|do|else|instanceof|new|return|throw|typeof|void|yield)$/;
    KeywordsWithNoLineTerminatorAfter = /^(?:return|throw|yield)$/;
    Newline = RegExp(LineTerminatorSequence.source);
    main$1 = { exports: {} };
    name = "dotenv";
    version$1 = "16.4.5";
    description = "Loads environment variables from .env file";
    main = "lib/main.js";
    types2 = "lib/main.d.ts";
    exports = {
      ".": {
        types: "./lib/main.d.ts",
        require: "./lib/main.js",
        "default": "./lib/main.js"
      },
      "./config": "./config.js",
      "./config.js": "./config.js",
      "./lib/env-options": "./lib/env-options.js",
      "./lib/env-options.js": "./lib/env-options.js",
      "./lib/cli-options": "./lib/cli-options.js",
      "./lib/cli-options.js": "./lib/cli-options.js",
      "./package.json": "./package.json"
    };
    scripts = {
      "dts-check": "tsc --project tests/types/tsconfig.json",
      lint: "standard",
      "lint-readme": "standard-markdown",
      pretest: "npm run lint && npm run dts-check",
      test: "tap tests/*.js --100 -Rspec",
      "test:coverage": "tap --coverage-report=lcov",
      prerelease: "npm test",
      release: "standard-version"
    };
    repository = {
      type: "git",
      url: "git://github.com/motdotla/dotenv.git"
    };
    funding = "https://dotenvx.com";
    keywords = [
      "dotenv",
      "env",
      ".env",
      "environment",
      "variables",
      "config",
      "settings"
    ];
    readmeFilename = "README.md";
    license = "BSD-2-Clause";
    devDependencies = {
      "@definitelytyped/dtslint": "^0.0.133",
      "@types/node": "^18.11.3",
      decache: "^4.6.1",
      sinon: "^14.0.1",
      standard: "^17.0.0",
      "standard-markdown": "^7.1.0",
      "standard-version": "^9.5.0",
      tap: "^16.3.0",
      tar: "^6.1.11",
      typescript: "^4.8.4"
    };
    engines = {
      node: ">=12"
    };
    browser$1 = {
      fs: false
    };
    require$$4 = {
      name,
      version: version$1,
      description,
      main,
      types: types2,
      exports,
      scripts,
      repository,
      funding,
      keywords,
      readmeFilename,
      license,
      devDependencies,
      engines,
      browser: browser$1
    };
    fs$9 = require$$0__default3;
    path$9 = require$$0$4;
    os$2 = require$$2;
    crypto$1 = require$$3$1;
    packageJson = require$$4;
    version2 = packageJson.version;
    LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config,
      decrypt,
      parse: parse$9,
      populate
    };
    main$1.exports.configDotenv = DotenvModule.configDotenv;
    main$1.exports._configVault = DotenvModule._configVault;
    main$1.exports._parseVault = DotenvModule._parseVault;
    main$1.exports.config = DotenvModule.config;
    main$1.exports.decrypt = DotenvModule.decrypt;
    parse_1$1 = main$1.exports.parse = DotenvModule.parse;
    main$1.exports.populate = DotenvModule.populate;
    main$1.exports = DotenvModule;
    modulePreloadPolyfillId = "vite/modulepreload-polyfill";
    resolvedModulePreloadPolyfillId = "\0" + modulePreloadPolyfillId + ".js";
    moduleScriptRE = /[ \t]*<script[^>]*type\s*=\s*(?:"module"|'module'|module)[^>]*>/i;
    modulePreloadLinkRE = /[ \t]*<link[^>]*rel\s*=\s*(?:"modulepreload"|'modulepreload'|modulepreload)[\s\S]*?\/>/i;
    importMapAppendRE = new RegExp(
      [moduleScriptRE, modulePreloadLinkRE].map((r) => r.source).join("|"),
      "i"
    );
    decoder = new TextDecoder();
    cssModuleRE = new RegExp(`\\.module${CSS_LANGS_RE.source}`);
    functionCallRE = /^[A-Z_][\w-]*\(/i;
    nonEscapedDoubleQuoteRe = /(?<!\\)"/g;
    importPostcssImport = createCachedImport(() => Promise.resolve().then(() => (init_dep_COdkJwUb(), dep_COdkJwUb_exports)).then(function(n) {
      return n.i;
    }));
    importPostcssModules = createCachedImport(() => Promise.resolve().then(() => (init_dep_CEGXe0Sr(), dep_CEGXe0Sr_exports)).then(function(n) {
      return n.i;
    }));
    importPostcss = createCachedImport(() => Promise.resolve().then(() => (init_postcss(), postcss_exports)));
    cssUrlRE = /(?<=^|[^\w\-\u0080-\uffff])url\((\s*('[^']+'|"[^"]+")\s*|[^'")]+)\)/;
    cssImageSetRE = /(?<=image-set\()((?:[\w\-]{1,256}\([^)]*\)|[^)])*)(?=\))/;
    UrlRewritePostcssPlugin = (opts) => {
      if (!opts) {
        throw new Error("base or replace is required");
      }
      return {
        postcssPlugin: "vite-url-rewrite",
        Once(root4) {
          const promises = [];
          root4.walkDecls((declaration) => {
            const importer = declaration.source?.input.file;
            if (!importer) {
              opts.logger.warnOnce(
                "\nA PostCSS plugin did not pass the `from` option to `postcss.parse`. This may cause imported assets to be incorrectly transformed. If you've recently added a PostCSS plugin that raised this warning, please contact the package author to fix the issue."
              );
            }
            const isCssUrl = cssUrlRE.test(declaration.value);
            const isCssImageSet = cssImageSetRE.test(declaration.value);
            if (isCssUrl || isCssImageSet) {
              const replacerForDeclaration = (rawUrl) => {
                return opts.replacer(rawUrl, importer);
              };
              const rewriterToUse = isCssImageSet ? rewriteCssImageSet : rewriteCssUrls;
              promises.push(
                rewriterToUse(declaration.value, replacerForDeclaration).then(
                  (url2) => {
                    declaration.value = url2;
                  }
                )
              );
            }
          });
          if (promises.length) {
            return Promise.all(promises);
          }
        }
      };
    };
    UrlRewritePostcssPlugin.postcss = true;
    cssNotProcessedRE = /(?:gradient|element|cross-fade|image)\(/;
    importLightningCSS = createCachedImport(() => Promise.resolve().then(() => (init_node(), node_exports)));
    new Set(builtinModules);
    own$1 = {}.hasOwnProperty;
    classRegExp = /^([A-Z][a-z\d]*)+$/;
    kTypes = /* @__PURE__ */ new Set([
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ]);
    messages = /* @__PURE__ */ new Map();
    nodeInternalPrefix = "__node_internal_";
    createError2(
      "ERR_INVALID_ARG_TYPE",
      /**
       * @param {string} name
       * @param {Array<string> | string} expected
       * @param {unknown} actual
       */
      (name2, expected, actual) => {
        assert$1(typeof name2 === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let message = "The ";
        if (name2.endsWith(" argument")) {
          message += `${name2} `;
        } else {
          const type = name2.includes(".") ? "property" : "argument";
          message += `"${name2}" ${type} `;
        }
        message += "must be ";
        const types3 = [];
        const instances = [];
        const other = [];
        for (const value2 of expected) {
          assert$1(
            typeof value2 === "string",
            "All expected entries have to be of type string"
          );
          if (kTypes.has(value2)) {
            types3.push(value2.toLowerCase());
          } else if (classRegExp.exec(value2) === null) {
            assert$1(
              value2 !== "object",
              'The value "object" should be written as "Object"'
            );
            other.push(value2);
          } else {
            instances.push(value2);
          }
        }
        if (instances.length > 0) {
          const pos = types3.indexOf("object");
          if (pos !== -1) {
            types3.slice(pos, 1);
            instances.push("Object");
          }
        }
        if (types3.length > 0) {
          message += `${types3.length > 1 ? "one of type" : "of type"} ${formatList(
            types3,
            "or"
          )}`;
          if (instances.length > 0 || other.length > 0) message += " or ";
        }
        if (instances.length > 0) {
          message += `an instance of ${formatList(instances, "or")}`;
          if (other.length > 0) message += " or ";
        }
        if (other.length > 0) {
          if (other.length > 1) {
            message += `one of ${formatList(other, "or")}`;
          } else {
            if (other[0].toLowerCase() !== other[0]) message += "an ";
            message += `${other[0]}`;
          }
        }
        message += `. Received ${determineSpecificType(actual)}`;
        return message;
      },
      TypeError
    );
    createError2(
      "ERR_INVALID_MODULE_SPECIFIER",
      /**
       * @param {string} request
       * @param {string} reason
       * @param {string} [base]
       */
      (request, reason, base = void 0) => {
        return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
      },
      TypeError
    );
    createError2(
      "ERR_INVALID_PACKAGE_CONFIG",
      /**
       * @param {string} path
       * @param {string} [base]
       * @param {string} [message]
       */
      (path9, base, message) => {
        return `Invalid package config ${path9}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
      },
      Error
    );
    createError2(
      "ERR_INVALID_PACKAGE_TARGET",
      /**
       * @param {string} packagePath
       * @param {string} key
       * @param {unknown} target
       * @param {boolean} [isImport=false]
       * @param {string} [base]
       */
      (packagePath, key, target, isImport = false, base = void 0) => {
        const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
        if (key === ".") {
          assert$1(isImport === false);
          return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
        }
        return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(
          target
        )} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
      },
      Error
    );
    createError2(
      "ERR_MODULE_NOT_FOUND",
      /**
       * @param {string} path
       * @param {string} base
       * @param {boolean} [exactUrl]
       */
      (path9, base, exactUrl = false) => {
        return `Cannot find ${exactUrl ? "module" : "package"} '${path9}' imported from ${base}`;
      },
      Error
    );
    createError2(
      "ERR_NETWORK_IMPORT_DISALLOWED",
      "import of '%s' by %s is not supported: %s",
      Error
    );
    createError2(
      "ERR_PACKAGE_IMPORT_NOT_DEFINED",
      /**
       * @param {string} specifier
       * @param {string} packagePath
       * @param {string} base
       */
      (specifier, packagePath, base) => {
        return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
      },
      TypeError
    );
    createError2(
      "ERR_PACKAGE_PATH_NOT_EXPORTED",
      /**
       * @param {string} packagePath
       * @param {string} subpath
       * @param {string} [base]
       */
      (packagePath, subpath, base = void 0) => {
        if (subpath === ".")
          return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
        return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
      },
      Error
    );
    createError2(
      "ERR_UNSUPPORTED_DIR_IMPORT",
      "Directory import '%s' is not supported resolving ES modules imported from %s",
      Error
    );
    createError2(
      "ERR_UNSUPPORTED_RESOLVE_REQUEST",
      'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.',
      TypeError
    );
    createError2(
      "ERR_UNKNOWN_FILE_EXTENSION",
      /**
       * @param {string} extension
       * @param {string} path
       */
      (extension2, path9) => {
        return `Unknown file extension "${extension2}" for ${path9}`;
      },
      TypeError
    );
    createError2(
      "ERR_INVALID_ARG_VALUE",
      /**
       * @param {string} name
       * @param {unknown} value
       * @param {string} [reason='is invalid']
       */
      (name2, value2, reason = "is invalid") => {
        let inspected = inspect(value2);
        if (inspected.length > 128) {
          inspected = `${inspected.slice(0, 128)}...`;
        }
        const type = name2.includes(".") ? "property" : "argument";
        return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
      },
      TypeError
      // Note: extra classes have been shaken out.
      // , RangeError
    );
    captureLargerStackTrace = hideStackFrames(
      /**
       * @param {Error} error
       * @returns {Error}
       */
      // @ts-expect-error: fine
      function(error) {
        const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();
        if (stackTraceLimitIsWritable) {
          userStackTraceLimit = Error.stackTraceLimit;
          Error.stackTraceLimit = Number.POSITIVE_INFINITY;
        }
        Error.captureStackTrace(error);
        if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;
        return error;
      }
    );
    ({ isMatch: isMatch$1, scan } = micromatch$2);
    ({ basename, dirname, relative, join } = posix$1);
    src2 = { exports: {} };
    browser = { exports: {} };
    debug$f = { exports: {} };
    node2 = { exports: {} };
    if (typeof process !== "undefined" && process.type === "renderer") {
      src2.exports = requireBrowser();
    } else {
      src2.exports = requireNode();
    }
    srcExports2 = src2.exports;
    encodeurl = encodeUrl$1;
    ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
    UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
    UNMATCHED_SURROGATE_PAIR_REPLACE = "$1\uFFFD$2";
    matchHtmlRegExp = /["'&<>]/;
    escapeHtml_1 = escapeHtml$1;
    onFinished$2 = { exports: {} };
    eeFirst = first$1;
    onFinished$2.exports = onFinished$1;
    onFinished$2.exports.isFinished = isFinished$1;
    first = eeFirst;
    defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    onFinishedExports = onFinished$2.exports;
    parseurl$1 = { exports: {} };
    url$3 = require$$0$9;
    parse$8 = url$3.parse;
    Url = url$3.Url;
    parseurl$1.exports = parseurl;
    parseurl$1.exports.original = originalurl;
    parseurlExports = parseurl$1.exports;
    require$$0$12 = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "(Unused)",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Unordered Collection",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "509": "Bandwidth Limit Exceeded",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    codes = require$$0$12;
    statuses$1 = status;
    status.STATUS_CODES = codes;
    status.codes = populateStatusesMap(status, codes);
    status.redirect = {
      300: true,
      301: true,
      302: true,
      303: true,
      305: true,
      307: true,
      308: true
    };
    status.empty = {
      204: true,
      205: true,
      304: true
    };
    status.retry = {
      502: true,
      503: true,
      504: true
    };
    unpipe_1 = unpipe$1;
    debug$e = srcExports2("finalhandler");
    encodeUrl = encodeurl;
    escapeHtml = escapeHtml_1;
    onFinished = onFinishedExports;
    parseUrl$2 = parseurlExports;
    statuses = statuses$1;
    unpipe = unpipe_1;
    DOUBLE_SPACE_REGEXP = /\x20{2}/g;
    NEWLINE_REGEXP = /\n/g;
    defer$1 = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    isFinished = onFinished.isFinished;
    finalhandler_1 = finalhandler$1;
    utilsMerge = { exports: {} };
    (function(module, exports2) {
      module.exports = function(a, b) {
        if (a && b) {
          for (var key in b) {
            a[key] = b[key];
          }
        }
        return a;
      };
    })(utilsMerge);
    utilsMergeExports = utilsMerge.exports;
    debug$d = srcExports2("connect:dispatcher");
    EventEmitter$3 = require$$0$7.EventEmitter;
    finalhandler = finalhandler_1;
    http$4 = require$$1;
    parseUrl$1 = parseurlExports;
    env = process.env.NODE_ENV || "development";
    proto = {};
    defer = typeof setImmediate === "function" ? setImmediate : function(fn) {
      process.nextTick(fn.bind.apply(fn, arguments));
    };
    proto.use = function use(route, fn) {
      var handle2 = fn;
      var path9 = route;
      if (typeof route !== "string") {
        handle2 = route;
        path9 = "/";
      }
      if (typeof handle2.handle === "function") {
        var server = handle2;
        server.route = path9;
        handle2 = function(req2, res, next) {
          server.handle(req2, res, next);
        };
      }
      if (handle2 instanceof http$4.Server) {
        handle2 = handle2.listeners("request")[0];
      }
      if (path9[path9.length - 1] === "/") {
        path9 = path9.slice(0, -1);
      }
      debug$d("use %s %s", path9 || "/", handle2.name || "anonymous");
      this.stack.push({ route: path9, handle: handle2 });
      return this;
    };
    proto.handle = function handle(req2, res, out) {
      var index4 = 0;
      var protohost = getProtohost(req2.url) || "";
      var removed = "";
      var slashAdded = false;
      var stack = this.stack;
      var done = out || finalhandler(req2, res, {
        env,
        onerror: logerror
      });
      req2.originalUrl = req2.originalUrl || req2.url;
      function next(err) {
        if (slashAdded) {
          req2.url = req2.url.substr(1);
          slashAdded = false;
        }
        if (removed.length !== 0) {
          req2.url = protohost + removed + req2.url.substr(protohost.length);
          removed = "";
        }
        var layer = stack[index4++];
        if (!layer) {
          defer(done, err);
          return;
        }
        var path9 = parseUrl$1(req2).pathname || "/";
        var route = layer.route;
        if (path9.toLowerCase().substr(0, route.length) !== route.toLowerCase()) {
          return next(err);
        }
        var c = path9.length > route.length && path9[route.length];
        if (c && c !== "/" && c !== ".") {
          return next(err);
        }
        if (route.length !== 0 && route !== "/") {
          removed = route;
          req2.url = protohost + req2.url.substr(protohost.length + removed.length);
          if (!protohost && req2.url[0] !== "/") {
            req2.url = "/" + req2.url;
            slashAdded = true;
          }
        }
        call(layer.handle, route, err, req2, res, next);
      }
      next();
    };
    proto.listen = function listen() {
      var server = http$4.createServer(this);
      return server.listen.apply(server, arguments);
    };
    lib2 = { exports: {} };
    getOwnPropertySymbols = Object.getOwnPropertySymbols;
    hasOwnProperty3 = Object.prototype.hasOwnProperty;
    propIsEnumerable = Object.prototype.propertyIsEnumerable;
    objectAssign = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty3.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
    vary$1 = { exports: {} };
    vary$1.exports = vary;
    vary$1.exports.append = append;
    FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
    varyExports = vary$1.exports;
    (function() {
      var assign = objectAssign;
      var vary2 = varyExports;
      var defaults2 = {
        origin: "*",
        methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
        preflightContinue: false,
        optionsSuccessStatus: 204
      };
      function isString3(s) {
        return typeof s === "string" || s instanceof String;
      }
      function isOriginAllowed(origin, allowedOrigin) {
        if (Array.isArray(allowedOrigin)) {
          for (var i = 0; i < allowedOrigin.length; ++i) {
            if (isOriginAllowed(origin, allowedOrigin[i])) {
              return true;
            }
          }
          return false;
        } else if (isString3(allowedOrigin)) {
          return origin === allowedOrigin;
        } else if (allowedOrigin instanceof RegExp) {
          return allowedOrigin.test(origin);
        } else {
          return !!allowedOrigin;
        }
      }
      function configureOrigin(options2, req2) {
        var requestOrigin = req2.headers.origin, headers = [], isAllowed;
        if (!options2.origin || options2.origin === "*") {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: "*"
          }]);
        } else if (isString3(options2.origin)) {
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: options2.origin
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        } else {
          isAllowed = isOriginAllowed(requestOrigin, options2.origin);
          headers.push([{
            key: "Access-Control-Allow-Origin",
            value: isAllowed ? requestOrigin : false
          }]);
          headers.push([{
            key: "Vary",
            value: "Origin"
          }]);
        }
        return headers;
      }
      function configureMethods(options2) {
        var methods = options2.methods;
        if (methods.join) {
          methods = options2.methods.join(",");
        }
        return {
          key: "Access-Control-Allow-Methods",
          value: methods
        };
      }
      function configureCredentials(options2) {
        if (options2.credentials === true) {
          return {
            key: "Access-Control-Allow-Credentials",
            value: "true"
          };
        }
        return null;
      }
      function configureAllowedHeaders(options2, req2) {
        var allowedHeaders = options2.allowedHeaders || options2.headers;
        var headers = [];
        if (!allowedHeaders) {
          allowedHeaders = req2.headers["access-control-request-headers"];
          headers.push([{
            key: "Vary",
            value: "Access-Control-Request-Headers"
          }]);
        } else if (allowedHeaders.join) {
          allowedHeaders = allowedHeaders.join(",");
        }
        if (allowedHeaders && allowedHeaders.length) {
          headers.push([{
            key: "Access-Control-Allow-Headers",
            value: allowedHeaders
          }]);
        }
        return headers;
      }
      function configureExposedHeaders(options2) {
        var headers = options2.exposedHeaders;
        if (!headers) {
          return null;
        } else if (headers.join) {
          headers = headers.join(",");
        }
        if (headers && headers.length) {
          return {
            key: "Access-Control-Expose-Headers",
            value: headers
          };
        }
        return null;
      }
      function configureMaxAge(options2) {
        var maxAge = (typeof options2.maxAge === "number" || options2.maxAge) && options2.maxAge.toString();
        if (maxAge && maxAge.length) {
          return {
            key: "Access-Control-Max-Age",
            value: maxAge
          };
        }
        return null;
      }
      function applyHeaders(headers, res) {
        for (var i = 0, n = headers.length; i < n; i++) {
          var header = headers[i];
          if (header) {
            if (Array.isArray(header)) {
              applyHeaders(header, res);
            } else if (header.key === "Vary" && header.value) {
              vary2(res, header.value);
            } else if (header.value) {
              res.setHeader(header.key, header.value);
            }
          }
        }
      }
      function cors(options2, req2, res, next) {
        var headers = [], method = req2.method && req2.method.toUpperCase && req2.method.toUpperCase();
        if (method === "OPTIONS") {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureMethods(options2));
          headers.push(configureAllowedHeaders(options2, req2));
          headers.push(configureMaxAge(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          if (options2.preflightContinue) {
            next();
          } else {
            res.statusCode = options2.optionsSuccessStatus;
            res.setHeader("Content-Length", "0");
            res.end();
          }
        } else {
          headers.push(configureOrigin(options2, req2));
          headers.push(configureCredentials(options2));
          headers.push(configureExposedHeaders(options2));
          applyHeaders(headers, res);
          next();
        }
      }
      function middlewareWrapper(o) {
        var optionsCallback = null;
        if (typeof o === "function") {
          optionsCallback = o;
        } else {
          optionsCallback = function(req2, cb) {
            cb(null, o);
          };
        }
        return function corsMiddleware(req2, res, next) {
          optionsCallback(req2, function(err, options2) {
            if (err) {
              next(err);
            } else {
              var corsOptions = assign({}, defaults2, options2);
              var originCallback = null;
              if (corsOptions.origin && typeof corsOptions.origin === "function") {
                originCallback = corsOptions.origin;
              } else if (corsOptions.origin) {
                originCallback = function(origin, cb) {
                  cb(null, corsOptions.origin);
                };
              }
              if (originCallback) {
                originCallback(req2.headers.origin, function(err2, origin) {
                  if (err2 || !origin) {
                    next(err2);
                  } else {
                    corsOptions.origin = origin;
                    cors(corsOptions, req2, res, next);
                  }
                });
              } else {
                next();
              }
            }
          });
        };
      }
      lib2.exports = middlewareWrapper;
    })();
    libExports = lib2.exports;
    chokidar = {};
    fs$8 = require$$0__default3;
    ({ Readable } = require$$0$6);
    sysPath$3 = require$$0$4;
    ({ promisify: promisify$3 } = require$$0$5);
    picomatch$1 = picomatch$3;
    readdir$1 = promisify$3(fs$8.readdir);
    stat$3 = promisify$3(fs$8.stat);
    lstat$2 = promisify$3(fs$8.lstat);
    realpath$1 = promisify$3(fs$8.realpath);
    BANG$2 = "!";
    RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
    NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
    FILE_TYPE = "files";
    DIR_TYPE = "directories";
    FILE_DIR_TYPE = "files_directories";
    EVERYTHING_TYPE = "all";
    ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
    isNormalFlowError = (error) => NORMAL_FLOW_ERRORS.has(error.code);
    [maj, min] = process.versions.node.split(".").slice(0, 2).map((n) => Number.parseInt(n, 10));
    wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
    normalizeFilter = (filter2) => {
      if (filter2 === void 0) return;
      if (typeof filter2 === "function") return filter2;
      if (typeof filter2 === "string") {
        const glob = picomatch$1(filter2.trim());
        return (entry2) => glob(entry2.basename);
      }
      if (Array.isArray(filter2)) {
        const positive = [];
        const negative = [];
        for (const item of filter2) {
          const trimmed = item.trim();
          if (trimmed.charAt(0) === BANG$2) {
            negative.push(picomatch$1(trimmed.slice(1)));
          } else {
            positive.push(picomatch$1(trimmed));
          }
        }
        if (negative.length > 0) {
          if (positive.length > 0) {
            return (entry2) => positive.some((f) => f(entry2.basename)) && !negative.some((f) => f(entry2.basename));
          }
          return (entry2) => !negative.some((f) => f(entry2.basename));
        }
        return (entry2) => positive.some((f) => f(entry2.basename));
      }
    };
    ReaddirpStream = class _ReaddirpStream extends Readable {
      static get defaultOptions() {
        return {
          root: ".",
          /* eslint-disable no-unused-vars */
          fileFilter: (path9) => true,
          directoryFilter: (path9) => true,
          /* eslint-enable no-unused-vars */
          type: FILE_TYPE,
          lstat: false,
          depth: 2147483648,
          alwaysStat: false
        };
      }
      constructor(options2 = {}) {
        super({
          objectMode: true,
          autoDestroy: true,
          highWaterMark: options2.highWaterMark || 4096
        });
        const opts = { ..._ReaddirpStream.defaultOptions, ...options2 };
        const { root: root4, type } = opts;
        this._fileFilter = normalizeFilter(opts.fileFilter);
        this._directoryFilter = normalizeFilter(opts.directoryFilter);
        const statMethod = opts.lstat ? lstat$2 : stat$3;
        if (wantBigintFsStats) {
          this._stat = (path9) => statMethod(path9, { bigint: true });
        } else {
          this._stat = statMethod;
        }
        this._maxDepth = opts.depth;
        this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);
        this._wantsEverything = type === EVERYTHING_TYPE;
        this._root = sysPath$3.resolve(root4);
        this._isDirent = "Dirent" in fs$8 && !opts.alwaysStat;
        this._statsProp = this._isDirent ? "dirent" : "stats";
        this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
        this.parents = [this._exploreDir(root4, 1)];
        this.reading = false;
        this.parent = void 0;
      }
      async _read(batch) {
        if (this.reading) return;
        this.reading = true;
        try {
          while (!this.destroyed && batch > 0) {
            const { path: path9, depth: depth2, files = [] } = this.parent || {};
            if (files.length > 0) {
              const slice2 = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path9));
              for (const entry2 of await Promise.all(slice2)) {
                if (this.destroyed) return;
                const entryType = await this._getEntryType(entry2);
                if (entryType === "directory" && this._directoryFilter(entry2)) {
                  if (depth2 <= this._maxDepth) {
                    this.parents.push(this._exploreDir(entry2.fullPath, depth2 + 1));
                  }
                  if (this._wantsDir) {
                    this.push(entry2);
                    batch--;
                  }
                } else if ((entryType === "file" || this._includeAsFile(entry2)) && this._fileFilter(entry2)) {
                  if (this._wantsFile) {
                    this.push(entry2);
                    batch--;
                  }
                }
              }
            } else {
              const parent = this.parents.pop();
              if (!parent) {
                this.push(null);
                break;
              }
              this.parent = await parent;
              if (this.destroyed) return;
            }
          }
        } catch (error) {
          this.destroy(error);
        } finally {
          this.reading = false;
        }
      }
      async _exploreDir(path9, depth2) {
        let files;
        try {
          files = await readdir$1(path9, this._rdOptions);
        } catch (error) {
          this._onError(error);
        }
        return { files, depth: depth2, path: path9 };
      }
      async _formatEntry(dirent, path9) {
        let entry2;
        try {
          const basename2 = this._isDirent ? dirent.name : dirent;
          const fullPath = sysPath$3.resolve(sysPath$3.join(path9, basename2));
          entry2 = { path: sysPath$3.relative(this._root, fullPath), fullPath, basename: basename2 };
          entry2[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
        } catch (err) {
          this._onError(err);
        }
        return entry2;
      }
      _onError(err) {
        if (isNormalFlowError(err) && !this.destroyed) {
          this.emit("warn", err);
        } else {
          this.destroy(err);
        }
      }
      async _getEntryType(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        if (!stats) {
          return;
        }
        if (stats.isFile()) {
          return "file";
        }
        if (stats.isDirectory()) {
          return "directory";
        }
        if (stats && stats.isSymbolicLink()) {
          const full = entry2.fullPath;
          try {
            const entryRealPath = await realpath$1(full);
            const entryRealPathStats = await lstat$2(entryRealPath);
            if (entryRealPathStats.isFile()) {
              return "file";
            }
            if (entryRealPathStats.isDirectory()) {
              const len = entryRealPath.length;
              if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath$3.sep) {
                const recursiveError = new Error(
                  `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                );
                recursiveError.code = RECURSIVE_ERROR_CODE;
                return this._onError(recursiveError);
              }
              return "directory";
            }
          } catch (error) {
            this._onError(error);
          }
        }
      }
      _includeAsFile(entry2) {
        const stats = entry2 && entry2[this._statsProp];
        return stats && this._wantsEverything && !stats.isDirectory();
      }
    };
    readdirp$1 = (root4, options2 = {}) => {
      let type = options2.entryType || options2.type;
      if (type === "both") type = FILE_DIR_TYPE;
      if (type) options2.type = type;
      if (!root4) {
        throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
      } else if (typeof root4 !== "string") {
        throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
      } else if (type && !ALL_TYPES.includes(type)) {
        throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
      }
      options2.root = root4;
      return new ReaddirpStream(options2);
    };
    readdirpPromise = (root4, options2 = {}) => {
      return new Promise((resolve8, reject) => {
        const files = [];
        readdirp$1(root4, options2).on("data", (entry2) => files.push(entry2)).on("end", () => resolve8(files)).on("error", (error) => reject(error));
      });
    };
    readdirp$1.promise = readdirpPromise;
    readdirp$1.ReaddirpStream = ReaddirpStream;
    readdirp$1.default = readdirp$1;
    readdirp_1 = readdirp$1;
    anymatch$2 = { exports: {} };
    normalizePath$2 = function(path9, stripTrailing) {
      if (typeof path9 !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path9 === "\\" || path9 === "/") return "/";
      var len = path9.length;
      if (len <= 1) return path9;
      var prefix = "";
      if (len > 4 && path9[3] === "\\") {
        var ch = path9[2];
        if ((ch === "?" || ch === ".") && path9.slice(0, 2) === "\\\\") {
          path9 = path9.slice(2);
          prefix = "//";
        }
      }
      var segs = path9.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
    anymatch_1 = anymatch$2.exports;
    Object.defineProperty(anymatch_1, "__esModule", { value: true });
    picomatch = picomatch$3;
    normalizePath$1 = normalizePath$2;
    BANG$1 = "!";
    DEFAULT_OPTIONS = { returnIndex: false };
    arrify$1 = (item) => Array.isArray(item) ? item : [item];
    createPattern = (matcher2, options2) => {
      if (typeof matcher2 === "function") {
        return matcher2;
      }
      if (typeof matcher2 === "string") {
        const glob = picomatch(matcher2, options2);
        return (string4) => matcher2 === string4 || glob(string4);
      }
      if (matcher2 instanceof RegExp) {
        return (string4) => matcher2.test(string4);
      }
      return (string4) => false;
    };
    matchPatterns = (patterns, negPatterns, args, returnIndex) => {
      const isList = Array.isArray(args);
      const _path2 = isList ? args[0] : args;
      if (!isList && typeof _path2 !== "string") {
        throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path2));
      }
      const path9 = normalizePath$1(_path2);
      for (let index4 = 0; index4 < negPatterns.length; index4++) {
        const nglob = negPatterns[index4];
        if (nglob(path9)) {
          return returnIndex ? -1 : false;
        }
      }
      const applied = isList && [path9].concat(args.slice(1));
      for (let index4 = 0; index4 < patterns.length; index4++) {
        const pattern2 = patterns[index4];
        if (isList ? pattern2(...applied) : pattern2(path9)) {
          return returnIndex ? index4 : true;
        }
      }
      return returnIndex ? -1 : false;
    };
    anymatch$1 = (matchers, testString, options2 = DEFAULT_OPTIONS) => {
      if (matchers == null) {
        throw new TypeError("anymatch: specify first argument");
      }
      const opts = typeof options2 === "boolean" ? { returnIndex: options2 } : options2;
      const returnIndex = opts.returnIndex || false;
      const mtchers = arrify$1(matchers);
      const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG$1).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
      const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG$1).map((matcher2) => createPattern(matcher2, opts));
      if (testString == null) {
        return (testString2, ri = false) => {
          const returnIndex2 = typeof ri === "boolean" ? ri : false;
          return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
        };
      }
      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
    };
    anymatch$1.default = anymatch$1;
    anymatch$2.exports = anymatch$1;
    anymatchExports = anymatch$2.exports;
    require$$02 = [
      "3dm",
      "3ds",
      "3g2",
      "3gp",
      "7z",
      "a",
      "aac",
      "adp",
      "ai",
      "aif",
      "aiff",
      "alz",
      "ape",
      "apk",
      "appimage",
      "ar",
      "arj",
      "asf",
      "au",
      "avi",
      "bak",
      "baml",
      "bh",
      "bin",
      "bk",
      "bmp",
      "btif",
      "bz2",
      "bzip2",
      "cab",
      "caf",
      "cgm",
      "class",
      "cmx",
      "cpio",
      "cr2",
      "cur",
      "dat",
      "dcm",
      "deb",
      "dex",
      "djvu",
      "dll",
      "dmg",
      "dng",
      "doc",
      "docm",
      "docx",
      "dot",
      "dotm",
      "dra",
      "DS_Store",
      "dsk",
      "dts",
      "dtshd",
      "dvb",
      "dwg",
      "dxf",
      "ecelp4800",
      "ecelp7470",
      "ecelp9600",
      "egg",
      "eol",
      "eot",
      "epub",
      "exe",
      "f4v",
      "fbs",
      "fh",
      "fla",
      "flac",
      "flatpak",
      "fli",
      "flv",
      "fpx",
      "fst",
      "fvt",
      "g3",
      "gh",
      "gif",
      "graffle",
      "gz",
      "gzip",
      "h261",
      "h263",
      "h264",
      "icns",
      "ico",
      "ief",
      "img",
      "ipa",
      "iso",
      "jar",
      "jpeg",
      "jpg",
      "jpgv",
      "jpm",
      "jxr",
      "key",
      "ktx",
      "lha",
      "lib",
      "lvp",
      "lz",
      "lzh",
      "lzma",
      "lzo",
      "m3u",
      "m4a",
      "m4v",
      "mar",
      "mdi",
      "mht",
      "mid",
      "midi",
      "mj2",
      "mka",
      "mkv",
      "mmr",
      "mng",
      "mobi",
      "mov",
      "movie",
      "mp3",
      "mp4",
      "mp4a",
      "mpeg",
      "mpg",
      "mpga",
      "mxu",
      "nef",
      "npx",
      "numbers",
      "nupkg",
      "o",
      "odp",
      "ods",
      "odt",
      "oga",
      "ogg",
      "ogv",
      "otf",
      "ott",
      "pages",
      "pbm",
      "pcx",
      "pdb",
      "pdf",
      "pea",
      "pgm",
      "pic",
      "png",
      "pnm",
      "pot",
      "potm",
      "potx",
      "ppa",
      "ppam",
      "ppm",
      "pps",
      "ppsm",
      "ppsx",
      "ppt",
      "pptm",
      "pptx",
      "psd",
      "pya",
      "pyc",
      "pyo",
      "pyv",
      "qt",
      "rar",
      "ras",
      "raw",
      "resources",
      "rgb",
      "rip",
      "rlc",
      "rmf",
      "rmvb",
      "rpm",
      "rtf",
      "rz",
      "s3m",
      "s7z",
      "scpt",
      "sgi",
      "shar",
      "snap",
      "sil",
      "sketch",
      "slk",
      "smv",
      "snk",
      "so",
      "stl",
      "suo",
      "sub",
      "swf",
      "tar",
      "tbz",
      "tbz2",
      "tga",
      "tgz",
      "thmx",
      "tif",
      "tiff",
      "tlz",
      "ttc",
      "ttf",
      "txz",
      "udf",
      "uvh",
      "uvi",
      "uvm",
      "uvp",
      "uvs",
      "uvu",
      "viv",
      "vob",
      "war",
      "wav",
      "wax",
      "wbmp",
      "wdp",
      "weba",
      "webm",
      "webp",
      "whl",
      "wim",
      "wm",
      "wma",
      "wmv",
      "wmx",
      "woff",
      "woff2",
      "wrm",
      "wvx",
      "xbm",
      "xif",
      "xla",
      "xlam",
      "xls",
      "xlsb",
      "xlsm",
      "xlsx",
      "xlt",
      "xltm",
      "xltx",
      "xm",
      "xmind",
      "xpi",
      "xpm",
      "xwd",
      "xz",
      "z",
      "zip",
      "zipx"
    ];
    binaryExtensions$1 = require$$02;
    path$8 = require$$0$4;
    binaryExtensions = binaryExtensions$1;
    extensions = new Set(binaryExtensions);
    isBinaryPath$1 = (filePath) => extensions.has(path$8.extname(filePath).slice(1).toLowerCase());
    constants$1 = {};
    (function(exports2) {
      const { sep: sep2 } = require$$0$4;
      const { platform: platform2 } = process;
      const os2 = require$$2;
      exports2.EV_ALL = "all";
      exports2.EV_READY = "ready";
      exports2.EV_ADD = "add";
      exports2.EV_CHANGE = "change";
      exports2.EV_ADD_DIR = "addDir";
      exports2.EV_UNLINK = "unlink";
      exports2.EV_UNLINK_DIR = "unlinkDir";
      exports2.EV_RAW = "raw";
      exports2.EV_ERROR = "error";
      exports2.STR_DATA = "data";
      exports2.STR_END = "end";
      exports2.STR_CLOSE = "close";
      exports2.FSEVENT_CREATED = "created";
      exports2.FSEVENT_MODIFIED = "modified";
      exports2.FSEVENT_DELETED = "deleted";
      exports2.FSEVENT_MOVED = "moved";
      exports2.FSEVENT_CLONED = "cloned";
      exports2.FSEVENT_UNKNOWN = "unknown";
      exports2.FSEVENT_FLAG_MUST_SCAN_SUBDIRS = 1;
      exports2.FSEVENT_TYPE_FILE = "file";
      exports2.FSEVENT_TYPE_DIRECTORY = "directory";
      exports2.FSEVENT_TYPE_SYMLINK = "symlink";
      exports2.KEY_LISTENERS = "listeners";
      exports2.KEY_ERR = "errHandlers";
      exports2.KEY_RAW = "rawEmitters";
      exports2.HANDLER_KEYS = [exports2.KEY_LISTENERS, exports2.KEY_ERR, exports2.KEY_RAW];
      exports2.DOT_SLASH = `.${sep2}`;
      exports2.BACK_SLASH_RE = /\\/g;
      exports2.DOUBLE_SLASH_RE = /\/\//;
      exports2.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
      exports2.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
      exports2.REPLACER_RE = /^\.[/\\]/;
      exports2.SLASH = "/";
      exports2.SLASH_SLASH = "//";
      exports2.BRACE_START = "{";
      exports2.BANG = "!";
      exports2.ONE_DOT = ".";
      exports2.TWO_DOTS = "..";
      exports2.STAR = "*";
      exports2.GLOBSTAR = "**";
      exports2.ROOT_GLOBSTAR = "/**/*";
      exports2.SLASH_GLOBSTAR = "/**";
      exports2.DIR_SUFFIX = "Dir";
      exports2.ANYMATCH_OPTS = { dot: true };
      exports2.STRING_TYPE = "string";
      exports2.FUNCTION_TYPE = "function";
      exports2.EMPTY_STR = "";
      exports2.EMPTY_FN = () => {
      };
      exports2.IDENTITY_FN = (val) => val;
      exports2.isWindows = platform2 === "win32";
      exports2.isMacos = platform2 === "darwin";
      exports2.isLinux = platform2 === "linux";
      exports2.isIBMi = os2.type() === "OS400";
    })(constants$1);
    fs$7 = require$$0__default3;
    sysPath$2 = require$$0$4;
    ({ promisify: promisify$2 } = require$$0$5);
    isBinaryPath = isBinaryPath$1;
    ({
      isWindows: isWindows$2,
      isLinux,
      EMPTY_FN: EMPTY_FN$2,
      EMPTY_STR: EMPTY_STR$1,
      KEY_LISTENERS,
      KEY_ERR,
      KEY_RAW,
      HANDLER_KEYS,
      EV_CHANGE: EV_CHANGE$2,
      EV_ADD: EV_ADD$2,
      EV_ADD_DIR: EV_ADD_DIR$2,
      EV_ERROR: EV_ERROR$2,
      STR_DATA: STR_DATA$1,
      STR_END: STR_END$2,
      BRACE_START: BRACE_START$1,
      STAR
    } = constants$1);
    THROTTLE_MODE_WATCH = "watch";
    open$2 = promisify$2(fs$7.open);
    stat$2 = promisify$2(fs$7.stat);
    lstat$1 = promisify$2(fs$7.lstat);
    close = promisify$2(fs$7.close);
    fsrealpath = promisify$2(fs$7.realpath);
    statMethods$1 = { lstat: lstat$1, stat: stat$2 };
    foreach = (val, fn) => {
      if (val instanceof Set) {
        val.forEach(fn);
      } else {
        fn(val);
      }
    };
    addAndConvert = (main2, prop, item) => {
      let container2 = main2[prop];
      if (!(container2 instanceof Set)) {
        main2[prop] = container2 = /* @__PURE__ */ new Set([container2]);
      }
      container2.add(item);
    };
    clearItem = (cont) => (key) => {
      const set2 = cont[key];
      if (set2 instanceof Set) {
        set2.clear();
      } else {
        delete cont[key];
      }
    };
    delFromSet = (main2, prop, item) => {
      const container2 = main2[prop];
      if (container2 instanceof Set) {
        container2.delete(item);
      } else if (container2 === item) {
        delete main2[prop];
      }
    };
    isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
    FsWatchInstances = /* @__PURE__ */ new Map();
    fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
      const cont = FsWatchInstances.get(fullPath);
      if (!cont) return;
      foreach(cont[type], (listener2) => {
        listener2(val1, val2, val3);
      });
    };
    setFsWatchListener = (path9, fullPath, options2, handlers) => {
      const { listener: listener2, errHandler, rawEmitter } = handlers;
      let cont = FsWatchInstances.get(fullPath);
      let watcher;
      if (!options2.persistent) {
        watcher = createFsWatchInstance(
          path9,
          options2,
          listener2,
          errHandler,
          rawEmitter
        );
        return watcher.close.bind(watcher);
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_ERR, errHandler);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        watcher = createFsWatchInstance(
          path9,
          options2,
          fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
          errHandler,
          // no need to use broadcast here
          fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
        );
        if (!watcher) return;
        watcher.on(EV_ERROR$2, async (error) => {
          const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
          cont.watcherUnusable = true;
          if (isWindows$2 && error.code === "EPERM") {
            try {
              const fd = await open$2(path9, "r");
              await close(fd);
              broadcastErr(error);
            } catch (err) {
            }
          } else {
            broadcastErr(error);
          }
        });
        cont = {
          listeners: listener2,
          errHandlers: errHandler,
          rawEmitters: rawEmitter,
          watcher
        };
        FsWatchInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_ERR, errHandler);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          cont.watcher.close();
          FsWatchInstances.delete(fullPath);
          HANDLER_KEYS.forEach(clearItem(cont));
          cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    FsWatchFileInstances = /* @__PURE__ */ new Map();
    setFsWatchFileListener = (path9, fullPath, options2, handlers) => {
      const { listener: listener2, rawEmitter } = handlers;
      let cont = FsWatchFileInstances.get(fullPath);
      const copts = cont && cont.options;
      if (copts && (copts.persistent < options2.persistent || copts.interval > options2.interval)) {
        fs$7.unwatchFile(fullPath);
        cont = void 0;
      }
      if (cont) {
        addAndConvert(cont, KEY_LISTENERS, listener2);
        addAndConvert(cont, KEY_RAW, rawEmitter);
      } else {
        cont = {
          listeners: listener2,
          rawEmitters: rawEmitter,
          options: options2,
          watcher: fs$7.watchFile(fullPath, options2, (curr, prev) => {
            foreach(cont.rawEmitters, (rawEmitter2) => {
              rawEmitter2(EV_CHANGE$2, fullPath, { curr, prev });
            });
            const currmtime = curr.mtimeMs;
            if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
              foreach(cont.listeners, (listener3) => listener3(path9, curr));
            }
          })
        };
        FsWatchFileInstances.set(fullPath, cont);
      }
      return () => {
        delFromSet(cont, KEY_LISTENERS, listener2);
        delFromSet(cont, KEY_RAW, rawEmitter);
        if (isEmptySet(cont.listeners)) {
          FsWatchFileInstances.delete(fullPath);
          fs$7.unwatchFile(fullPath);
          cont.options = cont.watcher = void 0;
          Object.freeze(cont);
        }
      };
    };
    NodeFsHandler$1 = class NodeFsHandler {
      /**
       * @param {import("../index").FSWatcher} fsW
       */
      constructor(fsW) {
        this.fsw = fsW;
        this._boundHandleError = (error) => fsW._handleError(error);
      }
      /**
       * Watch file for changes with fs_watchFile or fs_watch.
       * @param {String} path to file or dir
       * @param {Function} listener on fs change
       * @returns {Function} closer for the watcher instance
       */
      _watchWithNodeFs(path9, listener2) {
        const opts = this.fsw.options;
        const directory = sysPath$2.dirname(path9);
        const basename2 = sysPath$2.basename(path9);
        const parent = this.fsw._getWatchedDir(directory);
        parent.add(basename2);
        const absolutePath = sysPath$2.resolve(path9);
        const options2 = { persistent: opts.persistent };
        if (!listener2) listener2 = EMPTY_FN$2;
        let closer;
        if (opts.usePolling) {
          options2.interval = opts.enableBinaryInterval && isBinaryPath(basename2) ? opts.binaryInterval : opts.interval;
          closer = setFsWatchFileListener(path9, absolutePath, options2, {
            listener: listener2,
            rawEmitter: this.fsw._emitRaw
          });
        } else {
          closer = setFsWatchListener(path9, absolutePath, options2, {
            listener: listener2,
            errHandler: this._boundHandleError,
            rawEmitter: this.fsw._emitRaw
          });
        }
        return closer;
      }
      /**
       * Watch a file and emit add event if warranted.
       * @param {Path} file Path
       * @param {fs.Stats} stats result of fs_stat
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @returns {Function} closer for the watcher instance
       */
      _handleFile(file, stats, initialAdd) {
        if (this.fsw.closed) {
          return;
        }
        const dirname4 = sysPath$2.dirname(file);
        const basename2 = sysPath$2.basename(file);
        const parent = this.fsw._getWatchedDir(dirname4);
        let prevStats = stats;
        if (parent.has(basename2)) return;
        const listener2 = async (path9, newStats) => {
          if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
          if (!newStats || newStats.mtimeMs === 0) {
            try {
              const newStats2 = await stat$2(file);
              if (this.fsw.closed) return;
              const at2 = newStats2.atimeMs;
              const mt = newStats2.mtimeMs;
              if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE$2, file, newStats2);
              }
              if (isLinux && prevStats.ino !== newStats2.ino) {
                this.fsw._closeFile(path9);
                prevStats = newStats2;
                this.fsw._addPathCloser(path9, this._watchWithNodeFs(file, listener2));
              } else {
                prevStats = newStats2;
              }
            } catch (error) {
              this.fsw._remove(dirname4, basename2);
            }
          } else if (parent.has(basename2)) {
            const at2 = newStats.atimeMs;
            const mt = newStats.mtimeMs;
            if (!at2 || at2 <= mt || mt !== prevStats.mtimeMs) {
              this.fsw._emit(EV_CHANGE$2, file, newStats);
            }
            prevStats = newStats;
          }
        };
        const closer = this._watchWithNodeFs(file, listener2);
        if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
          if (!this.fsw._throttle(EV_ADD$2, file, 0)) return;
          this.fsw._emit(EV_ADD$2, file, stats);
        }
        return closer;
      }
      /**
       * Handle symlinks encountered while reading a dir.
       * @param {Object} entry returned by readdirp
       * @param {String} directory path of dir being read
       * @param {String} path of this item
       * @param {String} item basename of this item
       * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
       */
      async _handleSymlink(entry2, directory, path9, item) {
        if (this.fsw.closed) {
          return;
        }
        const full = entry2.fullPath;
        const dir = this.fsw._getWatchedDir(directory);
        if (!this.fsw.options.followSymlinks) {
          this.fsw._incrReadyCount();
          let linkPath;
          try {
            linkPath = await fsrealpath(path9);
          } catch (e) {
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw.closed) return;
          if (dir.has(item)) {
            if (this.fsw._symlinkPaths.get(full) !== linkPath) {
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_CHANGE$2, path9, entry2.stats);
            }
          } else {
            dir.add(item);
            this.fsw._symlinkPaths.set(full, linkPath);
            this.fsw._emit(EV_ADD$2, path9, entry2.stats);
          }
          this.fsw._emitReady();
          return true;
        }
        if (this.fsw._symlinkPaths.has(full)) {
          return true;
        }
        this.fsw._symlinkPaths.set(full, true);
      }
      _handleRead(directory, initialAdd, wh, target, dir, depth2, throttler) {
        directory = sysPath$2.join(directory, EMPTY_STR$1);
        if (!wh.hasGlob) {
          throttler = this.fsw._throttle("readdir", directory, 1e3);
          if (!throttler) return;
        }
        const previous = this.fsw._getWatchedDir(wh.path);
        const current = /* @__PURE__ */ new Set();
        let stream4 = this.fsw._readdirp(directory, {
          fileFilter: (entry2) => wh.filterPath(entry2),
          directoryFilter: (entry2) => wh.filterDir(entry2),
          depth: 0
        }).on(STR_DATA$1, async (entry2) => {
          if (this.fsw.closed) {
            stream4 = void 0;
            return;
          }
          const item = entry2.path;
          let path9 = sysPath$2.join(directory, item);
          current.add(item);
          if (entry2.stats.isSymbolicLink() && await this._handleSymlink(entry2, directory, path9, item)) {
            return;
          }
          if (this.fsw.closed) {
            stream4 = void 0;
            return;
          }
          if (item === target || !target && !previous.has(item)) {
            this.fsw._incrReadyCount();
            path9 = sysPath$2.join(dir, sysPath$2.relative(dir, path9));
            this._addToNodeFs(path9, initialAdd, wh, depth2 + 1);
          }
        }).on(EV_ERROR$2, this._boundHandleError);
        return new Promise(
          (resolve8) => stream4.once(STR_END$2, () => {
            if (this.fsw.closed) {
              stream4 = void 0;
              return;
            }
            const wasThrottled = throttler ? throttler.clear() : false;
            resolve8();
            previous.getChildren().filter((item) => {
              return item !== directory && !current.has(item) && // in case of intersecting globs;
              // a path may have been filtered out of this readdir, but
              // shouldn't be removed because it matches a different glob
              (!wh.hasGlob || wh.filterPath({
                fullPath: sysPath$2.resolve(directory, item)
              }));
            }).forEach((item) => {
              this.fsw._remove(directory, item);
            });
            stream4 = void 0;
            if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth2, throttler);
          })
        );
      }
      /**
       * Read directory to add / remove files from `@watched` list and re-read it on change.
       * @param {String} dir fs path
       * @param {fs.Stats} stats
       * @param {Boolean} initialAdd
       * @param {Number} depth relative to user-supplied path
       * @param {String} target child path targeted for watch
       * @param {Object} wh Common watch helpers for this path
       * @param {String} realpath
       * @returns {Promise<Function>} closer for the watcher instance.
       */
      async _handleDir(dir, stats, initialAdd, depth2, target, wh, realpath2) {
        const parentDir2 = this.fsw._getWatchedDir(sysPath$2.dirname(dir));
        const tracked = parentDir2.has(sysPath$2.basename(dir));
        if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
          if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR$2, dir, stats);
        }
        parentDir2.add(sysPath$2.basename(dir));
        this.fsw._getWatchedDir(dir);
        let throttler;
        let closer;
        const oDepth = this.fsw.options.depth;
        if ((oDepth == null || depth2 <= oDepth) && !this.fsw._symlinkPaths.has(realpath2)) {
          if (!target) {
            await this._handleRead(dir, initialAdd, wh, target, dir, depth2, throttler);
            if (this.fsw.closed) return;
          }
          closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
            if (stats2 && stats2.mtimeMs === 0) return;
            this._handleRead(dirPath, false, wh, target, dir, depth2, throttler);
          });
        }
        return closer;
      }
      /**
       * Handle added file, directory, or glob pattern.
       * Delegates call to _handleFile / _handleDir after checks.
       * @param {String} path to file or ir
       * @param {Boolean} initialAdd was the file added at watch instantiation?
       * @param {Object} priorWh depth relative to user-supplied path
       * @param {Number} depth Child path actually targeted for watch
       * @param {String=} target Child path actually targeted for watch
       * @returns {Promise}
       */
      async _addToNodeFs(path9, initialAdd, priorWh, depth2, target) {
        const ready = this.fsw._emitReady;
        if (this.fsw._isIgnored(path9) || this.fsw.closed) {
          ready();
          return false;
        }
        const wh = this.fsw._getWatchHelpers(path9, depth2);
        if (!wh.hasGlob && priorWh) {
          wh.hasGlob = priorWh.hasGlob;
          wh.globFilter = priorWh.globFilter;
          wh.filterPath = (entry2) => priorWh.filterPath(entry2);
          wh.filterDir = (entry2) => priorWh.filterDir(entry2);
        }
        try {
          const stats = await statMethods$1[wh.statMethod](wh.watchPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            ready();
            return false;
          }
          const follow = this.fsw.options.followSymlinks && !path9.includes(STAR) && !path9.includes(BRACE_START$1);
          let closer;
          if (stats.isDirectory()) {
            const absPath = sysPath$2.resolve(path9);
            const targetPath = follow ? await fsrealpath(path9) : path9;
            if (this.fsw.closed) return;
            closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth2, target, wh, targetPath);
            if (this.fsw.closed) return;
            if (absPath !== targetPath && targetPath !== void 0) {
              this.fsw._symlinkPaths.set(absPath, targetPath);
            }
          } else if (stats.isSymbolicLink()) {
            const targetPath = follow ? await fsrealpath(path9) : path9;
            if (this.fsw.closed) return;
            const parent = sysPath$2.dirname(wh.watchPath);
            this.fsw._getWatchedDir(parent).add(wh.watchPath);
            this.fsw._emit(EV_ADD$2, wh.watchPath, stats);
            closer = await this._handleDir(parent, stats, initialAdd, depth2, path9, wh, targetPath);
            if (this.fsw.closed) return;
            if (targetPath !== void 0) {
              this.fsw._symlinkPaths.set(sysPath$2.resolve(path9), targetPath);
            }
          } else {
            closer = this._handleFile(wh.watchPath, stats, initialAdd);
          }
          ready();
          this.fsw._addPathCloser(path9, closer);
          return false;
        } catch (error) {
          if (this.fsw._handleError(error)) {
            ready();
            return path9;
          }
        }
      }
    };
    nodefsHandler = NodeFsHandler$1;
    fseventsHandler = { exports: {} };
    fs$6 = require$$0__default3;
    sysPath$1 = require$$0$4;
    ({ promisify: promisify$1 } = require$$0$5);
    try {
      fsevents = __require3("fsevents");
    } catch (error) {
      if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);
    }
    if (fsevents) {
      const mtch = process.version.match(/v(\d+)\.(\d+)/);
      if (mtch && mtch[1] && mtch[2]) {
        const maj2 = Number.parseInt(mtch[1], 10);
        const min2 = Number.parseInt(mtch[2], 10);
        if (maj2 === 8 && min2 < 16) {
          fsevents = void 0;
        }
      }
    }
    ({
      EV_ADD: EV_ADD$1,
      EV_CHANGE: EV_CHANGE$1,
      EV_ADD_DIR: EV_ADD_DIR$1,
      EV_UNLINK: EV_UNLINK$1,
      EV_ERROR: EV_ERROR$1,
      STR_DATA,
      STR_END: STR_END$1,
      FSEVENT_CREATED,
      FSEVENT_MODIFIED,
      FSEVENT_DELETED,
      FSEVENT_MOVED,
      FSEVENT_UNKNOWN: (
        // FSEVENT_CLONED,
        FSEVENT_UNKNOWN
      ),
      FSEVENT_FLAG_MUST_SCAN_SUBDIRS,
      FSEVENT_TYPE_FILE,
      FSEVENT_TYPE_DIRECTORY,
      FSEVENT_TYPE_SYMLINK,
      ROOT_GLOBSTAR,
      DIR_SUFFIX,
      DOT_SLASH,
      FUNCTION_TYPE: FUNCTION_TYPE$1,
      EMPTY_FN: EMPTY_FN$1,
      IDENTITY_FN
    } = constants$1);
    Depth = (value2) => isNaN(value2) ? {} : { depth: value2 };
    stat$1 = promisify$1(fs$6.stat);
    lstat = promisify$1(fs$6.lstat);
    realpath = promisify$1(fs$6.realpath);
    statMethods = { stat: stat$1, lstat };
    FSEventsWatchers = /* @__PURE__ */ new Map();
    consolidateThreshhold = 10;
    wrongEventFlags = /* @__PURE__ */ new Set([
      69888,
      70400,
      71424,
      72704,
      73472,
      131328,
      131840,
      262912
    ]);
    createFSEventsInstance = (path9, callback) => {
      const stop = fsevents.watch(path9, callback);
      return { stop };
    };
    couldConsolidate = (path9) => {
      let count = 0;
      for (const watchPath of FSEventsWatchers.keys()) {
        if (watchPath.indexOf(path9) === 0) {
          count++;
          if (count >= consolidateThreshhold) {
            return true;
          }
        }
      }
      return false;
    };
    canUse = () => fsevents && FSEventsWatchers.size < 128;
    calcDepth = (path9, root4) => {
      let i = 0;
      while (!path9.indexOf(root4) && (path9 = sysPath$1.dirname(path9)) !== root4) i++;
      return i;
    };
    sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
    FsEventsHandler$1 = class FsEventsHandler {
      /**
       * @param {import('../index').FSWatcher} fsw
       */
      constructor(fsw) {
        this.fsw = fsw;
      }
      checkIgnored(path9, stats) {
        const ipaths = this.fsw._ignoredPaths;
        if (this.fsw._isIgnored(path9, stats)) {
          ipaths.add(path9);
          if (stats && stats.isDirectory()) {
            ipaths.add(path9 + ROOT_GLOBSTAR);
          }
          return true;
        }
        ipaths.delete(path9);
        ipaths.delete(path9 + ROOT_GLOBSTAR);
      }
      addOrChange(path9, fullPath, realPath, parent, watchedDir, item, info, opts) {
        const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;
        this.handleEvent(event, path9, fullPath, realPath, parent, watchedDir, item, info, opts);
      }
      async checkExists(path9, fullPath, realPath, parent, watchedDir, item, info, opts) {
        try {
          const stats = await stat$1(path9);
          if (this.fsw.closed) return;
          if (sameTypes(info, stats)) {
            this.addOrChange(path9, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path9, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        } catch (error) {
          if (error.code === "EACCES") {
            this.addOrChange(path9, fullPath, realPath, parent, watchedDir, item, info, opts);
          } else {
            this.handleEvent(EV_UNLINK$1, path9, fullPath, realPath, parent, watchedDir, item, info, opts);
          }
        }
      }
      handleEvent(event, path9, fullPath, realPath, parent, watchedDir, item, info, opts) {
        if (this.fsw.closed || this.checkIgnored(path9)) return;
        if (event === EV_UNLINK$1) {
          const isDirectory2 = info.type === FSEVENT_TYPE_DIRECTORY;
          if (isDirectory2 || watchedDir.has(item)) {
            this.fsw._remove(parent, item, isDirectory2);
          }
        } else {
          if (event === EV_ADD$1) {
            if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path9);
            if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
              const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
              return this._addToFsEvents(path9, false, true, curDepth);
            }
            this.fsw._getWatchedDir(parent).add(item);
          }
          const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
          this.fsw._emit(eventName, path9);
          if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path9, false, true);
        }
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} watchPath  - file/dir path to be watched with fsevents
       * @param {String} realPath   - real path (in case of symlinks)
       * @param {Function} transform  - path transformer
       * @param {Function} globFilter - path filter in case a glob pattern was provided
       * @returns {Function} closer for the watcher instance
      */
      _watchWithFsEvents(watchPath, realPath, transform3, globFilter) {
        if (this.fsw.closed || this.fsw._isIgnored(watchPath)) return;
        const opts = this.fsw.options;
        const watchCallback = async (fullPath, flags, info) => {
          if (this.fsw.closed || this.fsw._isIgnored(fullPath)) return;
          if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth) return;
          const path9 = transform3(sysPath$1.join(
            watchPath,
            sysPath$1.relative(watchPath, fullPath)
          ));
          if (globFilter && !globFilter(path9)) return;
          const parent = sysPath$1.dirname(path9);
          const item = sysPath$1.basename(path9);
          const watchedDir = this.fsw._getWatchedDir(
            info.type === FSEVENT_TYPE_DIRECTORY ? path9 : parent
          );
          if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
            if (typeof opts.ignored === FUNCTION_TYPE$1) {
              let stats;
              try {
                stats = await stat$1(path9);
              } catch (error) {
              }
              if (this.fsw.closed) return;
              if (this.checkIgnored(path9, stats)) return;
              if (sameTypes(info, stats)) {
                this.addOrChange(path9, fullPath, realPath, parent, watchedDir, item, info, opts);
              } else {
                this.handleEvent(EV_UNLINK$1, path9, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              this.checkExists(path9, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } else {
            switch (info.event) {
              case FSEVENT_CREATED:
              case FSEVENT_MODIFIED:
                return this.addOrChange(path9, fullPath, realPath, parent, watchedDir, item, info, opts);
              case FSEVENT_DELETED:
              case FSEVENT_MOVED:
                return this.checkExists(path9, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        };
        const closer = setFSEventsListener(
          watchPath,
          realPath,
          watchCallback,
          this.fsw._emitRaw
        );
        this.fsw._emitReady();
        return closer;
      }
      /**
       * Handle symlinks encountered during directory scan
       * @param {String} linkPath path to symlink
       * @param {String} fullPath absolute path to the symlink
       * @param {Function} transform pre-existing path transformer
       * @param {Number} curDepth level of subdirectories traversed to where symlink is
       * @returns {Promise<void>}
       */
      async _handleFsEventsSymlink(linkPath, fullPath, transform3, curDepth) {
        if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;
        this.fsw._symlinkPaths.set(fullPath, true);
        this.fsw._incrReadyCount();
        try {
          const linkTarget = await realpath(linkPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(linkTarget)) {
            return this.fsw._emitReady();
          }
          this.fsw._incrReadyCount();
          this._addToFsEvents(linkTarget || linkPath, (path9) => {
            let aliasedPath = linkPath;
            if (linkTarget && linkTarget !== DOT_SLASH) {
              aliasedPath = path9.replace(linkTarget, linkPath);
            } else if (path9 !== DOT_SLASH) {
              aliasedPath = sysPath$1.join(linkPath, path9);
            }
            return transform3(aliasedPath);
          }, false, curDepth);
        } catch (error) {
          if (this.fsw._handleError(error)) {
            return this.fsw._emitReady();
          }
        }
      }
      /**
       *
       * @param {Path} newPath
       * @param {fs.Stats} stats
       */
      emitAdd(newPath, stats, processPath, opts, forceAdd) {
        const pp = processPath(newPath);
        const isDir = stats.isDirectory();
        const dirObj = this.fsw._getWatchedDir(sysPath$1.dirname(pp));
        const base = sysPath$1.basename(pp);
        if (isDir) this.fsw._getWatchedDir(pp);
        if (dirObj.has(base)) return;
        dirObj.add(base);
        if (!opts.ignoreInitial || forceAdd === true) {
          this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);
        }
      }
      initWatch(realPath, path9, wh, processPath) {
        if (this.fsw.closed) return;
        const closer = this._watchWithFsEvents(
          wh.watchPath,
          sysPath$1.resolve(realPath || wh.watchPath),
          processPath,
          wh.globFilter
        );
        this.fsw._addPathCloser(path9, closer);
      }
      /**
       * Handle added path with fsevents
       * @param {String} path file/dir path or glob pattern
       * @param {Function|Boolean=} transform converts working path to what the user expects
       * @param {Boolean=} forceAdd ensure add is emitted
       * @param {Number=} priorDepth Level of subdirectories already traversed.
       * @returns {Promise<void>}
       */
      async _addToFsEvents(path9, transform3, forceAdd, priorDepth) {
        if (this.fsw.closed) {
          return;
        }
        const opts = this.fsw.options;
        const processPath = typeof transform3 === FUNCTION_TYPE$1 ? transform3 : IDENTITY_FN;
        const wh = this.fsw._getWatchHelpers(path9);
        try {
          const stats = await statMethods[wh.statMethod](wh.watchPath);
          if (this.fsw.closed) return;
          if (this.fsw._isIgnored(wh.watchPath, stats)) {
            throw null;
          }
          if (stats.isDirectory()) {
            if (!wh.globFilter) this.emitAdd(processPath(path9), stats, processPath, opts, forceAdd);
            if (priorDepth && priorDepth > opts.depth) return;
            this.fsw._readdirp(wh.watchPath, {
              fileFilter: (entry2) => wh.filterPath(entry2),
              directoryFilter: (entry2) => wh.filterDir(entry2),
              ...Depth(opts.depth - (priorDepth || 0))
            }).on(STR_DATA, (entry2) => {
              if (this.fsw.closed) {
                return;
              }
              if (entry2.stats.isDirectory() && !wh.filterPath(entry2)) return;
              const joinedPath = sysPath$1.join(wh.watchPath, entry2.path);
              const { fullPath } = entry2;
              if (wh.followSymlinks && entry2.stats.isSymbolicLink()) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath$1.resolve(wh.watchPath)) + 1;
                this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
              } else {
                this.emitAdd(joinedPath, entry2.stats, processPath, opts, forceAdd);
              }
            }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {
              this.fsw._emitReady();
            });
          } else {
            this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
            this.fsw._emitReady();
          }
        } catch (error) {
          if (!error || this.fsw._handleError(error)) {
            this.fsw._emitReady();
            this.fsw._emitReady();
          }
        }
        if (opts.persistent && forceAdd !== true) {
          if (typeof transform3 === FUNCTION_TYPE$1) {
            this.initWatch(void 0, path9, wh, processPath);
          } else {
            let realPath;
            try {
              realPath = await realpath(wh.watchPath);
            } catch (e) {
            }
            this.initWatch(realPath, path9, wh, processPath);
          }
        }
      }
    };
    fseventsHandler.exports = FsEventsHandler$1;
    fseventsHandler.exports.canUse = canUse;
    fseventsHandlerExports = fseventsHandler.exports;
    ({ EventEmitter: EventEmitter$2 } = require$$0$7);
    fs$5 = require$$0__default3;
    sysPath = require$$0$4;
    ({ promisify } = require$$0$5);
    readdirp = readdirp_1;
    anymatch = anymatchExports.default;
    globParent2 = globParent$2;
    isGlob2 = isGlob$2;
    braces = braces_1;
    normalizePath2 = normalizePath$2;
    NodeFsHandler2 = nodefsHandler;
    FsEventsHandler2 = fseventsHandlerExports;
    ({
      EV_ALL,
      EV_READY,
      EV_ADD,
      EV_CHANGE,
      EV_UNLINK,
      EV_ADD_DIR,
      EV_UNLINK_DIR,
      EV_RAW,
      EV_ERROR,
      STR_CLOSE,
      STR_END,
      BACK_SLASH_RE,
      DOUBLE_SLASH_RE,
      SLASH_OR_BACK_SLASH_RE,
      DOT_RE,
      REPLACER_RE,
      SLASH,
      SLASH_SLASH,
      BRACE_START,
      BANG,
      ONE_DOT,
      TWO_DOTS,
      GLOBSTAR,
      SLASH_GLOBSTAR,
      ANYMATCH_OPTS,
      STRING_TYPE,
      FUNCTION_TYPE,
      EMPTY_STR,
      EMPTY_FN,
      isWindows: isWindows$1,
      isMacos,
      isIBMi
    } = constants$1);
    stat2 = promisify(fs$5.stat);
    readdir = promisify(fs$5.readdir);
    arrify = (value2 = []) => Array.isArray(value2) ? value2 : [value2];
    flatten = (list2, result = []) => {
      list2.forEach((item) => {
        if (Array.isArray(item)) {
          flatten(item, result);
        } else {
          result.push(item);
        }
      });
      return result;
    };
    unifyPaths = (paths_) => {
      const paths = flatten(arrify(paths_));
      if (!paths.every((p) => typeof p === STRING_TYPE)) {
        throw new TypeError(`Non-string provided as watch path: ${paths}`);
      }
      return paths.map(normalizePathToUnix);
    };
    toUnix = (string4) => {
      let str2 = string4.replace(BACK_SLASH_RE, SLASH);
      let prepend = false;
      if (str2.startsWith(SLASH_SLASH)) {
        prepend = true;
      }
      while (str2.match(DOUBLE_SLASH_RE)) {
        str2 = str2.replace(DOUBLE_SLASH_RE, SLASH);
      }
      if (prepend) {
        str2 = SLASH + str2;
      }
      return str2;
    };
    normalizePathToUnix = (path9) => toUnix(sysPath.normalize(toUnix(path9)));
    normalizeIgnored = (cwd = EMPTY_STR) => (path9) => {
      if (typeof path9 !== STRING_TYPE) return path9;
      return normalizePathToUnix(sysPath.isAbsolute(path9) ? path9 : sysPath.join(cwd, path9));
    };
    getAbsolutePath = (path9, cwd) => {
      if (sysPath.isAbsolute(path9)) {
        return path9;
      }
      if (path9.startsWith(BANG)) {
        return BANG + sysPath.join(cwd, path9.slice(1));
      }
      return sysPath.join(cwd, path9);
    };
    undef = (opts, key) => opts[key] === void 0;
    DirEntry = class {
      /**
       * @param {Path} dir
       * @param {Function} removeWatcher
       */
      constructor(dir, removeWatcher) {
        this.path = dir;
        this._removeWatcher = removeWatcher;
        this.items = /* @__PURE__ */ new Set();
      }
      add(item) {
        const { items } = this;
        if (!items) return;
        if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);
      }
      async remove(item) {
        const { items } = this;
        if (!items) return;
        items.delete(item);
        if (items.size > 0) return;
        const dir = this.path;
        try {
          await readdir(dir);
        } catch (err) {
          if (this._removeWatcher) {
            this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
          }
        }
      }
      has(item) {
        const { items } = this;
        if (!items) return;
        return items.has(item);
      }
      /**
       * @returns {Array<String>}
       */
      getChildren() {
        const { items } = this;
        if (!items) return;
        return [...items.values()];
      }
      dispose() {
        this.items.clear();
        delete this.path;
        delete this._removeWatcher;
        delete this.items;
        Object.freeze(this);
      }
    };
    STAT_METHOD_F = "stat";
    STAT_METHOD_L = "lstat";
    WatchHelper = class {
      constructor(path9, watchPath, follow, fsw) {
        this.fsw = fsw;
        this.path = path9 = path9.replace(REPLACER_RE, EMPTY_STR);
        this.watchPath = watchPath;
        this.fullWatchPath = sysPath.resolve(watchPath);
        this.hasGlob = watchPath !== path9;
        if (path9 === EMPTY_STR) this.hasGlob = false;
        this.globSymlink = this.hasGlob && follow ? void 0 : false;
        this.globFilter = this.hasGlob ? anymatch(path9, void 0, ANYMATCH_OPTS) : false;
        this.dirParts = this.getDirParts(path9);
        this.dirParts.forEach((parts) => {
          if (parts.length > 1) parts.pop();
        });
        this.followSymlinks = follow;
        this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
      }
      checkGlobSymlink(entry2) {
        if (this.globSymlink === void 0) {
          this.globSymlink = entry2.fullParentDir === this.fullWatchPath ? false : { realPath: entry2.fullParentDir, linkPath: this.fullWatchPath };
        }
        if (this.globSymlink) {
          return entry2.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
        }
        return entry2.fullPath;
      }
      entryPath(entry2) {
        return sysPath.join(
          this.watchPath,
          sysPath.relative(this.watchPath, this.checkGlobSymlink(entry2))
        );
      }
      filterPath(entry2) {
        const { stats } = entry2;
        if (stats && stats.isSymbolicLink()) return this.filterDir(entry2);
        const resolvedPath = this.entryPath(entry2);
        const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
        return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
      }
      getDirParts(path9) {
        if (!this.hasGlob) return [];
        const parts = [];
        const expandedPath = path9.includes(BRACE_START) ? braces.expand(path9) : [path9];
        expandedPath.forEach((path10) => {
          parts.push(sysPath.relative(this.watchPath, path10).split(SLASH_OR_BACK_SLASH_RE));
        });
        return parts;
      }
      filterDir(entry2) {
        if (this.hasGlob) {
          const entryParts = this.getDirParts(this.checkGlobSymlink(entry2));
          let globstar = false;
          this.unmatchedGlob = !this.dirParts.some((parts) => {
            return parts.every((part, i) => {
              if (part === GLOBSTAR) globstar = true;
              return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
            });
          });
        }
        return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry2), entry2.stats);
      }
    };
    FSWatcher = class extends EventEmitter$2 {
      // Not indenting methods for history sake; for now.
      constructor(_opts) {
        super();
        const opts = {};
        if (_opts) Object.assign(opts, _opts);
        this._watched = /* @__PURE__ */ new Map();
        this._closers = /* @__PURE__ */ new Map();
        this._ignoredPaths = /* @__PURE__ */ new Set();
        this._throttled = /* @__PURE__ */ new Map();
        this._symlinkPaths = /* @__PURE__ */ new Map();
        this._streams = /* @__PURE__ */ new Set();
        this.closed = false;
        if (undef(opts, "persistent")) opts.persistent = true;
        if (undef(opts, "ignoreInitial")) opts.ignoreInitial = false;
        if (undef(opts, "ignorePermissionErrors")) opts.ignorePermissionErrors = false;
        if (undef(opts, "interval")) opts.interval = 100;
        if (undef(opts, "binaryInterval")) opts.binaryInterval = 300;
        if (undef(opts, "disableGlobbing")) opts.disableGlobbing = false;
        opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
        if (undef(opts, "useFsEvents")) opts.useFsEvents = !opts.usePolling;
        const canUseFsEvents = FsEventsHandler2.canUse();
        if (!canUseFsEvents) opts.useFsEvents = false;
        if (undef(opts, "usePolling") && !opts.useFsEvents) {
          opts.usePolling = isMacos;
        }
        if (isIBMi) {
          opts.usePolling = true;
        }
        const envPoll = process.env.CHOKIDAR_USEPOLLING;
        if (envPoll !== void 0) {
          const envLower = envPoll.toLowerCase();
          if (envLower === "false" || envLower === "0") {
            opts.usePolling = false;
          } else if (envLower === "true" || envLower === "1") {
            opts.usePolling = true;
          } else {
            opts.usePolling = !!envLower;
          }
        }
        const envInterval = process.env.CHOKIDAR_INTERVAL;
        if (envInterval) {
          opts.interval = Number.parseInt(envInterval, 10);
        }
        if (undef(opts, "atomic")) opts.atomic = !opts.usePolling && !opts.useFsEvents;
        if (opts.atomic) this._pendingUnlinks = /* @__PURE__ */ new Map();
        if (undef(opts, "followSymlinks")) opts.followSymlinks = true;
        if (undef(opts, "awaitWriteFinish")) opts.awaitWriteFinish = false;
        if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};
        const awf = opts.awaitWriteFinish;
        if (awf) {
          if (!awf.stabilityThreshold) awf.stabilityThreshold = 2e3;
          if (!awf.pollInterval) awf.pollInterval = 100;
          this._pendingWrites = /* @__PURE__ */ new Map();
        }
        if (opts.ignored) opts.ignored = arrify(opts.ignored);
        let readyCalls = 0;
        this._emitReady = () => {
          readyCalls++;
          if (readyCalls >= this._readyCount) {
            this._emitReady = EMPTY_FN;
            this._readyEmitted = true;
            process.nextTick(() => this.emit(EV_READY));
          }
        };
        this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
        this._readyEmitted = false;
        this.options = opts;
        if (opts.useFsEvents) {
          this._fsEventsHandler = new FsEventsHandler2(this);
        } else {
          this._nodeFsHandler = new NodeFsHandler2(this);
        }
        Object.freeze(opts);
      }
      // Public methods
      /**
       * Adds paths to be watched on an existing FSWatcher instance
       * @param {Path|Array<Path>} paths_
       * @param {String=} _origAdd private; for handling non-existent paths to be watched
       * @param {Boolean=} _internal private; indicates a non-user add
       * @returns {FSWatcher} for chaining
       */
      add(paths_, _origAdd, _internal) {
        const { cwd, disableGlobbing } = this.options;
        this.closed = false;
        let paths = unifyPaths(paths_);
        if (cwd) {
          paths = paths.map((path9) => {
            const absPath = getAbsolutePath(path9, cwd);
            if (disableGlobbing || !isGlob2(path9)) {
              return absPath;
            }
            return normalizePath2(absPath);
          });
        }
        paths = paths.filter((path9) => {
          if (path9.startsWith(BANG)) {
            this._ignoredPaths.add(path9.slice(1));
            return false;
          }
          this._ignoredPaths.delete(path9);
          this._ignoredPaths.delete(path9 + SLASH_GLOBSTAR);
          this._userIgnored = void 0;
          return true;
        });
        if (this.options.useFsEvents && this._fsEventsHandler) {
          if (!this._readyCount) this._readyCount = paths.length;
          if (this.options.persistent) this._readyCount += paths.length;
          paths.forEach((path9) => this._fsEventsHandler._addToFsEvents(path9));
        } else {
          if (!this._readyCount) this._readyCount = 0;
          this._readyCount += paths.length;
          Promise.all(
            paths.map(async (path9) => {
              const res = await this._nodeFsHandler._addToNodeFs(path9, !_internal, 0, 0, _origAdd);
              if (res) this._emitReady();
              return res;
            })
          ).then((results) => {
            if (this.closed) return;
            results.filter((item) => item).forEach((item) => {
              this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
            });
          });
        }
        return this;
      }
      /**
       * Close watchers or start ignoring events from specified paths.
       * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
       * @returns {FSWatcher} for chaining
      */
      unwatch(paths_) {
        if (this.closed) return this;
        const paths = unifyPaths(paths_);
        const { cwd } = this.options;
        paths.forEach((path9) => {
          if (!sysPath.isAbsolute(path9) && !this._closers.has(path9)) {
            if (cwd) path9 = sysPath.join(cwd, path9);
            path9 = sysPath.resolve(path9);
          }
          this._closePath(path9);
          this._ignoredPaths.add(path9);
          if (this._watched.has(path9)) {
            this._ignoredPaths.add(path9 + SLASH_GLOBSTAR);
          }
          this._userIgnored = void 0;
        });
        return this;
      }
      /**
       * Close watchers and remove all listeners from watched paths.
       * @returns {Promise<void>}.
      */
      close() {
        if (this.closed) return this._closePromise;
        this.closed = true;
        this.removeAllListeners();
        const closers = [];
        this._closers.forEach((closerList) => closerList.forEach((closer) => {
          const promise2 = closer();
          if (promise2 instanceof Promise) closers.push(promise2);
        }));
        this._streams.forEach((stream4) => stream4.destroy());
        this._userIgnored = void 0;
        this._readyCount = 0;
        this._readyEmitted = false;
        this._watched.forEach((dirent) => dirent.dispose());
        ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
          this[`_${key}`].clear();
        });
        this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
        return this._closePromise;
      }
      /**
       * Expose list of watched paths
       * @returns {Object} for chaining
      */
      getWatched() {
        const watchList = {};
        this._watched.forEach((entry2, dir) => {
          const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
          watchList[key || ONE_DOT] = entry2.getChildren().sort();
        });
        return watchList;
      }
      emitWithAll(event, args) {
        this.emit(...args);
        if (event !== EV_ERROR) this.emit(EV_ALL, ...args);
      }
      // Common helpers
      // --------------
      /**
       * Normalize and emit events.
       * Calling _emit DOES NOT MEAN emit() would be called!
       * @param {EventName} event Type of event
       * @param {Path} path File or directory path
       * @param {*=} val1 arguments to be passed with event
       * @param {*=} val2
       * @param {*=} val3
       * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      async _emit(event, path9, val1, val2, val3) {
        if (this.closed) return;
        const opts = this.options;
        if (isWindows$1) path9 = sysPath.normalize(path9);
        if (opts.cwd) path9 = sysPath.relative(opts.cwd, path9);
        const args = [event, path9];
        if (val3 !== void 0) args.push(val1, val2, val3);
        else if (val2 !== void 0) args.push(val1, val2);
        else if (val1 !== void 0) args.push(val1);
        const awf = opts.awaitWriteFinish;
        let pw;
        if (awf && (pw = this._pendingWrites.get(path9))) {
          pw.lastChange = /* @__PURE__ */ new Date();
          return this;
        }
        if (opts.atomic) {
          if (event === EV_UNLINK) {
            this._pendingUnlinks.set(path9, args);
            setTimeout(() => {
              this._pendingUnlinks.forEach((entry2, path10) => {
                this.emit(...entry2);
                this.emit(EV_ALL, ...entry2);
                this._pendingUnlinks.delete(path10);
              });
            }, typeof opts.atomic === "number" ? opts.atomic : 100);
            return this;
          }
          if (event === EV_ADD && this._pendingUnlinks.has(path9)) {
            event = args[0] = EV_CHANGE;
            this._pendingUnlinks.delete(path9);
          }
        }
        if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
          const awfEmit = (err, stats) => {
            if (err) {
              event = args[0] = EV_ERROR;
              args[1] = err;
              this.emitWithAll(event, args);
            } else if (stats) {
              if (args.length > 2) {
                args[2] = stats;
              } else {
                args.push(stats);
              }
              this.emitWithAll(event, args);
            }
          };
          this._awaitWriteFinish(path9, awf.stabilityThreshold, event, awfEmit);
          return this;
        }
        if (event === EV_CHANGE) {
          const isThrottled = !this._throttle(EV_CHANGE, path9, 50);
          if (isThrottled) return this;
        }
        if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
          const fullPath = opts.cwd ? sysPath.join(opts.cwd, path9) : path9;
          let stats;
          try {
            stats = await stat2(fullPath);
          } catch (err) {
          }
          if (!stats || this.closed) return;
          args.push(stats);
        }
        this.emitWithAll(event, args);
        return this;
      }
      /**
       * Common handler for errors
       * @param {Error} error
       * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
       */
      _handleError(error) {
        const code = error && error.code;
        if (error && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
          this.emit(EV_ERROR, error);
        }
        return error || this.closed;
      }
      /**
       * Helper utility for throttling
       * @param {ThrottleType} actionType type being throttled
       * @param {Path} path being acted upon
       * @param {Number} timeout duration of time to suppress duplicate actions
       * @returns {Object|false} tracking object or false if action should be suppressed
       */
      _throttle(actionType, path9, timeout2) {
        if (!this._throttled.has(actionType)) {
          this._throttled.set(actionType, /* @__PURE__ */ new Map());
        }
        const action = this._throttled.get(actionType);
        const actionPath = action.get(path9);
        if (actionPath) {
          actionPath.count++;
          return false;
        }
        let timeoutObject;
        const clear = () => {
          const item = action.get(path9);
          const count = item ? item.count : 0;
          action.delete(path9);
          clearTimeout(timeoutObject);
          if (item) clearTimeout(item.timeoutObject);
          return count;
        };
        timeoutObject = setTimeout(clear, timeout2);
        const thr = { timeoutObject, clear, count: 0 };
        action.set(path9, thr);
        return thr;
      }
      _incrReadyCount() {
        return this._readyCount++;
      }
      /**
       * Awaits write operation to finish.
       * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
       * @param {Path} path being acted upon
       * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
       * @param {EventName} event
       * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
       */
      _awaitWriteFinish(path9, threshold, event, awfEmit) {
        let timeoutHandler;
        let fullPath = path9;
        if (this.options.cwd && !sysPath.isAbsolute(path9)) {
          fullPath = sysPath.join(this.options.cwd, path9);
        }
        const now = /* @__PURE__ */ new Date();
        const awaitWriteFinish = (prevStat) => {
          fs$5.stat(fullPath, (err, curStat) => {
            if (err || !this._pendingWrites.has(path9)) {
              if (err && err.code !== "ENOENT") awfEmit(err);
              return;
            }
            const now2 = Number(/* @__PURE__ */ new Date());
            if (prevStat && curStat.size !== prevStat.size) {
              this._pendingWrites.get(path9).lastChange = now2;
            }
            const pw = this._pendingWrites.get(path9);
            const df = now2 - pw.lastChange;
            if (df >= threshold) {
              this._pendingWrites.delete(path9);
              awfEmit(void 0, curStat);
            } else {
              timeoutHandler = setTimeout(
                awaitWriteFinish,
                this.options.awaitWriteFinish.pollInterval,
                curStat
              );
            }
          });
        };
        if (!this._pendingWrites.has(path9)) {
          this._pendingWrites.set(path9, {
            lastChange: now,
            cancelWait: () => {
              this._pendingWrites.delete(path9);
              clearTimeout(timeoutHandler);
              return event;
            }
          });
          timeoutHandler = setTimeout(
            awaitWriteFinish,
            this.options.awaitWriteFinish.pollInterval
          );
        }
      }
      _getGlobIgnored() {
        return [...this._ignoredPaths.values()];
      }
      /**
       * Determines whether user has asked to ignore this path.
       * @param {Path} path filepath or dir
       * @param {fs.Stats=} stats result of fs.stat
       * @returns {Boolean}
       */
      _isIgnored(path9, stats) {
        if (this.options.atomic && DOT_RE.test(path9)) return true;
        if (!this._userIgnored) {
          const { cwd } = this.options;
          const ign = this.options.ignored;
          const ignored = ign && ign.map(normalizeIgnored(cwd));
          const paths = arrify(ignored).filter((path10) => typeof path10 === STRING_TYPE && !isGlob2(path10)).map((path10) => path10 + SLASH_GLOBSTAR);
          const list2 = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
          this._userIgnored = anymatch(list2, void 0, ANYMATCH_OPTS);
        }
        return this._userIgnored([path9, stats]);
      }
      _isntIgnored(path9, stat3) {
        return !this._isIgnored(path9, stat3);
      }
      /**
       * Provides a set of common helpers and properties relating to symlink and glob handling.
       * @param {Path} path file, directory, or glob pattern being watched
       * @param {Number=} depth at any depth > 0, this isn't a glob
       * @returns {WatchHelper} object containing helpers for this path
       */
      _getWatchHelpers(path9, depth2) {
        const watchPath = depth2 || this.options.disableGlobbing || !isGlob2(path9) ? path9 : globParent2(path9);
        const follow = this.options.followSymlinks;
        return new WatchHelper(path9, watchPath, follow, this);
      }
      // Directory helpers
      // -----------------
      /**
       * Provides directory tracking objects
       * @param {String} directory path of the directory
       * @returns {DirEntry} the directory's tracking object
       */
      _getWatchedDir(directory) {
        if (!this._boundRemove) this._boundRemove = this._remove.bind(this);
        const dir = sysPath.resolve(directory);
        if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));
        return this._watched.get(dir);
      }
      // File helpers
      // ------------
      /**
       * Check for read permissions.
       * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
       * @param {fs.Stats} stats - object, result of fs_stat
       * @returns {Boolean} indicates whether the file can be read
      */
      _hasReadPermissions(stats) {
        if (this.options.ignorePermissionErrors) return true;
        const md = stats && Number.parseInt(stats.mode, 10);
        const st = md & 511;
        const it = Number.parseInt(st.toString(8)[0], 10);
        return Boolean(4 & it);
      }
      /**
       * Handles emitting unlink events for
       * files and directories, and via recursion, for
       * files and directories within directories that are unlinked
       * @param {String} directory within which the following item is located
       * @param {String} item      base path of item/directory
       * @returns {void}
      */
      _remove(directory, item, isDirectory2) {
        const path9 = sysPath.join(directory, item);
        const fullPath = sysPath.resolve(path9);
        isDirectory2 = isDirectory2 != null ? isDirectory2 : this._watched.has(path9) || this._watched.has(fullPath);
        if (!this._throttle("remove", path9, 100)) return;
        if (!isDirectory2 && !this.options.useFsEvents && this._watched.size === 1) {
          this.add(directory, item, true);
        }
        const wp = this._getWatchedDir(path9);
        const nestedDirectoryChildren = wp.getChildren();
        nestedDirectoryChildren.forEach((nested) => this._remove(path9, nested));
        const parent = this._getWatchedDir(directory);
        const wasTracked = parent.has(item);
        parent.remove(item);
        if (this._symlinkPaths.has(fullPath)) {
          this._symlinkPaths.delete(fullPath);
        }
        let relPath = path9;
        if (this.options.cwd) relPath = sysPath.relative(this.options.cwd, path9);
        if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
          const event = this._pendingWrites.get(relPath).cancelWait();
          if (event === EV_ADD) return;
        }
        this._watched.delete(path9);
        this._watched.delete(fullPath);
        const eventName = isDirectory2 ? EV_UNLINK_DIR : EV_UNLINK;
        if (wasTracked && !this._isIgnored(path9)) this._emit(eventName, path9);
        if (!this.options.useFsEvents) {
          this._closePath(path9);
        }
      }
      /**
       * Closes all watchers for a path
       * @param {Path} path
       */
      _closePath(path9) {
        this._closeFile(path9);
        const dir = sysPath.dirname(path9);
        this._getWatchedDir(dir).remove(sysPath.basename(path9));
      }
      /**
       * Closes only file-specific watchers
       * @param {Path} path
       */
      _closeFile(path9) {
        const closers = this._closers.get(path9);
        if (!closers) return;
        closers.forEach((closer) => closer());
        this._closers.delete(path9);
      }
      /**
       *
       * @param {Path} path
       * @param {Function} closer
       */
      _addPathCloser(path9, closer) {
        if (!closer) return;
        let list2 = this._closers.get(path9);
        if (!list2) {
          list2 = [];
          this._closers.set(path9, list2);
        }
        list2.push(closer);
      }
      _readdirp(root4, opts) {
        if (this.closed) return;
        const options2 = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
        let stream4 = readdirp(root4, options2);
        this._streams.add(stream4);
        stream4.once(STR_CLOSE, () => {
          stream4 = void 0;
        });
        stream4.once(STR_END, () => {
          if (stream4) {
            this._streams.delete(stream4);
            stream4 = void 0;
          }
        });
        return stream4;
      }
    };
    chokidar.FSWatcher = FSWatcher;
    watch = (paths, options2) => {
      const watcher = new FSWatcher(options2);
      watcher.add(paths);
      return watcher;
    };
    chokidar.watch = watch;
    shellQuote$1 = {};
    quote = function quote2(xs) {
      return xs.map(function(s) {
        if (s && typeof s === "object") {
          return s.op.replace(/(.)/g, "\\$1");
        }
        if (/["\s]/.test(s) && !/'/.test(s)) {
          return "'" + s.replace(/(['\\])/g, "\\$1") + "'";
        }
        if (/["'\s]/.test(s)) {
          return '"' + s.replace(/(["\\$`!])/g, "\\$1") + '"';
        }
        return String(s).replace(/([A-Za-z]:)?([#!"$&'()*,:;<=>?@[\\\]^`{|}])/g, "$1\\$2");
      }).join(" ");
    };
    CONTROL = "(?:" + [
      "\\|\\|",
      "\\&\\&",
      ";;",
      "\\|\\&",
      "\\<\\(",
      "\\<\\<\\<",
      ">>",
      ">\\&",
      "<\\&",
      "[&;()|<>]"
    ].join("|") + ")";
    controlRE = new RegExp("^" + CONTROL + "$");
    META = "|&;()<> \\t";
    SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    hash2 = /^#$/;
    SQ = "'";
    DQ = '"';
    DS = "$";
    TOKEN = "";
    mult = 4294967296;
    for (i = 0; i < 4; i++) {
      TOKEN += (mult * Math.random()).toString(16);
    }
    startsWithToken = new RegExp("^" + TOKEN);
    parse$6 = function parse4(s, env2, opts) {
      var mapped = parseInternal(s, env2, opts);
      if (typeof env2 !== "function") {
        return mapped;
      }
      return mapped.reduce(function(acc, s2) {
        if (typeof s2 === "object") {
          return acc.concat(s2);
        }
        var xs = s2.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
        if (xs.length === 1) {
          return acc.concat(xs[0]);
        }
        return acc.concat(xs.filter(Boolean).map(function(x) {
          if (startsWithToken.test(x)) {
            return JSON.parse(x.split(TOKEN)[1]);
          }
          return x;
        }));
      }, []);
    };
    shellQuote$1.quote = quote;
    shellQuote$1.parse = parse$6;
    commonFsUtils = {
      existsSync: fs__default.existsSync,
      isDirectory,
      tryResolveRealFile,
      tryResolveRealFileWithExtensions,
      tryResolveRealFileOrType
    };
    Stats = require$$0__default3.Stats;
    normalizedClientEntry$1 = normalizePath$3(CLIENT_ENTRY);
    normalizedEnvEntry$1 = normalizePath$3(ENV_ENTRY);
    debug$c = createDebugger("vite:resolve-details", {
      onlyWhenFocused: true
    });
    externalTypes = [
      "css",
      // supported pre-processor types
      "less",
      "sass",
      "scss",
      "styl",
      "stylus",
      "pcss",
      "postcss",
      // wasm
      "wasm",
      // known SFC types
      "vue",
      "svelte",
      "marko",
      "astro",
      "imba",
      // JSX/TSX may be configured to be compiled differently from how esbuild
      // handles it by default, so exclude them as well
      "jsx",
      "tsx",
      ...KNOWN_ASSET_TYPES
    ];
    debug$b = createDebugger("vite:ssr-external");
    jsonLangs = `\\.(?:json|json5)(?:$|\\?)`;
    jsonLangRE = new RegExp(jsonLangs);
    debug$a = createDebugger("vite:optimize-deps");
    normalizedClientEntry = normalizePath$3(CLIENT_ENTRY);
    normalizedEnvEntry = normalizePath$3(ENV_ENTRY);
    wasmHelper = async (opts = {}, url2) => {
      let result;
      if (url2.startsWith("data:")) {
        const urlContent = url2.replace(/^data:.*?base64,/, "");
        let bytes;
        if (typeof Buffer === "function" && typeof Buffer.from === "function") {
          bytes = Buffer.from(urlContent, "base64");
        } else if (typeof atob === "function") {
          const binaryString = atob(urlContent);
          bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
        } else {
          throw new Error(
            "Failed to decode base64-encoded data URL, Buffer and atob are not supported"
          );
        }
        result = await WebAssembly.instantiate(bytes, opts);
      } else {
        const response = await fetch(url2);
        const contentType = response.headers.get("Content-Type") || "";
        if ("instantiateStreaming" in WebAssembly && contentType.startsWith("application/wasm")) {
          result = await WebAssembly.instantiateStreaming(response, opts);
        } else {
          const buffer = await response.arrayBuffer();
          result = await WebAssembly.instantiate(buffer, opts);
        }
      }
      return result.instance;
    };
    wasmHelperCode = wasmHelper.toString();
    if (!String.prototype.repeat) {
      throw new Error(
        "String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"
      );
    }
    if (!String.prototype.endsWith) {
      throw new Error(
        "String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"
      );
    }
    regex = ansiRegex();
    EMPTY_OBJECT2 = Object.freeze({});
    debugSourcemapCombineFilter = process.env.DEBUG_VITE_SOURCEMAP_COMBINE_FILTER;
    debugSourcemapCombine = createDebugger("vite:sourcemap-combine", {
      onlyWhenFocused: true
    });
    debugResolve = createDebugger("vite:resolve");
    debugPluginResolve = createDebugger("vite:plugin-resolve", {
      onlyWhenFocused: "vite:plugin"
    });
    debugPluginTransform = createDebugger("vite:plugin-transform", {
      onlyWhenFocused: "vite:plugin"
    });
    debug$9 = createDebugger("vite:deps");
    debug$8 = createDebugger("vite:deps");
    debug$7 = createDebugger("vite:deps");
    lockfileFormats = [
      { name: "package-lock.json", checkPatches: true, manager: "npm" },
      { name: "yarn.lock", checkPatches: true, manager: "yarn" },
      // Included in lockfile for v2+
      { name: "pnpm-lock.yaml", checkPatches: false, manager: "pnpm" },
      // Included in lockfile
      { name: "bun.lockb", checkPatches: true, manager: "bun" }
    ].sort((_, { manager }) => {
      return process.env.npm_config_user_agent?.startsWith(manager) ? 1 : -1;
    });
    lockfileNames = lockfileFormats.map((l) => l.name);
    MAX_TEMP_DIR_AGE_MS = 24 * 60 * 60 * 1e3;
    GRACEFUL_RENAME_TIMEOUT = 5e3;
    safeRename = promisify$4(function gracefulRename(from, to, cb) {
      const start = Date.now();
      let backoff = 0;
      fs__default.rename(from, to, function CB(er) {
        if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < GRACEFUL_RENAME_TIMEOUT) {
          setTimeout(function() {
            fs__default.stat(to, function(stater, st) {
              if (stater && stater.code === "ENOENT") fs__default.rename(from, to, CB);
              else CB(er);
            });
          }, backoff);
          if (backoff < 100) backoff += 10;
          return;
        }
        if (cb) cb(er);
      });
    });
    debugLoad = createDebugger("vite:load");
    debugTransform = createDebugger("vite:transform");
    debugCache$1 = createDebugger("vite:cache");
    isWsl$2 = { exports: {} };
    fs$3 = require$$0__default3;
    isDocker_1 = () => {
      if (isDocker$2 === void 0) {
        isDocker$2 = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker$2;
    };
    os = require$$2;
    fs$2 = require$$0__default3;
    isDocker$1 = isDocker_1;
    isWsl$1 = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker$1()) {
          return false;
        }
        return true;
      }
      try {
        return fs$2.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker$1() : false;
      } catch (_) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      isWsl$2.exports = isWsl$1;
    } else {
      isWsl$2.exports = isWsl$1();
    }
    isWslExports = isWsl$2.exports;
    defineLazyProp = (object2, propertyName, fn) => {
      const define2 = (value2) => Object.defineProperty(object2, propertyName, { value: value2, enumerable: true, writable: true });
      Object.defineProperty(object2, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define2(result);
          return result;
        },
        set(value2) {
          define2(value2);
        }
      });
      return object2;
    };
    path$32 = require$$0$4;
    childProcess = require$$2$1;
    ({ promises: fs$1, constants: fsConstants } = require$$0__default3);
    isWsl = isWslExports;
    isDocker = isDocker_1;
    defineLazyProperty = defineLazyProp;
    localXdgOpenPath = path$32.join(__dirname5, "xdg-open");
    ({ platform, arch } = process);
    hasContainerEnv = () => {
      try {
        fs$1.statSync("/run/.containerenv");
        return true;
      } catch {
        return false;
      }
    };
    getWslDrivesMountPoint = /* @__PURE__ */ (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs$1.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs$1.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    pTryEach = async (array2, mapper) => {
      let latestError;
      for (const item of array2) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    baseOpen = async (options2) => {
      options2 = {
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false,
        ...options2
      };
      if (Array.isArray(options2.app)) {
        return pTryEach(options2.app, (singleApp) => baseOpen({
          ...options2,
          app: singleApp
        }));
      }
      let { name: app2, arguments: appArguments = [] } = options2.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app2)) {
        return pTryEach(app2, (appName) => baseOpen({
          ...options2,
          app: {
            name: appName,
            arguments: appArguments
          }
        }));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options2.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options2.background) {
          cliArguments.push("--background");
        }
        if (options2.newInstance) {
          cliArguments.push("--new");
        }
        if (app2) {
          cliArguments.push("-a", app2);
        }
      } else if (platform === "win32" || isWsl && !isInsideContainer() && !app2) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push(
          "-NoProfile",
          "-NonInteractive",
          "\u2013ExecutionPolicy",
          "Bypass",
          "-EncodedCommand"
        );
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options2.wait) {
          encodedArguments.push("-Wait");
        }
        if (app2) {
          encodedArguments.push(`"\`"${app2}\`""`, "-ArgumentList");
          if (options2.target) {
            appArguments.unshift(options2.target);
          }
        } else if (options2.target) {
          encodedArguments.push(`"${options2.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options2.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app2) {
          command = app2;
        } else {
          const isBundled = !__dirname5 || __dirname5 === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs$1.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options2.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options2.target) {
        cliArguments.push(options2.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options2.wait) {
        return new Promise((resolve8, reject) => {
          subprocess.once("error", reject);
          subprocess.once("close", (exitCode) => {
            if (!options2.allowNonzeroExitCode && exitCode > 0) {
              reject(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve8(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    open = (target, options2) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen({
        ...options2,
        target
      });
    };
    openApp = (name2, options2) => {
      if (typeof name2 !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options2 || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen({
        ...options2,
        app: {
          name: name2,
          arguments: appArguments
        }
      });
    };
    apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open.apps = apps;
    open.openApp = openApp;
    crossSpawn = { exports: {} };
    if (process.platform === "win32" || commonjsGlobal.TESTING_WINDOWS) {
      core = requireWindows();
    } else {
      core = requireMode();
    }
    isexe_1 = isexe$1;
    isexe$1.sync = sync;
    isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    path$22 = require$$0$4;
    COLON = isWindows ? ";" : ":";
    isexe = isexe_1;
    getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: "ENOENT" });
    getPathInfo = (cmd, opt) => {
      const colon3 = opt.colon || COLON;
      const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [""] : [
        // windows always checks the cwd first
        ...isWindows ? [process.cwd()] : [],
        ...(opt.path || process.env.PATH || /* istanbul ignore next: very unusual */
        "").split(colon3)
      ];
      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM" : "";
      const pathExt = isWindows ? pathExtExe.split(colon3) : [""];
      if (isWindows) {
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      return {
        pathEnv,
        pathExt,
        pathExtExe
      };
    };
    which$1 = (cmd, opt, cb) => {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      if (!opt)
        opt = {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found2 = [];
      const step = (i) => new Promise((resolve8, reject) => {
        if (i === pathEnv.length)
          return opt.all && found2.length ? resolve8(found2) : reject(getNotFoundError(cmd));
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$22.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        resolve8(subStep(p, i, 0));
      });
      const subStep = (p, i, ii) => new Promise((resolve8, reject) => {
        if (ii === pathExt.length)
          return resolve8(step(i + 1));
        const ext2 = pathExt[ii];
        isexe(p + ext2, { pathExt: pathExtExe }, (er, is) => {
          if (!er && is) {
            if (opt.all)
              found2.push(p + ext2);
            else
              return resolve8(p + ext2);
          }
          return resolve8(subStep(p, i, ii + 1));
        });
      });
      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);
    };
    whichSync = (cmd, opt) => {
      opt = opt || {};
      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
      const found2 = [];
      for (let i = 0; i < pathEnv.length; i++) {
        const ppRaw = pathEnv[i];
        const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
        const pCmd = path$22.join(pathPart, cmd);
        const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
        for (let j = 0; j < pathExt.length; j++) {
          const cur = p + pathExt[j];
          try {
            const is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found2.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found2.length)
        return found2;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    };
    which_1 = which$1;
    which$1.sync = whichSync;
    pathKey$1 = { exports: {} };
    pathKey = (options2 = {}) => {
      const environment = options2.env || process.env;
      const platform2 = options2.platform || process.platform;
      if (platform2 !== "win32") {
        return "PATH";
      }
      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === "PATH") || "Path";
    };
    pathKey$1.exports = pathKey;
    pathKey$1.exports.default = pathKey;
    pathKeyExports = pathKey$1.exports;
    path$13 = require$$0$4;
    which = which_1;
    getPathKey = pathKeyExports;
    resolveCommand_1 = resolveCommand$1;
    _escape = {};
    metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    _escape.command = escapeCommand;
    _escape.argument = escapeArgument;
    shebangRegex$1 = /^#!(.*)/;
    shebangRegex = shebangRegex$1;
    shebangCommand$1 = (string4 = "") => {
      const match2 = string4.match(shebangRegex);
      if (!match2) {
        return null;
      }
      const [path9, argument] = match2[0].replace(/#! ?/, "").split(" ");
      const binary2 = path9.split("/").pop();
      if (binary2 === "env") {
        return argument;
      }
      return argument ? `${binary2} ${argument}` : binary2;
    };
    fs3 = require$$0__default3;
    shebangCommand = shebangCommand$1;
    readShebang_1 = readShebang$1;
    path4 = require$$0$4;
    resolveCommand = resolveCommand_1;
    escape$1 = _escape;
    readShebang = readShebang_1;
    isWin$1 = process.platform === "win32";
    isExecutableRegExp = /\.(?:com|exe)$/i;
    isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    parse_1 = parse$4;
    isWin = process.platform === "win32";
    enoent$1 = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
    cp = require$$2$1;
    parse$3 = parse_1;
    enoent = enoent$1;
    crossSpawn.exports = spawn;
    crossSpawn.exports.spawn = spawn;
    crossSpawn.exports.sync = spawnSync;
    crossSpawn.exports._parse = parse$3;
    crossSpawn.exports._enoent = enoent;
    crossSpawnExports = crossSpawn.exports;
    OTHER_SOURCE_MAP_REGEXP = new RegExp(
      `//# ${SOURCEMAPPING_URL}=data:application/json[^,]+base64,([A-Za-z0-9+/=]+)$`,
      "gm"
    );
    bufferUtil$1 = { exports: {} };
    BINARY_TYPES$2 = ["nodebuffer", "arraybuffer", "fragments"];
    hasBlob$1 = typeof Blob !== "undefined";
    if (hasBlob$1) BINARY_TYPES$2.push("blob");
    constants = {
      BINARY_TYPES: BINARY_TYPES$2,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob: hasBlob$1,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
    ({ EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants);
    FastBuffer$2 = Buffer[Symbol.species];
    bufferUtil$1.exports = {
      concat: concat$1,
      mask: _mask,
      toArrayBuffer: toArrayBuffer$1,
      toBuffer: toBuffer$2,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil2 = require5("bufferutil");
        bufferUtil$1.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil2.mask(source, mask, output, offset, length);
        };
        bufferUtil$1.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil2.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
    bufferUtilExports = bufferUtil$1.exports;
    kDone = Symbol("kDone");
    kRun = Symbol("kRun");
    Limiter$1 = class Limiter {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    limiter = Limiter$1;
    zlib = zlib$1;
    bufferUtil = bufferUtilExports;
    Limiter2 = limiter;
    ({ kStatusCode: kStatusCode$2 } = constants);
    FastBuffer$1 = Buffer[Symbol.species];
    TRAILER = Buffer.from([0, 0, 255, 255]);
    kPerMessageDeflate = Symbol("permessage-deflate");
    kTotalLength = Symbol("total-length");
    kCallback = Symbol("callback");
    kBuffers = Symbol("buffers");
    kError$1 = Symbol("error");
    PerMessageDeflate$4 = class PerMessageDeflate {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options2, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options2 || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter2(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value2 = params[key];
            if (value2.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value2 = value2[0];
            if (key === "client_max_window_bits") {
              if (value2 !== true) {
                const num = +value2;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value2}`
                  );
                }
                value2 = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value2;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
              value2 = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value2 !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value2}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value2;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError$1];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    permessageDeflate = PerMessageDeflate$4;
    validation = { exports: {} };
    ({ isUtf8 } = require$$0$a);
    ({ hasBlob } = constants);
    tokenChars$2 = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    validation.exports = {
      isBlob: isBlob$2,
      isValidStatusCode: isValidStatusCode$2,
      isValidUTF8: _isValidUTF8,
      tokenChars: tokenChars$2
    };
    if (isUtf8) {
      validation.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF82 = require5("utf-8-validate");
        validation.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);
        };
      } catch (e) {
      }
    }
    validationExports = validation.exports;
    ({ Writable: Writable$1 } = require$$0$6);
    PerMessageDeflate$3 = permessageDeflate;
    ({
      BINARY_TYPES: BINARY_TYPES$1,
      EMPTY_BUFFER: EMPTY_BUFFER$2,
      kStatusCode: kStatusCode$1,
      kWebSocket: kWebSocket$3
    } = constants);
    ({ concat, toArrayBuffer, unmask } = bufferUtilExports);
    ({ isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports);
    FastBuffer = Buffer[Symbol.species];
    GET_INFO = 0;
    GET_PAYLOAD_LENGTH_16 = 1;
    GET_PAYLOAD_LENGTH_64 = 2;
    GET_MASK = 3;
    GET_DATA = 4;
    INFLATING = 5;
    DEFER_EVENT = 6;
    Receiver$1 = class Receiver extends Writable$1 {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options2 = {}) {
        super();
        this._allowSynchronousEvents = options2.allowSynchronousEvents !== void 0 ? options2.allowSynchronousEvents : true;
        this._binaryType = options2.binaryType || BINARY_TYPES$1[0];
        this._extensions = options2.extensions || {};
        this._isServer = !!options2.isServer;
        this._maxPayload = options2.maxPayload | 0;
        this._skipUTF8Validation = !!options2.skipUTF8Validation;
        this[kWebSocket$3] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER$2;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER$2);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode$1(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode$1] = statusCode;
        return err;
      }
    };
    receiver = Receiver$1;
    ({ randomFillSync } = require$$3$1);
    PerMessageDeflate$2 = permessageDeflate;
    ({ EMPTY_BUFFER: EMPTY_BUFFER$1, kWebSocket: kWebSocket$2, NOOP: NOOP$2 } = constants);
    ({ isBlob: isBlob$1, isValidStatusCode } = validationExports);
    ({ mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports);
    kByteLength = Symbol("kByteLength");
    maskBuffer = Buffer.alloc(4);
    RANDOM_POOL_SIZE = 8 * 1024;
    randomPoolPointer = RANDOM_POOL_SIZE;
    DEFAULT = 0;
    DEFLATING = 1;
    GET_BLOB_DATA = 2;
    Sender$1 = class Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions2, generateMask) {
        this._extensions = extensions2 || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP$2;
        this[kWebSocket$2] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options2) {
        let mask;
        let merge3 = false;
        let offset = 2;
        let skipMasking = false;
        if (options2.mask) {
          mask = options2.maskBuffer || maskBuffer;
          if (options2.generateMask) {
            options2.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options2.mask || skipMasking) && options2[kByteLength] !== void 0) {
            dataLength = options2[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge3 = options2.mask && options2.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge3 ? dataLength + offset : offset);
        target[0] = options2.fin ? options2.opcode | 128 : options2.opcode;
        if (options2.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options2.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge3) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER$1;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options2 = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(buf, options2), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob$1(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer$1(data);
          byteLength = data.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options2 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob$1(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options2, cb]);
          } else {
            this.getBlobData(data, false, options2, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options2), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob$1(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer$1(data);
          byteLength = data.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options2 = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob$1(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options2, cb]);
          } else {
            this.getBlobData(data, false, options2, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options2, cb]);
        } else {
          this.sendFrame(Sender.frame(data, options2), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options2, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        let opcode = options2.binary ? 2 : 1;
        let rsv1 = options2.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob$1(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer$1(data);
          byteLength = data.length;
          readOnly = toBuffer$1.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options2.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options2.fin,
          generateMask: this._generateMask,
          mask: options2.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob$1(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options2, cb) {
        this._bufferedBytes += options2[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options2[kByteLength];
          const data = toBuffer$1(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(Sender.frame(data, options2), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options2, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options2, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options2), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];
        this._bufferedBytes += options2[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options2.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options2[kByteLength];
          this._state = DEFAULT;
          options2.readOnly = false;
          this.sendFrame(Sender.frame(buf, options2), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {Buffer[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list2, cb) {
        if (list2.length === 2) {
          this._socket.cork();
          this._socket.write(list2[0]);
          this._socket.write(list2[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list2[0], cb);
        }
      }
    };
    sender = Sender$1;
    ({ kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants);
    kCode = Symbol("kCode");
    kData = Symbol("kData");
    kError = Symbol("kError");
    kMessage = Symbol("kMessage");
    kReason = Symbol("kReason");
    kTarget = Symbol("kTarget");
    kType = Symbol("kType");
    kWasClean = Symbol("kWasClean");
    Event$1 = class Event2 {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event$1.prototype, "target", { enumerable: true });
    Object.defineProperty(Event$1.prototype, "type", { enumerable: true });
    CloseEvent = class extends Event$1 {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kCode] = options2.code === void 0 ? 0 : options2.code;
        this[kReason] = options2.reason === void 0 ? "" : options2.reason;
        this[kWasClean] = options2.wasClean === void 0 ? false : options2.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    ErrorEvent = class extends Event$1 {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kError] = options2.error === void 0 ? null : options2.error;
        this[kMessage] = options2.message === void 0 ? "" : options2.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    MessageEvent = class extends Event$1 {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options2 = {}) {
        super(type);
        this[kData] = options2.data === void 0 ? null : options2.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options2 = {}) {
        for (const listener2 of this.listeners(type)) {
          if (!options2[kForOnEventAttribute$1] && listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError2(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event$1("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute$1] = !!options2[kForOnEventAttribute$1];
        wrapper[kListener$1] = handler;
        if (options2.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener2 of this.listeners(type)) {
          if (listener2[kListener$1] === handler && !listener2[kForOnEventAttribute$1]) {
            this.removeListener(type, listener2);
            break;
          }
        }
      }
    };
    eventTarget = {
      CloseEvent,
      ErrorEvent,
      Event: Event$1,
      EventTarget,
      MessageEvent
    };
    ({ tokenChars: tokenChars$1 } = validationExports);
    extension$1 = { format: format$1, parse: parse$2 };
    EventEmitter$1 = require$$0$7;
    https$2 = require$$1$1;
    http$3 = require$$1;
    net = require$$4$1;
    tls = require$$4$2;
    ({ randomBytes, createHash: createHash$1 } = require$$3$1);
    ({ URL: URL$2 } = require$$0$9);
    PerMessageDeflate$1 = permessageDeflate;
    Receiver2 = receiver;
    Sender2 = sender;
    ({ isBlob } = validationExports);
    ({
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID: GUID$1,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket: kWebSocket$1,
      NOOP: NOOP$1
    } = constants);
    ({
      EventTarget: { addEventListener, removeEventListener }
    } = eventTarget);
    ({ format, parse: parse$12 } = extension$1);
    ({ toBuffer } = bufferUtilExports);
    closeTimeout = 30 * 1e3;
    kAborted = Symbol("kAborted");
    protocolVersions = [8, 13];
    readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    WebSocket$1 = class WebSocket extends EventEmitter$1 {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options2) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options2 = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options2);
        } else {
          this._autoPong = options2.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options2) {
        const receiver2 = new Receiver2({
          allowSynchronousEvents: options2.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options2.maxPayload,
          skipUTF8Validation: options2.skipUTF8Validation
        });
        const sender2 = new Sender2(socket, this._extensions, options2.generateMask);
        this._receiver = receiver2;
        this._sender = sender2;
        this._socket = socket;
        receiver2[kWebSocket$1] = this;
        sender2[kWebSocket$1] = this;
        socket[kWebSocket$1] = this;
        receiver2.on("conclude", receiverOnConclude);
        receiver2.on("drain", receiverOnDrain);
        receiver2.on("error", receiverOnError);
        receiver2.on("message", receiverOnMessage);
        receiver2.on("ping", receiverOnPing);
        receiver2.on("pong", receiverOnPong);
        sender2.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError$1);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate$1.extensionName]) {
          this._extensions[PerMessageDeflate$1.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake$1(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options2, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options2 === "function") {
          cb = options2;
          options2 = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options2
        };
        if (!this._extensions[PerMessageDeflate$1.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === WebSocket.CLOSED) return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake$1(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket$1, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket$1, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket$1, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket$1, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket$1.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket$1.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute]) return listener2[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener2 of this.listeners(method)) {
            if (listener2[kForOnEventAttribute]) {
              this.removeListener(method, listener2);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket$1.prototype.addEventListener = addEventListener;
    WebSocket$1.prototype.removeEventListener = removeEventListener;
    websocket = WebSocket$1;
    ({ tokenChars } = validationExports);
    subprotocol$1 = { parse: parse5 };
    EventEmitter = require$$0$7;
    http$2 = require$$1;
    ({ createHash } = require$$3$1);
    extension = extension$1;
    PerMessageDeflate2 = permessageDeflate;
    subprotocol = subprotocol$1;
    WebSocket2 = websocket;
    ({ GUID, kWebSocket } = constants);
    keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    RUNNING = 0;
    CLOSING = 1;
    CLOSED = 2;
    WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options2, callback) {
        super();
        options2 = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options2
        };
        if (options2.port == null && !options2.server && !options2.noServer || options2.port != null && (options2.server || options2.noServer) || options2.server && options2.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options2.port != null) {
          this._server = http$2.createServer((req2, res) => {
            const body = http$2.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options2.port,
            options2.host,
            options2.backlog,
            callback
          );
        } else if (options2.server) {
          this._server = options2.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req2, socket, head) => {
              this.handleUpgrade(req2, socket, head, emitConnection);
            }
          });
        }
        if (options2.perMessageDeflate === true) options2.perMessageDeflate = {};
        if (options2.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options2;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req2) {
        if (this.options.path) {
          const index4 = req2.url.indexOf("?");
          const pathname = index4 !== -1 ? req2.url.slice(0, index4) : req2.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req2, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req2.headers["sec-websocket-key"];
        const upgrade = req2.headers.upgrade;
        const version4 = +req2.headers["sec-websocket-version"];
        if (req2.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req2, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
          return;
        }
        if (version4 !== 8 && version4 !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req2)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req2.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req2.headers["sec-websocket-extensions"];
        const extensions2 = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate2(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate2.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);
              extensions2[PerMessageDeflate2.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req2, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req2.headers[`${version4 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req2.socket.authorized || req2.socket.encrypted),
            req: req2
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions2,
                key,
                protocols,
                req2,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions2, key, protocols, req2, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions2, key, protocols, req2, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req2) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions2[PerMessageDeflate2.extensionName]) {
          const params = extensions2[PerMessageDeflate2.extensionName].params;
          const value2 = extension.format({
            [PerMessageDeflate2.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value2}`);
          ws._extensions = extensions2;
        }
        this.emit("headers", headers, req2);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req2);
      }
    };
    websocketServer = WebSocketServer;
    WebSocketServerRaw_ = /* @__PURE__ */ getDefaultExportFromCjs(websocketServer);
    WebSocketServerRaw = process.versions.bun ? (
      // @ts-expect-error: Bun defines `import.meta.require`
      import.meta.require("ws").WebSocketServer
    ) : WebSocketServerRaw_;
    httpProxy$3 = { exports: {} };
    eventemitter3 = { exports: {} };
    (function(module) {
      var has = Object.prototype.hasOwnProperty, prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener2 = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener2, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener2);
        else emitter._events[evt] = [emitter._events[evt], listener2];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter2() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        var names = [], events2, name2;
        if (this._eventsCount === 0) return names;
        for (name2 in events2 = this._events) {
          if (has.call(events2, name2)) names.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events2));
        }
        return names;
      };
      EventEmitter2.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter2.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length, j;
          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter2.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter2.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events2 = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events2.push(listeners[i]);
            }
          }
          if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
      EventEmitter2.prefixed = prefix;
      EventEmitter2.EventEmitter = EventEmitter2;
      {
        module.exports = EventEmitter2;
      }
    })(eventemitter3);
    eventemitter3Exports = eventemitter3.exports;
    common$3 = {};
    requiresPort = function required(port, protocol) {
      protocol = protocol.split(":")[0];
      port = +port;
      if (!port) return false;
      switch (protocol) {
        case "http":
        case "ws":
          return port !== 80;
        case "https":
        case "wss":
          return port !== 443;
        case "ftp":
          return port !== 21;
        case "gopher":
          return port !== 70;
        case "file":
          return false;
      }
      return port !== 0;
    };
    (function(exports2) {
      var common2 = exports2, url2 = require$$0$9, required2 = requiresPort;
      var upgradeHeader = /(^|,)\s*upgrade\s*($|,)/i, isSSL = /^https|wss/;
      common2.isSSL = isSSL;
      common2.setupOutgoing = function(outgoing, options2, req2, forward) {
        outgoing.port = options2[forward || "target"].port || (isSSL.test(options2[forward || "target"].protocol) ? 443 : 80);
        [
          "host",
          "hostname",
          "socketPath",
          "pfx",
          "key",
          "passphrase",
          "cert",
          "ca",
          "ciphers",
          "secureProtocol"
        ].forEach(
          function(e) {
            outgoing[e] = options2[forward || "target"][e];
          }
        );
        outgoing.method = options2.method || req2.method;
        outgoing.headers = Object.assign({}, req2.headers);
        if (options2.headers) {
          Object.assign(outgoing.headers, options2.headers);
        }
        if (options2.auth) {
          outgoing.auth = options2.auth;
        }
        if (options2.ca) {
          outgoing.ca = options2.ca;
        }
        if (isSSL.test(options2[forward || "target"].protocol)) {
          outgoing.rejectUnauthorized = typeof options2.secure === "undefined" ? true : options2.secure;
        }
        outgoing.agent = options2.agent || false;
        outgoing.localAddress = options2.localAddress;
        if (!outgoing.agent) {
          outgoing.headers = outgoing.headers || {};
          if (typeof outgoing.headers.connection !== "string" || !upgradeHeader.test(outgoing.headers.connection)) {
            outgoing.headers.connection = "close";
          }
        }
        var target = options2[forward || "target"];
        var targetPath = target && options2.prependPath !== false ? target.path || "" : "";
        var outgoingPath = !options2.toProxy ? url2.parse(req2.url).path || "" : req2.url;
        outgoingPath = !options2.ignorePath ? outgoingPath : "";
        outgoing.path = common2.urlJoin(targetPath, outgoingPath);
        if (options2.changeOrigin) {
          outgoing.headers.host = required2(outgoing.port, options2[forward || "target"].protocol) && !hasPort(outgoing.host) ? outgoing.host + ":" + outgoing.port : outgoing.host;
        }
        return outgoing;
      };
      common2.setupSocket = function(socket) {
        socket.setTimeout(0);
        socket.setNoDelay(true);
        socket.setKeepAlive(true, 0);
        return socket;
      };
      common2.getPort = function(req2) {
        var res = req2.headers.host ? req2.headers.host.match(/:(\d+)/) : "";
        return res ? res[1] : common2.hasEncryptedConnection(req2) ? "443" : "80";
      };
      common2.hasEncryptedConnection = function(req2) {
        return Boolean(req2.connection.encrypted || req2.connection.pair);
      };
      common2.urlJoin = function() {
        var args = Array.prototype.slice.call(arguments), lastIndex = args.length - 1, last = args[lastIndex], lastSegs = last.split("?"), retSegs;
        args[lastIndex] = lastSegs.shift();
        retSegs = [
          args.filter(Boolean).join("/").replace(/\/+/g, "/").replace("http:/", "http://").replace("https:/", "https://")
        ];
        retSegs.push.apply(retSegs, lastSegs);
        return retSegs.join("?");
      };
      common2.rewriteCookieProperty = function rewriteCookieProperty(header, config2, property) {
        if (Array.isArray(header)) {
          return header.map(function(headerElement) {
            return rewriteCookieProperty(headerElement, config2, property);
          });
        }
        return header.replace(new RegExp("(;\\s*" + property + "=)([^;]+)", "i"), function(match2, prefix, previousValue) {
          var newValue;
          if (previousValue in config2) {
            newValue = config2[previousValue];
          } else if ("*" in config2) {
            newValue = config2["*"];
          } else {
            return match2;
          }
          if (newValue) {
            return prefix + newValue;
          } else {
            return "";
          }
        });
      };
      function hasPort(host) {
        return !!~host.indexOf(":");
      }
    })(common$3);
    url$1 = require$$0$9;
    common$2 = common$3;
    redirectRegex = /^201|30(1|2|7|8)$/;
    webOutgoing = {
      // <--
      /**
       * If is a HTTP 1.0 request, remove chunk headers
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      removeChunked: function removeChunked(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          delete proxyRes.headers["transfer-encoding"];
        }
      },
      /**
       * If is a HTTP 1.0 request, set the correct connection header
       * or if connection header not present, then use `keep-alive`
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      setConnection: function setConnection(req2, res, proxyRes) {
        if (req2.httpVersion === "1.0") {
          proxyRes.headers.connection = req2.headers.connection || "close";
        } else if (req2.httpVersion !== "2.0" && !proxyRes.headers.connection) {
          proxyRes.headers.connection = req2.headers.connection || "keep-alive";
        }
      },
      setRedirectHostRewrite: function setRedirectHostRewrite(req2, res, proxyRes, options2) {
        if ((options2.hostRewrite || options2.autoRewrite || options2.protocolRewrite) && proxyRes.headers["location"] && redirectRegex.test(proxyRes.statusCode)) {
          var target = url$1.parse(options2.target);
          var u = url$1.parse(proxyRes.headers["location"]);
          if (target.host != u.host) {
            return;
          }
          if (options2.hostRewrite) {
            u.host = options2.hostRewrite;
          } else if (options2.autoRewrite) {
            u.host = req2.headers["host"];
          }
          if (options2.protocolRewrite) {
            u.protocol = options2.protocolRewrite;
          }
          proxyRes.headers["location"] = u.format();
        }
      },
      /**
       * Copy headers from proxyResponse to response
       * set each header in response object.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       * @param {Object} Options options.cookieDomainRewrite: Config to rewrite cookie domain
       *
       * @api private
       */
      writeHeaders: function writeHeaders(req2, res, proxyRes, options2) {
        var rewriteCookieDomainConfig = options2.cookieDomainRewrite, rewriteCookiePathConfig = options2.cookiePathRewrite, preserveHeaderKeyCase = options2.preserveHeaderKeyCase, rawHeaderKeyMap, setHeader = function(key2, header) {
          if (header == void 0) return;
          if (rewriteCookieDomainConfig && key2.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookieDomainConfig, "domain");
          }
          if (rewriteCookiePathConfig && key2.toLowerCase() === "set-cookie") {
            header = common$2.rewriteCookieProperty(header, rewriteCookiePathConfig, "path");
          }
          res.setHeader(String(key2).trim(), header);
        };
        if (typeof rewriteCookieDomainConfig === "string") {
          rewriteCookieDomainConfig = { "*": rewriteCookieDomainConfig };
        }
        if (typeof rewriteCookiePathConfig === "string") {
          rewriteCookiePathConfig = { "*": rewriteCookiePathConfig };
        }
        if (preserveHeaderKeyCase && proxyRes.rawHeaders != void 0) {
          rawHeaderKeyMap = {};
          for (var i = 0; i < proxyRes.rawHeaders.length; i += 2) {
            var key = proxyRes.rawHeaders[i];
            rawHeaderKeyMap[key.toLowerCase()] = key;
          }
        }
        Object.keys(proxyRes.headers).forEach(function(key2) {
          var header = proxyRes.headers[key2];
          if (preserveHeaderKeyCase && rawHeaderKeyMap) {
            key2 = rawHeaderKeyMap[key2] || key2;
          }
          setHeader(key2, header);
        });
      },
      /**
       * Set the statusCode from the proxyResponse
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {proxyResponse} Res Response object from the proxy request
       *
       * @api private
       */
      writeStatusCode: function writeStatusCode(req2, res, proxyRes) {
        if (proxyRes.statusMessage) {
          res.statusCode = proxyRes.statusCode;
          res.statusMessage = proxyRes.statusMessage;
        } else {
          res.statusCode = proxyRes.statusCode;
        }
      }
    };
    followRedirects$1 = { exports: {} };
    debug_1 = function() {
      if (!debug$6) {
        try {
          debug$6 = srcExports$12("follow-redirects");
        } catch (error) {
        }
        if (typeof debug$6 !== "function") {
          debug$6 = function() {
          };
        }
      }
      debug$6.apply(null, arguments);
    };
    url = require$$0$9;
    URL$1 = url.URL;
    http$1 = require$$1;
    https$1 = require$$1$1;
    Writable = require$$0$6.Writable;
    assert = require$$4$3;
    debug$5 = debug_1;
    useNativeURL = false;
    try {
      assert(new URL$1());
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    destroy = Writable.prototype.destroy || noop;
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString2(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name2, value2) {
      this._options.headers[name2] = value2;
      this._currentRequest.setHeader(name2, value2);
    };
    RedirectableRequest.prototype.removeHeader = function(name2) {
      delete this._options.headers[name2];
      this._currentRequest.removeHeader(name2);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options2) {
      if (!options2.headers) {
        options2.headers = {};
      }
      if (options2.host) {
        if (!options2.hostname) {
          options2.hostname = options2.host;
        }
        delete options2.host;
      }
      if (!options2.pathname && options2.path) {
        var searchPos = options2.path.indexOf("?");
        if (searchPos < 0) {
          options2.pathname = options2.path;
        } else {
          options2.pathname = options2.path.substring(0, searchPos);
          options2.search = options2.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, […]
        // a client MUST send the target URI in absolute-form […].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location2 = response.headers.location;
      if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location2, currentUrl);
      debug$5("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    followRedirects$1.exports = wrap({ http: http$1, https: https$1 });
    followRedirects$1.exports.wrap = wrap;
    followRedirectsExports = followRedirects$1.exports;
    httpNative = require$$1;
    httpsNative = require$$1$1;
    web_o = webOutgoing;
    common$1 = common$3;
    followRedirects = followRedirectsExports;
    web_o = Object.keys(web_o).map(function(pass) {
      return web_o[pass];
    });
    nativeAgents = { http: httpNative, https: httpsNative };
    webIncoming = {
      /**
       * Sets `content-length` to '0' if request is of DELETE type.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      deleteLength: function deleteLength(req2, res, options2) {
        if ((req2.method === "DELETE" || req2.method === "OPTIONS") && !req2.headers["content-length"]) {
          req2.headers["content-length"] = "0";
          delete req2.headers["transfer-encoding"];
        }
      },
      /**
       * Sets timeout in request socket if it was specified in options.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      timeout: function timeout(req2, res, options2) {
        if (options2.timeout) {
          req2.socket.setTimeout(options2.timeout);
        }
      },
      /**
       * Sets `x-forwarded-*` headers if specified in config.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      XHeaders: function XHeaders(req2, res, options2) {
        if (!options2.xfwd) return;
        var encrypted = req2.isSpdy || common$1.hasEncryptedConnection(req2);
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common$1.getPort(req2),
          proto: encrypted ? "https" : "http"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
        req2.headers["x-forwarded-host"] = req2.headers["x-forwarded-host"] || req2.headers["host"] || "";
      },
      /**
       * Does the actual proxying. If `forward` is enabled fires up
       * a ForwardStream, same happens for ProxyStream. The request
       * just dies otherwise.
       *
       * @param {ClientRequest} Req Request object
       * @param {IncomingMessage} Res Response object
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      stream: function stream2(req2, res, options2, _, server, clb) {
        server.emit("start", req2, res, options2.target || options2.forward);
        var agents = options2.followRedirects ? followRedirects : nativeAgents;
        var http2 = agents.http;
        var https2 = agents.https;
        if (options2.forward) {
          var forwardReq = (options2.forward.protocol === "https:" ? https2 : http2).request(
            common$1.setupOutgoing(options2.ssl || {}, options2, req2, "forward")
          );
          var forwardError = createErrorHandler(forwardReq, options2.forward);
          req2.on("error", forwardError);
          forwardReq.on("error", forwardError);
          (options2.buffer || req2).pipe(forwardReq);
          if (!options2.target) {
            return res.end();
          }
        }
        var proxyReq = (options2.target.protocol === "https:" ? https2 : http2).request(
          common$1.setupOutgoing(options2.ssl || {}, options2, req2)
        );
        proxyReq.on("socket", function(socket) {
          if (server && !proxyReq.getHeader("expect")) {
            server.emit("proxyReq", proxyReq, req2, res, options2);
          }
        });
        if (options2.proxyTimeout) {
          proxyReq.setTimeout(options2.proxyTimeout, function() {
            proxyReq.abort();
          });
        }
        req2.on("aborted", function() {
          proxyReq.abort();
        });
        var proxyError = createErrorHandler(proxyReq, options2.target);
        req2.on("error", proxyError);
        proxyReq.on("error", proxyError);
        function createErrorHandler(proxyReq2, url2) {
          return function proxyError2(err) {
            if (req2.socket.destroyed && err.code === "ECONNRESET") {
              server.emit("econnreset", err, req2, res, url2);
              return proxyReq2.abort();
            }
            if (clb) {
              clb(err, req2, res, url2);
            } else {
              server.emit("error", err, req2, res, url2);
            }
          };
        }
        (options2.buffer || req2).pipe(proxyReq);
        proxyReq.on("response", function(proxyRes) {
          if (server) {
            server.emit("proxyRes", proxyRes, req2, res);
          }
          if (!res.headersSent && !options2.selfHandleResponse) {
            for (var i = 0; i < web_o.length; i++) {
              if (web_o[i](req2, res, proxyRes, options2)) {
                break;
              }
            }
          }
          if (!res.finished) {
            proxyRes.on("end", function() {
              if (server) server.emit("end", req2, res, proxyRes);
            });
            if (!options2.selfHandleResponse) proxyRes.pipe(res);
          } else {
            if (server) server.emit("end", req2, res, proxyRes);
          }
        });
      }
    };
    http = require$$1;
    https = require$$1$1;
    common = common$3;
    wsIncoming = {
      /**
       * WebSocket requests must have the `GET` method and
       * the `upgrade:websocket` header
       *
       * @param {ClientRequest} Req Request object
       * @param {Socket} Websocket
       *
       * @api private
       */
      checkMethodAndHeader: function checkMethodAndHeader(req2, socket) {
        if (req2.method !== "GET" || !req2.headers.upgrade) {
          socket.destroy();
          return true;
        }
        if (req2.headers.upgrade.toLowerCase() !== "websocket") {
          socket.destroy();
          return true;
        }
      },
      /**
       * Sets `x-forwarded-*` headers if specified in config.
       *
       * @param {ClientRequest} Req Request object
       * @param {Socket} Websocket
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      XHeaders: function XHeaders2(req2, socket, options2) {
        if (!options2.xfwd) return;
        var values = {
          for: req2.connection.remoteAddress || req2.socket.remoteAddress,
          port: common.getPort(req2),
          proto: common.hasEncryptedConnection(req2) ? "wss" : "ws"
        };
        ["for", "port", "proto"].forEach(function(header) {
          req2.headers["x-forwarded-" + header] = (req2.headers["x-forwarded-" + header] || "") + (req2.headers["x-forwarded-" + header] ? "," : "") + values[header];
        });
      },
      /**
       * Does the actual proxying. Make the request and upgrade it
       * send the Switching Protocols request and pipe the sockets.
       *
       * @param {ClientRequest} Req Request object
       * @param {Socket} Websocket
       * @param {Object} Options Config object passed to the proxy
       *
       * @api private
       */
      stream: function stream3(req2, socket, options2, head, server, clb) {
        var createHttpHeader = function(line, headers) {
          return Object.keys(headers).reduce(function(head2, key) {
            var value2 = headers[key];
            if (!Array.isArray(value2)) {
              head2.push(key + ": " + value2);
              return head2;
            }
            for (var i = 0; i < value2.length; i++) {
              head2.push(key + ": " + value2[i]);
            }
            return head2;
          }, [line]).join("\r\n") + "\r\n\r\n";
        };
        common.setupSocket(socket);
        if (head && head.length) socket.unshift(head);
        var proxyReq = (common.isSSL.test(options2.target.protocol) ? https : http).request(
          common.setupOutgoing(options2.ssl || {}, options2, req2)
        );
        if (server) {
          server.emit("proxyReqWs", proxyReq, req2, socket, options2, head);
        }
        proxyReq.on("error", onOutgoingError);
        proxyReq.on("response", function(res) {
          if (!res.upgrade) {
            socket.write(createHttpHeader("HTTP/" + res.httpVersion + " " + res.statusCode + " " + res.statusMessage, res.headers));
            res.pipe(socket);
          }
        });
        proxyReq.on("upgrade", function(proxyRes, proxySocket, proxyHead) {
          proxySocket.on("error", onOutgoingError);
          proxySocket.on("end", function() {
            server.emit("close", proxyRes, proxySocket, proxyHead);
          });
          socket.on("error", function() {
            proxySocket.end();
          });
          common.setupSocket(proxySocket);
          if (proxyHead && proxyHead.length) proxySocket.unshift(proxyHead);
          socket.write(createHttpHeader("HTTP/1.1 101 Switching Protocols", proxyRes.headers));
          proxySocket.pipe(socket).pipe(proxySocket);
          server.emit("open", proxySocket);
          server.emit("proxySocket", proxySocket);
        });
        return proxyReq.end();
        function onOutgoingError(err) {
          if (clb) {
            clb(err, req2, socket);
          } else {
            server.emit("error", err, req2, socket);
          }
          socket.end();
        }
      }
    };
    (function(module) {
      var httpProxy = module.exports, parse_url = require$$0$9.parse, EE3 = eventemitter3Exports, http2 = require$$1, https2 = require$$1$1, web = webIncoming, ws = wsIncoming;
      httpProxy.Server = ProxyServer2;
      function createRightProxy(type) {
        return function(options2) {
          return function(req2, res) {
            var passes = type === "ws" ? this.wsPasses : this.webPasses, args = [].slice.call(arguments), cntr = args.length - 1, head, cbl;
            if (typeof args[cntr] === "function") {
              cbl = args[cntr];
              cntr--;
            }
            var requestOptions = options2;
            if (!(args[cntr] instanceof Buffer) && args[cntr] !== res) {
              requestOptions = Object.assign({}, options2);
              Object.assign(requestOptions, args[cntr]);
              cntr--;
            }
            if (args[cntr] instanceof Buffer) {
              head = args[cntr];
            }
            ["target", "forward"].forEach(function(e) {
              if (typeof requestOptions[e] === "string")
                requestOptions[e] = parse_url(requestOptions[e]);
            });
            if (!requestOptions.target && !requestOptions.forward) {
              return this.emit("error", new Error("Must provide a proper URL as target"));
            }
            for (var i = 0; i < passes.length; i++) {
              if (passes[i](req2, res, requestOptions, head, this, cbl)) {
                break;
              }
            }
          };
        };
      }
      httpProxy.createRightProxy = createRightProxy;
      function ProxyServer2(options2) {
        EE3.call(this);
        options2 = options2 || {};
        options2.prependPath = options2.prependPath === false ? false : true;
        this.web = this.proxyRequest = createRightProxy("web")(options2);
        this.ws = this.proxyWebsocketRequest = createRightProxy("ws")(options2);
        this.options = options2;
        this.webPasses = Object.keys(web).map(function(pass) {
          return web[pass];
        });
        this.wsPasses = Object.keys(ws).map(function(pass) {
          return ws[pass];
        });
        this.on("error", this.onError, this);
      }
      require$$0$5.inherits(ProxyServer2, EE3);
      ProxyServer2.prototype.onError = function(err) {
        if (this.listeners("error").length === 1) {
          throw err;
        }
      };
      ProxyServer2.prototype.listen = function(port, hostname) {
        var self2 = this, closure = function(req2, res) {
          self2.web(req2, res);
        };
        this._server = this.options.ssl ? https2.createServer(this.options.ssl, closure) : http2.createServer(closure);
        if (this.options.ws) {
          this._server.on("upgrade", function(req2, socket, head) {
            self2.ws(req2, socket, head);
          });
        }
        this._server.listen(port, hostname);
        return this;
      };
      ProxyServer2.prototype.close = function(callback) {
        var self2 = this;
        if (this._server) {
          this._server.close(done);
        }
        function done() {
          self2._server = null;
          if (callback) {
            callback.apply(null, arguments);
          }
        }
      };
      ProxyServer2.prototype.before = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i = false;
        passes.forEach(function(v, idx) {
          if (v.name === passName) i = idx;
        });
        if (i === false) throw new Error("No such pass");
        passes.splice(i, 0, callback);
      };
      ProxyServer2.prototype.after = function(type, passName, callback) {
        if (type !== "ws" && type !== "web") {
          throw new Error("type must be `web` or `ws`");
        }
        var passes = type === "ws" ? this.wsPasses : this.webPasses, i = false;
        passes.forEach(function(v, idx) {
          if (v.name === passName) i = idx;
        });
        if (i === false) throw new Error("No such pass");
        passes.splice(i++, 0, callback);
      };
    })(httpProxy$3);
    httpProxyExports = httpProxy$3.exports;
    ProxyServer = httpProxyExports.Server;
    ProxyServer.createProxyServer = createProxyServer;
    ProxyServer.createServer = createProxyServer;
    ProxyServer.createProxy = createProxyServer;
    debug$4 = createDebugger("vite:proxy");
    debug$3 = createDebugger("vite:html-fallback");
    debug$2 = createDebugger("vite:send", {
      onlyWhenFocused: true
    });
    debugCache = createDebugger("vite:cache");
    logTime = createDebugger("vite:time");
    debugHmr = createDebugger("vite:hmr");
    normalizedClientDir = normalizePath$3(CLIENT_DIR);
    debug$1 = createDebugger("vite:import-analysis");
    clientDir = normalizePath$3(CLIENT_DIR);
    preloadMarker = `__VITE_PRELOAD__`;
    preloadMarkerRE = new RegExp(preloadMarker, "g");
    needsEscapeRegEx = /[\n\r'\\\u2028\u2029]/;
    quoteNewlineRegEx = /([\n\r'\u2028\u2029])/g;
    backSlashRegEx = /\\/g;
    getResolveUrl = (path22, URL2 = "URL") => `new ${URL2}(${path22}).href`;
    getRelativeUrlFromDocument = (relativePath, umd = false) => getResolveUrl(
      `'${escapeId(partialEncodeURIPath(relativePath))}', ${umd ? `typeof document === 'undefined' ? location.href : ` : ""}document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT' && document.currentScript.src || document.baseURI`
    );
    getFileUrlFromFullPath = (path22) => `require('u' + 'rl').pathToFileURL(${path22}).href`;
    getFileUrlFromRelativePath = (path22) => getFileUrlFromFullPath(`__dirname + '/${escapeId(path22)}'`);
    relativeUrlMechanisms = {
      amd: (relativePath) => {
        if (relativePath[0] !== ".") relativePath = "./" + relativePath;
        return getResolveUrl(
          `require.toUrl('${escapeId(relativePath)}'), document.baseURI`
        );
      },
      cjs: (relativePath) => `(typeof document === 'undefined' ? ${getFileUrlFromRelativePath(
        relativePath
      )} : ${getRelativeUrlFromDocument(relativePath)})`,
      es: (relativePath) => getResolveUrl(
        `'${escapeId(partialEncodeURIPath(relativePath))}', import.meta.url`
      ),
      iife: (relativePath) => getRelativeUrlFromDocument(relativePath),
      // NOTE: make sure rollup generate `module` params
      system: (relativePath) => getResolveUrl(
        `'${escapeId(partialEncodeURIPath(relativePath))}', module.meta.url`
      ),
      umd: (relativePath) => `(typeof document === 'undefined' && typeof location === 'undefined' ? ${getFileUrlFromRelativePath(
        relativePath
      )} : ${getRelativeUrlFromDocument(relativePath, true)})`
    };
    customRelativeUrlMechanisms = {
      ...relativeUrlMechanisms,
      "worker-iife": (relativePath) => getResolveUrl(
        `'${escapeId(partialEncodeURIPath(relativePath))}', self.location.href`
      )
    };
    debug = createDebugger("vite:config");
    promisifiedRealpath = promisify$4(fs__default.realpath);
    _require = createRequire$1(import.meta.url);
  }
});

// node_modules/@babel/types/lib/utils/shallowEqual.js
var require_shallowEqual = __commonJS({
  "node_modules/@babel/types/lib/utils/shallowEqual.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = shallowEqual;
    function shallowEqual(actual, expected) {
      const keys = Object.keys(expected);
      for (const key of keys) {
        if (actual[key] !== expected[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/utils/deprecationWarning.js
var require_deprecationWarning = __commonJS({
  "node_modules/@babel/types/lib/utils/deprecationWarning.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = deprecationWarning;
    var warnings = /* @__PURE__ */ new Set();
    function deprecationWarning(oldName, newName, prefix = "") {
      if (warnings.has(oldName)) return;
      warnings.add(oldName);
      const {
        internal,
        trace
      } = captureShortStackTrace(1, 2);
      if (internal) {
        return;
      }
      console.warn(`${prefix}\`${oldName}\` has been deprecated, please migrate to \`${newName}\`
${trace}`);
    }
    function captureShortStackTrace(skip, length) {
      const {
        stackTraceLimit,
        prepareStackTrace
      } = Error;
      let stackTrace;
      Error.stackTraceLimit = 1 + skip + length;
      Error.prepareStackTrace = function(err, stack) {
        stackTrace = stack;
      };
      new Error().stack;
      Error.stackTraceLimit = stackTraceLimit;
      Error.prepareStackTrace = prepareStackTrace;
      if (!stackTrace) return {
        internal: false,
        trace: ""
      };
      const shortStackTrace = stackTrace.slice(1 + skip, 1 + skip + length);
      return {
        internal: /[\\/]@babel[\\/]/.test(shortStackTrace[1].getFileName()),
        trace: shortStackTrace.map((frame) => `    at ${frame}`).join("\n")
      };
    }
  }
});

// node_modules/@babel/types/lib/validators/generated/index.js
var require_generated = __commonJS({
  "node_modules/@babel/types/lib/validators/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAccessor = isAccessor;
    exports2.isAnyTypeAnnotation = isAnyTypeAnnotation;
    exports2.isArgumentPlaceholder = isArgumentPlaceholder;
    exports2.isArrayExpression = isArrayExpression;
    exports2.isArrayPattern = isArrayPattern;
    exports2.isArrayTypeAnnotation = isArrayTypeAnnotation;
    exports2.isArrowFunctionExpression = isArrowFunctionExpression;
    exports2.isAssignmentExpression = isAssignmentExpression;
    exports2.isAssignmentPattern = isAssignmentPattern;
    exports2.isAwaitExpression = isAwaitExpression;
    exports2.isBigIntLiteral = isBigIntLiteral;
    exports2.isBinary = isBinary;
    exports2.isBinaryExpression = isBinaryExpression;
    exports2.isBindExpression = isBindExpression;
    exports2.isBlock = isBlock;
    exports2.isBlockParent = isBlockParent;
    exports2.isBlockStatement = isBlockStatement;
    exports2.isBooleanLiteral = isBooleanLiteral;
    exports2.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
    exports2.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
    exports2.isBreakStatement = isBreakStatement;
    exports2.isCallExpression = isCallExpression;
    exports2.isCatchClause = isCatchClause;
    exports2.isClass = isClass;
    exports2.isClassAccessorProperty = isClassAccessorProperty;
    exports2.isClassBody = isClassBody;
    exports2.isClassDeclaration = isClassDeclaration;
    exports2.isClassExpression = isClassExpression;
    exports2.isClassImplements = isClassImplements;
    exports2.isClassMethod = isClassMethod;
    exports2.isClassPrivateMethod = isClassPrivateMethod;
    exports2.isClassPrivateProperty = isClassPrivateProperty;
    exports2.isClassProperty = isClassProperty;
    exports2.isCompletionStatement = isCompletionStatement;
    exports2.isConditional = isConditional;
    exports2.isConditionalExpression = isConditionalExpression;
    exports2.isContinueStatement = isContinueStatement;
    exports2.isDebuggerStatement = isDebuggerStatement;
    exports2.isDecimalLiteral = isDecimalLiteral;
    exports2.isDeclaration = isDeclaration;
    exports2.isDeclareClass = isDeclareClass;
    exports2.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
    exports2.isDeclareExportDeclaration = isDeclareExportDeclaration;
    exports2.isDeclareFunction = isDeclareFunction;
    exports2.isDeclareInterface = isDeclareInterface;
    exports2.isDeclareModule = isDeclareModule;
    exports2.isDeclareModuleExports = isDeclareModuleExports;
    exports2.isDeclareOpaqueType = isDeclareOpaqueType;
    exports2.isDeclareTypeAlias = isDeclareTypeAlias;
    exports2.isDeclareVariable = isDeclareVariable;
    exports2.isDeclaredPredicate = isDeclaredPredicate;
    exports2.isDecorator = isDecorator;
    exports2.isDirective = isDirective;
    exports2.isDirectiveLiteral = isDirectiveLiteral;
    exports2.isDoExpression = isDoExpression;
    exports2.isDoWhileStatement = isDoWhileStatement;
    exports2.isEmptyStatement = isEmptyStatement;
    exports2.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
    exports2.isEnumBody = isEnumBody;
    exports2.isEnumBooleanBody = isEnumBooleanBody;
    exports2.isEnumBooleanMember = isEnumBooleanMember;
    exports2.isEnumDeclaration = isEnumDeclaration;
    exports2.isEnumDefaultedMember = isEnumDefaultedMember;
    exports2.isEnumMember = isEnumMember;
    exports2.isEnumNumberBody = isEnumNumberBody;
    exports2.isEnumNumberMember = isEnumNumberMember;
    exports2.isEnumStringBody = isEnumStringBody;
    exports2.isEnumStringMember = isEnumStringMember;
    exports2.isEnumSymbolBody = isEnumSymbolBody;
    exports2.isExistsTypeAnnotation = isExistsTypeAnnotation;
    exports2.isExportAllDeclaration = isExportAllDeclaration;
    exports2.isExportDeclaration = isExportDeclaration;
    exports2.isExportDefaultDeclaration = isExportDefaultDeclaration;
    exports2.isExportDefaultSpecifier = isExportDefaultSpecifier;
    exports2.isExportNamedDeclaration = isExportNamedDeclaration;
    exports2.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
    exports2.isExportSpecifier = isExportSpecifier;
    exports2.isExpression = isExpression;
    exports2.isExpressionStatement = isExpressionStatement;
    exports2.isExpressionWrapper = isExpressionWrapper;
    exports2.isFile = isFile;
    exports2.isFlow = isFlow;
    exports2.isFlowBaseAnnotation = isFlowBaseAnnotation;
    exports2.isFlowDeclaration = isFlowDeclaration;
    exports2.isFlowPredicate = isFlowPredicate;
    exports2.isFlowType = isFlowType;
    exports2.isFor = isFor;
    exports2.isForInStatement = isForInStatement;
    exports2.isForOfStatement = isForOfStatement;
    exports2.isForStatement = isForStatement;
    exports2.isForXStatement = isForXStatement;
    exports2.isFunction = isFunction2;
    exports2.isFunctionDeclaration = isFunctionDeclaration;
    exports2.isFunctionExpression = isFunctionExpression;
    exports2.isFunctionParent = isFunctionParent;
    exports2.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
    exports2.isFunctionTypeParam = isFunctionTypeParam;
    exports2.isGenericTypeAnnotation = isGenericTypeAnnotation;
    exports2.isIdentifier = isIdentifier2;
    exports2.isIfStatement = isIfStatement;
    exports2.isImmutable = isImmutable;
    exports2.isImport = isImport;
    exports2.isImportAttribute = isImportAttribute;
    exports2.isImportDeclaration = isImportDeclaration;
    exports2.isImportDefaultSpecifier = isImportDefaultSpecifier;
    exports2.isImportExpression = isImportExpression;
    exports2.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
    exports2.isImportOrExportDeclaration = isImportOrExportDeclaration;
    exports2.isImportSpecifier = isImportSpecifier;
    exports2.isIndexedAccessType = isIndexedAccessType;
    exports2.isInferredPredicate = isInferredPredicate;
    exports2.isInterfaceDeclaration = isInterfaceDeclaration;
    exports2.isInterfaceExtends = isInterfaceExtends;
    exports2.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
    exports2.isInterpreterDirective = isInterpreterDirective;
    exports2.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
    exports2.isJSX = isJSX;
    exports2.isJSXAttribute = isJSXAttribute;
    exports2.isJSXClosingElement = isJSXClosingElement;
    exports2.isJSXClosingFragment = isJSXClosingFragment;
    exports2.isJSXElement = isJSXElement;
    exports2.isJSXEmptyExpression = isJSXEmptyExpression;
    exports2.isJSXExpressionContainer = isJSXExpressionContainer;
    exports2.isJSXFragment = isJSXFragment;
    exports2.isJSXIdentifier = isJSXIdentifier;
    exports2.isJSXMemberExpression = isJSXMemberExpression;
    exports2.isJSXNamespacedName = isJSXNamespacedName;
    exports2.isJSXOpeningElement = isJSXOpeningElement;
    exports2.isJSXOpeningFragment = isJSXOpeningFragment;
    exports2.isJSXSpreadAttribute = isJSXSpreadAttribute;
    exports2.isJSXSpreadChild = isJSXSpreadChild;
    exports2.isJSXText = isJSXText;
    exports2.isLVal = isLVal;
    exports2.isLabeledStatement = isLabeledStatement;
    exports2.isLiteral = isLiteral;
    exports2.isLogicalExpression = isLogicalExpression;
    exports2.isLoop = isLoop;
    exports2.isMemberExpression = isMemberExpression;
    exports2.isMetaProperty = isMetaProperty;
    exports2.isMethod = isMethod;
    exports2.isMiscellaneous = isMiscellaneous;
    exports2.isMixedTypeAnnotation = isMixedTypeAnnotation;
    exports2.isModuleDeclaration = isModuleDeclaration;
    exports2.isModuleExpression = isModuleExpression;
    exports2.isModuleSpecifier = isModuleSpecifier;
    exports2.isNewExpression = isNewExpression;
    exports2.isNoop = isNoop;
    exports2.isNullLiteral = isNullLiteral;
    exports2.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
    exports2.isNullableTypeAnnotation = isNullableTypeAnnotation;
    exports2.isNumberLiteral = isNumberLiteral;
    exports2.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
    exports2.isNumberTypeAnnotation = isNumberTypeAnnotation;
    exports2.isNumericLiteral = isNumericLiteral;
    exports2.isObjectExpression = isObjectExpression;
    exports2.isObjectMember = isObjectMember;
    exports2.isObjectMethod = isObjectMethod;
    exports2.isObjectPattern = isObjectPattern;
    exports2.isObjectProperty = isObjectProperty;
    exports2.isObjectTypeAnnotation = isObjectTypeAnnotation;
    exports2.isObjectTypeCallProperty = isObjectTypeCallProperty;
    exports2.isObjectTypeIndexer = isObjectTypeIndexer;
    exports2.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
    exports2.isObjectTypeProperty = isObjectTypeProperty;
    exports2.isObjectTypeSpreadProperty = isObjectTypeSpreadProperty;
    exports2.isOpaqueType = isOpaqueType;
    exports2.isOptionalCallExpression = isOptionalCallExpression;
    exports2.isOptionalIndexedAccessType = isOptionalIndexedAccessType;
    exports2.isOptionalMemberExpression = isOptionalMemberExpression;
    exports2.isParenthesizedExpression = isParenthesizedExpression;
    exports2.isPattern = isPattern;
    exports2.isPatternLike = isPatternLike;
    exports2.isPipelineBareFunction = isPipelineBareFunction;
    exports2.isPipelinePrimaryTopicReference = isPipelinePrimaryTopicReference;
    exports2.isPipelineTopicExpression = isPipelineTopicExpression;
    exports2.isPlaceholder = isPlaceholder;
    exports2.isPrivate = isPrivate;
    exports2.isPrivateName = isPrivateName;
    exports2.isProgram = isProgram;
    exports2.isProperty = isProperty;
    exports2.isPureish = isPureish;
    exports2.isQualifiedTypeIdentifier = isQualifiedTypeIdentifier;
    exports2.isRecordExpression = isRecordExpression;
    exports2.isRegExpLiteral = isRegExpLiteral;
    exports2.isRegexLiteral = isRegexLiteral;
    exports2.isRestElement = isRestElement;
    exports2.isRestProperty = isRestProperty;
    exports2.isReturnStatement = isReturnStatement;
    exports2.isScopable = isScopable;
    exports2.isSequenceExpression = isSequenceExpression;
    exports2.isSpreadElement = isSpreadElement;
    exports2.isSpreadProperty = isSpreadProperty;
    exports2.isStandardized = isStandardized;
    exports2.isStatement = isStatement;
    exports2.isStaticBlock = isStaticBlock;
    exports2.isStringLiteral = isStringLiteral;
    exports2.isStringLiteralTypeAnnotation = isStringLiteralTypeAnnotation;
    exports2.isStringTypeAnnotation = isStringTypeAnnotation;
    exports2.isSuper = isSuper;
    exports2.isSwitchCase = isSwitchCase;
    exports2.isSwitchStatement = isSwitchStatement;
    exports2.isSymbolTypeAnnotation = isSymbolTypeAnnotation;
    exports2.isTSAnyKeyword = isTSAnyKeyword;
    exports2.isTSArrayType = isTSArrayType;
    exports2.isTSAsExpression = isTSAsExpression;
    exports2.isTSBaseType = isTSBaseType;
    exports2.isTSBigIntKeyword = isTSBigIntKeyword;
    exports2.isTSBooleanKeyword = isTSBooleanKeyword;
    exports2.isTSCallSignatureDeclaration = isTSCallSignatureDeclaration;
    exports2.isTSConditionalType = isTSConditionalType;
    exports2.isTSConstructSignatureDeclaration = isTSConstructSignatureDeclaration;
    exports2.isTSConstructorType = isTSConstructorType;
    exports2.isTSDeclareFunction = isTSDeclareFunction;
    exports2.isTSDeclareMethod = isTSDeclareMethod;
    exports2.isTSEntityName = isTSEntityName;
    exports2.isTSEnumBody = isTSEnumBody;
    exports2.isTSEnumDeclaration = isTSEnumDeclaration;
    exports2.isTSEnumMember = isTSEnumMember;
    exports2.isTSExportAssignment = isTSExportAssignment;
    exports2.isTSExpressionWithTypeArguments = isTSExpressionWithTypeArguments;
    exports2.isTSExternalModuleReference = isTSExternalModuleReference;
    exports2.isTSFunctionType = isTSFunctionType;
    exports2.isTSImportEqualsDeclaration = isTSImportEqualsDeclaration;
    exports2.isTSImportType = isTSImportType;
    exports2.isTSIndexSignature = isTSIndexSignature;
    exports2.isTSIndexedAccessType = isTSIndexedAccessType;
    exports2.isTSInferType = isTSInferType;
    exports2.isTSInstantiationExpression = isTSInstantiationExpression;
    exports2.isTSInterfaceBody = isTSInterfaceBody;
    exports2.isTSInterfaceDeclaration = isTSInterfaceDeclaration;
    exports2.isTSIntersectionType = isTSIntersectionType;
    exports2.isTSIntrinsicKeyword = isTSIntrinsicKeyword;
    exports2.isTSLiteralType = isTSLiteralType;
    exports2.isTSMappedType = isTSMappedType;
    exports2.isTSMethodSignature = isTSMethodSignature;
    exports2.isTSModuleBlock = isTSModuleBlock;
    exports2.isTSModuleDeclaration = isTSModuleDeclaration;
    exports2.isTSNamedTupleMember = isTSNamedTupleMember;
    exports2.isTSNamespaceExportDeclaration = isTSNamespaceExportDeclaration;
    exports2.isTSNeverKeyword = isTSNeverKeyword;
    exports2.isTSNonNullExpression = isTSNonNullExpression;
    exports2.isTSNullKeyword = isTSNullKeyword;
    exports2.isTSNumberKeyword = isTSNumberKeyword;
    exports2.isTSObjectKeyword = isTSObjectKeyword;
    exports2.isTSOptionalType = isTSOptionalType;
    exports2.isTSParameterProperty = isTSParameterProperty;
    exports2.isTSParenthesizedType = isTSParenthesizedType;
    exports2.isTSPropertySignature = isTSPropertySignature;
    exports2.isTSQualifiedName = isTSQualifiedName;
    exports2.isTSRestType = isTSRestType;
    exports2.isTSSatisfiesExpression = isTSSatisfiesExpression;
    exports2.isTSStringKeyword = isTSStringKeyword;
    exports2.isTSSymbolKeyword = isTSSymbolKeyword;
    exports2.isTSTemplateLiteralType = isTSTemplateLiteralType;
    exports2.isTSThisType = isTSThisType;
    exports2.isTSTupleType = isTSTupleType;
    exports2.isTSType = isTSType;
    exports2.isTSTypeAliasDeclaration = isTSTypeAliasDeclaration;
    exports2.isTSTypeAnnotation = isTSTypeAnnotation;
    exports2.isTSTypeAssertion = isTSTypeAssertion;
    exports2.isTSTypeElement = isTSTypeElement;
    exports2.isTSTypeLiteral = isTSTypeLiteral;
    exports2.isTSTypeOperator = isTSTypeOperator;
    exports2.isTSTypeParameter = isTSTypeParameter;
    exports2.isTSTypeParameterDeclaration = isTSTypeParameterDeclaration;
    exports2.isTSTypeParameterInstantiation = isTSTypeParameterInstantiation;
    exports2.isTSTypePredicate = isTSTypePredicate;
    exports2.isTSTypeQuery = isTSTypeQuery;
    exports2.isTSTypeReference = isTSTypeReference;
    exports2.isTSUndefinedKeyword = isTSUndefinedKeyword;
    exports2.isTSUnionType = isTSUnionType;
    exports2.isTSUnknownKeyword = isTSUnknownKeyword;
    exports2.isTSVoidKeyword = isTSVoidKeyword;
    exports2.isTaggedTemplateExpression = isTaggedTemplateExpression;
    exports2.isTemplateElement = isTemplateElement;
    exports2.isTemplateLiteral = isTemplateLiteral;
    exports2.isTerminatorless = isTerminatorless;
    exports2.isThisExpression = isThisExpression;
    exports2.isThisTypeAnnotation = isThisTypeAnnotation;
    exports2.isThrowStatement = isThrowStatement;
    exports2.isTopicReference = isTopicReference;
    exports2.isTryStatement = isTryStatement;
    exports2.isTupleExpression = isTupleExpression;
    exports2.isTupleTypeAnnotation = isTupleTypeAnnotation;
    exports2.isTypeAlias = isTypeAlias;
    exports2.isTypeAnnotation = isTypeAnnotation;
    exports2.isTypeCastExpression = isTypeCastExpression;
    exports2.isTypeParameter = isTypeParameter;
    exports2.isTypeParameterDeclaration = isTypeParameterDeclaration;
    exports2.isTypeParameterInstantiation = isTypeParameterInstantiation;
    exports2.isTypeScript = isTypeScript;
    exports2.isTypeofTypeAnnotation = isTypeofTypeAnnotation;
    exports2.isUnaryExpression = isUnaryExpression;
    exports2.isUnaryLike = isUnaryLike;
    exports2.isUnionTypeAnnotation = isUnionTypeAnnotation;
    exports2.isUpdateExpression = isUpdateExpression;
    exports2.isUserWhitespacable = isUserWhitespacable;
    exports2.isV8IntrinsicIdentifier = isV8IntrinsicIdentifier;
    exports2.isVariableDeclaration = isVariableDeclaration;
    exports2.isVariableDeclarator = isVariableDeclarator;
    exports2.isVariance = isVariance;
    exports2.isVoidTypeAnnotation = isVoidTypeAnnotation;
    exports2.isWhile = isWhile;
    exports2.isWhileStatement = isWhileStatement;
    exports2.isWithStatement = isWithStatement;
    exports2.isYieldExpression = isYieldExpression;
    var _shallowEqual = require_shallowEqual();
    var _deprecationWarning = require_deprecationWarning();
    function isArrayExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ArrayExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isAssignmentExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "AssignmentExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBinaryExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "BinaryExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isInterpreterDirective(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "InterpreterDirective") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDirective(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Directive") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDirectiveLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DirectiveLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBlockStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "BlockStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBreakStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "BreakStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isCallExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "CallExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isCatchClause(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "CatchClause") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isConditionalExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ConditionalExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isContinueStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ContinueStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDebuggerStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DebuggerStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDoWhileStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DoWhileStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEmptyStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EmptyStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExpressionStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ExpressionStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFile(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "File") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isForInStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ForInStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isForStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ForStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFunctionDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "FunctionDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFunctionExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "FunctionExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isIdentifier2(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Identifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isIfStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "IfStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isLabeledStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "LabeledStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isStringLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "StringLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNumericLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "NumericLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNullLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "NullLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBooleanLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "BooleanLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isRegExpLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "RegExpLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isLogicalExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "LogicalExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isMemberExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "MemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNewExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "NewExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isProgram(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Program") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectMethod(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isRestElement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "RestElement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isReturnStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ReturnStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isSequenceExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "SequenceExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isParenthesizedExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ParenthesizedExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isSwitchCase(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "SwitchCase") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isSwitchStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "SwitchStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isThisExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ThisExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isThrowStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ThrowStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTryStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TryStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isUnaryExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "UnaryExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isUpdateExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "UpdateExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isVariableDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "VariableDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isVariableDeclarator(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "VariableDeclarator") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isWhileStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "WhileStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isWithStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "WithStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isAssignmentPattern(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "AssignmentPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isArrayPattern(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ArrayPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isArrowFunctionExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ArrowFunctionExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassBody(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassBody") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExportAllDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ExportAllDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExportDefaultDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ExportDefaultDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExportNamedDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ExportNamedDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExportSpecifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ExportSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isForOfStatement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ForOfStatement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImportDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ImportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImportDefaultSpecifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ImportDefaultSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImportNamespaceSpecifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ImportNamespaceSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImportSpecifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ImportSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImportExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ImportExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isMetaProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "MetaProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassMethod(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectPattern(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectPattern") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isSpreadElement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "SpreadElement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isSuper(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Super") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTaggedTemplateExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TaggedTemplateExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTemplateElement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TemplateElement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTemplateLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TemplateLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isYieldExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "YieldExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isAwaitExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "AwaitExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImport(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Import") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBigIntLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "BigIntLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExportNamespaceSpecifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ExportNamespaceSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isOptionalMemberExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "OptionalMemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isOptionalCallExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "OptionalCallExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassAccessorProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassAccessorProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassPrivateProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassPrivateProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassPrivateMethod(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassPrivateMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPrivateName(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "PrivateName") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isStaticBlock(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "StaticBlock") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isAnyTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "AnyTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isArrayTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ArrayTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBooleanTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "BooleanTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBooleanLiteralTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "BooleanLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNullLiteralTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "NullLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClassImplements(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ClassImplements") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareClass(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareClass") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareFunction(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareInterface(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareInterface") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareModule(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareModule") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareModuleExports(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareModuleExports") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareTypeAlias(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareTypeAlias") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareOpaqueType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareOpaqueType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareVariable(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareVariable") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareExportDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareExportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclareExportAllDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclareExportAllDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclaredPredicate(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DeclaredPredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExistsTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ExistsTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFunctionTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "FunctionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFunctionTypeParam(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "FunctionTypeParam") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isGenericTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "GenericTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isInferredPredicate(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "InferredPredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isInterfaceExtends(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "InterfaceExtends") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isInterfaceDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "InterfaceDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isInterfaceTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "InterfaceTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isIntersectionTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "IntersectionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isMixedTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "MixedTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEmptyTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EmptyTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNullableTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "NullableTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNumberLiteralTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "NumberLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNumberTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "NumberTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectTypeInternalSlot(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectTypeInternalSlot") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectTypeCallProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectTypeCallProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectTypeIndexer(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectTypeIndexer") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectTypeProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectTypeProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectTypeSpreadProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ObjectTypeSpreadProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isOpaqueType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "OpaqueType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isQualifiedTypeIdentifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "QualifiedTypeIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isStringLiteralTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "StringLiteralTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isStringTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "StringTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isSymbolTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "SymbolTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isThisTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ThisTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTupleTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TupleTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTypeofTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TypeofTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTypeAlias(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TypeAlias") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTypeCastExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TypeCastExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTypeParameter(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TypeParameter") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTypeParameterDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TypeParameterDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTypeParameterInstantiation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TypeParameterInstantiation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isUnionTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "UnionTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isVariance(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Variance") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isVoidTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "VoidTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumBooleanBody(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumBooleanBody") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumNumberBody(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumNumberBody") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumStringBody(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumStringBody") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumSymbolBody(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumSymbolBody") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumBooleanMember(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumBooleanMember") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumNumberMember(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumNumberMember") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumStringMember(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumStringMember") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumDefaultedMember(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "EnumDefaultedMember") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isIndexedAccessType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "IndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isOptionalIndexedAccessType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "OptionalIndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXAttribute(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXClosingElement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXClosingElement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXElement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXElement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXEmptyExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXEmptyExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXExpressionContainer(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXExpressionContainer") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXSpreadChild(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXSpreadChild") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXIdentifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXMemberExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXMemberExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXNamespacedName(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXNamespacedName") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXOpeningElement(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXOpeningElement") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXSpreadAttribute(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXSpreadAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXText(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXText") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXFragment(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXOpeningFragment(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXOpeningFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSXClosingFragment(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "JSXClosingFragment") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNoop(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Noop") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPlaceholder(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Placeholder") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isV8IntrinsicIdentifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "V8IntrinsicIdentifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isArgumentPlaceholder(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ArgumentPlaceholder") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBindExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "BindExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImportAttribute(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ImportAttribute") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDecorator(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "Decorator") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDoExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DoExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExportDefaultSpecifier(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ExportDefaultSpecifier") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isRecordExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "RecordExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTupleExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TupleExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDecimalLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "DecimalLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isModuleExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "ModuleExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTopicReference(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TopicReference") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPipelineTopicExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "PipelineTopicExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPipelineBareFunction(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "PipelineBareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPipelinePrimaryTopicReference(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "PipelinePrimaryTopicReference") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSParameterProperty(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSParameterProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSDeclareFunction(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSDeclareFunction") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSDeclareMethod(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSDeclareMethod") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSQualifiedName(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSQualifiedName") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSCallSignatureDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSCallSignatureDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSConstructSignatureDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSConstructSignatureDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSPropertySignature(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSPropertySignature") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSMethodSignature(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSMethodSignature") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSIndexSignature(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSIndexSignature") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSAnyKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSAnyKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSBooleanKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSBooleanKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSBigIntKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSBigIntKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSIntrinsicKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSIntrinsicKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSNeverKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSNeverKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSNullKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSNullKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSNumberKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSNumberKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSObjectKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSObjectKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSStringKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSStringKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSSymbolKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSSymbolKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSUndefinedKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSUndefinedKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSUnknownKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSUnknownKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSVoidKeyword(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSVoidKeyword") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSThisType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSThisType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSFunctionType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSFunctionType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSConstructorType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSConstructorType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeReference(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeReference") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypePredicate(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypePredicate") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeQuery(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeQuery") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeLiteral(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSArrayType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSArrayType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTupleType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTupleType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSOptionalType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSOptionalType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSRestType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSRestType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSNamedTupleMember(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSNamedTupleMember") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSUnionType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSUnionType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSIntersectionType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSIntersectionType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSConditionalType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSConditionalType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSInferType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSInferType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSParenthesizedType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSParenthesizedType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeOperator(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeOperator") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSIndexedAccessType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSIndexedAccessType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSMappedType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSMappedType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTemplateLiteralType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTemplateLiteralType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSLiteralType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSLiteralType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSExpressionWithTypeArguments(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSExpressionWithTypeArguments") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSInterfaceDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSInterfaceDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSInterfaceBody(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSInterfaceBody") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeAliasDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeAliasDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSInstantiationExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSInstantiationExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSAsExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSAsExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSSatisfiesExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSSatisfiesExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeAssertion(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeAssertion") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSEnumBody(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSEnumBody") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSEnumDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSEnumDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSEnumMember(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSEnumMember") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSModuleDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSModuleDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSModuleBlock(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSModuleBlock") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSImportType(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSImportType") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSImportEqualsDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSImportEqualsDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSExternalModuleReference(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSExternalModuleReference") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSNonNullExpression(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSNonNullExpression") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSExportAssignment(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSExportAssignment") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSNamespaceExportDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSNamespaceExportDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeAnnotation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeAnnotation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeParameterInstantiation(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeParameterInstantiation") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeParameterDeclaration(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeParameterDeclaration") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeParameter(node3, opts) {
      if (!node3) return false;
      if (node3.type !== "TSTypeParameter") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isStandardized(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "InterpreterDirective":
        case "Directive":
        case "DirectiveLiteral":
        case "BlockStatement":
        case "BreakStatement":
        case "CallExpression":
        case "CatchClause":
        case "ConditionalExpression":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "File":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Identifier":
        case "IfStatement":
        case "LabeledStatement":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "Program":
        case "ObjectExpression":
        case "ObjectMethod":
        case "ObjectProperty":
        case "RestElement":
        case "ReturnStatement":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "SwitchCase":
        case "SwitchStatement":
        case "ThisExpression":
        case "ThrowStatement":
        case "TryStatement":
        case "UnaryExpression":
        case "UpdateExpression":
        case "VariableDeclaration":
        case "VariableDeclarator":
        case "WhileStatement":
        case "WithStatement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ArrowFunctionExpression":
        case "ClassBody":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ExportSpecifier":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ImportExpression":
        case "MetaProperty":
        case "ClassMethod":
        case "ObjectPattern":
        case "SpreadElement":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateElement":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "ExportNamespaceSpecifier":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
        case "StaticBlock":
          break;
        case "Placeholder":
          switch (node3.expectedNode) {
            case "Identifier":
            case "StringLiteral":
            case "BlockStatement":
            case "ClassBody":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExpression(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ParenthesizedExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ImportExpression":
        case "MetaProperty":
        case "Super":
        case "TaggedTemplateExpression":
        case "TemplateLiteral":
        case "YieldExpression":
        case "AwaitExpression":
        case "Import":
        case "BigIntLiteral":
        case "OptionalMemberExpression":
        case "OptionalCallExpression":
        case "TypeCastExpression":
        case "JSXElement":
        case "JSXFragment":
        case "BindExpression":
        case "DoExpression":
        case "RecordExpression":
        case "TupleExpression":
        case "DecimalLiteral":
        case "ModuleExpression":
        case "TopicReference":
        case "PipelineTopicExpression":
        case "PipelineBareFunction":
        case "PipelinePrimaryTopicReference":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node3.expectedNode) {
            case "Expression":
            case "Identifier":
            case "StringLiteral":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBinary(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "BinaryExpression":
        case "LogicalExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isScopable(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ClassExpression":
        case "ClassDeclaration":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node3.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBlockParent(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "BlockStatement":
        case "CatchClause":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "Program":
        case "ObjectMethod":
        case "SwitchStatement":
        case "WhileStatement":
        case "ArrowFunctionExpression":
        case "ForOfStatement":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node3.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isBlock(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "BlockStatement":
        case "Program":
        case "TSModuleBlock":
          break;
        case "Placeholder":
          if (node3.expectedNode === "BlockStatement") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isStatement(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "FunctionDeclaration":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ForOfStatement":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
          break;
        case "Placeholder":
          switch (node3.expectedNode) {
            case "Statement":
            case "Declaration":
            case "BlockStatement":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTerminatorless(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
        case "YieldExpression":
        case "AwaitExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isCompletionStatement(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "BreakStatement":
        case "ContinueStatement":
        case "ReturnStatement":
        case "ThrowStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isConditional(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ConditionalExpression":
        case "IfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isLoop(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isWhile(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "DoWhileStatement":
        case "WhileStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExpressionWrapper(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ExpressionStatement":
        case "ParenthesizedExpression":
        case "TypeCastExpression":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFor(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ForInStatement":
        case "ForStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isForXStatement(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ForInStatement":
        case "ForOfStatement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFunction2(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFunctionParent(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "ObjectMethod":
        case "ArrowFunctionExpression":
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "StaticBlock":
        case "TSModuleBlock":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPureish(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "FunctionDeclaration":
        case "FunctionExpression":
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "ArrowFunctionExpression":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node3.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isDeclaration(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "FunctionDeclaration":
        case "VariableDeclaration":
        case "ClassDeclaration":
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
        case "EnumDeclaration":
        case "TSDeclareFunction":
        case "TSInterfaceDeclaration":
        case "TSTypeAliasDeclaration":
        case "TSEnumDeclaration":
        case "TSModuleDeclaration":
        case "TSImportEqualsDeclaration":
          break;
        case "Placeholder":
          if (node3.expectedNode === "Declaration") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPatternLike(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "Identifier":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node3.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isLVal(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "Identifier":
        case "MemberExpression":
        case "RestElement":
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
        case "TSParameterProperty":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSNonNullExpression":
          break;
        case "Placeholder":
          switch (node3.expectedNode) {
            case "Pattern":
            case "Identifier":
              break;
            default:
              return false;
          }
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSEntityName(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "Identifier":
        case "TSQualifiedName":
          break;
        case "Placeholder":
          if (node3.expectedNode === "Identifier") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isLiteral(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "RegExpLiteral":
        case "TemplateLiteral":
        case "BigIntLiteral":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node3.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImmutable(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "StringLiteral":
        case "NumericLiteral":
        case "NullLiteral":
        case "BooleanLiteral":
        case "BigIntLiteral":
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXOpeningElement":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
        case "DecimalLiteral":
          break;
        case "Placeholder":
          if (node3.expectedNode === "StringLiteral") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isUserWhitespacable(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ObjectMethod":
        case "ObjectProperty":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isMethod(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ObjectMethod":
        case "ClassMethod":
        case "ClassPrivateMethod":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isObjectMember(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ObjectMethod":
        case "ObjectProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isProperty(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ObjectProperty":
        case "ClassProperty":
        case "ClassAccessorProperty":
        case "ClassPrivateProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isUnaryLike(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "UnaryExpression":
        case "SpreadElement":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPattern(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "AssignmentPattern":
        case "ArrayPattern":
        case "ObjectPattern":
          break;
        case "Placeholder":
          if (node3.expectedNode === "Pattern") break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isClass(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ClassExpression":
        case "ClassDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isImportOrExportDeclaration(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
        case "ImportDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isExportDeclaration(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ExportAllDeclaration":
        case "ExportDefaultDeclaration":
        case "ExportNamedDeclaration":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isModuleSpecifier(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ExportSpecifier":
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isAccessor(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ClassAccessorProperty":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isPrivate(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
        case "PrivateName":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFlow(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ClassImplements":
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "DeclaredPredicate":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "FunctionTypeParam":
        case "GenericTypeAnnotation":
        case "InferredPredicate":
        case "InterfaceExtends":
        case "InterfaceDeclaration":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "ObjectTypeInternalSlot":
        case "ObjectTypeCallProperty":
        case "ObjectTypeIndexer":
        case "ObjectTypeProperty":
        case "ObjectTypeSpreadProperty":
        case "OpaqueType":
        case "QualifiedTypeIdentifier":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "TypeAlias":
        case "TypeAnnotation":
        case "TypeCastExpression":
        case "TypeParameter":
        case "TypeParameterDeclaration":
        case "TypeParameterInstantiation":
        case "UnionTypeAnnotation":
        case "Variance":
        case "VoidTypeAnnotation":
        case "EnumDeclaration":
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFlowType(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "AnyTypeAnnotation":
        case "ArrayTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "BooleanLiteralTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "ExistsTypeAnnotation":
        case "FunctionTypeAnnotation":
        case "GenericTypeAnnotation":
        case "InterfaceTypeAnnotation":
        case "IntersectionTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NullableTypeAnnotation":
        case "NumberLiteralTypeAnnotation":
        case "NumberTypeAnnotation":
        case "ObjectTypeAnnotation":
        case "StringLiteralTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "TupleTypeAnnotation":
        case "TypeofTypeAnnotation":
        case "UnionTypeAnnotation":
        case "VoidTypeAnnotation":
        case "IndexedAccessType":
        case "OptionalIndexedAccessType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFlowBaseAnnotation(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "AnyTypeAnnotation":
        case "BooleanTypeAnnotation":
        case "NullLiteralTypeAnnotation":
        case "MixedTypeAnnotation":
        case "EmptyTypeAnnotation":
        case "NumberTypeAnnotation":
        case "StringTypeAnnotation":
        case "SymbolTypeAnnotation":
        case "ThisTypeAnnotation":
        case "VoidTypeAnnotation":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFlowDeclaration(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "DeclareClass":
        case "DeclareFunction":
        case "DeclareInterface":
        case "DeclareModule":
        case "DeclareModuleExports":
        case "DeclareTypeAlias":
        case "DeclareOpaqueType":
        case "DeclareVariable":
        case "DeclareExportDeclaration":
        case "DeclareExportAllDeclaration":
        case "InterfaceDeclaration":
        case "OpaqueType":
        case "TypeAlias":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isFlowPredicate(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "DeclaredPredicate":
        case "InferredPredicate":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumBody(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "EnumBooleanBody":
        case "EnumNumberBody":
        case "EnumStringBody":
        case "EnumSymbolBody":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isEnumMember(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "EnumBooleanMember":
        case "EnumNumberMember":
        case "EnumStringMember":
        case "EnumDefaultedMember":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isJSX(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "JSXAttribute":
        case "JSXClosingElement":
        case "JSXElement":
        case "JSXEmptyExpression":
        case "JSXExpressionContainer":
        case "JSXSpreadChild":
        case "JSXIdentifier":
        case "JSXMemberExpression":
        case "JSXNamespacedName":
        case "JSXOpeningElement":
        case "JSXSpreadAttribute":
        case "JSXText":
        case "JSXFragment":
        case "JSXOpeningFragment":
        case "JSXClosingFragment":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isMiscellaneous(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "Noop":
        case "Placeholder":
        case "V8IntrinsicIdentifier":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTypeScript(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "TSParameterProperty":
        case "TSDeclareFunction":
        case "TSDeclareMethod":
        case "TSQualifiedName":
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSNamedTupleMember":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSInterfaceDeclaration":
        case "TSInterfaceBody":
        case "TSTypeAliasDeclaration":
        case "TSInstantiationExpression":
        case "TSAsExpression":
        case "TSSatisfiesExpression":
        case "TSTypeAssertion":
        case "TSEnumBody":
        case "TSEnumDeclaration":
        case "TSEnumMember":
        case "TSModuleDeclaration":
        case "TSModuleBlock":
        case "TSImportType":
        case "TSImportEqualsDeclaration":
        case "TSExternalModuleReference":
        case "TSNonNullExpression":
        case "TSExportAssignment":
        case "TSNamespaceExportDeclaration":
        case "TSTypeAnnotation":
        case "TSTypeParameterInstantiation":
        case "TSTypeParameterDeclaration":
        case "TSTypeParameter":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSTypeElement(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "TSCallSignatureDeclaration":
        case "TSConstructSignatureDeclaration":
        case "TSPropertySignature":
        case "TSMethodSignature":
        case "TSIndexSignature":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSType(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSFunctionType":
        case "TSConstructorType":
        case "TSTypeReference":
        case "TSTypePredicate":
        case "TSTypeQuery":
        case "TSTypeLiteral":
        case "TSArrayType":
        case "TSTupleType":
        case "TSOptionalType":
        case "TSRestType":
        case "TSUnionType":
        case "TSIntersectionType":
        case "TSConditionalType":
        case "TSInferType":
        case "TSParenthesizedType":
        case "TSTypeOperator":
        case "TSIndexedAccessType":
        case "TSMappedType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
        case "TSExpressionWithTypeArguments":
        case "TSImportType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isTSBaseType(node3, opts) {
      if (!node3) return false;
      switch (node3.type) {
        case "TSAnyKeyword":
        case "TSBooleanKeyword":
        case "TSBigIntKeyword":
        case "TSIntrinsicKeyword":
        case "TSNeverKeyword":
        case "TSNullKeyword":
        case "TSNumberKeyword":
        case "TSObjectKeyword":
        case "TSStringKeyword":
        case "TSSymbolKeyword":
        case "TSUndefinedKeyword":
        case "TSUnknownKeyword":
        case "TSVoidKeyword":
        case "TSThisType":
        case "TSTemplateLiteralType":
        case "TSLiteralType":
          break;
        default:
          return false;
      }
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isNumberLiteral(node3, opts) {
      (0, _deprecationWarning.default)("isNumberLiteral", "isNumericLiteral");
      if (!node3) return false;
      if (node3.type !== "NumberLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isRegexLiteral(node3, opts) {
      (0, _deprecationWarning.default)("isRegexLiteral", "isRegExpLiteral");
      if (!node3) return false;
      if (node3.type !== "RegexLiteral") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isRestProperty(node3, opts) {
      (0, _deprecationWarning.default)("isRestProperty", "isRestElement");
      if (!node3) return false;
      if (node3.type !== "RestProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isSpreadProperty(node3, opts) {
      (0, _deprecationWarning.default)("isSpreadProperty", "isSpreadElement");
      if (!node3) return false;
      if (node3.type !== "SpreadProperty") return false;
      return opts == null || (0, _shallowEqual.default)(node3, opts);
    }
    function isModuleDeclaration(node3, opts) {
      (0, _deprecationWarning.default)("isModuleDeclaration", "isImportOrExportDeclaration");
      return isImportOrExportDeclaration(node3, opts);
    }
  }
});

// node_modules/@babel/types/lib/validators/matchesPattern.js
var require_matchesPattern = __commonJS({
  "node_modules/@babel/types/lib/validators/matchesPattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = matchesPattern;
    var _index = require_generated();
    function matchesPattern(member, match2, allowPartial) {
      if (!(0, _index.isMemberExpression)(member)) return false;
      const parts = Array.isArray(match2) ? match2 : match2.split(".");
      const nodes = [];
      let node3;
      for (node3 = member; (0, _index.isMemberExpression)(node3); node3 = node3.object) {
        nodes.push(node3.property);
      }
      nodes.push(node3);
      if (nodes.length < parts.length) return false;
      if (!allowPartial && nodes.length > parts.length) return false;
      for (let i = 0, j = nodes.length - 1; i < parts.length; i++, j--) {
        const node4 = nodes[j];
        let value2;
        if ((0, _index.isIdentifier)(node4)) {
          value2 = node4.name;
        } else if ((0, _index.isStringLiteral)(node4)) {
          value2 = node4.value;
        } else if ((0, _index.isThisExpression)(node4)) {
          value2 = "this";
        } else {
          return false;
        }
        if (parts[i] !== value2) return false;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js
var require_buildMatchMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/validators/buildMatchMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = buildMatchMemberExpression;
    var _matchesPattern = require_matchesPattern();
    function buildMatchMemberExpression(match2, allowPartial) {
      const parts = match2.split(".");
      return (member) => (0, _matchesPattern.default)(member, parts, allowPartial);
    }
  }
});

// node_modules/@babel/types/lib/validators/react/isReactComponent.js
var require_isReactComponent = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isReactComponent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var isReactComponent = (0, _buildMatchMemberExpression.default)("React.Component");
    var _default = exports2.default = isReactComponent;
  }
});

// node_modules/@babel/types/lib/validators/react/isCompatTag.js
var require_isCompatTag = __commonJS({
  "node_modules/@babel/types/lib/validators/react/isCompatTag.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isCompatTag;
    function isCompatTag(tagName) {
      return !!tagName && /^[a-z]/.test(tagName);
    }
  }
});

// node_modules/@babel/types/lib/validators/isType.js
var require_isType = __commonJS({
  "node_modules/@babel/types/lib/validators/isType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isType;
    var _index = require_definitions();
    function isType(nodeType, targetType) {
      if (nodeType === targetType) return true;
      if (nodeType == null) return false;
      if (_index.ALIAS_KEYS[targetType]) return false;
      const aliases = _index.FLIPPED_ALIAS_KEYS[targetType];
      if (aliases) {
        if (aliases[0] === nodeType) return true;
        for (const alias of aliases) {
          if (nodeType === alias) return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isPlaceholderType.js
var require_isPlaceholderType = __commonJS({
  "node_modules/@babel/types/lib/validators/isPlaceholderType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isPlaceholderType;
    var _index = require_definitions();
    function isPlaceholderType(placeholderType, targetType) {
      if (placeholderType === targetType) return true;
      const aliases = _index.PLACEHOLDERS_ALIAS[placeholderType];
      if (aliases) {
        for (const alias of aliases) {
          if (targetType === alias) return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/is.js
var require_is = __commonJS({
  "node_modules/@babel/types/lib/validators/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = is;
    var _shallowEqual = require_shallowEqual();
    var _isType = require_isType();
    var _isPlaceholderType = require_isPlaceholderType();
    var _index = require_definitions();
    function is(type, node3, opts) {
      if (!node3) return false;
      const matches = (0, _isType.default)(node3.type, type);
      if (!matches) {
        if (!opts && node3.type === "Placeholder" && type in _index.FLIPPED_ALIAS_KEYS) {
          return (0, _isPlaceholderType.default)(node3.expectedNode, type);
        }
        return false;
      }
      if (opts === void 0) {
        return true;
      } else {
        return (0, _shallowEqual.default)(node3, opts);
      }
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/identifier.js
var require_identifier = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIdentifierChar = isIdentifierChar;
    exports2.isIdentifierName = isIdentifierName;
    exports2.isIdentifierStart = isIdentifierStart;
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code, set2) {
      let pos = 65536;
      for (let i = 0, length = set2.length; i < length; i += 2) {
        pos += set2[i];
        if (pos > code) return false;
        pos += set2[i + 1];
        if (pos >= code) return true;
      }
      return false;
    }
    function isIdentifierStart(code) {
      if (code < 65) return code === 36;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code) {
      if (code < 48) return code === 36;
      if (code < 58) return true;
      if (code < 65) return false;
      if (code <= 90) return true;
      if (code < 97) return code === 95;
      if (code <= 122) return true;
      if (code <= 65535) {
        return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
      }
      return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
    }
    function isIdentifierName(name2) {
      let isFirst = true;
      for (let i = 0; i < name2.length; i++) {
        let cp2 = name2.charCodeAt(i);
        if ((cp2 & 64512) === 55296 && i + 1 < name2.length) {
          const trail = name2.charCodeAt(++i);
          if ((trail & 64512) === 56320) {
            cp2 = 65536 + ((cp2 & 1023) << 10) + (trail & 1023);
          }
        }
        if (isFirst) {
          isFirst = false;
          if (!isIdentifierStart(cp2)) {
            return false;
          }
        } else if (!isIdentifierChar(cp2)) {
          return false;
        }
      }
      return !isFirst;
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isKeyword = isKeyword;
    exports2.isReservedWord = isReservedWord;
    exports2.isStrictBindOnlyReservedWord = isStrictBindOnlyReservedWord;
    exports2.isStrictBindReservedWord = isStrictBindReservedWord;
    exports2.isStrictReservedWord = isStrictReservedWord;
    var reservedWords2 = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords2 = new Set(reservedWords2.keyword);
    var reservedWordsStrictSet = new Set(reservedWords2.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords2.strictBind);
    function isReservedWord(word2, inModule) {
      return inModule && word2 === "await" || word2 === "enum";
    }
    function isStrictReservedWord(word2, inModule) {
      return isReservedWord(word2, inModule) || reservedWordsStrictSet.has(word2);
    }
    function isStrictBindOnlyReservedWord(word2) {
      return reservedWordsStrictBindSet.has(word2);
    }
    function isStrictBindReservedWord(word2, inModule) {
      return isStrictReservedWord(word2, inModule) || isStrictBindOnlyReservedWord(word2);
    }
    function isKeyword(word2) {
      return keywords2.has(word2);
    }
  }
});

// node_modules/@babel/helper-validator-identifier/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/helper-validator-identifier/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "isIdentifierChar", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierChar;
      }
    });
    Object.defineProperty(exports2, "isIdentifierName", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierName;
      }
    });
    Object.defineProperty(exports2, "isIdentifierStart", {
      enumerable: true,
      get: function() {
        return _identifier.isIdentifierStart;
      }
    });
    Object.defineProperty(exports2, "isKeyword", {
      enumerable: true,
      get: function() {
        return _keyword.isKeyword;
      }
    });
    Object.defineProperty(exports2, "isReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindOnlyReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindOnlyReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictBindReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictBindReservedWord;
      }
    });
    Object.defineProperty(exports2, "isStrictReservedWord", {
      enumerable: true,
      get: function() {
        return _keyword.isStrictReservedWord;
      }
    });
    var _identifier = require_identifier();
    var _keyword = require_keyword();
  }
});

// node_modules/@babel/types/lib/validators/isValidIdentifier.js
var require_isValidIdentifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidIdentifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isValidIdentifier;
    var _helperValidatorIdentifier = require_lib();
    function isValidIdentifier(name2, reserved = true) {
      if (typeof name2 !== "string") return false;
      if (reserved) {
        if ((0, _helperValidatorIdentifier.isKeyword)(name2) || (0, _helperValidatorIdentifier.isStrictReservedWord)(name2, true)) {
          return false;
        }
      }
      return (0, _helperValidatorIdentifier.isIdentifierName)(name2);
    }
  }
});

// node_modules/@babel/helper-string-parser/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/helper-string-parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.readCodePoint = readCodePoint;
    exports2.readInt = readInt;
    exports2.readStringContents = readStringContents;
    var _isDigit = function isDigit(code) {
      return code >= 48 && code <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code;
          ({
            code,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCharCode(code));
        }
        case 117: {
          let code;
          ({
            code,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code === null ? null : String.fromCodePoint(code));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match2 = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match2[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code = input.charCodeAt(pos);
        let val;
        if (code === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code >= 97) {
          val = code - 97 + 10;
        } else if (code >= 65) {
          val = code - 65 + 10;
        } else if (_isDigit(code)) {
          val = code - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code;
      if (ch === 123) {
        ++pos;
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code !== null && code > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code,
        pos
      };
    }
  }
});

// node_modules/@babel/types/lib/constants/index.js
var require_constants = __commonJS({
  "node_modules/@babel/types/lib/constants/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UPDATE_OPERATORS = exports2.UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = exports2.STATEMENT_OR_BLOCK_KEYS = exports2.NUMBER_UNARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = exports2.NOT_LOCAL_BINDING = exports2.LOGICAL_OPERATORS = exports2.INHERIT_KEYS = exports2.FOR_INIT_KEYS = exports2.FLATTENABLE_KEYS = exports2.EQUALITY_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = exports2.COMMENT_KEYS = exports2.BOOLEAN_UNARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = exports2.BLOCK_SCOPED_SYMBOL = exports2.BINARY_OPERATORS = exports2.ASSIGNMENT_OPERATORS = void 0;
    var STATEMENT_OR_BLOCK_KEYS = exports2.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
    var FLATTENABLE_KEYS = exports2.FLATTENABLE_KEYS = ["body", "expressions"];
    var FOR_INIT_KEYS = exports2.FOR_INIT_KEYS = ["left", "init"];
    var COMMENT_KEYS = exports2.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
    var LOGICAL_OPERATORS = exports2.LOGICAL_OPERATORS = ["||", "&&", "??"];
    var UPDATE_OPERATORS = exports2.UPDATE_OPERATORS = ["++", "--"];
    var BOOLEAN_NUMBER_BINARY_OPERATORS = exports2.BOOLEAN_NUMBER_BINARY_OPERATORS = [">", "<", ">=", "<="];
    var EQUALITY_BINARY_OPERATORS = exports2.EQUALITY_BINARY_OPERATORS = ["==", "===", "!=", "!=="];
    var COMPARISON_BINARY_OPERATORS = exports2.COMPARISON_BINARY_OPERATORS = [...EQUALITY_BINARY_OPERATORS, "in", "instanceof"];
    var BOOLEAN_BINARY_OPERATORS = exports2.BOOLEAN_BINARY_OPERATORS = [...COMPARISON_BINARY_OPERATORS, ...BOOLEAN_NUMBER_BINARY_OPERATORS];
    var NUMBER_BINARY_OPERATORS = exports2.NUMBER_BINARY_OPERATORS = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
    var BINARY_OPERATORS = exports2.BINARY_OPERATORS = ["+", ...NUMBER_BINARY_OPERATORS, ...BOOLEAN_BINARY_OPERATORS, "|>"];
    var ASSIGNMENT_OPERATORS = exports2.ASSIGNMENT_OPERATORS = ["=", "+=", ...NUMBER_BINARY_OPERATORS.map((op) => op + "="), ...LOGICAL_OPERATORS.map((op) => op + "=")];
    var BOOLEAN_UNARY_OPERATORS = exports2.BOOLEAN_UNARY_OPERATORS = ["delete", "!"];
    var NUMBER_UNARY_OPERATORS = exports2.NUMBER_UNARY_OPERATORS = ["+", "-", "~"];
    var STRING_UNARY_OPERATORS = exports2.STRING_UNARY_OPERATORS = ["typeof"];
    var UNARY_OPERATORS = exports2.UNARY_OPERATORS = ["void", "throw", ...BOOLEAN_UNARY_OPERATORS, ...NUMBER_UNARY_OPERATORS, ...STRING_UNARY_OPERATORS];
    var INHERIT_KEYS = exports2.INHERIT_KEYS = {
      optional: ["typeAnnotation", "typeParameters", "returnType"],
      force: ["start", "loc", "end"]
    };
    var BLOCK_SCOPED_SYMBOL = exports2.BLOCK_SCOPED_SYMBOL = Symbol.for("var used to be block scoped");
    var NOT_LOCAL_BINDING = exports2.NOT_LOCAL_BINDING = Symbol.for("should not be considered a local binding");
  }
});

// node_modules/@babel/types/lib/definitions/utils.js
var require_utils = __commonJS({
  "node_modules/@babel/types/lib/definitions/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VISITOR_KEYS = exports2.NODE_PARENT_VALIDATIONS = exports2.NODE_FIELDS = exports2.FLIPPED_ALIAS_KEYS = exports2.DEPRECATED_KEYS = exports2.BUILDER_KEYS = exports2.ALIAS_KEYS = void 0;
    exports2.arrayOf = arrayOf;
    exports2.arrayOfType = arrayOfType;
    exports2.assertEach = assertEach;
    exports2.assertNodeOrValueType = assertNodeOrValueType;
    exports2.assertNodeType = assertNodeType;
    exports2.assertOneOf = assertOneOf;
    exports2.assertOptionalChainStart = assertOptionalChainStart;
    exports2.assertShape = assertShape;
    exports2.assertValueType = assertValueType;
    exports2.chain = chain;
    exports2.default = defineType;
    exports2.defineAliasedType = defineAliasedType;
    exports2.validate = validate;
    exports2.validateArrayOfType = validateArrayOfType;
    exports2.validateOptional = validateOptional;
    exports2.validateOptionalType = validateOptionalType;
    exports2.validateType = validateType;
    var _is = require_is();
    var _validate = require_validate();
    var VISITOR_KEYS = exports2.VISITOR_KEYS = {};
    var ALIAS_KEYS = exports2.ALIAS_KEYS = {};
    var FLIPPED_ALIAS_KEYS = exports2.FLIPPED_ALIAS_KEYS = {};
    var NODE_FIELDS = exports2.NODE_FIELDS = {};
    var BUILDER_KEYS = exports2.BUILDER_KEYS = {};
    var DEPRECATED_KEYS = exports2.DEPRECATED_KEYS = {};
    var NODE_PARENT_VALIDATIONS = exports2.NODE_PARENT_VALIDATIONS = {};
    function getType(val) {
      if (Array.isArray(val)) {
        return "array";
      } else if (val === null) {
        return "null";
      } else {
        return typeof val;
      }
    }
    function validate(validate2) {
      return {
        validate: validate2
      };
    }
    function validateType(...typeNames) {
      return validate(assertNodeType(...typeNames));
    }
    function validateOptional(validate2) {
      return {
        validate: validate2,
        optional: true
      };
    }
    function validateOptionalType(...typeNames) {
      return {
        validate: assertNodeType(...typeNames),
        optional: true
      };
    }
    function arrayOf(elementType) {
      return chain(assertValueType("array"), assertEach(elementType));
    }
    function arrayOfType(...typeNames) {
      return arrayOf(assertNodeType(...typeNames));
    }
    function validateArrayOfType(...typeNames) {
      return validate(arrayOfType(...typeNames));
    }
    function assertEach(callback) {
      const childValidator = process.env.BABEL_TYPES_8_BREAKING ? _validate.validateChild : () => {
      };
      function validator(node3, key, val) {
        if (!Array.isArray(val)) return;
        for (let i = 0; i < val.length; i++) {
          const subkey = `${key}[${i}]`;
          const v = val[i];
          callback(node3, subkey, v);
          childValidator(node3, subkey, v);
        }
      }
      validator.each = callback;
      return validator;
    }
    function assertOneOf(...values) {
      function validate2(node3, key, val) {
        if (!values.includes(val)) {
          throw new TypeError(`Property ${key} expected value to be one of ${JSON.stringify(values)} but got ${JSON.stringify(val)}`);
        }
      }
      validate2.oneOf = values;
      return validate2;
    }
    function assertNodeType(...types3) {
      function validate2(node3, key, val) {
        for (const type of types3) {
          if ((0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node3, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node3.type} expected node to be of a type ${JSON.stringify(types3)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeTypes = types3;
      return validate2;
    }
    function assertNodeOrValueType(...types3) {
      function validate2(node3, key, val) {
        for (const type of types3) {
          if (getType(val) === type || (0, _is.default)(type, val)) {
            (0, _validate.validateChild)(node3, key, val);
            return;
          }
        }
        throw new TypeError(`Property ${key} of ${node3.type} expected node to be of a type ${JSON.stringify(types3)} but instead got ${JSON.stringify(val == null ? void 0 : val.type)}`);
      }
      validate2.oneOfNodeOrValueTypes = types3;
      return validate2;
    }
    function assertValueType(type) {
      function validate2(node3, key, val) {
        const valid = getType(val) === type;
        if (!valid) {
          throw new TypeError(`Property ${key} expected type of ${type} but got ${getType(val)}`);
        }
      }
      validate2.type = type;
      return validate2;
    }
    function assertShape(shape) {
      function validate2(node3, key, val) {
        const errors = [];
        for (const property of Object.keys(shape)) {
          try {
            (0, _validate.validateField)(node3, property, val[property], shape[property]);
          } catch (error) {
            if (error instanceof TypeError) {
              errors.push(error.message);
              continue;
            }
            throw error;
          }
        }
        if (errors.length) {
          throw new TypeError(`Property ${key} of ${node3.type} expected to have the following:
${errors.join("\n")}`);
        }
      }
      validate2.shapeOf = shape;
      return validate2;
    }
    function assertOptionalChainStart() {
      function validate2(node3) {
        var _current;
        let current = node3;
        while (node3) {
          const {
            type
          } = current;
          if (type === "OptionalCallExpression") {
            if (current.optional) return;
            current = current.callee;
            continue;
          }
          if (type === "OptionalMemberExpression") {
            if (current.optional) return;
            current = current.object;
            continue;
          }
          break;
        }
        throw new TypeError(`Non-optional ${node3.type} must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from ${(_current = current) == null ? void 0 : _current.type}`);
      }
      return validate2;
    }
    function chain(...fns) {
      function validate2(...args) {
        for (const fn of fns) {
          fn(...args);
        }
      }
      validate2.chainOf = fns;
      if (fns.length >= 2 && "type" in fns[0] && fns[0].type === "array" && !("each" in fns[1])) {
        throw new Error(`An assertValueType("array") validator can only be followed by an assertEach(...) validator.`);
      }
      return validate2;
    }
    var validTypeOpts = /* @__PURE__ */ new Set(["aliases", "builder", "deprecatedAlias", "fields", "inherits", "visitor", "validate"]);
    var validFieldKeys = /* @__PURE__ */ new Set(["default", "optional", "deprecated", "validate"]);
    var store = {};
    function defineAliasedType(...aliases) {
      return (type, opts = {}) => {
        let defined2 = opts.aliases;
        if (!defined2) {
          var _store$opts$inherits$, _defined;
          if (opts.inherits) defined2 = (_store$opts$inherits$ = store[opts.inherits].aliases) == null ? void 0 : _store$opts$inherits$.slice();
          (_defined = defined2) != null ? _defined : defined2 = [];
          opts.aliases = defined2;
        }
        const additional = aliases.filter((a) => !defined2.includes(a));
        defined2.unshift(...additional);
        defineType(type, opts);
      };
    }
    function defineType(type, opts = {}) {
      const inherits = opts.inherits && store[opts.inherits] || {};
      let fields = opts.fields;
      if (!fields) {
        fields = {};
        if (inherits.fields) {
          const keys = Object.getOwnPropertyNames(inherits.fields);
          for (const key of keys) {
            const field = inherits.fields[key];
            const def = field.default;
            if (Array.isArray(def) ? def.length > 0 : def && typeof def === "object") {
              throw new Error("field defaults can only be primitives or empty arrays currently");
            }
            fields[key] = {
              default: Array.isArray(def) ? [] : def,
              optional: field.optional,
              deprecated: field.deprecated,
              validate: field.validate
            };
          }
        }
      }
      const visitor = opts.visitor || inherits.visitor || [];
      const aliases = opts.aliases || inherits.aliases || [];
      const builder = opts.builder || inherits.builder || opts.visitor || [];
      for (const k of Object.keys(opts)) {
        if (!validTypeOpts.has(k)) {
          throw new Error(`Unknown type option "${k}" on ${type}`);
        }
      }
      if (opts.deprecatedAlias) {
        DEPRECATED_KEYS[opts.deprecatedAlias] = type;
      }
      for (const key of visitor.concat(builder)) {
        fields[key] = fields[key] || {};
      }
      for (const key of Object.keys(fields)) {
        const field = fields[key];
        if (field.default !== void 0 && !builder.includes(key)) {
          field.optional = true;
        }
        if (field.default === void 0) {
          field.default = null;
        } else if (!field.validate && field.default != null) {
          field.validate = assertValueType(getType(field.default));
        }
        for (const k of Object.keys(field)) {
          if (!validFieldKeys.has(k)) {
            throw new Error(`Unknown field key "${k}" on ${type}.${key}`);
          }
        }
      }
      VISITOR_KEYS[type] = opts.visitor = visitor;
      BUILDER_KEYS[type] = opts.builder = builder;
      NODE_FIELDS[type] = opts.fields = fields;
      ALIAS_KEYS[type] = opts.aliases = aliases;
      aliases.forEach((alias) => {
        FLIPPED_ALIAS_KEYS[alias] = FLIPPED_ALIAS_KEYS[alias] || [];
        FLIPPED_ALIAS_KEYS[alias].push(type);
      });
      if (opts.validate) {
        NODE_PARENT_VALIDATIONS[type] = opts.validate;
      }
      store[type] = opts;
    }
  }
});

// node_modules/@babel/types/lib/definitions/core.js
var require_core = __commonJS({
  "node_modules/@babel/types/lib/definitions/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.patternLikeCommon = exports2.importAttributes = exports2.functionTypeAnnotationCommon = exports2.functionDeclarationCommon = exports2.functionCommon = exports2.classMethodOrPropertyCommon = exports2.classMethodOrDeclareMethodCommon = void 0;
    var _is = require_is();
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib();
    var _helperStringParser = require_lib2();
    var _index = require_constants();
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Standardized");
    defineType("ArrayExpression", {
      fields: {
        elements: {
          validate: (0, _utils.arrayOf)((0, _utils.assertNodeOrValueType)("null", "Expression", "SpreadElement")),
          default: !process.env.BABEL_TYPES_8_BREAKING ? [] : void 0
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    defineType("AssignmentExpression", {
      fields: {
        operator: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("string") : Object.assign(function() {
            const identifier = (0, _utils.assertOneOf)(..._index.ASSIGNMENT_OPERATORS);
            const pattern2 = (0, _utils.assertOneOf)("=");
            return function(node3, key, val) {
              const validator = (0, _is.default)("Pattern", node3.left) ? pattern2 : identifier;
              validator(node3, key, val);
            };
          }(), {
            type: "string"
          })
        },
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal", "OptionalMemberExpression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression", "OptionalMemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"]
    });
    defineType("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.BINARY_OPERATORS)
        },
        left: {
          validate: function() {
            const expression = (0, _utils.assertNodeType)("Expression");
            const inOp = (0, _utils.assertNodeType)("Expression", "PrivateName");
            const validator = Object.assign(function(node3, key, val) {
              const validator2 = node3.operator === "in" ? inOp : expression;
              validator2(node3, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "PrivateName"]
            });
            return validator;
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"]
    });
    defineType("InterpreterDirective", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("Directive", {
      visitor: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertNodeType)("DirectiveLiteral")
        }
      }
    });
    defineType("DirectiveLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, _utils.arrayOfType)("Directive"),
          default: []
        },
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"]
    });
    defineType("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression", "Super", "V8IntrinsicIdentifier")
        },
        arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      }, process.env.BABEL_TYPES_8_BREAKING ? {} : {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      },
      aliases: ["Scopable", "BlockParent"]
    });
    defineType("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        alternate: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression", "Conditional"]
    });
    defineType("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        }
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"]
    });
    defineType("DebuggerStatement", {
      aliases: ["Statement"]
    });
    defineType("DoWhileStatement", {
      builder: ["test", "body"],
      visitor: ["body", "test"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"]
    });
    defineType("EmptyStatement", {
      aliases: ["Statement"]
    });
    defineType("ExpressionStatement", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Statement", "ExpressionWrapper"]
    });
    defineType("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: {
          validate: (0, _utils.assertNodeType)("Program")
        },
        comments: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? Object.assign(() => {
          }, {
            each: {
              oneOfNodeTypes: ["CommentBlock", "CommentLine"]
            }
          }) : (0, _utils.assertEach)((0, _utils.assertNodeType)("CommentBlock", "CommentLine")),
          optional: true
        },
        tokens: {
          validate: (0, _utils.assertEach)(Object.assign(() => {
          }, {
            type: "any"
          })),
          optional: true
        }
      }
    });
    defineType("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("VariableDeclaration", "LVal") : (0, _utils.assertNodeType)("VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, _utils.assertNodeType)("VariableDeclaration", "Expression"),
          optional: true
        },
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        update: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    var functionCommon = () => ({
      params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement"),
      generator: {
        default: false
      },
      async: {
        default: false
      }
    });
    exports2.functionCommon = functionCommon;
    var functionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    exports2.functionTypeAnnotationCommon = functionTypeAnnotationCommon;
    var functionDeclarationCommon = () => Object.assign({}, functionCommon(), {
      declare: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      id: {
        validate: (0, _utils.assertNodeType)("Identifier"),
        optional: true
      }
    });
    exports2.functionDeclarationCommon = functionDeclarationCommon;
    defineType("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "typeParameters", "params", "predicate", "returnType", "body"],
      fields: Object.assign({}, functionDeclarationCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      }),
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Statement", "Pureish", "Declaration"],
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node3) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node3, "id", node3.id);
          }
        };
      }()
    });
    defineType("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    var patternLikeCommon = () => ({
      typeAnnotation: {
        validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
        optional: true
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    });
    exports2.patternLikeCommon = patternLikeCommon;
    defineType("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, patternLikeCommon(), {
        name: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node3, key, val) {
            if (!(0, _isValidIdentifier.default)(val, false)) {
              throw new TypeError(`"${val}" is not a valid identifier name`);
            }
          }, {
            type: "string"
          })) : (0, _utils.assertValueType)("string")
        }
      }),
      validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key, node3) {
        const match2 = /\.(\w+)$/.exec(key);
        if (!match2) return;
        const [, parentKey] = match2;
        const nonComp = {
          computed: false
        };
        if (parentKey === "property") {
          if ((0, _is.default)("MemberExpression", parent, nonComp)) return;
          if ((0, _is.default)("OptionalMemberExpression", parent, nonComp)) return;
        } else if (parentKey === "key") {
          if ((0, _is.default)("Property", parent, nonComp)) return;
          if ((0, _is.default)("Method", parent, nonComp)) return;
        } else if (parentKey === "exported") {
          if ((0, _is.default)("ExportSpecifier", parent)) return;
        } else if (parentKey === "imported") {
          if ((0, _is.default)("ImportSpecifier", parent, {
            imported: node3
          })) return;
        } else if (parentKey === "meta") {
          if ((0, _is.default)("MetaProperty", parent, {
            meta: node3
          })) return;
        }
        if (((0, _helperValidatorIdentifier.isKeyword)(node3.name) || (0, _helperValidatorIdentifier.isReservedWord)(node3.name, false)) && node3.name !== "this") {
          throw new TypeError(`"${node3.name}" is not a valid identifier`);
        }
      } : void 0
    });
    defineType("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        consequent: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        alternate: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("StringLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("number"), Object.assign(function(node3, key, val) {
            if (1 / val < 0 || !Number.isFinite(val)) {
              const error = new Error(`NumericLiterals must be non-negative finite numbers. You can use t.valueToNode(${val}) instead.`);
              {
              }
            }
          }, {
            type: "number"
          }))
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("BooleanLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("boolean")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: {
          validate: (0, _utils.assertValueType)("string")
        },
        flags: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("string"), Object.assign(function(node3, key, val) {
            const invalid = /[^gimsuy]/.exec(val);
            if (invalid) {
              throw new TypeError(`"${invalid[0]}" is not a valid RegExp flag`);
            }
          }, {
            type: "string"
          })) : (0, _utils.assertValueType)("string"),
          default: ""
        }
      }
    });
    defineType("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.LOGICAL_OPERATORS)
        },
        left: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("MemberExpression", {
      builder: ["object", "property", "computed", ...!process.env.BABEL_TYPES_8_BREAKING ? ["optional"] : []],
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign({
        object: {
          validate: (0, _utils.assertNodeType)("Expression", "Super")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node3, key, val) {
              const validator2 = node3.computed ? computed : normal;
              validator2(node3, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"];
            return validator;
          }()
        },
        computed: {
          default: false
        }
      }, !process.env.BABEL_TYPES_8_BREAKING ? {
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      } : {})
    });
    defineType("NewExpression", {
      inherits: "CallExpression"
    });
    defineType("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceType: {
          validate: (0, _utils.assertOneOf)("script", "module"),
          default: "script"
        },
        interpreter: {
          validate: (0, _utils.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: true
        },
        directives: {
          validate: (0, _utils.arrayOfType)("Directive"),
          default: []
        },
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "Block"]
    });
    defineType("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: (0, _utils.validateArrayOfType)("ObjectMethod", "ObjectProperty", "SpreadElement")
      }
    });
    defineType("ObjectMethod", {
      builder: ["kind", "key", "params", "body", "computed", "generator", "async"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        kind: Object.assign({
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }, !process.env.BABEL_TYPES_8_BREAKING ? {
          default: "method"
        } : {}),
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = function(node3, key, val) {
              const validator2 = node3.computed ? computed : normal;
              validator2(node3, key, val);
            };
            validator.oneOfNodeTypes = ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral"];
            return validator;
          }()
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }),
      aliases: ["UserWhitespacable", "Function", "Scopable", "BlockParent", "FunctionParent", "Method", "ObjectMember"]
    });
    defineType("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand", ...!process.env.BABEL_TYPES_8_BREAKING ? ["decorators"] : []],
      fields: {
        computed: {
          default: false
        },
        key: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node3, key, val) {
              const validator2 = node3.computed ? computed : normal;
              validator2(node3, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "DecimalLiteral", "PrivateName"]
            });
            return validator;
          }()
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression", "PatternLike")
        },
        shorthand: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node3, key, shorthand) {
            if (!shorthand) return;
            if (node3.computed) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if computed is true");
            }
            if (!(0, _is.default)("Identifier", node3.key)) {
              throw new TypeError("Property shorthand of ObjectProperty cannot be true if key is not an Identifier");
            }
          }, {
            type: "boolean"
          })) : (0, _utils.assertValueType)("boolean"),
          default: false
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const pattern2 = (0, _utils.assertNodeType)("Identifier", "Pattern", "TSAsExpression", "TSSatisfiesExpression", "TSNonNullExpression", "TSTypeAssertion");
        const expression = (0, _utils.assertNodeType)("Expression");
        return function(parent, key, node3) {
          const validator = (0, _is.default)("ObjectPattern", parent) ? pattern2 : expression;
          validator(node3, "value", node3.value);
        };
      }()
    });
    defineType("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, patternLikeCommon(), {
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        }
      }),
      validate: process.env.BABEL_TYPES_8_BREAKING ? function(parent, key) {
        const match2 = /(\w+)\[(\d+)\]/.exec(key);
        if (!match2) throw new Error("Internal Babel error: malformed key.");
        const [, listKey, index4] = match2;
        if (parent[listKey].length > +index4 + 1) {
          throw new TypeError(`RestElement must be last element of ${listKey}`);
        }
      } : void 0
    });
    defineType("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: (0, _utils.validateArrayOfType)("Expression")
      },
      aliases: ["Expression"]
    });
    defineType("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        consequent: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        cases: (0, _utils.validateArrayOfType)("SwitchCase")
      }
    });
    defineType("ThisExpression", {
      aliases: ["Expression"]
    });
    defineType("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("BlockStatement"), Object.assign(function(node3) {
            if (!node3.handler && !node3.finalizer) {
              throw new TypeError("TryStatement expects either a handler or finalizer, or both");
            }
          }, {
            oneOfNodeTypes: ["BlockStatement"]
          })) : (0, _utils.assertNodeType)("BlockStatement")
        },
        handler: {
          optional: true,
          validate: (0, _utils.assertNodeType)("CatchClause")
        },
        finalizer: {
          optional: true,
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      }
    });
    defineType("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: true
        },
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UNARY_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"]
    });
    defineType("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: {
          default: false
        },
        argument: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("Expression") : (0, _utils.assertNodeType)("Identifier", "MemberExpression")
        },
        operator: {
          validate: (0, _utils.assertOneOf)(..._index.UPDATE_OPERATORS)
        }
      },
      visitor: ["argument"],
      aliases: ["Expression"]
    });
    defineType("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        kind: {
          validate: (0, _utils.assertOneOf)("var", "let", "const", "using", "await using")
        },
        declarations: (0, _utils.validateArrayOfType)("VariableDeclarator")
      },
      validate: process.env.BABEL_TYPES_8_BREAKING ? (() => {
        const withoutInit = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node3) {
          if ((0, _is.default)("ForXStatement", parent, {
            left: node3
          })) {
            if (node3.declarations.length !== 1) {
              throw new TypeError(`Exactly one VariableDeclarator is required in the VariableDeclaration of a ${parent.type}`);
            }
          } else {
            node3.declarations.forEach((decl2) => {
              if (!decl2.init) withoutInit(decl2, "id", decl2.id);
            });
          }
        };
      })() : void 0
    });
    defineType("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertNodeType)("LVal") : (0, _utils.assertNodeType)("Identifier", "ArrayPattern", "ObjectPattern")
        },
        definite: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        init: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        }
      }
    });
    defineType("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        left: {
          validate: (0, _utils.assertNodeType)("Identifier", "ObjectPattern", "ArrayPattern", "MemberExpression", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression")
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      })
    });
    defineType("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        elements: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeOrValueType)("null", "PatternLike", "LVal")))
        }
      })
    });
    defineType("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["typeParameters", "params", "predicate", "returnType", "body"],
      aliases: ["Scopable", "Function", "BlockParent", "FunctionParent", "Expression", "Pureish"],
      fields: Object.assign({}, functionCommon(), functionTypeAnnotationCommon(), {
        expression: {
          validate: (0, _utils.assertValueType)("boolean")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement", "Expression")
        },
        predicate: {
          validate: (0, _utils.assertNodeType)("DeclaredPredicate", "InferredPredicate"),
          optional: true
        }
      })
    });
    defineType("ClassBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("ClassMethod", "ClassPrivateMethod", "ClassProperty", "ClassPrivateProperty", "ClassAccessorProperty", "TSDeclareMethod", "TSIndexSignature", "StaticBlock")
      }
    });
    defineType("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: ["decorators", "id", "typeParameters", "superClass", "superTypeParameters", "mixins", "implements", "body"],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        ["superTypeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        }
      }
    });
    defineType("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier"),
          optional: true
        },
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TypeParameterDeclaration", "TSTypeParameterDeclaration", "Noop"),
          optional: true
        },
        body: {
          validate: (0, _utils.assertNodeType)("ClassBody")
        },
        superClass: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        },
        ["superTypeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        },
        implements: {
          validate: (0, _utils.arrayOfType)("TSExpressionWithTypeArguments", "ClassImplements"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        mixins: {
          validate: (0, _utils.assertNodeType)("InterfaceExtends"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        abstract: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      },
      validate: !process.env.BABEL_TYPES_8_BREAKING ? void 0 : function() {
        const identifier = (0, _utils.assertNodeType)("Identifier");
        return function(parent, key, node3) {
          if (!(0, _is.default)("ExportDefaultDeclaration", parent)) {
            identifier(node3, "id", node3.id);
          }
        };
      }()
    });
    var importAttributes = exports2.importAttributes = {
      attributes: {
        optional: true,
        validate: (0, _utils.arrayOfType)("ImportAttribute")
      },
      assertions: {
        deprecated: true,
        optional: true,
        validate: (0, _utils.arrayOfType)("ImportAttribute")
      }
    };
    defineType("ExportAllDeclaration", {
      builder: ["source"],
      visitor: ["source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: Object.assign({
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }, importAttributes)
    });
    defineType("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: {
        declaration: (0, _utils.validateType)("TSDeclareFunction", "FunctionDeclaration", "ClassDeclaration", "Expression"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("value"))
      }
    });
    defineType("ExportNamedDeclaration", {
      builder: ["declaration", "specifiers", "source"],
      visitor: process.env ? ["declaration", "specifiers", "source", "attributes"] : ["declaration", "specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration", "ExportDeclaration"],
      fields: Object.assign({
        declaration: {
          optional: true,
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Declaration"), Object.assign(function(node3, key, val) {
            if (val && node3.specifiers.length) {
              throw new TypeError("Only declaration or specifiers is allowed on ExportNamedDeclaration");
            }
            if (val && node3.source) {
              throw new TypeError("Cannot export a declaration from a source");
            }
          }, {
            oneOfNodeTypes: ["Declaration"]
          })) : (0, _utils.assertNodeType)("Declaration")
        }
      }, importAttributes, {
        specifiers: {
          default: [],
          validate: (0, _utils.arrayOf)(function() {
            const sourced = (0, _utils.assertNodeType)("ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier");
            const sourceless = (0, _utils.assertNodeType)("ExportSpecifier");
            if (!process.env.BABEL_TYPES_8_BREAKING) return sourced;
            return Object.assign(function(node3, key, val) {
              const validator = node3.source ? sourced : sourceless;
              validator(node3, key, val);
            }, {
              oneOfNodeTypes: ["ExportSpecifier", "ExportDefaultSpecifier", "ExportNamespaceSpecifier"]
            });
          }())
        },
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral"),
          optional: true
        },
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      })
    });
    defineType("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        exportKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      }
    });
    defineType("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop", "ForXStatement"],
      fields: {
        left: {
          validate: function() {
            if (!process.env.BABEL_TYPES_8_BREAKING) {
              return (0, _utils.assertNodeType)("VariableDeclaration", "LVal");
            }
            const declaration = (0, _utils.assertNodeType)("VariableDeclaration");
            const lval = (0, _utils.assertNodeType)("Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression");
            return Object.assign(function(node3, key, val) {
              if ((0, _is.default)("VariableDeclaration", val)) {
                declaration(node3, key, val);
              } else {
                lval(node3, key, val);
              }
            }, {
              oneOfNodeTypes: ["VariableDeclaration", "Identifier", "MemberExpression", "ArrayPattern", "ObjectPattern", "TSAsExpression", "TSSatisfiesExpression", "TSTypeAssertion", "TSNonNullExpression"]
            });
          }()
        },
        right: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        body: {
          validate: (0, _utils.assertNodeType)("Statement")
        },
        await: {
          default: false
        }
      }
    });
    defineType("ImportDeclaration", {
      builder: ["specifiers", "source"],
      visitor: ["specifiers", "source", "attributes", "assertions"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: Object.assign({}, importAttributes, {
        module: {
          optional: true,
          validate: (0, _utils.assertValueType)("boolean")
        },
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        specifiers: (0, _utils.validateArrayOfType)("ImportSpecifier", "ImportDefaultSpecifier", "ImportNamespaceSpecifier"),
        source: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      })
    });
    defineType("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("ImportSpecifier", {
      visitor: ["imported", "local"],
      builder: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        imported: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "typeof", "value"),
          optional: true
        }
      }
    });
    defineType("ImportExpression", {
      visitor: ["source", "options"],
      aliases: ["Expression"],
      fields: {
        phase: {
          default: null,
          validate: (0, _utils.assertOneOf)("source", "defer")
        },
        source: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        options: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertNodeType)("Identifier"), Object.assign(function(node3, key, val) {
            let property;
            switch (val.name) {
              case "function":
                property = "sent";
                break;
              case "new":
                property = "target";
                break;
              case "import":
                property = "meta";
                break;
            }
            if (!(0, _is.default)("Identifier", node3.property, {
              name: property
            })) {
              throw new TypeError("Unrecognised MetaProperty");
            }
          }, {
            oneOfNodeTypes: ["Identifier"]
          })) : (0, _utils.assertNodeType)("Identifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    var classMethodOrPropertyCommon = () => ({
      abstract: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      accessibility: {
        validate: (0, _utils.assertOneOf)("public", "private", "protected"),
        optional: true
      },
      static: {
        default: false
      },
      override: {
        default: false
      },
      computed: {
        default: false
      },
      optional: {
        validate: (0, _utils.assertValueType)("boolean"),
        optional: true
      },
      key: {
        validate: (0, _utils.chain)(function() {
          const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral");
          const computed = (0, _utils.assertNodeType)("Expression");
          return function(node3, key, val) {
            const validator = node3.computed ? computed : normal;
            validator(node3, key, val);
          };
        }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression"))
      }
    });
    exports2.classMethodOrPropertyCommon = classMethodOrPropertyCommon;
    var classMethodOrDeclareMethodCommon = () => Object.assign({}, functionCommon(), classMethodOrPropertyCommon(), {
      params: (0, _utils.validateArrayOfType)("Identifier", "Pattern", "RestElement", "TSParameterProperty"),
      kind: {
        validate: (0, _utils.assertOneOf)("get", "set", "method", "constructor"),
        default: "method"
      },
      access: {
        validate: (0, _utils.chain)((0, _utils.assertValueType)("string"), (0, _utils.assertOneOf)("public", "private", "protected")),
        optional: true
      },
      decorators: {
        validate: (0, _utils.arrayOfType)("Decorator"),
        optional: true
      }
    });
    exports2.classMethodOrDeclareMethodCommon = classMethodOrDeclareMethodCommon;
    defineType("ClassMethod", {
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method"],
      builder: ["kind", "key", "params", "body", "computed", "static", "generator", "async"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, patternLikeCommon(), {
        properties: (0, _utils.validateArrayOfType)("RestElement", "ObjectProperty")
      })
    });
    defineType("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Super", {
      aliases: ["Expression"]
    });
    defineType("TaggedTemplateExpression", {
      visitor: ["tag", "typeParameters", "quasi"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        quasi: {
          validate: (0, _utils.assertNodeType)("TemplateLiteral")
        },
        ["typeParameters"]: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation", "TSTypeParameterInstantiation"),
          optional: true
        }
      }
    });
    defineType("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, _utils.chain)((0, _utils.assertShape)({
            raw: {
              validate: (0, _utils.assertValueType)("string")
            },
            cooked: {
              validate: (0, _utils.assertValueType)("string"),
              optional: true
            }
          }), function templateElementCookedValidator(node3) {
            const raw = node3.value.raw;
            let unterminatedCalled = false;
            const error = () => {
              throw new Error("Internal @babel/types error.");
            };
            const {
              str: str2,
              firstInvalidLoc
            } = (0, _helperStringParser.readStringContents)("template", raw, 0, 0, 0, {
              unterminated() {
                unterminatedCalled = true;
              },
              strictNumericEscape: error,
              invalidEscapeSequence: error,
              numericSeparatorInEscapeSequence: error,
              unexpectedNumericSeparator: error,
              invalidDigit: error,
              invalidCodePoint: error
            });
            if (!unterminatedCalled) throw new Error("Invalid raw");
            node3.value.cooked = firstInvalidLoc ? null : str2;
          })
        },
        tail: {
          default: false
        }
      }
    });
    defineType("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
        expressions: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("Expression", "TSType")), function(node3, key, val) {
            if (node3.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node3.type} quasis should be exactly one more than the number of expressions.
Expected ${val.length + 1} quasis but got ${node3.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.chain)((0, _utils.assertValueType)("boolean"), Object.assign(function(node3, key, val) {
            if (val && !node3.argument) {
              throw new TypeError("Property delegate of YieldExpression cannot be true if there is no argument");
            }
          }, {
            type: "boolean"
          })) : (0, _utils.assertValueType)("boolean"),
          default: false
        },
        argument: {
          optional: true,
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("Import", {
      aliases: ["Expression"]
    });
    defineType("BigIntLiteral", {
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"]
    });
    defineType("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        property: {
          validate: function() {
            const normal = (0, _utils.assertNodeType)("Identifier");
            const computed = (0, _utils.assertNodeType)("Expression");
            const validator = Object.assign(function(node3, key, val) {
              const validator2 = node3.computed ? computed : normal;
              validator2(node3, key, val);
            }, {
              oneOfNodeTypes: ["Expression", "Identifier"]
            });
            return validator;
          }()
        },
        computed: {
          default: false
        },
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        }
      }
    });
    defineType("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: Object.assign({
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        arguments: (0, _utils.validateArrayOfType)("Expression", "SpreadElement", "ArgumentPlaceholder"),
        optional: {
          validate: !process.env.BABEL_TYPES_8_BREAKING ? (0, _utils.assertValueType)("boolean") : (0, _utils.chain)((0, _utils.assertValueType)("boolean"), (0, _utils.assertOptionalChainStart)())
        },
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, {
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("ClassProperty", {
      visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassAccessorProperty", {
      visitor: ["decorators", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "typeAnnotation", "decorators", "computed", "static"],
      aliases: ["Property", "Accessor"],
      fields: Object.assign({}, classMethodOrPropertyCommon(), {
        key: {
          validate: (0, _utils.chain)(function() {
            const normal = (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "PrivateName");
            const computed = (0, _utils.assertNodeType)("Expression");
            return function(node3, key, val) {
              const validator = node3.computed ? computed : normal;
              validator(node3, key, val);
            };
          }(), (0, _utils.assertNodeType)("Identifier", "StringLiteral", "NumericLiteral", "BigIntLiteral", "Expression", "PrivateName"))
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        declare: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      })
    });
    defineType("ClassPrivateProperty", {
      visitor: ["decorators", "variance", "key", "typeAnnotation", "value"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        value: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        },
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TypeAnnotation", "TSTypeAnnotation", "Noop"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        },
        static: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        optional: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        definite: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        variance: {
          validate: (0, _utils.assertNodeType)("Variance"),
          optional: true
        }
      }
    });
    defineType("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: ["decorators", "key", "typeParameters", "params", "returnType", "body"],
      aliases: ["Function", "Scopable", "BlockParent", "FunctionParent", "Method", "Private"],
      fields: Object.assign({}, classMethodOrDeclareMethodCommon(), functionTypeAnnotationCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("get", "set", "method"),
          default: "method"
        },
        key: {
          validate: (0, _utils.assertNodeType)("PrivateName")
        },
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        }
      })
    });
    defineType("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: {
        id: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    defineType("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/flow.js
var require_flow = __commonJS({
  "node_modules/@babel/types/lib/definitions/flow.js"() {
    "use strict";
    var _core = require_core();
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("Flow");
    var defineInterfaceishType = (name2) => {
      const isDeclareClass = name2 === "DeclareClass";
      defineType(name2, {
        builder: ["id", "typeParameters", "extends", "body"],
        visitor: ["id", "typeParameters", "extends", ...isDeclareClass ? ["mixins", "implements"] : [], "body"],
        aliases: ["FlowDeclaration", "Statement", "Declaration"],
        fields: Object.assign({
          id: (0, _utils.validateType)("Identifier"),
          typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
          extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends"))
        }, isDeclareClass ? {
          mixins: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
          implements: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ClassImplements"))
        } : {}, {
          body: (0, _utils.validateType)("ObjectTypeAnnotation")
        })
      });
    };
    defineType("AnyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ArrayTypeAnnotation", {
      visitor: ["elementType"],
      aliases: ["FlowType"],
      fields: {
        elementType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("BooleanTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("BooleanLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("NullLiteralTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ClassImplements", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("DeclareClass");
    defineType("DeclareFunction", {
      builder: ["id"],
      visitor: ["id", "predicate"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        predicate: (0, _utils.validateOptionalType)("DeclaredPredicate")
      }
    });
    defineInterfaceishType("DeclareInterface");
    defineType("DeclareModule", {
      builder: ["id", "body", "kind"],
      visitor: ["id", "body"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        body: (0, _utils.validateType)("BlockStatement"),
        kind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("CommonJS", "ES"))
      }
    });
    defineType("DeclareModuleExports", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("DeclareTypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("DeclareOpaqueType", {
      visitor: ["id", "typeParameters", "supertype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateOptionalType)("FlowType")
      }
    });
    defineType("DeclareVariable", {
      visitor: ["id"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("DeclareExportDeclaration", {
      visitor: ["declaration", "specifiers", "source", "attributes"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        declaration: (0, _utils.validateOptionalType)("Flow"),
        specifiers: (0, _utils.validateOptional)((0, _utils.arrayOfType)("ExportSpecifier", "ExportNamespaceSpecifier")),
        source: (0, _utils.validateOptionalType)("StringLiteral"),
        default: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }, _core.importAttributes)
    });
    defineType("DeclareExportAllDeclaration", {
      visitor: ["source", "attributes"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: Object.assign({
        source: (0, _utils.validateType)("StringLiteral"),
        exportKind: (0, _utils.validateOptional)((0, _utils.assertOneOf)("type", "value"))
      }, _core.importAttributes)
    });
    defineType("DeclaredPredicate", {
      visitor: ["value"],
      aliases: ["FlowPredicate"],
      fields: {
        value: (0, _utils.validateType)("Flow")
      }
    });
    defineType("ExistsTypeAnnotation", {
      aliases: ["FlowType"]
    });
    defineType("FunctionTypeAnnotation", {
      builder: ["typeParameters", "params", "rest", "returnType"],
      visitor: ["typeParameters", "this", "params", "rest", "returnType"],
      aliases: ["FlowType"],
      fields: {
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        params: (0, _utils.validateArrayOfType)("FunctionTypeParam"),
        rest: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        this: (0, _utils.validateOptionalType)("FunctionTypeParam"),
        returnType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("FunctionTypeParam", {
      visitor: ["name", "typeAnnotation"],
      fields: {
        name: (0, _utils.validateOptionalType)("Identifier"),
        typeAnnotation: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("GenericTypeAnnotation", {
      visitor: ["id", "typeParameters"],
      aliases: ["FlowType"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineType("InferredPredicate", {
      aliases: ["FlowPredicate"]
    });
    defineType("InterfaceExtends", {
      visitor: ["id", "typeParameters"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterInstantiation")
      }
    });
    defineInterfaceishType("InterfaceDeclaration");
    defineType("InterfaceTypeAnnotation", {
      visitor: ["extends", "body"],
      aliases: ["FlowType"],
      fields: {
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("InterfaceExtends")),
        body: (0, _utils.validateType)("ObjectTypeAnnotation")
      }
    });
    defineType("IntersectionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("MixedTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EmptyTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("NullableTypeAnnotation", {
      visitor: ["typeAnnotation"],
      aliases: ["FlowType"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("NumberLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("number"))
      }
    });
    defineType("NumberTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ObjectTypeAnnotation", {
      visitor: ["properties", "indexers", "callProperties", "internalSlots"],
      aliases: ["FlowType"],
      builder: ["properties", "indexers", "callProperties", "internalSlots", "exact"],
      fields: {
        properties: (0, _utils.validate)((0, _utils.arrayOfType)("ObjectTypeProperty", "ObjectTypeSpreadProperty")),
        indexers: {
          validate: (0, _utils.arrayOfType)("ObjectTypeIndexer"),
          optional: true,
          default: []
        },
        callProperties: {
          validate: (0, _utils.arrayOfType)("ObjectTypeCallProperty"),
          optional: true,
          default: []
        },
        internalSlots: {
          validate: (0, _utils.arrayOfType)("ObjectTypeInternalSlot"),
          optional: true,
          default: []
        },
        exact: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        },
        inexact: (0, _utils.validateOptional)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeInternalSlot", {
      visitor: ["id", "value"],
      builder: ["id", "value", "optional", "static", "method"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        value: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeCallProperty", {
      visitor: ["value"],
      aliases: ["UserWhitespacable"],
      fields: {
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeIndexer", {
      visitor: ["variance", "id", "key", "value"],
      builder: ["id", "key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        id: (0, _utils.validateOptionalType)("Identifier"),
        key: (0, _utils.validateType)("FlowType"),
        value: (0, _utils.validateType)("FlowType"),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("ObjectTypeProperty", {
      visitor: ["key", "value", "variance"],
      aliases: ["UserWhitespacable"],
      fields: {
        key: (0, _utils.validateType)("Identifier", "StringLiteral"),
        value: (0, _utils.validateType)("FlowType"),
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("init", "get", "set")),
        static: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        proto: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        variance: (0, _utils.validateOptionalType)("Variance"),
        method: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("ObjectTypeSpreadProperty", {
      visitor: ["argument"],
      aliases: ["UserWhitespacable"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OpaqueType", {
      visitor: ["id", "typeParameters", "supertype", "impltype"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        supertype: (0, _utils.validateOptionalType)("FlowType"),
        impltype: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("QualifiedTypeIdentifier", {
      visitor: ["qualification", "id"],
      builder: ["id", "qualification"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        qualification: (0, _utils.validateType)("Identifier", "QualifiedTypeIdentifier")
      }
    });
    defineType("StringLiteralTypeAnnotation", {
      builder: ["value"],
      aliases: ["FlowType"],
      fields: {
        value: (0, _utils.validate)((0, _utils.assertValueType)("string"))
      }
    });
    defineType("StringTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("SymbolTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("ThisTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("TupleTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("TypeofTypeAnnotation", {
      visitor: ["argument"],
      aliases: ["FlowType"],
      fields: {
        argument: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAlias", {
      visitor: ["id", "typeParameters", "right"],
      aliases: ["FlowDeclaration", "Statement", "Declaration"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TypeParameterDeclaration"),
        right: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("TypeCastExpression", {
      visitor: ["expression", "typeAnnotation"],
      aliases: ["ExpressionWrapper", "Expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TypeAnnotation")
      }
    });
    defineType("TypeParameter", {
      visitor: ["bound", "default", "variance"],
      fields: {
        name: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        bound: (0, _utils.validateOptionalType)("TypeAnnotation"),
        default: (0, _utils.validateOptionalType)("FlowType"),
        variance: (0, _utils.validateOptionalType)("Variance")
      }
    });
    defineType("TypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("TypeParameter"))
      }
    });
    defineType("TypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("UnionTypeAnnotation", {
      visitor: ["types"],
      aliases: ["FlowType"],
      fields: {
        types: (0, _utils.validate)((0, _utils.arrayOfType)("FlowType"))
      }
    });
    defineType("Variance", {
      builder: ["kind"],
      fields: {
        kind: (0, _utils.validate)((0, _utils.assertOneOf)("minus", "plus"))
      }
    });
    defineType("VoidTypeAnnotation", {
      aliases: ["FlowType", "FlowBaseAnnotation"]
    });
    defineType("EnumDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        body: (0, _utils.validateType)("EnumBooleanBody", "EnumNumberBody", "EnumStringBody", "EnumSymbolBody")
      }
    });
    defineType("EnumBooleanBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumBooleanMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumNumberBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumNumberMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumStringBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        explicitType: (0, _utils.validate)((0, _utils.assertValueType)("boolean")),
        members: (0, _utils.validateArrayOfType)("EnumStringMember", "EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumSymbolBody", {
      aliases: ["EnumBody"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("EnumDefaultedMember"),
        hasUnknownMembers: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
    defineType("EnumBooleanMember", {
      aliases: ["EnumMember"],
      builder: ["id"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("BooleanLiteral")
      }
    });
    defineType("EnumNumberMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("NumericLiteral")
      }
    });
    defineType("EnumStringMember", {
      aliases: ["EnumMember"],
      visitor: ["id", "init"],
      fields: {
        id: (0, _utils.validateType)("Identifier"),
        init: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("EnumDefaultedMember", {
      aliases: ["EnumMember"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("IndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType")
      }
    });
    defineType("OptionalIndexedAccessType", {
      visitor: ["objectType", "indexType"],
      aliases: ["FlowType"],
      fields: {
        objectType: (0, _utils.validateType)("FlowType"),
        indexType: (0, _utils.validateType)("FlowType"),
        optional: (0, _utils.validate)((0, _utils.assertValueType)("boolean"))
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/jsx.js
var require_jsx = __commonJS({
  "node_modules/@babel/types/lib/definitions/jsx.js"() {
    "use strict";
    var _utils = require_utils();
    var defineType = (0, _utils.defineAliasedType)("JSX");
    defineType("JSXAttribute", {
      visitor: ["name", "value"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXNamespacedName")
        },
        value: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXElement", "JSXFragment", "StringLiteral", "JSXExpressionContainer")
        }
      }
    });
    defineType("JSXClosingElement", {
      visitor: ["name"],
      aliases: ["Immutable"],
      fields: {
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        }
      }
    });
    defineType("JSXElement", {
      builder: ["openingElement", "closingElement", "children", "selfClosing"],
      visitor: ["openingElement", "children", "closingElement"],
      aliases: ["Immutable", "Expression"],
      fields: Object.assign({
        openingElement: {
          validate: (0, _utils.assertNodeType)("JSXOpeningElement")
        },
        closingElement: {
          optional: true,
          validate: (0, _utils.assertNodeType)("JSXClosingElement")
        },
        children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
      }, {
        selfClosing: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        }
      })
    });
    defineType("JSXEmptyExpression", {});
    defineType("JSXExpressionContainer", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression", "JSXEmptyExpression")
        }
      }
    });
    defineType("JSXSpreadChild", {
      visitor: ["expression"],
      aliases: ["Immutable"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXMemberExpression", {
      visitor: ["object", "property"],
      fields: {
        object: {
          validate: (0, _utils.assertNodeType)("JSXMemberExpression", "JSXIdentifier")
        },
        property: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXNamespacedName", {
      visitor: ["namespace", "name"],
      fields: {
        namespace: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        },
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier")
        }
      }
    });
    defineType("JSXOpeningElement", {
      builder: ["name", "attributes", "selfClosing"],
      visitor: ["name", "typeParameters", "typeArguments", "attributes"],
      aliases: ["Immutable"],
      fields: Object.assign({
        name: {
          validate: (0, _utils.assertNodeType)("JSXIdentifier", "JSXMemberExpression", "JSXNamespacedName")
        },
        selfClosing: {
          default: false
        },
        attributes: (0, _utils.validateArrayOfType)("JSXAttribute", "JSXSpreadAttribute"),
        typeArguments: {
          validate: (0, _utils.assertNodeType)("TypeParameterInstantiation"),
          optional: true
        }
      }, {
        typeParameters: {
          validate: (0, _utils.assertNodeType)("TSTypeParameterInstantiation"),
          optional: true
        }
      })
    });
    defineType("JSXSpreadAttribute", {
      visitor: ["argument"],
      fields: {
        argument: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    defineType("JSXText", {
      aliases: ["Immutable"],
      builder: ["value"],
      fields: {
        value: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
    defineType("JSXFragment", {
      builder: ["openingFragment", "closingFragment", "children"],
      visitor: ["openingFragment", "children", "closingFragment"],
      aliases: ["Immutable", "Expression"],
      fields: {
        openingFragment: {
          validate: (0, _utils.assertNodeType)("JSXOpeningFragment")
        },
        closingFragment: {
          validate: (0, _utils.assertNodeType)("JSXClosingFragment")
        },
        children: (0, _utils.validateArrayOfType)("JSXText", "JSXExpressionContainer", "JSXSpreadChild", "JSXElement", "JSXFragment")
      }
    });
    defineType("JSXOpeningFragment", {
      aliases: ["Immutable"]
    });
    defineType("JSXClosingFragment", {
      aliases: ["Immutable"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/placeholders.js
var require_placeholders = __commonJS({
  "node_modules/@babel/types/lib/definitions/placeholders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PLACEHOLDERS_FLIPPED_ALIAS = exports2.PLACEHOLDERS_ALIAS = exports2.PLACEHOLDERS = void 0;
    var _utils = require_utils();
    var PLACEHOLDERS = exports2.PLACEHOLDERS = ["Identifier", "StringLiteral", "Expression", "Statement", "Declaration", "BlockStatement", "ClassBody", "Pattern"];
    var PLACEHOLDERS_ALIAS = exports2.PLACEHOLDERS_ALIAS = {
      Declaration: ["Statement"],
      Pattern: ["PatternLike", "LVal"]
    };
    for (const type of PLACEHOLDERS) {
      const alias = _utils.ALIAS_KEYS[type];
      if (alias != null && alias.length) PLACEHOLDERS_ALIAS[type] = alias;
    }
    var PLACEHOLDERS_FLIPPED_ALIAS = exports2.PLACEHOLDERS_FLIPPED_ALIAS = {};
    Object.keys(PLACEHOLDERS_ALIAS).forEach((type) => {
      PLACEHOLDERS_ALIAS[type].forEach((alias) => {
        if (!hasOwnProperty.call(PLACEHOLDERS_FLIPPED_ALIAS, alias)) {
          PLACEHOLDERS_FLIPPED_ALIAS[alias] = [];
        }
        PLACEHOLDERS_FLIPPED_ALIAS[alias].push(type);
      });
    });
  }
});

// node_modules/@babel/types/lib/definitions/misc.js
var require_misc = __commonJS({
  "node_modules/@babel/types/lib/definitions/misc.js"() {
    "use strict";
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var _core = require_core();
    var defineType = (0, _utils.defineAliasedType)("Miscellaneous");
    {
      defineType("Noop", {
        visitor: []
      });
    }
    defineType("Placeholder", {
      visitor: [],
      builder: ["expectedNode", "name"],
      fields: Object.assign({
        name: {
          validate: (0, _utils.assertNodeType)("Identifier")
        },
        expectedNode: {
          validate: (0, _utils.assertOneOf)(..._placeholders.PLACEHOLDERS)
        }
      }, (0, _core.patternLikeCommon)())
    });
    defineType("V8IntrinsicIdentifier", {
      builder: ["name"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/experimental.js
var require_experimental = __commonJS({
  "node_modules/@babel/types/lib/definitions/experimental.js"() {
    "use strict";
    var _utils = require_utils();
    (0, _utils.default)("ArgumentPlaceholder", {});
    (0, _utils.default)("BindExpression", {
      visitor: ["object", "callee"],
      aliases: ["Expression"],
      fields: !process.env.BABEL_TYPES_8_BREAKING ? {
        object: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        },
        callee: {
          validate: Object.assign(() => {
          }, {
            oneOfNodeTypes: ["Expression"]
          })
        }
      } : {
        object: {
          validate: (0, _utils.assertNodeType)("Expression")
        },
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("ImportAttribute", {
      visitor: ["key", "value"],
      fields: {
        key: {
          validate: (0, _utils.assertNodeType)("Identifier", "StringLiteral")
        },
        value: {
          validate: (0, _utils.assertNodeType)("StringLiteral")
        }
      }
    });
    (0, _utils.default)("Decorator", {
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      }
    });
    (0, _utils.default)("DoExpression", {
      visitor: ["body"],
      builder: ["body", "async"],
      aliases: ["Expression"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("BlockStatement")
        },
        async: {
          validate: (0, _utils.assertValueType)("boolean"),
          default: false
        }
      }
    });
    (0, _utils.default)("ExportDefaultSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        exported: {
          validate: (0, _utils.assertNodeType)("Identifier")
        }
      }
    });
    (0, _utils.default)("RecordExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: (0, _utils.validateArrayOfType)("ObjectProperty", "SpreadElement")
      }
    });
    (0, _utils.default)("TupleExpression", {
      fields: {
        elements: {
          validate: (0, _utils.arrayOfType)("Expression", "SpreadElement"),
          default: []
        }
      },
      visitor: ["elements"],
      aliases: ["Expression"]
    });
    {
      (0, _utils.default)("DecimalLiteral", {
        builder: ["value"],
        fields: {
          value: {
            validate: (0, _utils.assertValueType)("string")
          }
        },
        aliases: ["Expression", "Pureish", "Literal", "Immutable"]
      });
    }
    (0, _utils.default)("ModuleExpression", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, _utils.assertNodeType)("Program")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("TopicReference", {
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineTopicExpression", {
      builder: ["expression"],
      visitor: ["expression"],
      fields: {
        expression: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelineBareFunction", {
      builder: ["callee"],
      visitor: ["callee"],
      fields: {
        callee: {
          validate: (0, _utils.assertNodeType)("Expression")
        }
      },
      aliases: ["Expression"]
    });
    (0, _utils.default)("PipelinePrimaryTopicReference", {
      aliases: ["Expression"]
    });
  }
});

// node_modules/@babel/types/lib/definitions/typescript.js
var require_typescript = __commonJS({
  "node_modules/@babel/types/lib/definitions/typescript.js"() {
    "use strict";
    var _utils = require_utils();
    var _core = require_core();
    var _is = require_is();
    var defineType = (0, _utils.defineAliasedType)("TypeScript");
    var bool = (0, _utils.assertValueType)("boolean");
    var tSFunctionTypeAnnotationCommon = () => ({
      returnType: {
        validate: (0, _utils.assertNodeType)("TSTypeAnnotation", "Noop"),
        optional: true
      },
      typeParameters: {
        validate: (0, _utils.assertNodeType)("TSTypeParameterDeclaration", "Noop"),
        optional: true
      }
    });
    defineType("TSParameterProperty", {
      aliases: ["LVal"],
      visitor: ["parameter"],
      fields: {
        accessibility: {
          validate: (0, _utils.assertOneOf)("public", "private", "protected"),
          optional: true
        },
        readonly: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        parameter: {
          validate: (0, _utils.assertNodeType)("Identifier", "AssignmentPattern")
        },
        override: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        decorators: {
          validate: (0, _utils.arrayOfType)("Decorator"),
          optional: true
        }
      }
    });
    defineType("TSDeclareFunction", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.functionDeclarationCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSDeclareMethod", {
      visitor: ["decorators", "key", "typeParameters", "params", "returnType"],
      fields: Object.assign({}, (0, _core.classMethodOrDeclareMethodCommon)(), tSFunctionTypeAnnotationCommon())
    });
    defineType("TSQualifiedName", {
      aliases: ["TSEntityName"],
      visitor: ["left", "right"],
      fields: {
        left: (0, _utils.validateType)("TSEntityName"),
        right: (0, _utils.validateType)("Identifier")
      }
    });
    var signatureDeclarationCommon = () => ({
      typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
      ["parameters"]: (0, _utils.validateArrayOfType)("ArrayPattern", "Identifier", "ObjectPattern", "RestElement"),
      ["typeAnnotation"]: (0, _utils.validateOptionalType)("TSTypeAnnotation")
    });
    var callConstructSignatureDeclaration = {
      aliases: ["TSTypeElement"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"],
      fields: signatureDeclarationCommon()
    };
    defineType("TSCallSignatureDeclaration", callConstructSignatureDeclaration);
    defineType("TSConstructSignatureDeclaration", callConstructSignatureDeclaration);
    var namedTypeElementCommon = () => ({
      key: (0, _utils.validateType)("Expression"),
      computed: {
        default: false
      },
      optional: (0, _utils.validateOptional)(bool)
    });
    defineType("TSPropertySignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeAnnotation"],
      fields: Object.assign({}, namedTypeElementCommon(), {
        readonly: (0, _utils.validateOptional)(bool),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        kind: {
          optional: true,
          validate: (0, _utils.assertOneOf)("get", "set")
        }
      })
    });
    defineType("TSMethodSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["key", "typeParameters", "parameters", "typeAnnotation"],
      fields: Object.assign({}, signatureDeclarationCommon(), namedTypeElementCommon(), {
        kind: {
          validate: (0, _utils.assertOneOf)("method", "get", "set")
        }
      })
    });
    defineType("TSIndexSignature", {
      aliases: ["TSTypeElement"],
      visitor: ["parameters", "typeAnnotation"],
      fields: {
        readonly: (0, _utils.validateOptional)(bool),
        static: (0, _utils.validateOptional)(bool),
        parameters: (0, _utils.validateArrayOfType)("Identifier"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation")
      }
    });
    var tsKeywordTypes = ["TSAnyKeyword", "TSBooleanKeyword", "TSBigIntKeyword", "TSIntrinsicKeyword", "TSNeverKeyword", "TSNullKeyword", "TSNumberKeyword", "TSObjectKeyword", "TSStringKeyword", "TSSymbolKeyword", "TSUndefinedKeyword", "TSUnknownKeyword", "TSVoidKeyword"];
    for (const type of tsKeywordTypes) {
      defineType(type, {
        aliases: ["TSType", "TSBaseType"],
        visitor: [],
        fields: {}
      });
    }
    defineType("TSThisType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: [],
      fields: {}
    });
    var fnOrCtrBase = {
      aliases: ["TSType"],
      visitor: ["typeParameters", "parameters", "typeAnnotation"]
    };
    defineType("TSFunctionType", Object.assign({}, fnOrCtrBase, {
      fields: signatureDeclarationCommon()
    }));
    defineType("TSConstructorType", Object.assign({}, fnOrCtrBase, {
      fields: Object.assign({}, signatureDeclarationCommon(), {
        abstract: (0, _utils.validateOptional)(bool)
      })
    }));
    defineType("TSTypeReference", {
      aliases: ["TSType"],
      visitor: ["typeName", "typeParameters"],
      fields: {
        typeName: (0, _utils.validateType)("TSEntityName"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypePredicate", {
      aliases: ["TSType"],
      visitor: ["parameterName", "typeAnnotation"],
      builder: ["parameterName", "typeAnnotation", "asserts"],
      fields: {
        parameterName: (0, _utils.validateType)("Identifier", "TSThisType"),
        typeAnnotation: (0, _utils.validateOptionalType)("TSTypeAnnotation"),
        asserts: (0, _utils.validateOptional)(bool)
      }
    });
    defineType("TSTypeQuery", {
      aliases: ["TSType"],
      visitor: ["exprName", "typeParameters"],
      fields: {
        exprName: (0, _utils.validateType)("TSEntityName", "TSImportType"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    defineType("TSTypeLiteral", {
      aliases: ["TSType"],
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSArrayType", {
      aliases: ["TSType"],
      visitor: ["elementType"],
      fields: {
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTupleType", {
      aliases: ["TSType"],
      visitor: ["elementTypes"],
      fields: {
        elementTypes: (0, _utils.validateArrayOfType)("TSType", "TSNamedTupleMember")
      }
    });
    defineType("TSOptionalType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSRestType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSNamedTupleMember", {
      visitor: ["label", "elementType"],
      builder: ["label", "elementType", "optional"],
      fields: {
        label: (0, _utils.validateType)("Identifier"),
        optional: {
          validate: bool,
          default: false
        },
        elementType: (0, _utils.validateType)("TSType")
      }
    });
    var unionOrIntersection = {
      aliases: ["TSType"],
      visitor: ["types"],
      fields: {
        types: (0, _utils.validateArrayOfType)("TSType")
      }
    };
    defineType("TSUnionType", unionOrIntersection);
    defineType("TSIntersectionType", unionOrIntersection);
    defineType("TSConditionalType", {
      aliases: ["TSType"],
      visitor: ["checkType", "extendsType", "trueType", "falseType"],
      fields: {
        checkType: (0, _utils.validateType)("TSType"),
        extendsType: (0, _utils.validateType)("TSType"),
        trueType: (0, _utils.validateType)("TSType"),
        falseType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInferType", {
      aliases: ["TSType"],
      visitor: ["typeParameter"],
      fields: {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }
    });
    defineType("TSParenthesizedType", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSTypeOperator", {
      aliases: ["TSType"],
      visitor: ["typeAnnotation"],
      fields: {
        operator: (0, _utils.validate)((0, _utils.assertValueType)("string")),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSIndexedAccessType", {
      aliases: ["TSType"],
      visitor: ["objectType", "indexType"],
      fields: {
        objectType: (0, _utils.validateType)("TSType"),
        indexType: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSMappedType", {
      aliases: ["TSType"],
      visitor: ["typeParameter", "nameType", "typeAnnotation"],
      builder: ["typeParameter", "typeAnnotation", "nameType"],
      fields: Object.assign({}, {
        typeParameter: (0, _utils.validateType)("TSTypeParameter")
      }, {
        readonly: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        optional: (0, _utils.validateOptional)((0, _utils.assertOneOf)(true, false, "+", "-")),
        typeAnnotation: (0, _utils.validateOptionalType)("TSType"),
        nameType: (0, _utils.validateOptionalType)("TSType")
      })
    });
    defineType("TSTemplateLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["quasis", "types"],
      fields: {
        quasis: (0, _utils.validateArrayOfType)("TemplateElement"),
        types: {
          validate: (0, _utils.chain)((0, _utils.assertValueType)("array"), (0, _utils.assertEach)((0, _utils.assertNodeType)("TSType")), function(node3, key, val) {
            if (node3.quasis.length !== val.length + 1) {
              throw new TypeError(`Number of ${node3.type} quasis should be exactly one more than the number of types.
Expected ${val.length + 1} quasis but got ${node3.quasis.length}`);
            }
          })
        }
      }
    });
    defineType("TSLiteralType", {
      aliases: ["TSType", "TSBaseType"],
      visitor: ["literal"],
      fields: {
        literal: {
          validate: function() {
            const unaryExpression = (0, _utils.assertNodeType)("NumericLiteral", "BigIntLiteral");
            const unaryOperator = (0, _utils.assertOneOf)("-");
            const literal = (0, _utils.assertNodeType)("NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral");
            function validator(parent, key, node3) {
              if ((0, _is.default)("UnaryExpression", node3)) {
                unaryOperator(node3, "operator", node3.operator);
                unaryExpression(node3, "argument", node3.argument);
              } else {
                literal(parent, key, node3);
              }
            }
            validator.oneOfNodeTypes = ["NumericLiteral", "StringLiteral", "BooleanLiteral", "BigIntLiteral", "TemplateLiteral", "UnaryExpression"];
            return validator;
          }()
        }
      }
    });
    {
      defineType("TSExpressionWithTypeArguments", {
        aliases: ["TSType"],
        visitor: ["expression", "typeParameters"],
        fields: {
          expression: (0, _utils.validateType)("TSEntityName"),
          typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
        }
      });
    }
    defineType("TSInterfaceDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "extends", "body"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        extends: (0, _utils.validateOptional)((0, _utils.arrayOfType)("TSExpressionWithTypeArguments")),
        body: (0, _utils.validateType)("TSInterfaceBody")
      }
    });
    defineType("TSInterfaceBody", {
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("TSTypeElement")
      }
    });
    defineType("TSTypeAliasDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "typeParameters", "typeAnnotation"],
      fields: {
        declare: (0, _utils.validateOptional)(bool),
        id: (0, _utils.validateType)("Identifier"),
        typeParameters: (0, _utils.validateOptionalType)("TSTypeParameterDeclaration"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    });
    defineType("TSInstantiationExpression", {
      aliases: ["Expression"],
      visitor: ["expression", "typeParameters"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation")
      }
    });
    var TSTypeExpression = {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression", "typeAnnotation"],
      fields: {
        expression: (0, _utils.validateType)("Expression"),
        typeAnnotation: (0, _utils.validateType)("TSType")
      }
    };
    defineType("TSAsExpression", TSTypeExpression);
    defineType("TSSatisfiesExpression", TSTypeExpression);
    defineType("TSTypeAssertion", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["typeAnnotation", "expression"],
      fields: {
        typeAnnotation: (0, _utils.validateType)("TSType"),
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSEnumBody", {
      visitor: ["members"],
      fields: {
        members: (0, _utils.validateArrayOfType)("TSEnumMember")
      }
    });
    {
      defineType("TSEnumDeclaration", {
        aliases: ["Statement", "Declaration"],
        visitor: ["id", "members"],
        fields: {
          declare: (0, _utils.validateOptional)(bool),
          const: (0, _utils.validateOptional)(bool),
          id: (0, _utils.validateType)("Identifier"),
          members: (0, _utils.validateArrayOfType)("TSEnumMember"),
          initializer: (0, _utils.validateOptionalType)("Expression"),
          body: (0, _utils.validateOptionalType)("TSEnumBody")
        }
      });
    }
    defineType("TSEnumMember", {
      visitor: ["id", "initializer"],
      fields: {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        initializer: (0, _utils.validateOptionalType)("Expression")
      }
    });
    defineType("TSModuleDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "body"],
      fields: Object.assign({
        kind: {
          validate: (0, _utils.assertOneOf)("global", "module", "namespace")
        },
        declare: (0, _utils.validateOptional)(bool)
      }, {
        global: (0, _utils.validateOptional)(bool)
      }, {
        id: (0, _utils.validateType)("Identifier", "StringLiteral"),
        body: (0, _utils.validateType)("TSModuleBlock", "TSModuleDeclaration")
      })
    });
    defineType("TSModuleBlock", {
      aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
      visitor: ["body"],
      fields: {
        body: (0, _utils.validateArrayOfType)("Statement")
      }
    });
    defineType("TSImportType", {
      aliases: ["TSType"],
      builder: ["argument", "qualifier", "typeParameters"],
      visitor: ["argument", "options", "qualifier", "typeParameters"],
      fields: {
        argument: (0, _utils.validateType)("StringLiteral"),
        qualifier: (0, _utils.validateOptionalType)("TSEntityName"),
        ["typeParameters"]: (0, _utils.validateOptionalType)("TSTypeParameterInstantiation"),
        options: {
          validate: (0, _utils.assertNodeType)("Expression"),
          optional: true
        }
      }
    });
    defineType("TSImportEqualsDeclaration", {
      aliases: ["Statement", "Declaration"],
      visitor: ["id", "moduleReference"],
      fields: Object.assign({}, {
        isExport: (0, _utils.validate)(bool)
      }, {
        id: (0, _utils.validateType)("Identifier"),
        moduleReference: (0, _utils.validateType)("TSEntityName", "TSExternalModuleReference"),
        importKind: {
          validate: (0, _utils.assertOneOf)("type", "value"),
          optional: true
        }
      })
    });
    defineType("TSExternalModuleReference", {
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("StringLiteral")
      }
    });
    defineType("TSNonNullExpression", {
      aliases: ["Expression", "LVal", "PatternLike"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSExportAssignment", {
      aliases: ["Statement"],
      visitor: ["expression"],
      fields: {
        expression: (0, _utils.validateType)("Expression")
      }
    });
    defineType("TSNamespaceExportDeclaration", {
      aliases: ["Statement"],
      visitor: ["id"],
      fields: {
        id: (0, _utils.validateType)("Identifier")
      }
    });
    defineType("TSTypeAnnotation", {
      visitor: ["typeAnnotation"],
      fields: {
        typeAnnotation: {
          validate: (0, _utils.assertNodeType)("TSType")
        }
      }
    });
    defineType("TSTypeParameterInstantiation", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validateArrayOfType)("TSType")
      }
    });
    defineType("TSTypeParameterDeclaration", {
      visitor: ["params"],
      fields: {
        params: (0, _utils.validateArrayOfType)("TSTypeParameter")
      }
    });
    defineType("TSTypeParameter", {
      builder: ["constraint", "default", "name"],
      visitor: ["constraint", "default"],
      fields: {
        name: {
          validate: (0, _utils.assertValueType)("string")
        },
        in: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        out: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        const: {
          validate: (0, _utils.assertValueType)("boolean"),
          optional: true
        },
        constraint: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        },
        default: {
          validate: (0, _utils.assertNodeType)("TSType"),
          optional: true
        }
      }
    });
  }
});

// node_modules/@babel/types/lib/definitions/deprecated-aliases.js
var require_deprecated_aliases = __commonJS({
  "node_modules/@babel/types/lib/definitions/deprecated-aliases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DEPRECATED_ALIASES = void 0;
    var DEPRECATED_ALIASES = exports2.DEPRECATED_ALIASES = {
      ModuleDeclaration: "ImportOrExportDeclaration"
    };
  }
});

// node_modules/@babel/types/lib/definitions/index.js
var require_definitions = __commonJS({
  "node_modules/@babel/types/lib/definitions/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports2, "BUILDER_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.BUILDER_KEYS;
      }
    });
    Object.defineProperty(exports2, "DEPRECATED_ALIASES", {
      enumerable: true,
      get: function() {
        return _deprecatedAliases.DEPRECATED_ALIASES;
      }
    });
    Object.defineProperty(exports2, "DEPRECATED_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.DEPRECATED_KEYS;
      }
    });
    Object.defineProperty(exports2, "FLIPPED_ALIAS_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.FLIPPED_ALIAS_KEYS;
      }
    });
    Object.defineProperty(exports2, "NODE_FIELDS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_FIELDS;
      }
    });
    Object.defineProperty(exports2, "NODE_PARENT_VALIDATIONS", {
      enumerable: true,
      get: function() {
        return _utils.NODE_PARENT_VALIDATIONS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_ALIAS;
      }
    });
    Object.defineProperty(exports2, "PLACEHOLDERS_FLIPPED_ALIAS", {
      enumerable: true,
      get: function() {
        return _placeholders.PLACEHOLDERS_FLIPPED_ALIAS;
      }
    });
    exports2.TYPES = void 0;
    Object.defineProperty(exports2, "VISITOR_KEYS", {
      enumerable: true,
      get: function() {
        return _utils.VISITOR_KEYS;
      }
    });
    require_core();
    require_flow();
    require_jsx();
    require_misc();
    require_experimental();
    require_typescript();
    var _utils = require_utils();
    var _placeholders = require_placeholders();
    var _deprecatedAliases = require_deprecated_aliases();
    Object.keys(_deprecatedAliases.DEPRECATED_ALIASES).forEach((deprecatedAlias) => {
      _utils.FLIPPED_ALIAS_KEYS[deprecatedAlias] = _utils.FLIPPED_ALIAS_KEYS[_deprecatedAliases.DEPRECATED_ALIASES[deprecatedAlias]];
    });
    var TYPES = exports2.TYPES = [].concat(Object.keys(_utils.VISITOR_KEYS), Object.keys(_utils.FLIPPED_ALIAS_KEYS), Object.keys(_utils.DEPRECATED_KEYS));
  }
});

// node_modules/@babel/types/lib/validators/validate.js
var require_validate = __commonJS({
  "node_modules/@babel/types/lib/validators/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = validate;
    exports2.validateChild = validateChild;
    exports2.validateField = validateField;
    exports2.validateInternal = validateInternal;
    var _index = require_definitions();
    function validate(node3, key, val) {
      if (!node3) return;
      const fields = _index.NODE_FIELDS[node3.type];
      if (!fields) return;
      const field = fields[key];
      validateField(node3, key, val, field);
      validateChild(node3, key, val);
    }
    function validateInternal(field, node3, key, val, maybeNode) {
      if (!(field != null && field.validate)) return;
      if (field.optional && val == null) return;
      field.validate(node3, key, val);
      if (maybeNode) {
        var _NODE_PARENT_VALIDATI;
        const type = val.type;
        if (type == null) return;
        (_NODE_PARENT_VALIDATI = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI.call(_index.NODE_PARENT_VALIDATIONS, node3, key, val);
      }
    }
    function validateField(node3, key, val, field) {
      if (!(field != null && field.validate)) return;
      if (field.optional && val == null) return;
      field.validate(node3, key, val);
    }
    function validateChild(node3, key, val) {
      var _NODE_PARENT_VALIDATI2;
      const type = val == null ? void 0 : val.type;
      if (type == null) return;
      (_NODE_PARENT_VALIDATI2 = _index.NODE_PARENT_VALIDATIONS[type]) == null || _NODE_PARENT_VALIDATI2.call(_index.NODE_PARENT_VALIDATIONS, node3, key, val);
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/lowercase.js
var require_lowercase = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/lowercase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.anyTypeAnnotation = anyTypeAnnotation;
    exports2.argumentPlaceholder = argumentPlaceholder;
    exports2.arrayExpression = arrayExpression;
    exports2.arrayPattern = arrayPattern;
    exports2.arrayTypeAnnotation = arrayTypeAnnotation;
    exports2.arrowFunctionExpression = arrowFunctionExpression;
    exports2.assignmentExpression = assignmentExpression;
    exports2.assignmentPattern = assignmentPattern;
    exports2.awaitExpression = awaitExpression;
    exports2.bigIntLiteral = bigIntLiteral;
    exports2.binaryExpression = binaryExpression;
    exports2.bindExpression = bindExpression;
    exports2.blockStatement = blockStatement;
    exports2.booleanLiteral = booleanLiteral;
    exports2.booleanLiteralTypeAnnotation = booleanLiteralTypeAnnotation;
    exports2.booleanTypeAnnotation = booleanTypeAnnotation;
    exports2.breakStatement = breakStatement;
    exports2.callExpression = callExpression;
    exports2.catchClause = catchClause;
    exports2.classAccessorProperty = classAccessorProperty;
    exports2.classBody = classBody;
    exports2.classDeclaration = classDeclaration;
    exports2.classExpression = classExpression;
    exports2.classImplements = classImplements;
    exports2.classMethod = classMethod;
    exports2.classPrivateMethod = classPrivateMethod;
    exports2.classPrivateProperty = classPrivateProperty;
    exports2.classProperty = classProperty;
    exports2.conditionalExpression = conditionalExpression;
    exports2.continueStatement = continueStatement;
    exports2.debuggerStatement = debuggerStatement;
    exports2.decimalLiteral = decimalLiteral;
    exports2.declareClass = declareClass;
    exports2.declareExportAllDeclaration = declareExportAllDeclaration;
    exports2.declareExportDeclaration = declareExportDeclaration;
    exports2.declareFunction = declareFunction;
    exports2.declareInterface = declareInterface;
    exports2.declareModule = declareModule;
    exports2.declareModuleExports = declareModuleExports;
    exports2.declareOpaqueType = declareOpaqueType;
    exports2.declareTypeAlias = declareTypeAlias;
    exports2.declareVariable = declareVariable;
    exports2.declaredPredicate = declaredPredicate;
    exports2.decorator = decorator;
    exports2.directive = directive;
    exports2.directiveLiteral = directiveLiteral;
    exports2.doExpression = doExpression;
    exports2.doWhileStatement = doWhileStatement;
    exports2.emptyStatement = emptyStatement;
    exports2.emptyTypeAnnotation = emptyTypeAnnotation;
    exports2.enumBooleanBody = enumBooleanBody;
    exports2.enumBooleanMember = enumBooleanMember;
    exports2.enumDeclaration = enumDeclaration;
    exports2.enumDefaultedMember = enumDefaultedMember;
    exports2.enumNumberBody = enumNumberBody;
    exports2.enumNumberMember = enumNumberMember;
    exports2.enumStringBody = enumStringBody;
    exports2.enumStringMember = enumStringMember;
    exports2.enumSymbolBody = enumSymbolBody;
    exports2.existsTypeAnnotation = existsTypeAnnotation;
    exports2.exportAllDeclaration = exportAllDeclaration;
    exports2.exportDefaultDeclaration = exportDefaultDeclaration;
    exports2.exportDefaultSpecifier = exportDefaultSpecifier;
    exports2.exportNamedDeclaration = exportNamedDeclaration;
    exports2.exportNamespaceSpecifier = exportNamespaceSpecifier;
    exports2.exportSpecifier = exportSpecifier;
    exports2.expressionStatement = expressionStatement;
    exports2.file = file;
    exports2.forInStatement = forInStatement;
    exports2.forOfStatement = forOfStatement;
    exports2.forStatement = forStatement;
    exports2.functionDeclaration = functionDeclaration;
    exports2.functionExpression = functionExpression;
    exports2.functionTypeAnnotation = functionTypeAnnotation;
    exports2.functionTypeParam = functionTypeParam;
    exports2.genericTypeAnnotation = genericTypeAnnotation;
    exports2.identifier = identifier;
    exports2.ifStatement = ifStatement;
    exports2.import = _import;
    exports2.importAttribute = importAttribute;
    exports2.importDeclaration = importDeclaration;
    exports2.importDefaultSpecifier = importDefaultSpecifier;
    exports2.importExpression = importExpression;
    exports2.importNamespaceSpecifier = importNamespaceSpecifier;
    exports2.importSpecifier = importSpecifier;
    exports2.indexedAccessType = indexedAccessType;
    exports2.inferredPredicate = inferredPredicate;
    exports2.interfaceDeclaration = interfaceDeclaration;
    exports2.interfaceExtends = interfaceExtends;
    exports2.interfaceTypeAnnotation = interfaceTypeAnnotation;
    exports2.interpreterDirective = interpreterDirective;
    exports2.intersectionTypeAnnotation = intersectionTypeAnnotation;
    exports2.jSXAttribute = exports2.jsxAttribute = jsxAttribute;
    exports2.jSXClosingElement = exports2.jsxClosingElement = jsxClosingElement;
    exports2.jSXClosingFragment = exports2.jsxClosingFragment = jsxClosingFragment;
    exports2.jSXElement = exports2.jsxElement = jsxElement;
    exports2.jSXEmptyExpression = exports2.jsxEmptyExpression = jsxEmptyExpression;
    exports2.jSXExpressionContainer = exports2.jsxExpressionContainer = jsxExpressionContainer;
    exports2.jSXFragment = exports2.jsxFragment = jsxFragment;
    exports2.jSXIdentifier = exports2.jsxIdentifier = jsxIdentifier;
    exports2.jSXMemberExpression = exports2.jsxMemberExpression = jsxMemberExpression;
    exports2.jSXNamespacedName = exports2.jsxNamespacedName = jsxNamespacedName;
    exports2.jSXOpeningElement = exports2.jsxOpeningElement = jsxOpeningElement;
    exports2.jSXOpeningFragment = exports2.jsxOpeningFragment = jsxOpeningFragment;
    exports2.jSXSpreadAttribute = exports2.jsxSpreadAttribute = jsxSpreadAttribute;
    exports2.jSXSpreadChild = exports2.jsxSpreadChild = jsxSpreadChild;
    exports2.jSXText = exports2.jsxText = jsxText;
    exports2.labeledStatement = labeledStatement;
    exports2.logicalExpression = logicalExpression;
    exports2.memberExpression = memberExpression;
    exports2.metaProperty = metaProperty;
    exports2.mixedTypeAnnotation = mixedTypeAnnotation;
    exports2.moduleExpression = moduleExpression;
    exports2.newExpression = newExpression;
    exports2.noop = noop2;
    exports2.nullLiteral = nullLiteral;
    exports2.nullLiteralTypeAnnotation = nullLiteralTypeAnnotation;
    exports2.nullableTypeAnnotation = nullableTypeAnnotation;
    exports2.numberLiteral = NumberLiteral;
    exports2.numberLiteralTypeAnnotation = numberLiteralTypeAnnotation;
    exports2.numberTypeAnnotation = numberTypeAnnotation;
    exports2.numericLiteral = numericLiteral;
    exports2.objectExpression = objectExpression;
    exports2.objectMethod = objectMethod;
    exports2.objectPattern = objectPattern;
    exports2.objectProperty = objectProperty;
    exports2.objectTypeAnnotation = objectTypeAnnotation;
    exports2.objectTypeCallProperty = objectTypeCallProperty;
    exports2.objectTypeIndexer = objectTypeIndexer;
    exports2.objectTypeInternalSlot = objectTypeInternalSlot;
    exports2.objectTypeProperty = objectTypeProperty;
    exports2.objectTypeSpreadProperty = objectTypeSpreadProperty;
    exports2.opaqueType = opaqueType;
    exports2.optionalCallExpression = optionalCallExpression;
    exports2.optionalIndexedAccessType = optionalIndexedAccessType;
    exports2.optionalMemberExpression = optionalMemberExpression;
    exports2.parenthesizedExpression = parenthesizedExpression;
    exports2.pipelineBareFunction = pipelineBareFunction;
    exports2.pipelinePrimaryTopicReference = pipelinePrimaryTopicReference;
    exports2.pipelineTopicExpression = pipelineTopicExpression;
    exports2.placeholder = placeholder;
    exports2.privateName = privateName;
    exports2.program = program;
    exports2.qualifiedTypeIdentifier = qualifiedTypeIdentifier;
    exports2.recordExpression = recordExpression;
    exports2.regExpLiteral = regExpLiteral;
    exports2.regexLiteral = RegexLiteral;
    exports2.restElement = restElement;
    exports2.restProperty = RestProperty;
    exports2.returnStatement = returnStatement;
    exports2.sequenceExpression = sequenceExpression;
    exports2.spreadElement = spreadElement;
    exports2.spreadProperty = SpreadProperty;
    exports2.staticBlock = staticBlock;
    exports2.stringLiteral = stringLiteral;
    exports2.stringLiteralTypeAnnotation = stringLiteralTypeAnnotation;
    exports2.stringTypeAnnotation = stringTypeAnnotation;
    exports2.super = _super;
    exports2.switchCase = switchCase;
    exports2.switchStatement = switchStatement;
    exports2.symbolTypeAnnotation = symbolTypeAnnotation;
    exports2.taggedTemplateExpression = taggedTemplateExpression;
    exports2.templateElement = templateElement;
    exports2.templateLiteral = templateLiteral;
    exports2.thisExpression = thisExpression;
    exports2.thisTypeAnnotation = thisTypeAnnotation;
    exports2.throwStatement = throwStatement;
    exports2.topicReference = topicReference;
    exports2.tryStatement = tryStatement;
    exports2.tSAnyKeyword = exports2.tsAnyKeyword = tsAnyKeyword;
    exports2.tSArrayType = exports2.tsArrayType = tsArrayType;
    exports2.tSAsExpression = exports2.tsAsExpression = tsAsExpression;
    exports2.tSBigIntKeyword = exports2.tsBigIntKeyword = tsBigIntKeyword;
    exports2.tSBooleanKeyword = exports2.tsBooleanKeyword = tsBooleanKeyword;
    exports2.tSCallSignatureDeclaration = exports2.tsCallSignatureDeclaration = tsCallSignatureDeclaration;
    exports2.tSConditionalType = exports2.tsConditionalType = tsConditionalType;
    exports2.tSConstructSignatureDeclaration = exports2.tsConstructSignatureDeclaration = tsConstructSignatureDeclaration;
    exports2.tSConstructorType = exports2.tsConstructorType = tsConstructorType;
    exports2.tSDeclareFunction = exports2.tsDeclareFunction = tsDeclareFunction;
    exports2.tSDeclareMethod = exports2.tsDeclareMethod = tsDeclareMethod;
    exports2.tSEnumBody = exports2.tsEnumBody = tsEnumBody;
    exports2.tSEnumDeclaration = exports2.tsEnumDeclaration = tsEnumDeclaration;
    exports2.tSEnumMember = exports2.tsEnumMember = tsEnumMember;
    exports2.tSExportAssignment = exports2.tsExportAssignment = tsExportAssignment;
    exports2.tSExpressionWithTypeArguments = exports2.tsExpressionWithTypeArguments = tsExpressionWithTypeArguments;
    exports2.tSExternalModuleReference = exports2.tsExternalModuleReference = tsExternalModuleReference;
    exports2.tSFunctionType = exports2.tsFunctionType = tsFunctionType;
    exports2.tSImportEqualsDeclaration = exports2.tsImportEqualsDeclaration = tsImportEqualsDeclaration;
    exports2.tSImportType = exports2.tsImportType = tsImportType;
    exports2.tSIndexSignature = exports2.tsIndexSignature = tsIndexSignature;
    exports2.tSIndexedAccessType = exports2.tsIndexedAccessType = tsIndexedAccessType;
    exports2.tSInferType = exports2.tsInferType = tsInferType;
    exports2.tSInstantiationExpression = exports2.tsInstantiationExpression = tsInstantiationExpression;
    exports2.tSInterfaceBody = exports2.tsInterfaceBody = tsInterfaceBody;
    exports2.tSInterfaceDeclaration = exports2.tsInterfaceDeclaration = tsInterfaceDeclaration;
    exports2.tSIntersectionType = exports2.tsIntersectionType = tsIntersectionType;
    exports2.tSIntrinsicKeyword = exports2.tsIntrinsicKeyword = tsIntrinsicKeyword;
    exports2.tSLiteralType = exports2.tsLiteralType = tsLiteralType;
    exports2.tSMappedType = exports2.tsMappedType = tsMappedType;
    exports2.tSMethodSignature = exports2.tsMethodSignature = tsMethodSignature;
    exports2.tSModuleBlock = exports2.tsModuleBlock = tsModuleBlock;
    exports2.tSModuleDeclaration = exports2.tsModuleDeclaration = tsModuleDeclaration;
    exports2.tSNamedTupleMember = exports2.tsNamedTupleMember = tsNamedTupleMember;
    exports2.tSNamespaceExportDeclaration = exports2.tsNamespaceExportDeclaration = tsNamespaceExportDeclaration;
    exports2.tSNeverKeyword = exports2.tsNeverKeyword = tsNeverKeyword;
    exports2.tSNonNullExpression = exports2.tsNonNullExpression = tsNonNullExpression;
    exports2.tSNullKeyword = exports2.tsNullKeyword = tsNullKeyword;
    exports2.tSNumberKeyword = exports2.tsNumberKeyword = tsNumberKeyword;
    exports2.tSObjectKeyword = exports2.tsObjectKeyword = tsObjectKeyword;
    exports2.tSOptionalType = exports2.tsOptionalType = tsOptionalType;
    exports2.tSParameterProperty = exports2.tsParameterProperty = tsParameterProperty;
    exports2.tSParenthesizedType = exports2.tsParenthesizedType = tsParenthesizedType;
    exports2.tSPropertySignature = exports2.tsPropertySignature = tsPropertySignature;
    exports2.tSQualifiedName = exports2.tsQualifiedName = tsQualifiedName;
    exports2.tSRestType = exports2.tsRestType = tsRestType;
    exports2.tSSatisfiesExpression = exports2.tsSatisfiesExpression = tsSatisfiesExpression;
    exports2.tSStringKeyword = exports2.tsStringKeyword = tsStringKeyword;
    exports2.tSSymbolKeyword = exports2.tsSymbolKeyword = tsSymbolKeyword;
    exports2.tSTemplateLiteralType = exports2.tsTemplateLiteralType = tsTemplateLiteralType;
    exports2.tSThisType = exports2.tsThisType = tsThisType;
    exports2.tSTupleType = exports2.tsTupleType = tsTupleType;
    exports2.tSTypeAliasDeclaration = exports2.tsTypeAliasDeclaration = tsTypeAliasDeclaration;
    exports2.tSTypeAnnotation = exports2.tsTypeAnnotation = tsTypeAnnotation;
    exports2.tSTypeAssertion = exports2.tsTypeAssertion = tsTypeAssertion;
    exports2.tSTypeLiteral = exports2.tsTypeLiteral = tsTypeLiteral;
    exports2.tSTypeOperator = exports2.tsTypeOperator = tsTypeOperator;
    exports2.tSTypeParameter = exports2.tsTypeParameter = tsTypeParameter;
    exports2.tSTypeParameterDeclaration = exports2.tsTypeParameterDeclaration = tsTypeParameterDeclaration;
    exports2.tSTypeParameterInstantiation = exports2.tsTypeParameterInstantiation = tsTypeParameterInstantiation;
    exports2.tSTypePredicate = exports2.tsTypePredicate = tsTypePredicate;
    exports2.tSTypeQuery = exports2.tsTypeQuery = tsTypeQuery;
    exports2.tSTypeReference = exports2.tsTypeReference = tsTypeReference;
    exports2.tSUndefinedKeyword = exports2.tsUndefinedKeyword = tsUndefinedKeyword;
    exports2.tSUnionType = exports2.tsUnionType = tsUnionType;
    exports2.tSUnknownKeyword = exports2.tsUnknownKeyword = tsUnknownKeyword;
    exports2.tSVoidKeyword = exports2.tsVoidKeyword = tsVoidKeyword;
    exports2.tupleExpression = tupleExpression;
    exports2.tupleTypeAnnotation = tupleTypeAnnotation;
    exports2.typeAlias = typeAlias;
    exports2.typeAnnotation = typeAnnotation;
    exports2.typeCastExpression = typeCastExpression;
    exports2.typeParameter = typeParameter;
    exports2.typeParameterDeclaration = typeParameterDeclaration;
    exports2.typeParameterInstantiation = typeParameterInstantiation;
    exports2.typeofTypeAnnotation = typeofTypeAnnotation;
    exports2.unaryExpression = unaryExpression;
    exports2.unionTypeAnnotation = unionTypeAnnotation;
    exports2.updateExpression = updateExpression;
    exports2.v8IntrinsicIdentifier = v8IntrinsicIdentifier;
    exports2.variableDeclaration = variableDeclaration;
    exports2.variableDeclarator = variableDeclarator;
    exports2.variance = variance;
    exports2.voidTypeAnnotation = voidTypeAnnotation;
    exports2.whileStatement = whileStatement;
    exports2.withStatement = withStatement;
    exports2.yieldExpression = yieldExpression;
    var _validate = require_validate();
    var _deprecationWarning = require_deprecationWarning();
    var utils2 = require_utils();
    var {
      validateInternal: validate
    } = _validate;
    var {
      NODE_FIELDS
    } = utils2;
    function arrayExpression(elements = []) {
      const node3 = {
        type: "ArrayExpression",
        elements
      };
      const defs = NODE_FIELDS.ArrayExpression;
      validate(defs.elements, node3, "elements", elements, 1);
      return node3;
    }
    function assignmentExpression(operator, left, right) {
      const node3 = {
        type: "AssignmentExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.AssignmentExpression;
      validate(defs.operator, node3, "operator", operator);
      validate(defs.left, node3, "left", left, 1);
      validate(defs.right, node3, "right", right, 1);
      return node3;
    }
    function binaryExpression(operator, left, right) {
      const node3 = {
        type: "BinaryExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.BinaryExpression;
      validate(defs.operator, node3, "operator", operator);
      validate(defs.left, node3, "left", left, 1);
      validate(defs.right, node3, "right", right, 1);
      return node3;
    }
    function interpreterDirective(value2) {
      const node3 = {
        type: "InterpreterDirective",
        value: value2
      };
      const defs = NODE_FIELDS.InterpreterDirective;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function directive(value2) {
      const node3 = {
        type: "Directive",
        value: value2
      };
      const defs = NODE_FIELDS.Directive;
      validate(defs.value, node3, "value", value2, 1);
      return node3;
    }
    function directiveLiteral(value2) {
      const node3 = {
        type: "DirectiveLiteral",
        value: value2
      };
      const defs = NODE_FIELDS.DirectiveLiteral;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function blockStatement(body, directives = []) {
      const node3 = {
        type: "BlockStatement",
        body,
        directives
      };
      const defs = NODE_FIELDS.BlockStatement;
      validate(defs.body, node3, "body", body, 1);
      validate(defs.directives, node3, "directives", directives, 1);
      return node3;
    }
    function breakStatement(label = null) {
      const node3 = {
        type: "BreakStatement",
        label
      };
      const defs = NODE_FIELDS.BreakStatement;
      validate(defs.label, node3, "label", label, 1);
      return node3;
    }
    function callExpression(callee, _arguments) {
      const node3 = {
        type: "CallExpression",
        callee,
        arguments: _arguments
      };
      const defs = NODE_FIELDS.CallExpression;
      validate(defs.callee, node3, "callee", callee, 1);
      validate(defs.arguments, node3, "arguments", _arguments, 1);
      return node3;
    }
    function catchClause(param = null, body) {
      const node3 = {
        type: "CatchClause",
        param,
        body
      };
      const defs = NODE_FIELDS.CatchClause;
      validate(defs.param, node3, "param", param, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function conditionalExpression(test, consequent, alternate) {
      const node3 = {
        type: "ConditionalExpression",
        test,
        consequent,
        alternate
      };
      const defs = NODE_FIELDS.ConditionalExpression;
      validate(defs.test, node3, "test", test, 1);
      validate(defs.consequent, node3, "consequent", consequent, 1);
      validate(defs.alternate, node3, "alternate", alternate, 1);
      return node3;
    }
    function continueStatement(label = null) {
      const node3 = {
        type: "ContinueStatement",
        label
      };
      const defs = NODE_FIELDS.ContinueStatement;
      validate(defs.label, node3, "label", label, 1);
      return node3;
    }
    function debuggerStatement() {
      return {
        type: "DebuggerStatement"
      };
    }
    function doWhileStatement(test, body) {
      const node3 = {
        type: "DoWhileStatement",
        test,
        body
      };
      const defs = NODE_FIELDS.DoWhileStatement;
      validate(defs.test, node3, "test", test, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function emptyStatement() {
      return {
        type: "EmptyStatement"
      };
    }
    function expressionStatement(expression) {
      const node3 = {
        type: "ExpressionStatement",
        expression
      };
      const defs = NODE_FIELDS.ExpressionStatement;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function file(program2, comments = null, tokens = null) {
      const node3 = {
        type: "File",
        program: program2,
        comments,
        tokens
      };
      const defs = NODE_FIELDS.File;
      validate(defs.program, node3, "program", program2, 1);
      validate(defs.comments, node3, "comments", comments, 1);
      validate(defs.tokens, node3, "tokens", tokens);
      return node3;
    }
    function forInStatement(left, right, body) {
      const node3 = {
        type: "ForInStatement",
        left,
        right,
        body
      };
      const defs = NODE_FIELDS.ForInStatement;
      validate(defs.left, node3, "left", left, 1);
      validate(defs.right, node3, "right", right, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function forStatement(init2 = null, test = null, update = null, body) {
      const node3 = {
        type: "ForStatement",
        init: init2,
        test,
        update,
        body
      };
      const defs = NODE_FIELDS.ForStatement;
      validate(defs.init, node3, "init", init2, 1);
      validate(defs.test, node3, "test", test, 1);
      validate(defs.update, node3, "update", update, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function functionDeclaration(id3 = null, params, body, generator = false, async2 = false) {
      const node3 = {
        type: "FunctionDeclaration",
        id: id3,
        params,
        body,
        generator,
        async: async2
      };
      const defs = NODE_FIELDS.FunctionDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.params, node3, "params", params, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.generator, node3, "generator", generator);
      validate(defs.async, node3, "async", async2);
      return node3;
    }
    function functionExpression(id3 = null, params, body, generator = false, async2 = false) {
      const node3 = {
        type: "FunctionExpression",
        id: id3,
        params,
        body,
        generator,
        async: async2
      };
      const defs = NODE_FIELDS.FunctionExpression;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.params, node3, "params", params, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.generator, node3, "generator", generator);
      validate(defs.async, node3, "async", async2);
      return node3;
    }
    function identifier(name2) {
      const node3 = {
        type: "Identifier",
        name: name2
      };
      const defs = NODE_FIELDS.Identifier;
      validate(defs.name, node3, "name", name2);
      return node3;
    }
    function ifStatement(test, consequent, alternate = null) {
      const node3 = {
        type: "IfStatement",
        test,
        consequent,
        alternate
      };
      const defs = NODE_FIELDS.IfStatement;
      validate(defs.test, node3, "test", test, 1);
      validate(defs.consequent, node3, "consequent", consequent, 1);
      validate(defs.alternate, node3, "alternate", alternate, 1);
      return node3;
    }
    function labeledStatement(label, body) {
      const node3 = {
        type: "LabeledStatement",
        label,
        body
      };
      const defs = NODE_FIELDS.LabeledStatement;
      validate(defs.label, node3, "label", label, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function stringLiteral(value2) {
      const node3 = {
        type: "StringLiteral",
        value: value2
      };
      const defs = NODE_FIELDS.StringLiteral;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function numericLiteral(value2) {
      const node3 = {
        type: "NumericLiteral",
        value: value2
      };
      const defs = NODE_FIELDS.NumericLiteral;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function nullLiteral() {
      return {
        type: "NullLiteral"
      };
    }
    function booleanLiteral(value2) {
      const node3 = {
        type: "BooleanLiteral",
        value: value2
      };
      const defs = NODE_FIELDS.BooleanLiteral;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function regExpLiteral(pattern2, flags = "") {
      const node3 = {
        type: "RegExpLiteral",
        pattern: pattern2,
        flags
      };
      const defs = NODE_FIELDS.RegExpLiteral;
      validate(defs.pattern, node3, "pattern", pattern2);
      validate(defs.flags, node3, "flags", flags);
      return node3;
    }
    function logicalExpression(operator, left, right) {
      const node3 = {
        type: "LogicalExpression",
        operator,
        left,
        right
      };
      const defs = NODE_FIELDS.LogicalExpression;
      validate(defs.operator, node3, "operator", operator);
      validate(defs.left, node3, "left", left, 1);
      validate(defs.right, node3, "right", right, 1);
      return node3;
    }
    function memberExpression(object2, property, computed = false, optional = null) {
      const node3 = {
        type: "MemberExpression",
        object: object2,
        property,
        computed,
        optional
      };
      const defs = NODE_FIELDS.MemberExpression;
      validate(defs.object, node3, "object", object2, 1);
      validate(defs.property, node3, "property", property, 1);
      validate(defs.computed, node3, "computed", computed);
      validate(defs.optional, node3, "optional", optional);
      return node3;
    }
    function newExpression(callee, _arguments) {
      const node3 = {
        type: "NewExpression",
        callee,
        arguments: _arguments
      };
      const defs = NODE_FIELDS.NewExpression;
      validate(defs.callee, node3, "callee", callee, 1);
      validate(defs.arguments, node3, "arguments", _arguments, 1);
      return node3;
    }
    function program(body, directives = [], sourceType = "script", interpreter = null) {
      const node3 = {
        type: "Program",
        body,
        directives,
        sourceType,
        interpreter
      };
      const defs = NODE_FIELDS.Program;
      validate(defs.body, node3, "body", body, 1);
      validate(defs.directives, node3, "directives", directives, 1);
      validate(defs.sourceType, node3, "sourceType", sourceType);
      validate(defs.interpreter, node3, "interpreter", interpreter, 1);
      return node3;
    }
    function objectExpression(properties) {
      const node3 = {
        type: "ObjectExpression",
        properties
      };
      const defs = NODE_FIELDS.ObjectExpression;
      validate(defs.properties, node3, "properties", properties, 1);
      return node3;
    }
    function objectMethod(kind = "method", key, params, body, computed = false, generator = false, async2 = false) {
      const node3 = {
        type: "ObjectMethod",
        kind,
        key,
        params,
        body,
        computed,
        generator,
        async: async2
      };
      const defs = NODE_FIELDS.ObjectMethod;
      validate(defs.kind, node3, "kind", kind);
      validate(defs.key, node3, "key", key, 1);
      validate(defs.params, node3, "params", params, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.computed, node3, "computed", computed);
      validate(defs.generator, node3, "generator", generator);
      validate(defs.async, node3, "async", async2);
      return node3;
    }
    function objectProperty(key, value2, computed = false, shorthand = false, decorators = null) {
      const node3 = {
        type: "ObjectProperty",
        key,
        value: value2,
        computed,
        shorthand,
        decorators
      };
      const defs = NODE_FIELDS.ObjectProperty;
      validate(defs.key, node3, "key", key, 1);
      validate(defs.value, node3, "value", value2, 1);
      validate(defs.computed, node3, "computed", computed);
      validate(defs.shorthand, node3, "shorthand", shorthand);
      validate(defs.decorators, node3, "decorators", decorators, 1);
      return node3;
    }
    function restElement(argument) {
      const node3 = {
        type: "RestElement",
        argument
      };
      const defs = NODE_FIELDS.RestElement;
      validate(defs.argument, node3, "argument", argument, 1);
      return node3;
    }
    function returnStatement(argument = null) {
      const node3 = {
        type: "ReturnStatement",
        argument
      };
      const defs = NODE_FIELDS.ReturnStatement;
      validate(defs.argument, node3, "argument", argument, 1);
      return node3;
    }
    function sequenceExpression(expressions) {
      const node3 = {
        type: "SequenceExpression",
        expressions
      };
      const defs = NODE_FIELDS.SequenceExpression;
      validate(defs.expressions, node3, "expressions", expressions, 1);
      return node3;
    }
    function parenthesizedExpression(expression) {
      const node3 = {
        type: "ParenthesizedExpression",
        expression
      };
      const defs = NODE_FIELDS.ParenthesizedExpression;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function switchCase(test = null, consequent) {
      const node3 = {
        type: "SwitchCase",
        test,
        consequent
      };
      const defs = NODE_FIELDS.SwitchCase;
      validate(defs.test, node3, "test", test, 1);
      validate(defs.consequent, node3, "consequent", consequent, 1);
      return node3;
    }
    function switchStatement(discriminant, cases) {
      const node3 = {
        type: "SwitchStatement",
        discriminant,
        cases
      };
      const defs = NODE_FIELDS.SwitchStatement;
      validate(defs.discriminant, node3, "discriminant", discriminant, 1);
      validate(defs.cases, node3, "cases", cases, 1);
      return node3;
    }
    function thisExpression() {
      return {
        type: "ThisExpression"
      };
    }
    function throwStatement(argument) {
      const node3 = {
        type: "ThrowStatement",
        argument
      };
      const defs = NODE_FIELDS.ThrowStatement;
      validate(defs.argument, node3, "argument", argument, 1);
      return node3;
    }
    function tryStatement(block, handler = null, finalizer = null) {
      const node3 = {
        type: "TryStatement",
        block,
        handler,
        finalizer
      };
      const defs = NODE_FIELDS.TryStatement;
      validate(defs.block, node3, "block", block, 1);
      validate(defs.handler, node3, "handler", handler, 1);
      validate(defs.finalizer, node3, "finalizer", finalizer, 1);
      return node3;
    }
    function unaryExpression(operator, argument, prefix = true) {
      const node3 = {
        type: "UnaryExpression",
        operator,
        argument,
        prefix
      };
      const defs = NODE_FIELDS.UnaryExpression;
      validate(defs.operator, node3, "operator", operator);
      validate(defs.argument, node3, "argument", argument, 1);
      validate(defs.prefix, node3, "prefix", prefix);
      return node3;
    }
    function updateExpression(operator, argument, prefix = false) {
      const node3 = {
        type: "UpdateExpression",
        operator,
        argument,
        prefix
      };
      const defs = NODE_FIELDS.UpdateExpression;
      validate(defs.operator, node3, "operator", operator);
      validate(defs.argument, node3, "argument", argument, 1);
      validate(defs.prefix, node3, "prefix", prefix);
      return node3;
    }
    function variableDeclaration(kind, declarations) {
      const node3 = {
        type: "VariableDeclaration",
        kind,
        declarations
      };
      const defs = NODE_FIELDS.VariableDeclaration;
      validate(defs.kind, node3, "kind", kind);
      validate(defs.declarations, node3, "declarations", declarations, 1);
      return node3;
    }
    function variableDeclarator(id3, init2 = null) {
      const node3 = {
        type: "VariableDeclarator",
        id: id3,
        init: init2
      };
      const defs = NODE_FIELDS.VariableDeclarator;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.init, node3, "init", init2, 1);
      return node3;
    }
    function whileStatement(test, body) {
      const node3 = {
        type: "WhileStatement",
        test,
        body
      };
      const defs = NODE_FIELDS.WhileStatement;
      validate(defs.test, node3, "test", test, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function withStatement(object2, body) {
      const node3 = {
        type: "WithStatement",
        object: object2,
        body
      };
      const defs = NODE_FIELDS.WithStatement;
      validate(defs.object, node3, "object", object2, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function assignmentPattern(left, right) {
      const node3 = {
        type: "AssignmentPattern",
        left,
        right
      };
      const defs = NODE_FIELDS.AssignmentPattern;
      validate(defs.left, node3, "left", left, 1);
      validate(defs.right, node3, "right", right, 1);
      return node3;
    }
    function arrayPattern(elements) {
      const node3 = {
        type: "ArrayPattern",
        elements
      };
      const defs = NODE_FIELDS.ArrayPattern;
      validate(defs.elements, node3, "elements", elements, 1);
      return node3;
    }
    function arrowFunctionExpression(params, body, async2 = false) {
      const node3 = {
        type: "ArrowFunctionExpression",
        params,
        body,
        async: async2,
        expression: null
      };
      const defs = NODE_FIELDS.ArrowFunctionExpression;
      validate(defs.params, node3, "params", params, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.async, node3, "async", async2);
      return node3;
    }
    function classBody(body) {
      const node3 = {
        type: "ClassBody",
        body
      };
      const defs = NODE_FIELDS.ClassBody;
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function classExpression(id3 = null, superClass = null, body, decorators = null) {
      const node3 = {
        type: "ClassExpression",
        id: id3,
        superClass,
        body,
        decorators
      };
      const defs = NODE_FIELDS.ClassExpression;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.superClass, node3, "superClass", superClass, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.decorators, node3, "decorators", decorators, 1);
      return node3;
    }
    function classDeclaration(id3 = null, superClass = null, body, decorators = null) {
      const node3 = {
        type: "ClassDeclaration",
        id: id3,
        superClass,
        body,
        decorators
      };
      const defs = NODE_FIELDS.ClassDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.superClass, node3, "superClass", superClass, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.decorators, node3, "decorators", decorators, 1);
      return node3;
    }
    function exportAllDeclaration(source) {
      const node3 = {
        type: "ExportAllDeclaration",
        source
      };
      const defs = NODE_FIELDS.ExportAllDeclaration;
      validate(defs.source, node3, "source", source, 1);
      return node3;
    }
    function exportDefaultDeclaration(declaration) {
      const node3 = {
        type: "ExportDefaultDeclaration",
        declaration
      };
      const defs = NODE_FIELDS.ExportDefaultDeclaration;
      validate(defs.declaration, node3, "declaration", declaration, 1);
      return node3;
    }
    function exportNamedDeclaration(declaration = null, specifiers = [], source = null) {
      const node3 = {
        type: "ExportNamedDeclaration",
        declaration,
        specifiers,
        source
      };
      const defs = NODE_FIELDS.ExportNamedDeclaration;
      validate(defs.declaration, node3, "declaration", declaration, 1);
      validate(defs.specifiers, node3, "specifiers", specifiers, 1);
      validate(defs.source, node3, "source", source, 1);
      return node3;
    }
    function exportSpecifier(local, exported) {
      const node3 = {
        type: "ExportSpecifier",
        local,
        exported
      };
      const defs = NODE_FIELDS.ExportSpecifier;
      validate(defs.local, node3, "local", local, 1);
      validate(defs.exported, node3, "exported", exported, 1);
      return node3;
    }
    function forOfStatement(left, right, body, _await = false) {
      const node3 = {
        type: "ForOfStatement",
        left,
        right,
        body,
        await: _await
      };
      const defs = NODE_FIELDS.ForOfStatement;
      validate(defs.left, node3, "left", left, 1);
      validate(defs.right, node3, "right", right, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.await, node3, "await", _await);
      return node3;
    }
    function importDeclaration(specifiers, source) {
      const node3 = {
        type: "ImportDeclaration",
        specifiers,
        source
      };
      const defs = NODE_FIELDS.ImportDeclaration;
      validate(defs.specifiers, node3, "specifiers", specifiers, 1);
      validate(defs.source, node3, "source", source, 1);
      return node3;
    }
    function importDefaultSpecifier(local) {
      const node3 = {
        type: "ImportDefaultSpecifier",
        local
      };
      const defs = NODE_FIELDS.ImportDefaultSpecifier;
      validate(defs.local, node3, "local", local, 1);
      return node3;
    }
    function importNamespaceSpecifier(local) {
      const node3 = {
        type: "ImportNamespaceSpecifier",
        local
      };
      const defs = NODE_FIELDS.ImportNamespaceSpecifier;
      validate(defs.local, node3, "local", local, 1);
      return node3;
    }
    function importSpecifier(local, imported) {
      const node3 = {
        type: "ImportSpecifier",
        local,
        imported
      };
      const defs = NODE_FIELDS.ImportSpecifier;
      validate(defs.local, node3, "local", local, 1);
      validate(defs.imported, node3, "imported", imported, 1);
      return node3;
    }
    function importExpression(source, options2 = null) {
      const node3 = {
        type: "ImportExpression",
        source,
        options: options2
      };
      const defs = NODE_FIELDS.ImportExpression;
      validate(defs.source, node3, "source", source, 1);
      validate(defs.options, node3, "options", options2, 1);
      return node3;
    }
    function metaProperty(meta, property) {
      const node3 = {
        type: "MetaProperty",
        meta,
        property
      };
      const defs = NODE_FIELDS.MetaProperty;
      validate(defs.meta, node3, "meta", meta, 1);
      validate(defs.property, node3, "property", property, 1);
      return node3;
    }
    function classMethod(kind = "method", key, params, body, computed = false, _static = false, generator = false, async2 = false) {
      const node3 = {
        type: "ClassMethod",
        kind,
        key,
        params,
        body,
        computed,
        static: _static,
        generator,
        async: async2
      };
      const defs = NODE_FIELDS.ClassMethod;
      validate(defs.kind, node3, "kind", kind);
      validate(defs.key, node3, "key", key, 1);
      validate(defs.params, node3, "params", params, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.computed, node3, "computed", computed);
      validate(defs.static, node3, "static", _static);
      validate(defs.generator, node3, "generator", generator);
      validate(defs.async, node3, "async", async2);
      return node3;
    }
    function objectPattern(properties) {
      const node3 = {
        type: "ObjectPattern",
        properties
      };
      const defs = NODE_FIELDS.ObjectPattern;
      validate(defs.properties, node3, "properties", properties, 1);
      return node3;
    }
    function spreadElement(argument) {
      const node3 = {
        type: "SpreadElement",
        argument
      };
      const defs = NODE_FIELDS.SpreadElement;
      validate(defs.argument, node3, "argument", argument, 1);
      return node3;
    }
    function _super() {
      return {
        type: "Super"
      };
    }
    function taggedTemplateExpression(tag3, quasi) {
      const node3 = {
        type: "TaggedTemplateExpression",
        tag: tag3,
        quasi
      };
      const defs = NODE_FIELDS.TaggedTemplateExpression;
      validate(defs.tag, node3, "tag", tag3, 1);
      validate(defs.quasi, node3, "quasi", quasi, 1);
      return node3;
    }
    function templateElement(value2, tail = false) {
      const node3 = {
        type: "TemplateElement",
        value: value2,
        tail
      };
      const defs = NODE_FIELDS.TemplateElement;
      validate(defs.value, node3, "value", value2);
      validate(defs.tail, node3, "tail", tail);
      return node3;
    }
    function templateLiteral(quasis, expressions) {
      const node3 = {
        type: "TemplateLiteral",
        quasis,
        expressions
      };
      const defs = NODE_FIELDS.TemplateLiteral;
      validate(defs.quasis, node3, "quasis", quasis, 1);
      validate(defs.expressions, node3, "expressions", expressions, 1);
      return node3;
    }
    function yieldExpression(argument = null, delegate = false) {
      const node3 = {
        type: "YieldExpression",
        argument,
        delegate
      };
      const defs = NODE_FIELDS.YieldExpression;
      validate(defs.argument, node3, "argument", argument, 1);
      validate(defs.delegate, node3, "delegate", delegate);
      return node3;
    }
    function awaitExpression(argument) {
      const node3 = {
        type: "AwaitExpression",
        argument
      };
      const defs = NODE_FIELDS.AwaitExpression;
      validate(defs.argument, node3, "argument", argument, 1);
      return node3;
    }
    function _import() {
      return {
        type: "Import"
      };
    }
    function bigIntLiteral(value2) {
      const node3 = {
        type: "BigIntLiteral",
        value: value2
      };
      const defs = NODE_FIELDS.BigIntLiteral;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function exportNamespaceSpecifier(exported) {
      const node3 = {
        type: "ExportNamespaceSpecifier",
        exported
      };
      const defs = NODE_FIELDS.ExportNamespaceSpecifier;
      validate(defs.exported, node3, "exported", exported, 1);
      return node3;
    }
    function optionalMemberExpression(object2, property, computed = false, optional) {
      const node3 = {
        type: "OptionalMemberExpression",
        object: object2,
        property,
        computed,
        optional
      };
      const defs = NODE_FIELDS.OptionalMemberExpression;
      validate(defs.object, node3, "object", object2, 1);
      validate(defs.property, node3, "property", property, 1);
      validate(defs.computed, node3, "computed", computed);
      validate(defs.optional, node3, "optional", optional);
      return node3;
    }
    function optionalCallExpression(callee, _arguments, optional) {
      const node3 = {
        type: "OptionalCallExpression",
        callee,
        arguments: _arguments,
        optional
      };
      const defs = NODE_FIELDS.OptionalCallExpression;
      validate(defs.callee, node3, "callee", callee, 1);
      validate(defs.arguments, node3, "arguments", _arguments, 1);
      validate(defs.optional, node3, "optional", optional);
      return node3;
    }
    function classProperty(key, value2 = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      const node3 = {
        type: "ClassProperty",
        key,
        value: value2,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      };
      const defs = NODE_FIELDS.ClassProperty;
      validate(defs.key, node3, "key", key, 1);
      validate(defs.value, node3, "value", value2, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.decorators, node3, "decorators", decorators, 1);
      validate(defs.computed, node3, "computed", computed);
      validate(defs.static, node3, "static", _static);
      return node3;
    }
    function classAccessorProperty(key, value2 = null, typeAnnotation2 = null, decorators = null, computed = false, _static = false) {
      const node3 = {
        type: "ClassAccessorProperty",
        key,
        value: value2,
        typeAnnotation: typeAnnotation2,
        decorators,
        computed,
        static: _static
      };
      const defs = NODE_FIELDS.ClassAccessorProperty;
      validate(defs.key, node3, "key", key, 1);
      validate(defs.value, node3, "value", value2, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.decorators, node3, "decorators", decorators, 1);
      validate(defs.computed, node3, "computed", computed);
      validate(defs.static, node3, "static", _static);
      return node3;
    }
    function classPrivateProperty(key, value2 = null, decorators = null, _static = false) {
      const node3 = {
        type: "ClassPrivateProperty",
        key,
        value: value2,
        decorators,
        static: _static
      };
      const defs = NODE_FIELDS.ClassPrivateProperty;
      validate(defs.key, node3, "key", key, 1);
      validate(defs.value, node3, "value", value2, 1);
      validate(defs.decorators, node3, "decorators", decorators, 1);
      validate(defs.static, node3, "static", _static);
      return node3;
    }
    function classPrivateMethod(kind = "method", key, params, body, _static = false) {
      const node3 = {
        type: "ClassPrivateMethod",
        kind,
        key,
        params,
        body,
        static: _static
      };
      const defs = NODE_FIELDS.ClassPrivateMethod;
      validate(defs.kind, node3, "kind", kind);
      validate(defs.key, node3, "key", key, 1);
      validate(defs.params, node3, "params", params, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.static, node3, "static", _static);
      return node3;
    }
    function privateName(id3) {
      const node3 = {
        type: "PrivateName",
        id: id3
      };
      const defs = NODE_FIELDS.PrivateName;
      validate(defs.id, node3, "id", id3, 1);
      return node3;
    }
    function staticBlock(body) {
      const node3 = {
        type: "StaticBlock",
        body
      };
      const defs = NODE_FIELDS.StaticBlock;
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function anyTypeAnnotation() {
      return {
        type: "AnyTypeAnnotation"
      };
    }
    function arrayTypeAnnotation(elementType) {
      const node3 = {
        type: "ArrayTypeAnnotation",
        elementType
      };
      const defs = NODE_FIELDS.ArrayTypeAnnotation;
      validate(defs.elementType, node3, "elementType", elementType, 1);
      return node3;
    }
    function booleanTypeAnnotation() {
      return {
        type: "BooleanTypeAnnotation"
      };
    }
    function booleanLiteralTypeAnnotation(value2) {
      const node3 = {
        type: "BooleanLiteralTypeAnnotation",
        value: value2
      };
      const defs = NODE_FIELDS.BooleanLiteralTypeAnnotation;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function nullLiteralTypeAnnotation() {
      return {
        type: "NullLiteralTypeAnnotation"
      };
    }
    function classImplements(id3, typeParameters = null) {
      const node3 = {
        type: "ClassImplements",
        id: id3,
        typeParameters
      };
      const defs = NODE_FIELDS.ClassImplements;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      return node3;
    }
    function declareClass(id3, typeParameters = null, _extends = null, body) {
      const node3 = {
        type: "DeclareClass",
        id: id3,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.DeclareClass;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.extends, node3, "extends", _extends, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function declareFunction(id3) {
      const node3 = {
        type: "DeclareFunction",
        id: id3
      };
      const defs = NODE_FIELDS.DeclareFunction;
      validate(defs.id, node3, "id", id3, 1);
      return node3;
    }
    function declareInterface(id3, typeParameters = null, _extends = null, body) {
      const node3 = {
        type: "DeclareInterface",
        id: id3,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.DeclareInterface;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.extends, node3, "extends", _extends, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function declareModule(id3, body, kind = null) {
      const node3 = {
        type: "DeclareModule",
        id: id3,
        body,
        kind
      };
      const defs = NODE_FIELDS.DeclareModule;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.body, node3, "body", body, 1);
      validate(defs.kind, node3, "kind", kind);
      return node3;
    }
    function declareModuleExports(typeAnnotation2) {
      const node3 = {
        type: "DeclareModuleExports",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.DeclareModuleExports;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function declareTypeAlias(id3, typeParameters = null, right) {
      const node3 = {
        type: "DeclareTypeAlias",
        id: id3,
        typeParameters,
        right
      };
      const defs = NODE_FIELDS.DeclareTypeAlias;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.right, node3, "right", right, 1);
      return node3;
    }
    function declareOpaqueType(id3, typeParameters = null, supertype = null) {
      const node3 = {
        type: "DeclareOpaqueType",
        id: id3,
        typeParameters,
        supertype
      };
      const defs = NODE_FIELDS.DeclareOpaqueType;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.supertype, node3, "supertype", supertype, 1);
      return node3;
    }
    function declareVariable(id3) {
      const node3 = {
        type: "DeclareVariable",
        id: id3
      };
      const defs = NODE_FIELDS.DeclareVariable;
      validate(defs.id, node3, "id", id3, 1);
      return node3;
    }
    function declareExportDeclaration(declaration = null, specifiers = null, source = null, attributes = null) {
      const node3 = {
        type: "DeclareExportDeclaration",
        declaration,
        specifiers,
        source,
        attributes
      };
      const defs = NODE_FIELDS.DeclareExportDeclaration;
      validate(defs.declaration, node3, "declaration", declaration, 1);
      validate(defs.specifiers, node3, "specifiers", specifiers, 1);
      validate(defs.source, node3, "source", source, 1);
      validate(defs.attributes, node3, "attributes", attributes, 1);
      return node3;
    }
    function declareExportAllDeclaration(source, attributes = null) {
      const node3 = {
        type: "DeclareExportAllDeclaration",
        source,
        attributes
      };
      const defs = NODE_FIELDS.DeclareExportAllDeclaration;
      validate(defs.source, node3, "source", source, 1);
      validate(defs.attributes, node3, "attributes", attributes, 1);
      return node3;
    }
    function declaredPredicate(value2) {
      const node3 = {
        type: "DeclaredPredicate",
        value: value2
      };
      const defs = NODE_FIELDS.DeclaredPredicate;
      validate(defs.value, node3, "value", value2, 1);
      return node3;
    }
    function existsTypeAnnotation() {
      return {
        type: "ExistsTypeAnnotation"
      };
    }
    function functionTypeAnnotation(typeParameters = null, params, rest = null, returnType) {
      const node3 = {
        type: "FunctionTypeAnnotation",
        typeParameters,
        params,
        rest,
        returnType
      };
      const defs = NODE_FIELDS.FunctionTypeAnnotation;
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.params, node3, "params", params, 1);
      validate(defs.rest, node3, "rest", rest, 1);
      validate(defs.returnType, node3, "returnType", returnType, 1);
      return node3;
    }
    function functionTypeParam(name2 = null, typeAnnotation2) {
      const node3 = {
        type: "FunctionTypeParam",
        name: name2,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.FunctionTypeParam;
      validate(defs.name, node3, "name", name2, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function genericTypeAnnotation(id3, typeParameters = null) {
      const node3 = {
        type: "GenericTypeAnnotation",
        id: id3,
        typeParameters
      };
      const defs = NODE_FIELDS.GenericTypeAnnotation;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      return node3;
    }
    function inferredPredicate() {
      return {
        type: "InferredPredicate"
      };
    }
    function interfaceExtends(id3, typeParameters = null) {
      const node3 = {
        type: "InterfaceExtends",
        id: id3,
        typeParameters
      };
      const defs = NODE_FIELDS.InterfaceExtends;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      return node3;
    }
    function interfaceDeclaration(id3, typeParameters = null, _extends = null, body) {
      const node3 = {
        type: "InterfaceDeclaration",
        id: id3,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.InterfaceDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.extends, node3, "extends", _extends, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function interfaceTypeAnnotation(_extends = null, body) {
      const node3 = {
        type: "InterfaceTypeAnnotation",
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.InterfaceTypeAnnotation;
      validate(defs.extends, node3, "extends", _extends, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function intersectionTypeAnnotation(types3) {
      const node3 = {
        type: "IntersectionTypeAnnotation",
        types: types3
      };
      const defs = NODE_FIELDS.IntersectionTypeAnnotation;
      validate(defs.types, node3, "types", types3, 1);
      return node3;
    }
    function mixedTypeAnnotation() {
      return {
        type: "MixedTypeAnnotation"
      };
    }
    function emptyTypeAnnotation() {
      return {
        type: "EmptyTypeAnnotation"
      };
    }
    function nullableTypeAnnotation(typeAnnotation2) {
      const node3 = {
        type: "NullableTypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.NullableTypeAnnotation;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function numberLiteralTypeAnnotation(value2) {
      const node3 = {
        type: "NumberLiteralTypeAnnotation",
        value: value2
      };
      const defs = NODE_FIELDS.NumberLiteralTypeAnnotation;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function numberTypeAnnotation() {
      return {
        type: "NumberTypeAnnotation"
      };
    }
    function objectTypeAnnotation(properties, indexers = [], callProperties = [], internalSlots = [], exact = false) {
      const node3 = {
        type: "ObjectTypeAnnotation",
        properties,
        indexers,
        callProperties,
        internalSlots,
        exact
      };
      const defs = NODE_FIELDS.ObjectTypeAnnotation;
      validate(defs.properties, node3, "properties", properties, 1);
      validate(defs.indexers, node3, "indexers", indexers, 1);
      validate(defs.callProperties, node3, "callProperties", callProperties, 1);
      validate(defs.internalSlots, node3, "internalSlots", internalSlots, 1);
      validate(defs.exact, node3, "exact", exact);
      return node3;
    }
    function objectTypeInternalSlot(id3, value2, optional, _static, method) {
      const node3 = {
        type: "ObjectTypeInternalSlot",
        id: id3,
        value: value2,
        optional,
        static: _static,
        method
      };
      const defs = NODE_FIELDS.ObjectTypeInternalSlot;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.value, node3, "value", value2, 1);
      validate(defs.optional, node3, "optional", optional);
      validate(defs.static, node3, "static", _static);
      validate(defs.method, node3, "method", method);
      return node3;
    }
    function objectTypeCallProperty(value2) {
      const node3 = {
        type: "ObjectTypeCallProperty",
        value: value2,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeCallProperty;
      validate(defs.value, node3, "value", value2, 1);
      return node3;
    }
    function objectTypeIndexer(id3 = null, key, value2, variance2 = null) {
      const node3 = {
        type: "ObjectTypeIndexer",
        id: id3,
        key,
        value: value2,
        variance: variance2,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeIndexer;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.key, node3, "key", key, 1);
      validate(defs.value, node3, "value", value2, 1);
      validate(defs.variance, node3, "variance", variance2, 1);
      return node3;
    }
    function objectTypeProperty(key, value2, variance2 = null) {
      const node3 = {
        type: "ObjectTypeProperty",
        key,
        value: value2,
        variance: variance2,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null
      };
      const defs = NODE_FIELDS.ObjectTypeProperty;
      validate(defs.key, node3, "key", key, 1);
      validate(defs.value, node3, "value", value2, 1);
      validate(defs.variance, node3, "variance", variance2, 1);
      return node3;
    }
    function objectTypeSpreadProperty(argument) {
      const node3 = {
        type: "ObjectTypeSpreadProperty",
        argument
      };
      const defs = NODE_FIELDS.ObjectTypeSpreadProperty;
      validate(defs.argument, node3, "argument", argument, 1);
      return node3;
    }
    function opaqueType(id3, typeParameters = null, supertype = null, impltype) {
      const node3 = {
        type: "OpaqueType",
        id: id3,
        typeParameters,
        supertype,
        impltype
      };
      const defs = NODE_FIELDS.OpaqueType;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.supertype, node3, "supertype", supertype, 1);
      validate(defs.impltype, node3, "impltype", impltype, 1);
      return node3;
    }
    function qualifiedTypeIdentifier(id3, qualification) {
      const node3 = {
        type: "QualifiedTypeIdentifier",
        id: id3,
        qualification
      };
      const defs = NODE_FIELDS.QualifiedTypeIdentifier;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.qualification, node3, "qualification", qualification, 1);
      return node3;
    }
    function stringLiteralTypeAnnotation(value2) {
      const node3 = {
        type: "StringLiteralTypeAnnotation",
        value: value2
      };
      const defs = NODE_FIELDS.StringLiteralTypeAnnotation;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function stringTypeAnnotation() {
      return {
        type: "StringTypeAnnotation"
      };
    }
    function symbolTypeAnnotation() {
      return {
        type: "SymbolTypeAnnotation"
      };
    }
    function thisTypeAnnotation() {
      return {
        type: "ThisTypeAnnotation"
      };
    }
    function tupleTypeAnnotation(types3) {
      const node3 = {
        type: "TupleTypeAnnotation",
        types: types3
      };
      const defs = NODE_FIELDS.TupleTypeAnnotation;
      validate(defs.types, node3, "types", types3, 1);
      return node3;
    }
    function typeofTypeAnnotation(argument) {
      const node3 = {
        type: "TypeofTypeAnnotation",
        argument
      };
      const defs = NODE_FIELDS.TypeofTypeAnnotation;
      validate(defs.argument, node3, "argument", argument, 1);
      return node3;
    }
    function typeAlias(id3, typeParameters = null, right) {
      const node3 = {
        type: "TypeAlias",
        id: id3,
        typeParameters,
        right
      };
      const defs = NODE_FIELDS.TypeAlias;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.right, node3, "right", right, 1);
      return node3;
    }
    function typeAnnotation(typeAnnotation2) {
      const node3 = {
        type: "TypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TypeAnnotation;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function typeCastExpression(expression, typeAnnotation2) {
      const node3 = {
        type: "TypeCastExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TypeCastExpression;
      validate(defs.expression, node3, "expression", expression, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function typeParameter(bound = null, _default = null, variance2 = null) {
      const node3 = {
        type: "TypeParameter",
        bound,
        default: _default,
        variance: variance2,
        name: null
      };
      const defs = NODE_FIELDS.TypeParameter;
      validate(defs.bound, node3, "bound", bound, 1);
      validate(defs.default, node3, "default", _default, 1);
      validate(defs.variance, node3, "variance", variance2, 1);
      return node3;
    }
    function typeParameterDeclaration(params) {
      const node3 = {
        type: "TypeParameterDeclaration",
        params
      };
      const defs = NODE_FIELDS.TypeParameterDeclaration;
      validate(defs.params, node3, "params", params, 1);
      return node3;
    }
    function typeParameterInstantiation(params) {
      const node3 = {
        type: "TypeParameterInstantiation",
        params
      };
      const defs = NODE_FIELDS.TypeParameterInstantiation;
      validate(defs.params, node3, "params", params, 1);
      return node3;
    }
    function unionTypeAnnotation(types3) {
      const node3 = {
        type: "UnionTypeAnnotation",
        types: types3
      };
      const defs = NODE_FIELDS.UnionTypeAnnotation;
      validate(defs.types, node3, "types", types3, 1);
      return node3;
    }
    function variance(kind) {
      const node3 = {
        type: "Variance",
        kind
      };
      const defs = NODE_FIELDS.Variance;
      validate(defs.kind, node3, "kind", kind);
      return node3;
    }
    function voidTypeAnnotation() {
      return {
        type: "VoidTypeAnnotation"
      };
    }
    function enumDeclaration(id3, body) {
      const node3 = {
        type: "EnumDeclaration",
        id: id3,
        body
      };
      const defs = NODE_FIELDS.EnumDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function enumBooleanBody(members) {
      const node3 = {
        type: "EnumBooleanBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumBooleanBody;
      validate(defs.members, node3, "members", members, 1);
      return node3;
    }
    function enumNumberBody(members) {
      const node3 = {
        type: "EnumNumberBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumNumberBody;
      validate(defs.members, node3, "members", members, 1);
      return node3;
    }
    function enumStringBody(members) {
      const node3 = {
        type: "EnumStringBody",
        members,
        explicitType: null,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumStringBody;
      validate(defs.members, node3, "members", members, 1);
      return node3;
    }
    function enumSymbolBody(members) {
      const node3 = {
        type: "EnumSymbolBody",
        members,
        hasUnknownMembers: null
      };
      const defs = NODE_FIELDS.EnumSymbolBody;
      validate(defs.members, node3, "members", members, 1);
      return node3;
    }
    function enumBooleanMember(id3) {
      const node3 = {
        type: "EnumBooleanMember",
        id: id3,
        init: null
      };
      const defs = NODE_FIELDS.EnumBooleanMember;
      validate(defs.id, node3, "id", id3, 1);
      return node3;
    }
    function enumNumberMember(id3, init2) {
      const node3 = {
        type: "EnumNumberMember",
        id: id3,
        init: init2
      };
      const defs = NODE_FIELDS.EnumNumberMember;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.init, node3, "init", init2, 1);
      return node3;
    }
    function enumStringMember(id3, init2) {
      const node3 = {
        type: "EnumStringMember",
        id: id3,
        init: init2
      };
      const defs = NODE_FIELDS.EnumStringMember;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.init, node3, "init", init2, 1);
      return node3;
    }
    function enumDefaultedMember(id3) {
      const node3 = {
        type: "EnumDefaultedMember",
        id: id3
      };
      const defs = NODE_FIELDS.EnumDefaultedMember;
      validate(defs.id, node3, "id", id3, 1);
      return node3;
    }
    function indexedAccessType(objectType, indexType) {
      const node3 = {
        type: "IndexedAccessType",
        objectType,
        indexType
      };
      const defs = NODE_FIELDS.IndexedAccessType;
      validate(defs.objectType, node3, "objectType", objectType, 1);
      validate(defs.indexType, node3, "indexType", indexType, 1);
      return node3;
    }
    function optionalIndexedAccessType(objectType, indexType) {
      const node3 = {
        type: "OptionalIndexedAccessType",
        objectType,
        indexType,
        optional: null
      };
      const defs = NODE_FIELDS.OptionalIndexedAccessType;
      validate(defs.objectType, node3, "objectType", objectType, 1);
      validate(defs.indexType, node3, "indexType", indexType, 1);
      return node3;
    }
    function jsxAttribute(name2, value2 = null) {
      const node3 = {
        type: "JSXAttribute",
        name: name2,
        value: value2
      };
      const defs = NODE_FIELDS.JSXAttribute;
      validate(defs.name, node3, "name", name2, 1);
      validate(defs.value, node3, "value", value2, 1);
      return node3;
    }
    function jsxClosingElement(name2) {
      const node3 = {
        type: "JSXClosingElement",
        name: name2
      };
      const defs = NODE_FIELDS.JSXClosingElement;
      validate(defs.name, node3, "name", name2, 1);
      return node3;
    }
    function jsxElement(openingElement, closingElement = null, children, selfClosing = null) {
      const node3 = {
        type: "JSXElement",
        openingElement,
        closingElement,
        children,
        selfClosing
      };
      const defs = NODE_FIELDS.JSXElement;
      validate(defs.openingElement, node3, "openingElement", openingElement, 1);
      validate(defs.closingElement, node3, "closingElement", closingElement, 1);
      validate(defs.children, node3, "children", children, 1);
      validate(defs.selfClosing, node3, "selfClosing", selfClosing);
      return node3;
    }
    function jsxEmptyExpression() {
      return {
        type: "JSXEmptyExpression"
      };
    }
    function jsxExpressionContainer(expression) {
      const node3 = {
        type: "JSXExpressionContainer",
        expression
      };
      const defs = NODE_FIELDS.JSXExpressionContainer;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function jsxSpreadChild(expression) {
      const node3 = {
        type: "JSXSpreadChild",
        expression
      };
      const defs = NODE_FIELDS.JSXSpreadChild;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function jsxIdentifier(name2) {
      const node3 = {
        type: "JSXIdentifier",
        name: name2
      };
      const defs = NODE_FIELDS.JSXIdentifier;
      validate(defs.name, node3, "name", name2);
      return node3;
    }
    function jsxMemberExpression(object2, property) {
      const node3 = {
        type: "JSXMemberExpression",
        object: object2,
        property
      };
      const defs = NODE_FIELDS.JSXMemberExpression;
      validate(defs.object, node3, "object", object2, 1);
      validate(defs.property, node3, "property", property, 1);
      return node3;
    }
    function jsxNamespacedName(namespace2, name2) {
      const node3 = {
        type: "JSXNamespacedName",
        namespace: namespace2,
        name: name2
      };
      const defs = NODE_FIELDS.JSXNamespacedName;
      validate(defs.namespace, node3, "namespace", namespace2, 1);
      validate(defs.name, node3, "name", name2, 1);
      return node3;
    }
    function jsxOpeningElement(name2, attributes, selfClosing = false) {
      const node3 = {
        type: "JSXOpeningElement",
        name: name2,
        attributes,
        selfClosing
      };
      const defs = NODE_FIELDS.JSXOpeningElement;
      validate(defs.name, node3, "name", name2, 1);
      validate(defs.attributes, node3, "attributes", attributes, 1);
      validate(defs.selfClosing, node3, "selfClosing", selfClosing);
      return node3;
    }
    function jsxSpreadAttribute(argument) {
      const node3 = {
        type: "JSXSpreadAttribute",
        argument
      };
      const defs = NODE_FIELDS.JSXSpreadAttribute;
      validate(defs.argument, node3, "argument", argument, 1);
      return node3;
    }
    function jsxText(value2) {
      const node3 = {
        type: "JSXText",
        value: value2
      };
      const defs = NODE_FIELDS.JSXText;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function jsxFragment(openingFragment, closingFragment, children) {
      const node3 = {
        type: "JSXFragment",
        openingFragment,
        closingFragment,
        children
      };
      const defs = NODE_FIELDS.JSXFragment;
      validate(defs.openingFragment, node3, "openingFragment", openingFragment, 1);
      validate(defs.closingFragment, node3, "closingFragment", closingFragment, 1);
      validate(defs.children, node3, "children", children, 1);
      return node3;
    }
    function jsxOpeningFragment() {
      return {
        type: "JSXOpeningFragment"
      };
    }
    function jsxClosingFragment() {
      return {
        type: "JSXClosingFragment"
      };
    }
    function noop2() {
      return {
        type: "Noop"
      };
    }
    function placeholder(expectedNode, name2) {
      const node3 = {
        type: "Placeholder",
        expectedNode,
        name: name2
      };
      const defs = NODE_FIELDS.Placeholder;
      validate(defs.expectedNode, node3, "expectedNode", expectedNode);
      validate(defs.name, node3, "name", name2, 1);
      return node3;
    }
    function v8IntrinsicIdentifier(name2) {
      const node3 = {
        type: "V8IntrinsicIdentifier",
        name: name2
      };
      const defs = NODE_FIELDS.V8IntrinsicIdentifier;
      validate(defs.name, node3, "name", name2);
      return node3;
    }
    function argumentPlaceholder() {
      return {
        type: "ArgumentPlaceholder"
      };
    }
    function bindExpression(object2, callee) {
      const node3 = {
        type: "BindExpression",
        object: object2,
        callee
      };
      const defs = NODE_FIELDS.BindExpression;
      validate(defs.object, node3, "object", object2, 1);
      validate(defs.callee, node3, "callee", callee, 1);
      return node3;
    }
    function importAttribute(key, value2) {
      const node3 = {
        type: "ImportAttribute",
        key,
        value: value2
      };
      const defs = NODE_FIELDS.ImportAttribute;
      validate(defs.key, node3, "key", key, 1);
      validate(defs.value, node3, "value", value2, 1);
      return node3;
    }
    function decorator(expression) {
      const node3 = {
        type: "Decorator",
        expression
      };
      const defs = NODE_FIELDS.Decorator;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function doExpression(body, async2 = false) {
      const node3 = {
        type: "DoExpression",
        body,
        async: async2
      };
      const defs = NODE_FIELDS.DoExpression;
      validate(defs.body, node3, "body", body, 1);
      validate(defs.async, node3, "async", async2);
      return node3;
    }
    function exportDefaultSpecifier(exported) {
      const node3 = {
        type: "ExportDefaultSpecifier",
        exported
      };
      const defs = NODE_FIELDS.ExportDefaultSpecifier;
      validate(defs.exported, node3, "exported", exported, 1);
      return node3;
    }
    function recordExpression(properties) {
      const node3 = {
        type: "RecordExpression",
        properties
      };
      const defs = NODE_FIELDS.RecordExpression;
      validate(defs.properties, node3, "properties", properties, 1);
      return node3;
    }
    function tupleExpression(elements = []) {
      const node3 = {
        type: "TupleExpression",
        elements
      };
      const defs = NODE_FIELDS.TupleExpression;
      validate(defs.elements, node3, "elements", elements, 1);
      return node3;
    }
    function decimalLiteral(value2) {
      const node3 = {
        type: "DecimalLiteral",
        value: value2
      };
      const defs = NODE_FIELDS.DecimalLiteral;
      validate(defs.value, node3, "value", value2);
      return node3;
    }
    function moduleExpression(body) {
      const node3 = {
        type: "ModuleExpression",
        body
      };
      const defs = NODE_FIELDS.ModuleExpression;
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function topicReference() {
      return {
        type: "TopicReference"
      };
    }
    function pipelineTopicExpression(expression) {
      const node3 = {
        type: "PipelineTopicExpression",
        expression
      };
      const defs = NODE_FIELDS.PipelineTopicExpression;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function pipelineBareFunction(callee) {
      const node3 = {
        type: "PipelineBareFunction",
        callee
      };
      const defs = NODE_FIELDS.PipelineBareFunction;
      validate(defs.callee, node3, "callee", callee, 1);
      return node3;
    }
    function pipelinePrimaryTopicReference() {
      return {
        type: "PipelinePrimaryTopicReference"
      };
    }
    function tsParameterProperty(parameter) {
      const node3 = {
        type: "TSParameterProperty",
        parameter
      };
      const defs = NODE_FIELDS.TSParameterProperty;
      validate(defs.parameter, node3, "parameter", parameter, 1);
      return node3;
    }
    function tsDeclareFunction(id3 = null, typeParameters = null, params, returnType = null) {
      const node3 = {
        type: "TSDeclareFunction",
        id: id3,
        typeParameters,
        params,
        returnType
      };
      const defs = NODE_FIELDS.TSDeclareFunction;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.params, node3, "params", params, 1);
      validate(defs.returnType, node3, "returnType", returnType, 1);
      return node3;
    }
    function tsDeclareMethod(decorators = null, key, typeParameters = null, params, returnType = null) {
      const node3 = {
        type: "TSDeclareMethod",
        decorators,
        key,
        typeParameters,
        params,
        returnType
      };
      const defs = NODE_FIELDS.TSDeclareMethod;
      validate(defs.decorators, node3, "decorators", decorators, 1);
      validate(defs.key, node3, "key", key, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.params, node3, "params", params, 1);
      validate(defs.returnType, node3, "returnType", returnType, 1);
      return node3;
    }
    function tsQualifiedName(left, right) {
      const node3 = {
        type: "TSQualifiedName",
        left,
        right
      };
      const defs = NODE_FIELDS.TSQualifiedName;
      validate(defs.left, node3, "left", left, 1);
      validate(defs.right, node3, "right", right, 1);
      return node3;
    }
    function tsCallSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node3 = {
        type: "TSCallSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSCallSignatureDeclaration;
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node3, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsConstructSignatureDeclaration(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node3 = {
        type: "TSConstructSignatureDeclaration",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSConstructSignatureDeclaration;
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node3, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsPropertySignature(key, typeAnnotation2 = null) {
      const node3 = {
        type: "TSPropertySignature",
        key,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSPropertySignature;
      validate(defs.key, node3, "key", key, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsMethodSignature(key, typeParameters = null, parameters, typeAnnotation2 = null) {
      const node3 = {
        type: "TSMethodSignature",
        key,
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2,
        kind: null
      };
      const defs = NODE_FIELDS.TSMethodSignature;
      validate(defs.key, node3, "key", key, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node3, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsIndexSignature(parameters, typeAnnotation2 = null) {
      const node3 = {
        type: "TSIndexSignature",
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSIndexSignature;
      validate(defs.parameters, node3, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsAnyKeyword() {
      return {
        type: "TSAnyKeyword"
      };
    }
    function tsBooleanKeyword() {
      return {
        type: "TSBooleanKeyword"
      };
    }
    function tsBigIntKeyword() {
      return {
        type: "TSBigIntKeyword"
      };
    }
    function tsIntrinsicKeyword() {
      return {
        type: "TSIntrinsicKeyword"
      };
    }
    function tsNeverKeyword() {
      return {
        type: "TSNeverKeyword"
      };
    }
    function tsNullKeyword() {
      return {
        type: "TSNullKeyword"
      };
    }
    function tsNumberKeyword() {
      return {
        type: "TSNumberKeyword"
      };
    }
    function tsObjectKeyword() {
      return {
        type: "TSObjectKeyword"
      };
    }
    function tsStringKeyword() {
      return {
        type: "TSStringKeyword"
      };
    }
    function tsSymbolKeyword() {
      return {
        type: "TSSymbolKeyword"
      };
    }
    function tsUndefinedKeyword() {
      return {
        type: "TSUndefinedKeyword"
      };
    }
    function tsUnknownKeyword() {
      return {
        type: "TSUnknownKeyword"
      };
    }
    function tsVoidKeyword() {
      return {
        type: "TSVoidKeyword"
      };
    }
    function tsThisType() {
      return {
        type: "TSThisType"
      };
    }
    function tsFunctionType(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node3 = {
        type: "TSFunctionType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSFunctionType;
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node3, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsConstructorType(typeParameters = null, parameters, typeAnnotation2 = null) {
      const node3 = {
        type: "TSConstructorType",
        typeParameters,
        parameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSConstructorType;
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.parameters, node3, "parameters", parameters, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsTypeReference(typeName, typeParameters = null) {
      const node3 = {
        type: "TSTypeReference",
        typeName,
        typeParameters
      };
      const defs = NODE_FIELDS.TSTypeReference;
      validate(defs.typeName, node3, "typeName", typeName, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      return node3;
    }
    function tsTypePredicate(parameterName, typeAnnotation2 = null, asserts = null) {
      const node3 = {
        type: "TSTypePredicate",
        parameterName,
        typeAnnotation: typeAnnotation2,
        asserts
      };
      const defs = NODE_FIELDS.TSTypePredicate;
      validate(defs.parameterName, node3, "parameterName", parameterName, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.asserts, node3, "asserts", asserts);
      return node3;
    }
    function tsTypeQuery(exprName, typeParameters = null) {
      const node3 = {
        type: "TSTypeQuery",
        exprName,
        typeParameters
      };
      const defs = NODE_FIELDS.TSTypeQuery;
      validate(defs.exprName, node3, "exprName", exprName, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      return node3;
    }
    function tsTypeLiteral(members) {
      const node3 = {
        type: "TSTypeLiteral",
        members
      };
      const defs = NODE_FIELDS.TSTypeLiteral;
      validate(defs.members, node3, "members", members, 1);
      return node3;
    }
    function tsArrayType(elementType) {
      const node3 = {
        type: "TSArrayType",
        elementType
      };
      const defs = NODE_FIELDS.TSArrayType;
      validate(defs.elementType, node3, "elementType", elementType, 1);
      return node3;
    }
    function tsTupleType(elementTypes) {
      const node3 = {
        type: "TSTupleType",
        elementTypes
      };
      const defs = NODE_FIELDS.TSTupleType;
      validate(defs.elementTypes, node3, "elementTypes", elementTypes, 1);
      return node3;
    }
    function tsOptionalType(typeAnnotation2) {
      const node3 = {
        type: "TSOptionalType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSOptionalType;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsRestType(typeAnnotation2) {
      const node3 = {
        type: "TSRestType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSRestType;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsNamedTupleMember(label, elementType, optional = false) {
      const node3 = {
        type: "TSNamedTupleMember",
        label,
        elementType,
        optional
      };
      const defs = NODE_FIELDS.TSNamedTupleMember;
      validate(defs.label, node3, "label", label, 1);
      validate(defs.elementType, node3, "elementType", elementType, 1);
      validate(defs.optional, node3, "optional", optional);
      return node3;
    }
    function tsUnionType(types3) {
      const node3 = {
        type: "TSUnionType",
        types: types3
      };
      const defs = NODE_FIELDS.TSUnionType;
      validate(defs.types, node3, "types", types3, 1);
      return node3;
    }
    function tsIntersectionType(types3) {
      const node3 = {
        type: "TSIntersectionType",
        types: types3
      };
      const defs = NODE_FIELDS.TSIntersectionType;
      validate(defs.types, node3, "types", types3, 1);
      return node3;
    }
    function tsConditionalType(checkType, extendsType, trueType, falseType) {
      const node3 = {
        type: "TSConditionalType",
        checkType,
        extendsType,
        trueType,
        falseType
      };
      const defs = NODE_FIELDS.TSConditionalType;
      validate(defs.checkType, node3, "checkType", checkType, 1);
      validate(defs.extendsType, node3, "extendsType", extendsType, 1);
      validate(defs.trueType, node3, "trueType", trueType, 1);
      validate(defs.falseType, node3, "falseType", falseType, 1);
      return node3;
    }
    function tsInferType(typeParameter2) {
      const node3 = {
        type: "TSInferType",
        typeParameter: typeParameter2
      };
      const defs = NODE_FIELDS.TSInferType;
      validate(defs.typeParameter, node3, "typeParameter", typeParameter2, 1);
      return node3;
    }
    function tsParenthesizedType(typeAnnotation2) {
      const node3 = {
        type: "TSParenthesizedType",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSParenthesizedType;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsTypeOperator(typeAnnotation2) {
      const node3 = {
        type: "TSTypeOperator",
        typeAnnotation: typeAnnotation2,
        operator: null
      };
      const defs = NODE_FIELDS.TSTypeOperator;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsIndexedAccessType(objectType, indexType) {
      const node3 = {
        type: "TSIndexedAccessType",
        objectType,
        indexType
      };
      const defs = NODE_FIELDS.TSIndexedAccessType;
      validate(defs.objectType, node3, "objectType", objectType, 1);
      validate(defs.indexType, node3, "indexType", indexType, 1);
      return node3;
    }
    function tsMappedType(typeParameter2, typeAnnotation2 = null, nameType = null) {
      const node3 = {
        type: "TSMappedType",
        typeParameter: typeParameter2,
        typeAnnotation: typeAnnotation2,
        nameType
      };
      const defs = NODE_FIELDS.TSMappedType;
      validate(defs.typeParameter, node3, "typeParameter", typeParameter2, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.nameType, node3, "nameType", nameType, 1);
      return node3;
    }
    function tsTemplateLiteralType(quasis, types3) {
      const node3 = {
        type: "TSTemplateLiteralType",
        quasis,
        types: types3
      };
      const defs = NODE_FIELDS.TSTemplateLiteralType;
      validate(defs.quasis, node3, "quasis", quasis, 1);
      validate(defs.types, node3, "types", types3, 1);
      return node3;
    }
    function tsLiteralType(literal) {
      const node3 = {
        type: "TSLiteralType",
        literal
      };
      const defs = NODE_FIELDS.TSLiteralType;
      validate(defs.literal, node3, "literal", literal, 1);
      return node3;
    }
    function tsExpressionWithTypeArguments(expression, typeParameters = null) {
      const node3 = {
        type: "TSExpressionWithTypeArguments",
        expression,
        typeParameters
      };
      const defs = NODE_FIELDS.TSExpressionWithTypeArguments;
      validate(defs.expression, node3, "expression", expression, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      return node3;
    }
    function tsInterfaceDeclaration(id3, typeParameters = null, _extends = null, body) {
      const node3 = {
        type: "TSInterfaceDeclaration",
        id: id3,
        typeParameters,
        extends: _extends,
        body
      };
      const defs = NODE_FIELDS.TSInterfaceDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.extends, node3, "extends", _extends, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function tsInterfaceBody(body) {
      const node3 = {
        type: "TSInterfaceBody",
        body
      };
      const defs = NODE_FIELDS.TSInterfaceBody;
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function tsTypeAliasDeclaration(id3, typeParameters = null, typeAnnotation2) {
      const node3 = {
        type: "TSTypeAliasDeclaration",
        id: id3,
        typeParameters,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSTypeAliasDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsInstantiationExpression(expression, typeParameters = null) {
      const node3 = {
        type: "TSInstantiationExpression",
        expression,
        typeParameters
      };
      const defs = NODE_FIELDS.TSInstantiationExpression;
      validate(defs.expression, node3, "expression", expression, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      return node3;
    }
    function tsAsExpression(expression, typeAnnotation2) {
      const node3 = {
        type: "TSAsExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSAsExpression;
      validate(defs.expression, node3, "expression", expression, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsSatisfiesExpression(expression, typeAnnotation2) {
      const node3 = {
        type: "TSSatisfiesExpression",
        expression,
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSSatisfiesExpression;
      validate(defs.expression, node3, "expression", expression, 1);
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsTypeAssertion(typeAnnotation2, expression) {
      const node3 = {
        type: "TSTypeAssertion",
        typeAnnotation: typeAnnotation2,
        expression
      };
      const defs = NODE_FIELDS.TSTypeAssertion;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function tsEnumBody(members) {
      const node3 = {
        type: "TSEnumBody",
        members
      };
      const defs = NODE_FIELDS.TSEnumBody;
      validate(defs.members, node3, "members", members, 1);
      return node3;
    }
    function tsEnumDeclaration(id3, members) {
      const node3 = {
        type: "TSEnumDeclaration",
        id: id3,
        members
      };
      const defs = NODE_FIELDS.TSEnumDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.members, node3, "members", members, 1);
      return node3;
    }
    function tsEnumMember(id3, initializer = null) {
      const node3 = {
        type: "TSEnumMember",
        id: id3,
        initializer
      };
      const defs = NODE_FIELDS.TSEnumMember;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.initializer, node3, "initializer", initializer, 1);
      return node3;
    }
    function tsModuleDeclaration(id3, body) {
      const node3 = {
        type: "TSModuleDeclaration",
        id: id3,
        body,
        kind: null
      };
      const defs = NODE_FIELDS.TSModuleDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function tsModuleBlock(body) {
      const node3 = {
        type: "TSModuleBlock",
        body
      };
      const defs = NODE_FIELDS.TSModuleBlock;
      validate(defs.body, node3, "body", body, 1);
      return node3;
    }
    function tsImportType(argument, qualifier = null, typeParameters = null) {
      const node3 = {
        type: "TSImportType",
        argument,
        qualifier,
        typeParameters
      };
      const defs = NODE_FIELDS.TSImportType;
      validate(defs.argument, node3, "argument", argument, 1);
      validate(defs.qualifier, node3, "qualifier", qualifier, 1);
      validate(defs.typeParameters, node3, "typeParameters", typeParameters, 1);
      return node3;
    }
    function tsImportEqualsDeclaration(id3, moduleReference) {
      const node3 = {
        type: "TSImportEqualsDeclaration",
        id: id3,
        moduleReference,
        isExport: null
      };
      const defs = NODE_FIELDS.TSImportEqualsDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      validate(defs.moduleReference, node3, "moduleReference", moduleReference, 1);
      return node3;
    }
    function tsExternalModuleReference(expression) {
      const node3 = {
        type: "TSExternalModuleReference",
        expression
      };
      const defs = NODE_FIELDS.TSExternalModuleReference;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function tsNonNullExpression(expression) {
      const node3 = {
        type: "TSNonNullExpression",
        expression
      };
      const defs = NODE_FIELDS.TSNonNullExpression;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function tsExportAssignment(expression) {
      const node3 = {
        type: "TSExportAssignment",
        expression
      };
      const defs = NODE_FIELDS.TSExportAssignment;
      validate(defs.expression, node3, "expression", expression, 1);
      return node3;
    }
    function tsNamespaceExportDeclaration(id3) {
      const node3 = {
        type: "TSNamespaceExportDeclaration",
        id: id3
      };
      const defs = NODE_FIELDS.TSNamespaceExportDeclaration;
      validate(defs.id, node3, "id", id3, 1);
      return node3;
    }
    function tsTypeAnnotation(typeAnnotation2) {
      const node3 = {
        type: "TSTypeAnnotation",
        typeAnnotation: typeAnnotation2
      };
      const defs = NODE_FIELDS.TSTypeAnnotation;
      validate(defs.typeAnnotation, node3, "typeAnnotation", typeAnnotation2, 1);
      return node3;
    }
    function tsTypeParameterInstantiation(params) {
      const node3 = {
        type: "TSTypeParameterInstantiation",
        params
      };
      const defs = NODE_FIELDS.TSTypeParameterInstantiation;
      validate(defs.params, node3, "params", params, 1);
      return node3;
    }
    function tsTypeParameterDeclaration(params) {
      const node3 = {
        type: "TSTypeParameterDeclaration",
        params
      };
      const defs = NODE_FIELDS.TSTypeParameterDeclaration;
      validate(defs.params, node3, "params", params, 1);
      return node3;
    }
    function tsTypeParameter(constraint = null, _default = null, name2) {
      const node3 = {
        type: "TSTypeParameter",
        constraint,
        default: _default,
        name: name2
      };
      const defs = NODE_FIELDS.TSTypeParameter;
      validate(defs.constraint, node3, "constraint", constraint, 1);
      validate(defs.default, node3, "default", _default, 1);
      validate(defs.name, node3, "name", name2);
      return node3;
    }
    function NumberLiteral(value2) {
      (0, _deprecationWarning.default)("NumberLiteral", "NumericLiteral", "The node type ");
      return numericLiteral(value2);
    }
    function RegexLiteral(pattern2, flags = "") {
      (0, _deprecationWarning.default)("RegexLiteral", "RegExpLiteral", "The node type ");
      return regExpLiteral(pattern2, flags);
    }
    function RestProperty(argument) {
      (0, _deprecationWarning.default)("RestProperty", "RestElement", "The node type ");
      return restElement(argument);
    }
    function SpreadProperty(argument) {
      (0, _deprecationWarning.default)("SpreadProperty", "SpreadElement", "The node type ");
      return spreadElement(argument);
    }
  }
});

// node_modules/@babel/types/lib/builders/generated/uppercase.js
var require_uppercase = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/uppercase.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "AnyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.anyTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ArgumentPlaceholder", {
      enumerable: true,
      get: function() {
        return _lowercase.argumentPlaceholder;
      }
    });
    Object.defineProperty(exports2, "ArrayExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.arrayExpression;
      }
    });
    Object.defineProperty(exports2, "ArrayPattern", {
      enumerable: true,
      get: function() {
        return _lowercase.arrayPattern;
      }
    });
    Object.defineProperty(exports2, "ArrayTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.arrayTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ArrowFunctionExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.arrowFunctionExpression;
      }
    });
    Object.defineProperty(exports2, "AssignmentExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.assignmentExpression;
      }
    });
    Object.defineProperty(exports2, "AssignmentPattern", {
      enumerable: true,
      get: function() {
        return _lowercase.assignmentPattern;
      }
    });
    Object.defineProperty(exports2, "AwaitExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.awaitExpression;
      }
    });
    Object.defineProperty(exports2, "BigIntLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.bigIntLiteral;
      }
    });
    Object.defineProperty(exports2, "BinaryExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.binaryExpression;
      }
    });
    Object.defineProperty(exports2, "BindExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.bindExpression;
      }
    });
    Object.defineProperty(exports2, "BlockStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.blockStatement;
      }
    });
    Object.defineProperty(exports2, "BooleanLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.booleanLiteral;
      }
    });
    Object.defineProperty(exports2, "BooleanLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.booleanLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "BooleanTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.booleanTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "BreakStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.breakStatement;
      }
    });
    Object.defineProperty(exports2, "CallExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.callExpression;
      }
    });
    Object.defineProperty(exports2, "CatchClause", {
      enumerable: true,
      get: function() {
        return _lowercase.catchClause;
      }
    });
    Object.defineProperty(exports2, "ClassAccessorProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.classAccessorProperty;
      }
    });
    Object.defineProperty(exports2, "ClassBody", {
      enumerable: true,
      get: function() {
        return _lowercase.classBody;
      }
    });
    Object.defineProperty(exports2, "ClassDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.classDeclaration;
      }
    });
    Object.defineProperty(exports2, "ClassExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.classExpression;
      }
    });
    Object.defineProperty(exports2, "ClassImplements", {
      enumerable: true,
      get: function() {
        return _lowercase.classImplements;
      }
    });
    Object.defineProperty(exports2, "ClassMethod", {
      enumerable: true,
      get: function() {
        return _lowercase.classMethod;
      }
    });
    Object.defineProperty(exports2, "ClassPrivateMethod", {
      enumerable: true,
      get: function() {
        return _lowercase.classPrivateMethod;
      }
    });
    Object.defineProperty(exports2, "ClassPrivateProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.classPrivateProperty;
      }
    });
    Object.defineProperty(exports2, "ClassProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.classProperty;
      }
    });
    Object.defineProperty(exports2, "ConditionalExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.conditionalExpression;
      }
    });
    Object.defineProperty(exports2, "ContinueStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.continueStatement;
      }
    });
    Object.defineProperty(exports2, "DebuggerStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.debuggerStatement;
      }
    });
    Object.defineProperty(exports2, "DecimalLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.decimalLiteral;
      }
    });
    Object.defineProperty(exports2, "DeclareClass", {
      enumerable: true,
      get: function() {
        return _lowercase.declareClass;
      }
    });
    Object.defineProperty(exports2, "DeclareExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.declareExportAllDeclaration;
      }
    });
    Object.defineProperty(exports2, "DeclareExportDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.declareExportDeclaration;
      }
    });
    Object.defineProperty(exports2, "DeclareFunction", {
      enumerable: true,
      get: function() {
        return _lowercase.declareFunction;
      }
    });
    Object.defineProperty(exports2, "DeclareInterface", {
      enumerable: true,
      get: function() {
        return _lowercase.declareInterface;
      }
    });
    Object.defineProperty(exports2, "DeclareModule", {
      enumerable: true,
      get: function() {
        return _lowercase.declareModule;
      }
    });
    Object.defineProperty(exports2, "DeclareModuleExports", {
      enumerable: true,
      get: function() {
        return _lowercase.declareModuleExports;
      }
    });
    Object.defineProperty(exports2, "DeclareOpaqueType", {
      enumerable: true,
      get: function() {
        return _lowercase.declareOpaqueType;
      }
    });
    Object.defineProperty(exports2, "DeclareTypeAlias", {
      enumerable: true,
      get: function() {
        return _lowercase.declareTypeAlias;
      }
    });
    Object.defineProperty(exports2, "DeclareVariable", {
      enumerable: true,
      get: function() {
        return _lowercase.declareVariable;
      }
    });
    Object.defineProperty(exports2, "DeclaredPredicate", {
      enumerable: true,
      get: function() {
        return _lowercase.declaredPredicate;
      }
    });
    Object.defineProperty(exports2, "Decorator", {
      enumerable: true,
      get: function() {
        return _lowercase.decorator;
      }
    });
    Object.defineProperty(exports2, "Directive", {
      enumerable: true,
      get: function() {
        return _lowercase.directive;
      }
    });
    Object.defineProperty(exports2, "DirectiveLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.directiveLiteral;
      }
    });
    Object.defineProperty(exports2, "DoExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.doExpression;
      }
    });
    Object.defineProperty(exports2, "DoWhileStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.doWhileStatement;
      }
    });
    Object.defineProperty(exports2, "EmptyStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.emptyStatement;
      }
    });
    Object.defineProperty(exports2, "EmptyTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.emptyTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "EnumBooleanBody", {
      enumerable: true,
      get: function() {
        return _lowercase.enumBooleanBody;
      }
    });
    Object.defineProperty(exports2, "EnumBooleanMember", {
      enumerable: true,
      get: function() {
        return _lowercase.enumBooleanMember;
      }
    });
    Object.defineProperty(exports2, "EnumDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.enumDeclaration;
      }
    });
    Object.defineProperty(exports2, "EnumDefaultedMember", {
      enumerable: true,
      get: function() {
        return _lowercase.enumDefaultedMember;
      }
    });
    Object.defineProperty(exports2, "EnumNumberBody", {
      enumerable: true,
      get: function() {
        return _lowercase.enumNumberBody;
      }
    });
    Object.defineProperty(exports2, "EnumNumberMember", {
      enumerable: true,
      get: function() {
        return _lowercase.enumNumberMember;
      }
    });
    Object.defineProperty(exports2, "EnumStringBody", {
      enumerable: true,
      get: function() {
        return _lowercase.enumStringBody;
      }
    });
    Object.defineProperty(exports2, "EnumStringMember", {
      enumerable: true,
      get: function() {
        return _lowercase.enumStringMember;
      }
    });
    Object.defineProperty(exports2, "EnumSymbolBody", {
      enumerable: true,
      get: function() {
        return _lowercase.enumSymbolBody;
      }
    });
    Object.defineProperty(exports2, "ExistsTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.existsTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ExportAllDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.exportAllDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportDefaultDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.exportDefaultDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.exportDefaultSpecifier;
      }
    });
    Object.defineProperty(exports2, "ExportNamedDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.exportNamedDeclaration;
      }
    });
    Object.defineProperty(exports2, "ExportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.exportNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports2, "ExportSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.exportSpecifier;
      }
    });
    Object.defineProperty(exports2, "ExpressionStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.expressionStatement;
      }
    });
    Object.defineProperty(exports2, "File", {
      enumerable: true,
      get: function() {
        return _lowercase.file;
      }
    });
    Object.defineProperty(exports2, "ForInStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.forInStatement;
      }
    });
    Object.defineProperty(exports2, "ForOfStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.forOfStatement;
      }
    });
    Object.defineProperty(exports2, "ForStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.forStatement;
      }
    });
    Object.defineProperty(exports2, "FunctionDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.functionDeclaration;
      }
    });
    Object.defineProperty(exports2, "FunctionExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.functionExpression;
      }
    });
    Object.defineProperty(exports2, "FunctionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.functionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "FunctionTypeParam", {
      enumerable: true,
      get: function() {
        return _lowercase.functionTypeParam;
      }
    });
    Object.defineProperty(exports2, "GenericTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.genericTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: function() {
        return _lowercase.identifier;
      }
    });
    Object.defineProperty(exports2, "IfStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.ifStatement;
      }
    });
    Object.defineProperty(exports2, "Import", {
      enumerable: true,
      get: function() {
        return _lowercase.import;
      }
    });
    Object.defineProperty(exports2, "ImportAttribute", {
      enumerable: true,
      get: function() {
        return _lowercase.importAttribute;
      }
    });
    Object.defineProperty(exports2, "ImportDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.importDeclaration;
      }
    });
    Object.defineProperty(exports2, "ImportDefaultSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.importDefaultSpecifier;
      }
    });
    Object.defineProperty(exports2, "ImportExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.importExpression;
      }
    });
    Object.defineProperty(exports2, "ImportNamespaceSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.importNamespaceSpecifier;
      }
    });
    Object.defineProperty(exports2, "ImportSpecifier", {
      enumerable: true,
      get: function() {
        return _lowercase.importSpecifier;
      }
    });
    Object.defineProperty(exports2, "IndexedAccessType", {
      enumerable: true,
      get: function() {
        return _lowercase.indexedAccessType;
      }
    });
    Object.defineProperty(exports2, "InferredPredicate", {
      enumerable: true,
      get: function() {
        return _lowercase.inferredPredicate;
      }
    });
    Object.defineProperty(exports2, "InterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.interfaceDeclaration;
      }
    });
    Object.defineProperty(exports2, "InterfaceExtends", {
      enumerable: true,
      get: function() {
        return _lowercase.interfaceExtends;
      }
    });
    Object.defineProperty(exports2, "InterfaceTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.interfaceTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "InterpreterDirective", {
      enumerable: true,
      get: function() {
        return _lowercase.interpreterDirective;
      }
    });
    Object.defineProperty(exports2, "IntersectionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.intersectionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "JSXAttribute", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxAttribute;
      }
    });
    Object.defineProperty(exports2, "JSXClosingElement", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxClosingElement;
      }
    });
    Object.defineProperty(exports2, "JSXClosingFragment", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxClosingFragment;
      }
    });
    Object.defineProperty(exports2, "JSXElement", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxElement;
      }
    });
    Object.defineProperty(exports2, "JSXEmptyExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxEmptyExpression;
      }
    });
    Object.defineProperty(exports2, "JSXExpressionContainer", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxExpressionContainer;
      }
    });
    Object.defineProperty(exports2, "JSXFragment", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxFragment;
      }
    });
    Object.defineProperty(exports2, "JSXIdentifier", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxIdentifier;
      }
    });
    Object.defineProperty(exports2, "JSXMemberExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxMemberExpression;
      }
    });
    Object.defineProperty(exports2, "JSXNamespacedName", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxNamespacedName;
      }
    });
    Object.defineProperty(exports2, "JSXOpeningElement", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxOpeningElement;
      }
    });
    Object.defineProperty(exports2, "JSXOpeningFragment", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxOpeningFragment;
      }
    });
    Object.defineProperty(exports2, "JSXSpreadAttribute", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxSpreadAttribute;
      }
    });
    Object.defineProperty(exports2, "JSXSpreadChild", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxSpreadChild;
      }
    });
    Object.defineProperty(exports2, "JSXText", {
      enumerable: true,
      get: function() {
        return _lowercase.jsxText;
      }
    });
    Object.defineProperty(exports2, "LabeledStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.labeledStatement;
      }
    });
    Object.defineProperty(exports2, "LogicalExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.logicalExpression;
      }
    });
    Object.defineProperty(exports2, "MemberExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.memberExpression;
      }
    });
    Object.defineProperty(exports2, "MetaProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.metaProperty;
      }
    });
    Object.defineProperty(exports2, "MixedTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.mixedTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ModuleExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.moduleExpression;
      }
    });
    Object.defineProperty(exports2, "NewExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.newExpression;
      }
    });
    Object.defineProperty(exports2, "Noop", {
      enumerable: true,
      get: function() {
        return _lowercase.noop;
      }
    });
    Object.defineProperty(exports2, "NullLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.nullLiteral;
      }
    });
    Object.defineProperty(exports2, "NullLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.nullLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NullableTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.nullableTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NumberLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.numberLiteral;
      }
    });
    Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.numberLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NumberTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.numberTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "NumericLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.numericLiteral;
      }
    });
    Object.defineProperty(exports2, "ObjectExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.objectExpression;
      }
    });
    Object.defineProperty(exports2, "ObjectMethod", {
      enumerable: true,
      get: function() {
        return _lowercase.objectMethod;
      }
    });
    Object.defineProperty(exports2, "ObjectPattern", {
      enumerable: true,
      get: function() {
        return _lowercase.objectPattern;
      }
    });
    Object.defineProperty(exports2, "ObjectProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.objectProperty;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeCallProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeCallProperty;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeIndexer", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeIndexer;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeInternalSlot", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeInternalSlot;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeProperty;
      }
    });
    Object.defineProperty(exports2, "ObjectTypeSpreadProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.objectTypeSpreadProperty;
      }
    });
    Object.defineProperty(exports2, "OpaqueType", {
      enumerable: true,
      get: function() {
        return _lowercase.opaqueType;
      }
    });
    Object.defineProperty(exports2, "OptionalCallExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.optionalCallExpression;
      }
    });
    Object.defineProperty(exports2, "OptionalIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _lowercase.optionalIndexedAccessType;
      }
    });
    Object.defineProperty(exports2, "OptionalMemberExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.optionalMemberExpression;
      }
    });
    Object.defineProperty(exports2, "ParenthesizedExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.parenthesizedExpression;
      }
    });
    Object.defineProperty(exports2, "PipelineBareFunction", {
      enumerable: true,
      get: function() {
        return _lowercase.pipelineBareFunction;
      }
    });
    Object.defineProperty(exports2, "PipelinePrimaryTopicReference", {
      enumerable: true,
      get: function() {
        return _lowercase.pipelinePrimaryTopicReference;
      }
    });
    Object.defineProperty(exports2, "PipelineTopicExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.pipelineTopicExpression;
      }
    });
    Object.defineProperty(exports2, "Placeholder", {
      enumerable: true,
      get: function() {
        return _lowercase.placeholder;
      }
    });
    Object.defineProperty(exports2, "PrivateName", {
      enumerable: true,
      get: function() {
        return _lowercase.privateName;
      }
    });
    Object.defineProperty(exports2, "Program", {
      enumerable: true,
      get: function() {
        return _lowercase.program;
      }
    });
    Object.defineProperty(exports2, "QualifiedTypeIdentifier", {
      enumerable: true,
      get: function() {
        return _lowercase.qualifiedTypeIdentifier;
      }
    });
    Object.defineProperty(exports2, "RecordExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.recordExpression;
      }
    });
    Object.defineProperty(exports2, "RegExpLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.regExpLiteral;
      }
    });
    Object.defineProperty(exports2, "RegexLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.regexLiteral;
      }
    });
    Object.defineProperty(exports2, "RestElement", {
      enumerable: true,
      get: function() {
        return _lowercase.restElement;
      }
    });
    Object.defineProperty(exports2, "RestProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.restProperty;
      }
    });
    Object.defineProperty(exports2, "ReturnStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.returnStatement;
      }
    });
    Object.defineProperty(exports2, "SequenceExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.sequenceExpression;
      }
    });
    Object.defineProperty(exports2, "SpreadElement", {
      enumerable: true,
      get: function() {
        return _lowercase.spreadElement;
      }
    });
    Object.defineProperty(exports2, "SpreadProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.spreadProperty;
      }
    });
    Object.defineProperty(exports2, "StaticBlock", {
      enumerable: true,
      get: function() {
        return _lowercase.staticBlock;
      }
    });
    Object.defineProperty(exports2, "StringLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.stringLiteral;
      }
    });
    Object.defineProperty(exports2, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.stringLiteralTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "StringTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.stringTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "Super", {
      enumerable: true,
      get: function() {
        return _lowercase.super;
      }
    });
    Object.defineProperty(exports2, "SwitchCase", {
      enumerable: true,
      get: function() {
        return _lowercase.switchCase;
      }
    });
    Object.defineProperty(exports2, "SwitchStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.switchStatement;
      }
    });
    Object.defineProperty(exports2, "SymbolTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.symbolTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TSAnyKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsAnyKeyword;
      }
    });
    Object.defineProperty(exports2, "TSArrayType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsArrayType;
      }
    });
    Object.defineProperty(exports2, "TSAsExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tsAsExpression;
      }
    });
    Object.defineProperty(exports2, "TSBigIntKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsBigIntKeyword;
      }
    });
    Object.defineProperty(exports2, "TSBooleanKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsBooleanKeyword;
      }
    });
    Object.defineProperty(exports2, "TSCallSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsCallSignatureDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSConditionalType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsConditionalType;
      }
    });
    Object.defineProperty(exports2, "TSConstructSignatureDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsConstructSignatureDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSConstructorType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsConstructorType;
      }
    });
    Object.defineProperty(exports2, "TSDeclareFunction", {
      enumerable: true,
      get: function() {
        return _lowercase.tsDeclareFunction;
      }
    });
    Object.defineProperty(exports2, "TSDeclareMethod", {
      enumerable: true,
      get: function() {
        return _lowercase.tsDeclareMethod;
      }
    });
    Object.defineProperty(exports2, "TSEnumBody", {
      enumerable: true,
      get: function() {
        return _lowercase.tsEnumBody;
      }
    });
    Object.defineProperty(exports2, "TSEnumDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsEnumDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSEnumMember", {
      enumerable: true,
      get: function() {
        return _lowercase.tsEnumMember;
      }
    });
    Object.defineProperty(exports2, "TSExportAssignment", {
      enumerable: true,
      get: function() {
        return _lowercase.tsExportAssignment;
      }
    });
    Object.defineProperty(exports2, "TSExpressionWithTypeArguments", {
      enumerable: true,
      get: function() {
        return _lowercase.tsExpressionWithTypeArguments;
      }
    });
    Object.defineProperty(exports2, "TSExternalModuleReference", {
      enumerable: true,
      get: function() {
        return _lowercase.tsExternalModuleReference;
      }
    });
    Object.defineProperty(exports2, "TSFunctionType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsFunctionType;
      }
    });
    Object.defineProperty(exports2, "TSImportEqualsDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsImportEqualsDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSImportType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsImportType;
      }
    });
    Object.defineProperty(exports2, "TSIndexSignature", {
      enumerable: true,
      get: function() {
        return _lowercase.tsIndexSignature;
      }
    });
    Object.defineProperty(exports2, "TSIndexedAccessType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsIndexedAccessType;
      }
    });
    Object.defineProperty(exports2, "TSInferType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsInferType;
      }
    });
    Object.defineProperty(exports2, "TSInstantiationExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tsInstantiationExpression;
      }
    });
    Object.defineProperty(exports2, "TSInterfaceBody", {
      enumerable: true,
      get: function() {
        return _lowercase.tsInterfaceBody;
      }
    });
    Object.defineProperty(exports2, "TSInterfaceDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsInterfaceDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSIntersectionType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsIntersectionType;
      }
    });
    Object.defineProperty(exports2, "TSIntrinsicKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsIntrinsicKeyword;
      }
    });
    Object.defineProperty(exports2, "TSLiteralType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsLiteralType;
      }
    });
    Object.defineProperty(exports2, "TSMappedType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsMappedType;
      }
    });
    Object.defineProperty(exports2, "TSMethodSignature", {
      enumerable: true,
      get: function() {
        return _lowercase.tsMethodSignature;
      }
    });
    Object.defineProperty(exports2, "TSModuleBlock", {
      enumerable: true,
      get: function() {
        return _lowercase.tsModuleBlock;
      }
    });
    Object.defineProperty(exports2, "TSModuleDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsModuleDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSNamedTupleMember", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNamedTupleMember;
      }
    });
    Object.defineProperty(exports2, "TSNamespaceExportDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNamespaceExportDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSNeverKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNeverKeyword;
      }
    });
    Object.defineProperty(exports2, "TSNonNullExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNonNullExpression;
      }
    });
    Object.defineProperty(exports2, "TSNullKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNullKeyword;
      }
    });
    Object.defineProperty(exports2, "TSNumberKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsNumberKeyword;
      }
    });
    Object.defineProperty(exports2, "TSObjectKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsObjectKeyword;
      }
    });
    Object.defineProperty(exports2, "TSOptionalType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsOptionalType;
      }
    });
    Object.defineProperty(exports2, "TSParameterProperty", {
      enumerable: true,
      get: function() {
        return _lowercase.tsParameterProperty;
      }
    });
    Object.defineProperty(exports2, "TSParenthesizedType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsParenthesizedType;
      }
    });
    Object.defineProperty(exports2, "TSPropertySignature", {
      enumerable: true,
      get: function() {
        return _lowercase.tsPropertySignature;
      }
    });
    Object.defineProperty(exports2, "TSQualifiedName", {
      enumerable: true,
      get: function() {
        return _lowercase.tsQualifiedName;
      }
    });
    Object.defineProperty(exports2, "TSRestType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsRestType;
      }
    });
    Object.defineProperty(exports2, "TSSatisfiesExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tsSatisfiesExpression;
      }
    });
    Object.defineProperty(exports2, "TSStringKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsStringKeyword;
      }
    });
    Object.defineProperty(exports2, "TSSymbolKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsSymbolKeyword;
      }
    });
    Object.defineProperty(exports2, "TSTemplateLiteralType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTemplateLiteralType;
      }
    });
    Object.defineProperty(exports2, "TSThisType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsThisType;
      }
    });
    Object.defineProperty(exports2, "TSTupleType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTupleType;
      }
    });
    Object.defineProperty(exports2, "TSTypeAliasDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeAliasDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TSTypeAssertion", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeAssertion;
      }
    });
    Object.defineProperty(exports2, "TSTypeLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeLiteral;
      }
    });
    Object.defineProperty(exports2, "TSTypeOperator", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeOperator;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameter", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeParameter;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeParameterDeclaration;
      }
    });
    Object.defineProperty(exports2, "TSTypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeParameterInstantiation;
      }
    });
    Object.defineProperty(exports2, "TSTypePredicate", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypePredicate;
      }
    });
    Object.defineProperty(exports2, "TSTypeQuery", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeQuery;
      }
    });
    Object.defineProperty(exports2, "TSTypeReference", {
      enumerable: true,
      get: function() {
        return _lowercase.tsTypeReference;
      }
    });
    Object.defineProperty(exports2, "TSUndefinedKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsUndefinedKeyword;
      }
    });
    Object.defineProperty(exports2, "TSUnionType", {
      enumerable: true,
      get: function() {
        return _lowercase.tsUnionType;
      }
    });
    Object.defineProperty(exports2, "TSUnknownKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsUnknownKeyword;
      }
    });
    Object.defineProperty(exports2, "TSVoidKeyword", {
      enumerable: true,
      get: function() {
        return _lowercase.tsVoidKeyword;
      }
    });
    Object.defineProperty(exports2, "TaggedTemplateExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.taggedTemplateExpression;
      }
    });
    Object.defineProperty(exports2, "TemplateElement", {
      enumerable: true,
      get: function() {
        return _lowercase.templateElement;
      }
    });
    Object.defineProperty(exports2, "TemplateLiteral", {
      enumerable: true,
      get: function() {
        return _lowercase.templateLiteral;
      }
    });
    Object.defineProperty(exports2, "ThisExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.thisExpression;
      }
    });
    Object.defineProperty(exports2, "ThisTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.thisTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "ThrowStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.throwStatement;
      }
    });
    Object.defineProperty(exports2, "TopicReference", {
      enumerable: true,
      get: function() {
        return _lowercase.topicReference;
      }
    });
    Object.defineProperty(exports2, "TryStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.tryStatement;
      }
    });
    Object.defineProperty(exports2, "TupleExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.tupleExpression;
      }
    });
    Object.defineProperty(exports2, "TupleTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.tupleTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TypeAlias", {
      enumerable: true,
      get: function() {
        return _lowercase.typeAlias;
      }
    });
    Object.defineProperty(exports2, "TypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.typeAnnotation;
      }
    });
    Object.defineProperty(exports2, "TypeCastExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.typeCastExpression;
      }
    });
    Object.defineProperty(exports2, "TypeParameter", {
      enumerable: true,
      get: function() {
        return _lowercase.typeParameter;
      }
    });
    Object.defineProperty(exports2, "TypeParameterDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.typeParameterDeclaration;
      }
    });
    Object.defineProperty(exports2, "TypeParameterInstantiation", {
      enumerable: true,
      get: function() {
        return _lowercase.typeParameterInstantiation;
      }
    });
    Object.defineProperty(exports2, "TypeofTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.typeofTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "UnaryExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.unaryExpression;
      }
    });
    Object.defineProperty(exports2, "UnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.unionTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "UpdateExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.updateExpression;
      }
    });
    Object.defineProperty(exports2, "V8IntrinsicIdentifier", {
      enumerable: true,
      get: function() {
        return _lowercase.v8IntrinsicIdentifier;
      }
    });
    Object.defineProperty(exports2, "VariableDeclaration", {
      enumerable: true,
      get: function() {
        return _lowercase.variableDeclaration;
      }
    });
    Object.defineProperty(exports2, "VariableDeclarator", {
      enumerable: true,
      get: function() {
        return _lowercase.variableDeclarator;
      }
    });
    Object.defineProperty(exports2, "Variance", {
      enumerable: true,
      get: function() {
        return _lowercase.variance;
      }
    });
    Object.defineProperty(exports2, "VoidTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _lowercase.voidTypeAnnotation;
      }
    });
    Object.defineProperty(exports2, "WhileStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.whileStatement;
      }
    });
    Object.defineProperty(exports2, "WithStatement", {
      enumerable: true,
      get: function() {
        return _lowercase.withStatement;
      }
    });
    Object.defineProperty(exports2, "YieldExpression", {
      enumerable: true,
      get: function() {
        return _lowercase.yieldExpression;
      }
    });
    var _lowercase = require_lowercase();
  }
});

// node_modules/@babel/types/lib/builders/generated/index.js
var require_generated2 = __commonJS({
  "node_modules/@babel/types/lib/builders/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _lowercase = require_lowercase();
    Object.keys(_lowercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _lowercase[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _lowercase[key];
        }
      });
    });
    var _uppercase = require_uppercase();
    Object.keys(_uppercase).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _uppercase[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _uppercase[key];
        }
      });
    });
  }
});

// node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js
var require_cleanJSXElementLiteralChild = __commonJS({
  "node_modules/@babel/types/lib/utils/react/cleanJSXElementLiteralChild.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cleanJSXElementLiteralChild;
    var _index = require_generated2();
    var _index2 = require_lib3();
    function cleanJSXElementLiteralChild(child, args) {
      const lines = child.value.split(/\r\n|\n|\r/);
      let lastNonEmptyLine = 0;
      for (let i = 0; i < lines.length; i++) {
        if (/[^ \t]/.exec(lines[i])) {
          lastNonEmptyLine = i;
        }
      }
      let str2 = "";
      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const isFirstLine = i === 0;
        const isLastLine = i === lines.length - 1;
        const isLastNonEmptyLine = i === lastNonEmptyLine;
        let trimmedLine = line.replace(/\t/g, " ");
        if (!isFirstLine) {
          trimmedLine = trimmedLine.replace(/^ +/, "");
        }
        if (!isLastLine) {
          trimmedLine = trimmedLine.replace(/ +$/, "");
        }
        if (trimmedLine) {
          if (!isLastNonEmptyLine) {
            trimmedLine += " ";
          }
          str2 += trimmedLine;
        }
      }
      if (str2) args.push((0, _index2.inherits)((0, _index.stringLiteral)(str2), child));
    }
  }
});

// node_modules/@babel/types/lib/builders/react/buildChildren.js
var require_buildChildren = __commonJS({
  "node_modules/@babel/types/lib/builders/react/buildChildren.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = buildChildren;
    var _index = require_generated();
    var _cleanJSXElementLiteralChild = require_cleanJSXElementLiteralChild();
    function buildChildren(node3) {
      const elements = [];
      for (let i = 0; i < node3.children.length; i++) {
        let child = node3.children[i];
        if ((0, _index.isJSXText)(child)) {
          (0, _cleanJSXElementLiteralChild.default)(child, elements);
          continue;
        }
        if ((0, _index.isJSXExpressionContainer)(child)) child = child.expression;
        if ((0, _index.isJSXEmptyExpression)(child)) continue;
        elements.push(child);
      }
      return elements;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNode.js
var require_isNode = __commonJS({
  "node_modules/@babel/types/lib/validators/isNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isNode2;
    var _index = require_definitions();
    function isNode2(node3) {
      return !!(node3 && _index.VISITOR_KEYS[node3.type]);
    }
  }
});

// node_modules/@babel/types/lib/asserts/assertNode.js
var require_assertNode = __commonJS({
  "node_modules/@babel/types/lib/asserts/assertNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = assertNode;
    var _isNode = require_isNode();
    function assertNode(node3) {
      if (!(0, _isNode.default)(node3)) {
        var _node$type;
        const type = (_node$type = node3 == null ? void 0 : node3.type) != null ? _node$type : JSON.stringify(node3);
        throw new TypeError(`Not a valid node of type "${type}"`);
      }
    }
  }
});

// node_modules/@babel/types/lib/asserts/generated/index.js
var require_generated3 = __commonJS({
  "node_modules/@babel/types/lib/asserts/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertAccessor = assertAccessor;
    exports2.assertAnyTypeAnnotation = assertAnyTypeAnnotation;
    exports2.assertArgumentPlaceholder = assertArgumentPlaceholder;
    exports2.assertArrayExpression = assertArrayExpression;
    exports2.assertArrayPattern = assertArrayPattern;
    exports2.assertArrayTypeAnnotation = assertArrayTypeAnnotation;
    exports2.assertArrowFunctionExpression = assertArrowFunctionExpression;
    exports2.assertAssignmentExpression = assertAssignmentExpression;
    exports2.assertAssignmentPattern = assertAssignmentPattern;
    exports2.assertAwaitExpression = assertAwaitExpression;
    exports2.assertBigIntLiteral = assertBigIntLiteral;
    exports2.assertBinary = assertBinary;
    exports2.assertBinaryExpression = assertBinaryExpression;
    exports2.assertBindExpression = assertBindExpression;
    exports2.assertBlock = assertBlock;
    exports2.assertBlockParent = assertBlockParent;
    exports2.assertBlockStatement = assertBlockStatement;
    exports2.assertBooleanLiteral = assertBooleanLiteral;
    exports2.assertBooleanLiteralTypeAnnotation = assertBooleanLiteralTypeAnnotation;
    exports2.assertBooleanTypeAnnotation = assertBooleanTypeAnnotation;
    exports2.assertBreakStatement = assertBreakStatement;
    exports2.assertCallExpression = assertCallExpression;
    exports2.assertCatchClause = assertCatchClause;
    exports2.assertClass = assertClass;
    exports2.assertClassAccessorProperty = assertClassAccessorProperty;
    exports2.assertClassBody = assertClassBody;
    exports2.assertClassDeclaration = assertClassDeclaration;
    exports2.assertClassExpression = assertClassExpression;
    exports2.assertClassImplements = assertClassImplements;
    exports2.assertClassMethod = assertClassMethod;
    exports2.assertClassPrivateMethod = assertClassPrivateMethod;
    exports2.assertClassPrivateProperty = assertClassPrivateProperty;
    exports2.assertClassProperty = assertClassProperty;
    exports2.assertCompletionStatement = assertCompletionStatement;
    exports2.assertConditional = assertConditional;
    exports2.assertConditionalExpression = assertConditionalExpression;
    exports2.assertContinueStatement = assertContinueStatement;
    exports2.assertDebuggerStatement = assertDebuggerStatement;
    exports2.assertDecimalLiteral = assertDecimalLiteral;
    exports2.assertDeclaration = assertDeclaration;
    exports2.assertDeclareClass = assertDeclareClass;
    exports2.assertDeclareExportAllDeclaration = assertDeclareExportAllDeclaration;
    exports2.assertDeclareExportDeclaration = assertDeclareExportDeclaration;
    exports2.assertDeclareFunction = assertDeclareFunction;
    exports2.assertDeclareInterface = assertDeclareInterface;
    exports2.assertDeclareModule = assertDeclareModule;
    exports2.assertDeclareModuleExports = assertDeclareModuleExports;
    exports2.assertDeclareOpaqueType = assertDeclareOpaqueType;
    exports2.assertDeclareTypeAlias = assertDeclareTypeAlias;
    exports2.assertDeclareVariable = assertDeclareVariable;
    exports2.assertDeclaredPredicate = assertDeclaredPredicate;
    exports2.assertDecorator = assertDecorator;
    exports2.assertDirective = assertDirective;
    exports2.assertDirectiveLiteral = assertDirectiveLiteral;
    exports2.assertDoExpression = assertDoExpression;
    exports2.assertDoWhileStatement = assertDoWhileStatement;
    exports2.assertEmptyStatement = assertEmptyStatement;
    exports2.assertEmptyTypeAnnotation = assertEmptyTypeAnnotation;
    exports2.assertEnumBody = assertEnumBody;
    exports2.assertEnumBooleanBody = assertEnumBooleanBody;
    exports2.assertEnumBooleanMember = assertEnumBooleanMember;
    exports2.assertEnumDeclaration = assertEnumDeclaration;
    exports2.assertEnumDefaultedMember = assertEnumDefaultedMember;
    exports2.assertEnumMember = assertEnumMember;
    exports2.assertEnumNumberBody = assertEnumNumberBody;
    exports2.assertEnumNumberMember = assertEnumNumberMember;
    exports2.assertEnumStringBody = assertEnumStringBody;
    exports2.assertEnumStringMember = assertEnumStringMember;
    exports2.assertEnumSymbolBody = assertEnumSymbolBody;
    exports2.assertExistsTypeAnnotation = assertExistsTypeAnnotation;
    exports2.assertExportAllDeclaration = assertExportAllDeclaration;
    exports2.assertExportDeclaration = assertExportDeclaration;
    exports2.assertExportDefaultDeclaration = assertExportDefaultDeclaration;
    exports2.assertExportDefaultSpecifier = assertExportDefaultSpecifier;
    exports2.assertExportNamedDeclaration = assertExportNamedDeclaration;
    exports2.assertExportNamespaceSpecifier = assertExportNamespaceSpecifier;
    exports2.assertExportSpecifier = assertExportSpecifier;
    exports2.assertExpression = assertExpression;
    exports2.assertExpressionStatement = assertExpressionStatement;
    exports2.assertExpressionWrapper = assertExpressionWrapper;
    exports2.assertFile = assertFile;
    exports2.assertFlow = assertFlow;
    exports2.assertFlowBaseAnnotation = assertFlowBaseAnnotation;
    exports2.assertFlowDeclaration = assertFlowDeclaration;
    exports2.assertFlowPredicate = assertFlowPredicate;
    exports2.assertFlowType = assertFlowType;
    exports2.assertFor = assertFor;
    exports2.assertForInStatement = assertForInStatement;
    exports2.assertForOfStatement = assertForOfStatement;
    exports2.assertForStatement = assertForStatement;
    exports2.assertForXStatement = assertForXStatement;
    exports2.assertFunction = assertFunction;
    exports2.assertFunctionDeclaration = assertFunctionDeclaration;
    exports2.assertFunctionExpression = assertFunctionExpression;
    exports2.assertFunctionParent = assertFunctionParent;
    exports2.assertFunctionTypeAnnotation = assertFunctionTypeAnnotation;
    exports2.assertFunctionTypeParam = assertFunctionTypeParam;
    exports2.assertGenericTypeAnnotation = assertGenericTypeAnnotation;
    exports2.assertIdentifier = assertIdentifier;
    exports2.assertIfStatement = assertIfStatement;
    exports2.assertImmutable = assertImmutable;
    exports2.assertImport = assertImport;
    exports2.assertImportAttribute = assertImportAttribute;
    exports2.assertImportDeclaration = assertImportDeclaration;
    exports2.assertImportDefaultSpecifier = assertImportDefaultSpecifier;
    exports2.assertImportExpression = assertImportExpression;
    exports2.assertImportNamespaceSpecifier = assertImportNamespaceSpecifier;
    exports2.assertImportOrExportDeclaration = assertImportOrExportDeclaration;
    exports2.assertImportSpecifier = assertImportSpecifier;
    exports2.assertIndexedAccessType = assertIndexedAccessType;
    exports2.assertInferredPredicate = assertInferredPredicate;
    exports2.assertInterfaceDeclaration = assertInterfaceDeclaration;
    exports2.assertInterfaceExtends = assertInterfaceExtends;
    exports2.assertInterfaceTypeAnnotation = assertInterfaceTypeAnnotation;
    exports2.assertInterpreterDirective = assertInterpreterDirective;
    exports2.assertIntersectionTypeAnnotation = assertIntersectionTypeAnnotation;
    exports2.assertJSX = assertJSX;
    exports2.assertJSXAttribute = assertJSXAttribute;
    exports2.assertJSXClosingElement = assertJSXClosingElement;
    exports2.assertJSXClosingFragment = assertJSXClosingFragment;
    exports2.assertJSXElement = assertJSXElement;
    exports2.assertJSXEmptyExpression = assertJSXEmptyExpression;
    exports2.assertJSXExpressionContainer = assertJSXExpressionContainer;
    exports2.assertJSXFragment = assertJSXFragment;
    exports2.assertJSXIdentifier = assertJSXIdentifier;
    exports2.assertJSXMemberExpression = assertJSXMemberExpression;
    exports2.assertJSXNamespacedName = assertJSXNamespacedName;
    exports2.assertJSXOpeningElement = assertJSXOpeningElement;
    exports2.assertJSXOpeningFragment = assertJSXOpeningFragment;
    exports2.assertJSXSpreadAttribute = assertJSXSpreadAttribute;
    exports2.assertJSXSpreadChild = assertJSXSpreadChild;
    exports2.assertJSXText = assertJSXText;
    exports2.assertLVal = assertLVal;
    exports2.assertLabeledStatement = assertLabeledStatement;
    exports2.assertLiteral = assertLiteral;
    exports2.assertLogicalExpression = assertLogicalExpression;
    exports2.assertLoop = assertLoop;
    exports2.assertMemberExpression = assertMemberExpression;
    exports2.assertMetaProperty = assertMetaProperty;
    exports2.assertMethod = assertMethod;
    exports2.assertMiscellaneous = assertMiscellaneous;
    exports2.assertMixedTypeAnnotation = assertMixedTypeAnnotation;
    exports2.assertModuleDeclaration = assertModuleDeclaration;
    exports2.assertModuleExpression = assertModuleExpression;
    exports2.assertModuleSpecifier = assertModuleSpecifier;
    exports2.assertNewExpression = assertNewExpression;
    exports2.assertNoop = assertNoop;
    exports2.assertNullLiteral = assertNullLiteral;
    exports2.assertNullLiteralTypeAnnotation = assertNullLiteralTypeAnnotation;
    exports2.assertNullableTypeAnnotation = assertNullableTypeAnnotation;
    exports2.assertNumberLiteral = assertNumberLiteral;
    exports2.assertNumberLiteralTypeAnnotation = assertNumberLiteralTypeAnnotation;
    exports2.assertNumberTypeAnnotation = assertNumberTypeAnnotation;
    exports2.assertNumericLiteral = assertNumericLiteral;
    exports2.assertObjectExpression = assertObjectExpression;
    exports2.assertObjectMember = assertObjectMember;
    exports2.assertObjectMethod = assertObjectMethod;
    exports2.assertObjectPattern = assertObjectPattern;
    exports2.assertObjectProperty = assertObjectProperty;
    exports2.assertObjectTypeAnnotation = assertObjectTypeAnnotation;
    exports2.assertObjectTypeCallProperty = assertObjectTypeCallProperty;
    exports2.assertObjectTypeIndexer = assertObjectTypeIndexer;
    exports2.assertObjectTypeInternalSlot = assertObjectTypeInternalSlot;
    exports2.assertObjectTypeProperty = assertObjectTypeProperty;
    exports2.assertObjectTypeSpreadProperty = assertObjectTypeSpreadProperty;
    exports2.assertOpaqueType = assertOpaqueType;
    exports2.assertOptionalCallExpression = assertOptionalCallExpression;
    exports2.assertOptionalIndexedAccessType = assertOptionalIndexedAccessType;
    exports2.assertOptionalMemberExpression = assertOptionalMemberExpression;
    exports2.assertParenthesizedExpression = assertParenthesizedExpression;
    exports2.assertPattern = assertPattern;
    exports2.assertPatternLike = assertPatternLike;
    exports2.assertPipelineBareFunction = assertPipelineBareFunction;
    exports2.assertPipelinePrimaryTopicReference = assertPipelinePrimaryTopicReference;
    exports2.assertPipelineTopicExpression = assertPipelineTopicExpression;
    exports2.assertPlaceholder = assertPlaceholder;
    exports2.assertPrivate = assertPrivate;
    exports2.assertPrivateName = assertPrivateName;
    exports2.assertProgram = assertProgram;
    exports2.assertProperty = assertProperty;
    exports2.assertPureish = assertPureish;
    exports2.assertQualifiedTypeIdentifier = assertQualifiedTypeIdentifier;
    exports2.assertRecordExpression = assertRecordExpression;
    exports2.assertRegExpLiteral = assertRegExpLiteral;
    exports2.assertRegexLiteral = assertRegexLiteral;
    exports2.assertRestElement = assertRestElement;
    exports2.assertRestProperty = assertRestProperty;
    exports2.assertReturnStatement = assertReturnStatement;
    exports2.assertScopable = assertScopable;
    exports2.assertSequenceExpression = assertSequenceExpression;
    exports2.assertSpreadElement = assertSpreadElement;
    exports2.assertSpreadProperty = assertSpreadProperty;
    exports2.assertStandardized = assertStandardized;
    exports2.assertStatement = assertStatement;
    exports2.assertStaticBlock = assertStaticBlock;
    exports2.assertStringLiteral = assertStringLiteral;
    exports2.assertStringLiteralTypeAnnotation = assertStringLiteralTypeAnnotation;
    exports2.assertStringTypeAnnotation = assertStringTypeAnnotation;
    exports2.assertSuper = assertSuper;
    exports2.assertSwitchCase = assertSwitchCase;
    exports2.assertSwitchStatement = assertSwitchStatement;
    exports2.assertSymbolTypeAnnotation = assertSymbolTypeAnnotation;
    exports2.assertTSAnyKeyword = assertTSAnyKeyword;
    exports2.assertTSArrayType = assertTSArrayType;
    exports2.assertTSAsExpression = assertTSAsExpression;
    exports2.assertTSBaseType = assertTSBaseType;
    exports2.assertTSBigIntKeyword = assertTSBigIntKeyword;
    exports2.assertTSBooleanKeyword = assertTSBooleanKeyword;
    exports2.assertTSCallSignatureDeclaration = assertTSCallSignatureDeclaration;
    exports2.assertTSConditionalType = assertTSConditionalType;
    exports2.assertTSConstructSignatureDeclaration = assertTSConstructSignatureDeclaration;
    exports2.assertTSConstructorType = assertTSConstructorType;
    exports2.assertTSDeclareFunction = assertTSDeclareFunction;
    exports2.assertTSDeclareMethod = assertTSDeclareMethod;
    exports2.assertTSEntityName = assertTSEntityName;
    exports2.assertTSEnumBody = assertTSEnumBody;
    exports2.assertTSEnumDeclaration = assertTSEnumDeclaration;
    exports2.assertTSEnumMember = assertTSEnumMember;
    exports2.assertTSExportAssignment = assertTSExportAssignment;
    exports2.assertTSExpressionWithTypeArguments = assertTSExpressionWithTypeArguments;
    exports2.assertTSExternalModuleReference = assertTSExternalModuleReference;
    exports2.assertTSFunctionType = assertTSFunctionType;
    exports2.assertTSImportEqualsDeclaration = assertTSImportEqualsDeclaration;
    exports2.assertTSImportType = assertTSImportType;
    exports2.assertTSIndexSignature = assertTSIndexSignature;
    exports2.assertTSIndexedAccessType = assertTSIndexedAccessType;
    exports2.assertTSInferType = assertTSInferType;
    exports2.assertTSInstantiationExpression = assertTSInstantiationExpression;
    exports2.assertTSInterfaceBody = assertTSInterfaceBody;
    exports2.assertTSInterfaceDeclaration = assertTSInterfaceDeclaration;
    exports2.assertTSIntersectionType = assertTSIntersectionType;
    exports2.assertTSIntrinsicKeyword = assertTSIntrinsicKeyword;
    exports2.assertTSLiteralType = assertTSLiteralType;
    exports2.assertTSMappedType = assertTSMappedType;
    exports2.assertTSMethodSignature = assertTSMethodSignature;
    exports2.assertTSModuleBlock = assertTSModuleBlock;
    exports2.assertTSModuleDeclaration = assertTSModuleDeclaration;
    exports2.assertTSNamedTupleMember = assertTSNamedTupleMember;
    exports2.assertTSNamespaceExportDeclaration = assertTSNamespaceExportDeclaration;
    exports2.assertTSNeverKeyword = assertTSNeverKeyword;
    exports2.assertTSNonNullExpression = assertTSNonNullExpression;
    exports2.assertTSNullKeyword = assertTSNullKeyword;
    exports2.assertTSNumberKeyword = assertTSNumberKeyword;
    exports2.assertTSObjectKeyword = assertTSObjectKeyword;
    exports2.assertTSOptionalType = assertTSOptionalType;
    exports2.assertTSParameterProperty = assertTSParameterProperty;
    exports2.assertTSParenthesizedType = assertTSParenthesizedType;
    exports2.assertTSPropertySignature = assertTSPropertySignature;
    exports2.assertTSQualifiedName = assertTSQualifiedName;
    exports2.assertTSRestType = assertTSRestType;
    exports2.assertTSSatisfiesExpression = assertTSSatisfiesExpression;
    exports2.assertTSStringKeyword = assertTSStringKeyword;
    exports2.assertTSSymbolKeyword = assertTSSymbolKeyword;
    exports2.assertTSTemplateLiteralType = assertTSTemplateLiteralType;
    exports2.assertTSThisType = assertTSThisType;
    exports2.assertTSTupleType = assertTSTupleType;
    exports2.assertTSType = assertTSType;
    exports2.assertTSTypeAliasDeclaration = assertTSTypeAliasDeclaration;
    exports2.assertTSTypeAnnotation = assertTSTypeAnnotation;
    exports2.assertTSTypeAssertion = assertTSTypeAssertion;
    exports2.assertTSTypeElement = assertTSTypeElement;
    exports2.assertTSTypeLiteral = assertTSTypeLiteral;
    exports2.assertTSTypeOperator = assertTSTypeOperator;
    exports2.assertTSTypeParameter = assertTSTypeParameter;
    exports2.assertTSTypeParameterDeclaration = assertTSTypeParameterDeclaration;
    exports2.assertTSTypeParameterInstantiation = assertTSTypeParameterInstantiation;
    exports2.assertTSTypePredicate = assertTSTypePredicate;
    exports2.assertTSTypeQuery = assertTSTypeQuery;
    exports2.assertTSTypeReference = assertTSTypeReference;
    exports2.assertTSUndefinedKeyword = assertTSUndefinedKeyword;
    exports2.assertTSUnionType = assertTSUnionType;
    exports2.assertTSUnknownKeyword = assertTSUnknownKeyword;
    exports2.assertTSVoidKeyword = assertTSVoidKeyword;
    exports2.assertTaggedTemplateExpression = assertTaggedTemplateExpression;
    exports2.assertTemplateElement = assertTemplateElement;
    exports2.assertTemplateLiteral = assertTemplateLiteral;
    exports2.assertTerminatorless = assertTerminatorless;
    exports2.assertThisExpression = assertThisExpression;
    exports2.assertThisTypeAnnotation = assertThisTypeAnnotation;
    exports2.assertThrowStatement = assertThrowStatement;
    exports2.assertTopicReference = assertTopicReference;
    exports2.assertTryStatement = assertTryStatement;
    exports2.assertTupleExpression = assertTupleExpression;
    exports2.assertTupleTypeAnnotation = assertTupleTypeAnnotation;
    exports2.assertTypeAlias = assertTypeAlias;
    exports2.assertTypeAnnotation = assertTypeAnnotation;
    exports2.assertTypeCastExpression = assertTypeCastExpression;
    exports2.assertTypeParameter = assertTypeParameter;
    exports2.assertTypeParameterDeclaration = assertTypeParameterDeclaration;
    exports2.assertTypeParameterInstantiation = assertTypeParameterInstantiation;
    exports2.assertTypeScript = assertTypeScript;
    exports2.assertTypeofTypeAnnotation = assertTypeofTypeAnnotation;
    exports2.assertUnaryExpression = assertUnaryExpression;
    exports2.assertUnaryLike = assertUnaryLike;
    exports2.assertUnionTypeAnnotation = assertUnionTypeAnnotation;
    exports2.assertUpdateExpression = assertUpdateExpression;
    exports2.assertUserWhitespacable = assertUserWhitespacable;
    exports2.assertV8IntrinsicIdentifier = assertV8IntrinsicIdentifier;
    exports2.assertVariableDeclaration = assertVariableDeclaration;
    exports2.assertVariableDeclarator = assertVariableDeclarator;
    exports2.assertVariance = assertVariance;
    exports2.assertVoidTypeAnnotation = assertVoidTypeAnnotation;
    exports2.assertWhile = assertWhile;
    exports2.assertWhileStatement = assertWhileStatement;
    exports2.assertWithStatement = assertWithStatement;
    exports2.assertYieldExpression = assertYieldExpression;
    var _is = require_is();
    var _deprecationWarning = require_deprecationWarning();
    function assert2(type, node3, opts) {
      if (!(0, _is.default)(type, node3, opts)) {
        throw new Error(`Expected type "${type}" with option ${JSON.stringify(opts)}, but instead got "${node3.type}".`);
      }
    }
    function assertArrayExpression(node3, opts) {
      assert2("ArrayExpression", node3, opts);
    }
    function assertAssignmentExpression(node3, opts) {
      assert2("AssignmentExpression", node3, opts);
    }
    function assertBinaryExpression(node3, opts) {
      assert2("BinaryExpression", node3, opts);
    }
    function assertInterpreterDirective(node3, opts) {
      assert2("InterpreterDirective", node3, opts);
    }
    function assertDirective(node3, opts) {
      assert2("Directive", node3, opts);
    }
    function assertDirectiveLiteral(node3, opts) {
      assert2("DirectiveLiteral", node3, opts);
    }
    function assertBlockStatement(node3, opts) {
      assert2("BlockStatement", node3, opts);
    }
    function assertBreakStatement(node3, opts) {
      assert2("BreakStatement", node3, opts);
    }
    function assertCallExpression(node3, opts) {
      assert2("CallExpression", node3, opts);
    }
    function assertCatchClause(node3, opts) {
      assert2("CatchClause", node3, opts);
    }
    function assertConditionalExpression(node3, opts) {
      assert2("ConditionalExpression", node3, opts);
    }
    function assertContinueStatement(node3, opts) {
      assert2("ContinueStatement", node3, opts);
    }
    function assertDebuggerStatement(node3, opts) {
      assert2("DebuggerStatement", node3, opts);
    }
    function assertDoWhileStatement(node3, opts) {
      assert2("DoWhileStatement", node3, opts);
    }
    function assertEmptyStatement(node3, opts) {
      assert2("EmptyStatement", node3, opts);
    }
    function assertExpressionStatement(node3, opts) {
      assert2("ExpressionStatement", node3, opts);
    }
    function assertFile(node3, opts) {
      assert2("File", node3, opts);
    }
    function assertForInStatement(node3, opts) {
      assert2("ForInStatement", node3, opts);
    }
    function assertForStatement(node3, opts) {
      assert2("ForStatement", node3, opts);
    }
    function assertFunctionDeclaration(node3, opts) {
      assert2("FunctionDeclaration", node3, opts);
    }
    function assertFunctionExpression(node3, opts) {
      assert2("FunctionExpression", node3, opts);
    }
    function assertIdentifier(node3, opts) {
      assert2("Identifier", node3, opts);
    }
    function assertIfStatement(node3, opts) {
      assert2("IfStatement", node3, opts);
    }
    function assertLabeledStatement(node3, opts) {
      assert2("LabeledStatement", node3, opts);
    }
    function assertStringLiteral(node3, opts) {
      assert2("StringLiteral", node3, opts);
    }
    function assertNumericLiteral(node3, opts) {
      assert2("NumericLiteral", node3, opts);
    }
    function assertNullLiteral(node3, opts) {
      assert2("NullLiteral", node3, opts);
    }
    function assertBooleanLiteral(node3, opts) {
      assert2("BooleanLiteral", node3, opts);
    }
    function assertRegExpLiteral(node3, opts) {
      assert2("RegExpLiteral", node3, opts);
    }
    function assertLogicalExpression(node3, opts) {
      assert2("LogicalExpression", node3, opts);
    }
    function assertMemberExpression(node3, opts) {
      assert2("MemberExpression", node3, opts);
    }
    function assertNewExpression(node3, opts) {
      assert2("NewExpression", node3, opts);
    }
    function assertProgram(node3, opts) {
      assert2("Program", node3, opts);
    }
    function assertObjectExpression(node3, opts) {
      assert2("ObjectExpression", node3, opts);
    }
    function assertObjectMethod(node3, opts) {
      assert2("ObjectMethod", node3, opts);
    }
    function assertObjectProperty(node3, opts) {
      assert2("ObjectProperty", node3, opts);
    }
    function assertRestElement(node3, opts) {
      assert2("RestElement", node3, opts);
    }
    function assertReturnStatement(node3, opts) {
      assert2("ReturnStatement", node3, opts);
    }
    function assertSequenceExpression(node3, opts) {
      assert2("SequenceExpression", node3, opts);
    }
    function assertParenthesizedExpression(node3, opts) {
      assert2("ParenthesizedExpression", node3, opts);
    }
    function assertSwitchCase(node3, opts) {
      assert2("SwitchCase", node3, opts);
    }
    function assertSwitchStatement(node3, opts) {
      assert2("SwitchStatement", node3, opts);
    }
    function assertThisExpression(node3, opts) {
      assert2("ThisExpression", node3, opts);
    }
    function assertThrowStatement(node3, opts) {
      assert2("ThrowStatement", node3, opts);
    }
    function assertTryStatement(node3, opts) {
      assert2("TryStatement", node3, opts);
    }
    function assertUnaryExpression(node3, opts) {
      assert2("UnaryExpression", node3, opts);
    }
    function assertUpdateExpression(node3, opts) {
      assert2("UpdateExpression", node3, opts);
    }
    function assertVariableDeclaration(node3, opts) {
      assert2("VariableDeclaration", node3, opts);
    }
    function assertVariableDeclarator(node3, opts) {
      assert2("VariableDeclarator", node3, opts);
    }
    function assertWhileStatement(node3, opts) {
      assert2("WhileStatement", node3, opts);
    }
    function assertWithStatement(node3, opts) {
      assert2("WithStatement", node3, opts);
    }
    function assertAssignmentPattern(node3, opts) {
      assert2("AssignmentPattern", node3, opts);
    }
    function assertArrayPattern(node3, opts) {
      assert2("ArrayPattern", node3, opts);
    }
    function assertArrowFunctionExpression(node3, opts) {
      assert2("ArrowFunctionExpression", node3, opts);
    }
    function assertClassBody(node3, opts) {
      assert2("ClassBody", node3, opts);
    }
    function assertClassExpression(node3, opts) {
      assert2("ClassExpression", node3, opts);
    }
    function assertClassDeclaration(node3, opts) {
      assert2("ClassDeclaration", node3, opts);
    }
    function assertExportAllDeclaration(node3, opts) {
      assert2("ExportAllDeclaration", node3, opts);
    }
    function assertExportDefaultDeclaration(node3, opts) {
      assert2("ExportDefaultDeclaration", node3, opts);
    }
    function assertExportNamedDeclaration(node3, opts) {
      assert2("ExportNamedDeclaration", node3, opts);
    }
    function assertExportSpecifier(node3, opts) {
      assert2("ExportSpecifier", node3, opts);
    }
    function assertForOfStatement(node3, opts) {
      assert2("ForOfStatement", node3, opts);
    }
    function assertImportDeclaration(node3, opts) {
      assert2("ImportDeclaration", node3, opts);
    }
    function assertImportDefaultSpecifier(node3, opts) {
      assert2("ImportDefaultSpecifier", node3, opts);
    }
    function assertImportNamespaceSpecifier(node3, opts) {
      assert2("ImportNamespaceSpecifier", node3, opts);
    }
    function assertImportSpecifier(node3, opts) {
      assert2("ImportSpecifier", node3, opts);
    }
    function assertImportExpression(node3, opts) {
      assert2("ImportExpression", node3, opts);
    }
    function assertMetaProperty(node3, opts) {
      assert2("MetaProperty", node3, opts);
    }
    function assertClassMethod(node3, opts) {
      assert2("ClassMethod", node3, opts);
    }
    function assertObjectPattern(node3, opts) {
      assert2("ObjectPattern", node3, opts);
    }
    function assertSpreadElement(node3, opts) {
      assert2("SpreadElement", node3, opts);
    }
    function assertSuper(node3, opts) {
      assert2("Super", node3, opts);
    }
    function assertTaggedTemplateExpression(node3, opts) {
      assert2("TaggedTemplateExpression", node3, opts);
    }
    function assertTemplateElement(node3, opts) {
      assert2("TemplateElement", node3, opts);
    }
    function assertTemplateLiteral(node3, opts) {
      assert2("TemplateLiteral", node3, opts);
    }
    function assertYieldExpression(node3, opts) {
      assert2("YieldExpression", node3, opts);
    }
    function assertAwaitExpression(node3, opts) {
      assert2("AwaitExpression", node3, opts);
    }
    function assertImport(node3, opts) {
      assert2("Import", node3, opts);
    }
    function assertBigIntLiteral(node3, opts) {
      assert2("BigIntLiteral", node3, opts);
    }
    function assertExportNamespaceSpecifier(node3, opts) {
      assert2("ExportNamespaceSpecifier", node3, opts);
    }
    function assertOptionalMemberExpression(node3, opts) {
      assert2("OptionalMemberExpression", node3, opts);
    }
    function assertOptionalCallExpression(node3, opts) {
      assert2("OptionalCallExpression", node3, opts);
    }
    function assertClassProperty(node3, opts) {
      assert2("ClassProperty", node3, opts);
    }
    function assertClassAccessorProperty(node3, opts) {
      assert2("ClassAccessorProperty", node3, opts);
    }
    function assertClassPrivateProperty(node3, opts) {
      assert2("ClassPrivateProperty", node3, opts);
    }
    function assertClassPrivateMethod(node3, opts) {
      assert2("ClassPrivateMethod", node3, opts);
    }
    function assertPrivateName(node3, opts) {
      assert2("PrivateName", node3, opts);
    }
    function assertStaticBlock(node3, opts) {
      assert2("StaticBlock", node3, opts);
    }
    function assertAnyTypeAnnotation(node3, opts) {
      assert2("AnyTypeAnnotation", node3, opts);
    }
    function assertArrayTypeAnnotation(node3, opts) {
      assert2("ArrayTypeAnnotation", node3, opts);
    }
    function assertBooleanTypeAnnotation(node3, opts) {
      assert2("BooleanTypeAnnotation", node3, opts);
    }
    function assertBooleanLiteralTypeAnnotation(node3, opts) {
      assert2("BooleanLiteralTypeAnnotation", node3, opts);
    }
    function assertNullLiteralTypeAnnotation(node3, opts) {
      assert2("NullLiteralTypeAnnotation", node3, opts);
    }
    function assertClassImplements(node3, opts) {
      assert2("ClassImplements", node3, opts);
    }
    function assertDeclareClass(node3, opts) {
      assert2("DeclareClass", node3, opts);
    }
    function assertDeclareFunction(node3, opts) {
      assert2("DeclareFunction", node3, opts);
    }
    function assertDeclareInterface(node3, opts) {
      assert2("DeclareInterface", node3, opts);
    }
    function assertDeclareModule(node3, opts) {
      assert2("DeclareModule", node3, opts);
    }
    function assertDeclareModuleExports(node3, opts) {
      assert2("DeclareModuleExports", node3, opts);
    }
    function assertDeclareTypeAlias(node3, opts) {
      assert2("DeclareTypeAlias", node3, opts);
    }
    function assertDeclareOpaqueType(node3, opts) {
      assert2("DeclareOpaqueType", node3, opts);
    }
    function assertDeclareVariable(node3, opts) {
      assert2("DeclareVariable", node3, opts);
    }
    function assertDeclareExportDeclaration(node3, opts) {
      assert2("DeclareExportDeclaration", node3, opts);
    }
    function assertDeclareExportAllDeclaration(node3, opts) {
      assert2("DeclareExportAllDeclaration", node3, opts);
    }
    function assertDeclaredPredicate(node3, opts) {
      assert2("DeclaredPredicate", node3, opts);
    }
    function assertExistsTypeAnnotation(node3, opts) {
      assert2("ExistsTypeAnnotation", node3, opts);
    }
    function assertFunctionTypeAnnotation(node3, opts) {
      assert2("FunctionTypeAnnotation", node3, opts);
    }
    function assertFunctionTypeParam(node3, opts) {
      assert2("FunctionTypeParam", node3, opts);
    }
    function assertGenericTypeAnnotation(node3, opts) {
      assert2("GenericTypeAnnotation", node3, opts);
    }
    function assertInferredPredicate(node3, opts) {
      assert2("InferredPredicate", node3, opts);
    }
    function assertInterfaceExtends(node3, opts) {
      assert2("InterfaceExtends", node3, opts);
    }
    function assertInterfaceDeclaration(node3, opts) {
      assert2("InterfaceDeclaration", node3, opts);
    }
    function assertInterfaceTypeAnnotation(node3, opts) {
      assert2("InterfaceTypeAnnotation", node3, opts);
    }
    function assertIntersectionTypeAnnotation(node3, opts) {
      assert2("IntersectionTypeAnnotation", node3, opts);
    }
    function assertMixedTypeAnnotation(node3, opts) {
      assert2("MixedTypeAnnotation", node3, opts);
    }
    function assertEmptyTypeAnnotation(node3, opts) {
      assert2("EmptyTypeAnnotation", node3, opts);
    }
    function assertNullableTypeAnnotation(node3, opts) {
      assert2("NullableTypeAnnotation", node3, opts);
    }
    function assertNumberLiteralTypeAnnotation(node3, opts) {
      assert2("NumberLiteralTypeAnnotation", node3, opts);
    }
    function assertNumberTypeAnnotation(node3, opts) {
      assert2("NumberTypeAnnotation", node3, opts);
    }
    function assertObjectTypeAnnotation(node3, opts) {
      assert2("ObjectTypeAnnotation", node3, opts);
    }
    function assertObjectTypeInternalSlot(node3, opts) {
      assert2("ObjectTypeInternalSlot", node3, opts);
    }
    function assertObjectTypeCallProperty(node3, opts) {
      assert2("ObjectTypeCallProperty", node3, opts);
    }
    function assertObjectTypeIndexer(node3, opts) {
      assert2("ObjectTypeIndexer", node3, opts);
    }
    function assertObjectTypeProperty(node3, opts) {
      assert2("ObjectTypeProperty", node3, opts);
    }
    function assertObjectTypeSpreadProperty(node3, opts) {
      assert2("ObjectTypeSpreadProperty", node3, opts);
    }
    function assertOpaqueType(node3, opts) {
      assert2("OpaqueType", node3, opts);
    }
    function assertQualifiedTypeIdentifier(node3, opts) {
      assert2("QualifiedTypeIdentifier", node3, opts);
    }
    function assertStringLiteralTypeAnnotation(node3, opts) {
      assert2("StringLiteralTypeAnnotation", node3, opts);
    }
    function assertStringTypeAnnotation(node3, opts) {
      assert2("StringTypeAnnotation", node3, opts);
    }
    function assertSymbolTypeAnnotation(node3, opts) {
      assert2("SymbolTypeAnnotation", node3, opts);
    }
    function assertThisTypeAnnotation(node3, opts) {
      assert2("ThisTypeAnnotation", node3, opts);
    }
    function assertTupleTypeAnnotation(node3, opts) {
      assert2("TupleTypeAnnotation", node3, opts);
    }
    function assertTypeofTypeAnnotation(node3, opts) {
      assert2("TypeofTypeAnnotation", node3, opts);
    }
    function assertTypeAlias(node3, opts) {
      assert2("TypeAlias", node3, opts);
    }
    function assertTypeAnnotation(node3, opts) {
      assert2("TypeAnnotation", node3, opts);
    }
    function assertTypeCastExpression(node3, opts) {
      assert2("TypeCastExpression", node3, opts);
    }
    function assertTypeParameter(node3, opts) {
      assert2("TypeParameter", node3, opts);
    }
    function assertTypeParameterDeclaration(node3, opts) {
      assert2("TypeParameterDeclaration", node3, opts);
    }
    function assertTypeParameterInstantiation(node3, opts) {
      assert2("TypeParameterInstantiation", node3, opts);
    }
    function assertUnionTypeAnnotation(node3, opts) {
      assert2("UnionTypeAnnotation", node3, opts);
    }
    function assertVariance(node3, opts) {
      assert2("Variance", node3, opts);
    }
    function assertVoidTypeAnnotation(node3, opts) {
      assert2("VoidTypeAnnotation", node3, opts);
    }
    function assertEnumDeclaration(node3, opts) {
      assert2("EnumDeclaration", node3, opts);
    }
    function assertEnumBooleanBody(node3, opts) {
      assert2("EnumBooleanBody", node3, opts);
    }
    function assertEnumNumberBody(node3, opts) {
      assert2("EnumNumberBody", node3, opts);
    }
    function assertEnumStringBody(node3, opts) {
      assert2("EnumStringBody", node3, opts);
    }
    function assertEnumSymbolBody(node3, opts) {
      assert2("EnumSymbolBody", node3, opts);
    }
    function assertEnumBooleanMember(node3, opts) {
      assert2("EnumBooleanMember", node3, opts);
    }
    function assertEnumNumberMember(node3, opts) {
      assert2("EnumNumberMember", node3, opts);
    }
    function assertEnumStringMember(node3, opts) {
      assert2("EnumStringMember", node3, opts);
    }
    function assertEnumDefaultedMember(node3, opts) {
      assert2("EnumDefaultedMember", node3, opts);
    }
    function assertIndexedAccessType(node3, opts) {
      assert2("IndexedAccessType", node3, opts);
    }
    function assertOptionalIndexedAccessType(node3, opts) {
      assert2("OptionalIndexedAccessType", node3, opts);
    }
    function assertJSXAttribute(node3, opts) {
      assert2("JSXAttribute", node3, opts);
    }
    function assertJSXClosingElement(node3, opts) {
      assert2("JSXClosingElement", node3, opts);
    }
    function assertJSXElement(node3, opts) {
      assert2("JSXElement", node3, opts);
    }
    function assertJSXEmptyExpression(node3, opts) {
      assert2("JSXEmptyExpression", node3, opts);
    }
    function assertJSXExpressionContainer(node3, opts) {
      assert2("JSXExpressionContainer", node3, opts);
    }
    function assertJSXSpreadChild(node3, opts) {
      assert2("JSXSpreadChild", node3, opts);
    }
    function assertJSXIdentifier(node3, opts) {
      assert2("JSXIdentifier", node3, opts);
    }
    function assertJSXMemberExpression(node3, opts) {
      assert2("JSXMemberExpression", node3, opts);
    }
    function assertJSXNamespacedName(node3, opts) {
      assert2("JSXNamespacedName", node3, opts);
    }
    function assertJSXOpeningElement(node3, opts) {
      assert2("JSXOpeningElement", node3, opts);
    }
    function assertJSXSpreadAttribute(node3, opts) {
      assert2("JSXSpreadAttribute", node3, opts);
    }
    function assertJSXText(node3, opts) {
      assert2("JSXText", node3, opts);
    }
    function assertJSXFragment(node3, opts) {
      assert2("JSXFragment", node3, opts);
    }
    function assertJSXOpeningFragment(node3, opts) {
      assert2("JSXOpeningFragment", node3, opts);
    }
    function assertJSXClosingFragment(node3, opts) {
      assert2("JSXClosingFragment", node3, opts);
    }
    function assertNoop(node3, opts) {
      assert2("Noop", node3, opts);
    }
    function assertPlaceholder(node3, opts) {
      assert2("Placeholder", node3, opts);
    }
    function assertV8IntrinsicIdentifier(node3, opts) {
      assert2("V8IntrinsicIdentifier", node3, opts);
    }
    function assertArgumentPlaceholder(node3, opts) {
      assert2("ArgumentPlaceholder", node3, opts);
    }
    function assertBindExpression(node3, opts) {
      assert2("BindExpression", node3, opts);
    }
    function assertImportAttribute(node3, opts) {
      assert2("ImportAttribute", node3, opts);
    }
    function assertDecorator(node3, opts) {
      assert2("Decorator", node3, opts);
    }
    function assertDoExpression(node3, opts) {
      assert2("DoExpression", node3, opts);
    }
    function assertExportDefaultSpecifier(node3, opts) {
      assert2("ExportDefaultSpecifier", node3, opts);
    }
    function assertRecordExpression(node3, opts) {
      assert2("RecordExpression", node3, opts);
    }
    function assertTupleExpression(node3, opts) {
      assert2("TupleExpression", node3, opts);
    }
    function assertDecimalLiteral(node3, opts) {
      assert2("DecimalLiteral", node3, opts);
    }
    function assertModuleExpression(node3, opts) {
      assert2("ModuleExpression", node3, opts);
    }
    function assertTopicReference(node3, opts) {
      assert2("TopicReference", node3, opts);
    }
    function assertPipelineTopicExpression(node3, opts) {
      assert2("PipelineTopicExpression", node3, opts);
    }
    function assertPipelineBareFunction(node3, opts) {
      assert2("PipelineBareFunction", node3, opts);
    }
    function assertPipelinePrimaryTopicReference(node3, opts) {
      assert2("PipelinePrimaryTopicReference", node3, opts);
    }
    function assertTSParameterProperty(node3, opts) {
      assert2("TSParameterProperty", node3, opts);
    }
    function assertTSDeclareFunction(node3, opts) {
      assert2("TSDeclareFunction", node3, opts);
    }
    function assertTSDeclareMethod(node3, opts) {
      assert2("TSDeclareMethod", node3, opts);
    }
    function assertTSQualifiedName(node3, opts) {
      assert2("TSQualifiedName", node3, opts);
    }
    function assertTSCallSignatureDeclaration(node3, opts) {
      assert2("TSCallSignatureDeclaration", node3, opts);
    }
    function assertTSConstructSignatureDeclaration(node3, opts) {
      assert2("TSConstructSignatureDeclaration", node3, opts);
    }
    function assertTSPropertySignature(node3, opts) {
      assert2("TSPropertySignature", node3, opts);
    }
    function assertTSMethodSignature(node3, opts) {
      assert2("TSMethodSignature", node3, opts);
    }
    function assertTSIndexSignature(node3, opts) {
      assert2("TSIndexSignature", node3, opts);
    }
    function assertTSAnyKeyword(node3, opts) {
      assert2("TSAnyKeyword", node3, opts);
    }
    function assertTSBooleanKeyword(node3, opts) {
      assert2("TSBooleanKeyword", node3, opts);
    }
    function assertTSBigIntKeyword(node3, opts) {
      assert2("TSBigIntKeyword", node3, opts);
    }
    function assertTSIntrinsicKeyword(node3, opts) {
      assert2("TSIntrinsicKeyword", node3, opts);
    }
    function assertTSNeverKeyword(node3, opts) {
      assert2("TSNeverKeyword", node3, opts);
    }
    function assertTSNullKeyword(node3, opts) {
      assert2("TSNullKeyword", node3, opts);
    }
    function assertTSNumberKeyword(node3, opts) {
      assert2("TSNumberKeyword", node3, opts);
    }
    function assertTSObjectKeyword(node3, opts) {
      assert2("TSObjectKeyword", node3, opts);
    }
    function assertTSStringKeyword(node3, opts) {
      assert2("TSStringKeyword", node3, opts);
    }
    function assertTSSymbolKeyword(node3, opts) {
      assert2("TSSymbolKeyword", node3, opts);
    }
    function assertTSUndefinedKeyword(node3, opts) {
      assert2("TSUndefinedKeyword", node3, opts);
    }
    function assertTSUnknownKeyword(node3, opts) {
      assert2("TSUnknownKeyword", node3, opts);
    }
    function assertTSVoidKeyword(node3, opts) {
      assert2("TSVoidKeyword", node3, opts);
    }
    function assertTSThisType(node3, opts) {
      assert2("TSThisType", node3, opts);
    }
    function assertTSFunctionType(node3, opts) {
      assert2("TSFunctionType", node3, opts);
    }
    function assertTSConstructorType(node3, opts) {
      assert2("TSConstructorType", node3, opts);
    }
    function assertTSTypeReference(node3, opts) {
      assert2("TSTypeReference", node3, opts);
    }
    function assertTSTypePredicate(node3, opts) {
      assert2("TSTypePredicate", node3, opts);
    }
    function assertTSTypeQuery(node3, opts) {
      assert2("TSTypeQuery", node3, opts);
    }
    function assertTSTypeLiteral(node3, opts) {
      assert2("TSTypeLiteral", node3, opts);
    }
    function assertTSArrayType(node3, opts) {
      assert2("TSArrayType", node3, opts);
    }
    function assertTSTupleType(node3, opts) {
      assert2("TSTupleType", node3, opts);
    }
    function assertTSOptionalType(node3, opts) {
      assert2("TSOptionalType", node3, opts);
    }
    function assertTSRestType(node3, opts) {
      assert2("TSRestType", node3, opts);
    }
    function assertTSNamedTupleMember(node3, opts) {
      assert2("TSNamedTupleMember", node3, opts);
    }
    function assertTSUnionType(node3, opts) {
      assert2("TSUnionType", node3, opts);
    }
    function assertTSIntersectionType(node3, opts) {
      assert2("TSIntersectionType", node3, opts);
    }
    function assertTSConditionalType(node3, opts) {
      assert2("TSConditionalType", node3, opts);
    }
    function assertTSInferType(node3, opts) {
      assert2("TSInferType", node3, opts);
    }
    function assertTSParenthesizedType(node3, opts) {
      assert2("TSParenthesizedType", node3, opts);
    }
    function assertTSTypeOperator(node3, opts) {
      assert2("TSTypeOperator", node3, opts);
    }
    function assertTSIndexedAccessType(node3, opts) {
      assert2("TSIndexedAccessType", node3, opts);
    }
    function assertTSMappedType(node3, opts) {
      assert2("TSMappedType", node3, opts);
    }
    function assertTSTemplateLiteralType(node3, opts) {
      assert2("TSTemplateLiteralType", node3, opts);
    }
    function assertTSLiteralType(node3, opts) {
      assert2("TSLiteralType", node3, opts);
    }
    function assertTSExpressionWithTypeArguments(node3, opts) {
      assert2("TSExpressionWithTypeArguments", node3, opts);
    }
    function assertTSInterfaceDeclaration(node3, opts) {
      assert2("TSInterfaceDeclaration", node3, opts);
    }
    function assertTSInterfaceBody(node3, opts) {
      assert2("TSInterfaceBody", node3, opts);
    }
    function assertTSTypeAliasDeclaration(node3, opts) {
      assert2("TSTypeAliasDeclaration", node3, opts);
    }
    function assertTSInstantiationExpression(node3, opts) {
      assert2("TSInstantiationExpression", node3, opts);
    }
    function assertTSAsExpression(node3, opts) {
      assert2("TSAsExpression", node3, opts);
    }
    function assertTSSatisfiesExpression(node3, opts) {
      assert2("TSSatisfiesExpression", node3, opts);
    }
    function assertTSTypeAssertion(node3, opts) {
      assert2("TSTypeAssertion", node3, opts);
    }
    function assertTSEnumBody(node3, opts) {
      assert2("TSEnumBody", node3, opts);
    }
    function assertTSEnumDeclaration(node3, opts) {
      assert2("TSEnumDeclaration", node3, opts);
    }
    function assertTSEnumMember(node3, opts) {
      assert2("TSEnumMember", node3, opts);
    }
    function assertTSModuleDeclaration(node3, opts) {
      assert2("TSModuleDeclaration", node3, opts);
    }
    function assertTSModuleBlock(node3, opts) {
      assert2("TSModuleBlock", node3, opts);
    }
    function assertTSImportType(node3, opts) {
      assert2("TSImportType", node3, opts);
    }
    function assertTSImportEqualsDeclaration(node3, opts) {
      assert2("TSImportEqualsDeclaration", node3, opts);
    }
    function assertTSExternalModuleReference(node3, opts) {
      assert2("TSExternalModuleReference", node3, opts);
    }
    function assertTSNonNullExpression(node3, opts) {
      assert2("TSNonNullExpression", node3, opts);
    }
    function assertTSExportAssignment(node3, opts) {
      assert2("TSExportAssignment", node3, opts);
    }
    function assertTSNamespaceExportDeclaration(node3, opts) {
      assert2("TSNamespaceExportDeclaration", node3, opts);
    }
    function assertTSTypeAnnotation(node3, opts) {
      assert2("TSTypeAnnotation", node3, opts);
    }
    function assertTSTypeParameterInstantiation(node3, opts) {
      assert2("TSTypeParameterInstantiation", node3, opts);
    }
    function assertTSTypeParameterDeclaration(node3, opts) {
      assert2("TSTypeParameterDeclaration", node3, opts);
    }
    function assertTSTypeParameter(node3, opts) {
      assert2("TSTypeParameter", node3, opts);
    }
    function assertStandardized(node3, opts) {
      assert2("Standardized", node3, opts);
    }
    function assertExpression(node3, opts) {
      assert2("Expression", node3, opts);
    }
    function assertBinary(node3, opts) {
      assert2("Binary", node3, opts);
    }
    function assertScopable(node3, opts) {
      assert2("Scopable", node3, opts);
    }
    function assertBlockParent(node3, opts) {
      assert2("BlockParent", node3, opts);
    }
    function assertBlock(node3, opts) {
      assert2("Block", node3, opts);
    }
    function assertStatement(node3, opts) {
      assert2("Statement", node3, opts);
    }
    function assertTerminatorless(node3, opts) {
      assert2("Terminatorless", node3, opts);
    }
    function assertCompletionStatement(node3, opts) {
      assert2("CompletionStatement", node3, opts);
    }
    function assertConditional(node3, opts) {
      assert2("Conditional", node3, opts);
    }
    function assertLoop(node3, opts) {
      assert2("Loop", node3, opts);
    }
    function assertWhile(node3, opts) {
      assert2("While", node3, opts);
    }
    function assertExpressionWrapper(node3, opts) {
      assert2("ExpressionWrapper", node3, opts);
    }
    function assertFor(node3, opts) {
      assert2("For", node3, opts);
    }
    function assertForXStatement(node3, opts) {
      assert2("ForXStatement", node3, opts);
    }
    function assertFunction(node3, opts) {
      assert2("Function", node3, opts);
    }
    function assertFunctionParent(node3, opts) {
      assert2("FunctionParent", node3, opts);
    }
    function assertPureish(node3, opts) {
      assert2("Pureish", node3, opts);
    }
    function assertDeclaration(node3, opts) {
      assert2("Declaration", node3, opts);
    }
    function assertPatternLike(node3, opts) {
      assert2("PatternLike", node3, opts);
    }
    function assertLVal(node3, opts) {
      assert2("LVal", node3, opts);
    }
    function assertTSEntityName(node3, opts) {
      assert2("TSEntityName", node3, opts);
    }
    function assertLiteral(node3, opts) {
      assert2("Literal", node3, opts);
    }
    function assertImmutable(node3, opts) {
      assert2("Immutable", node3, opts);
    }
    function assertUserWhitespacable(node3, opts) {
      assert2("UserWhitespacable", node3, opts);
    }
    function assertMethod(node3, opts) {
      assert2("Method", node3, opts);
    }
    function assertObjectMember(node3, opts) {
      assert2("ObjectMember", node3, opts);
    }
    function assertProperty(node3, opts) {
      assert2("Property", node3, opts);
    }
    function assertUnaryLike(node3, opts) {
      assert2("UnaryLike", node3, opts);
    }
    function assertPattern(node3, opts) {
      assert2("Pattern", node3, opts);
    }
    function assertClass(node3, opts) {
      assert2("Class", node3, opts);
    }
    function assertImportOrExportDeclaration(node3, opts) {
      assert2("ImportOrExportDeclaration", node3, opts);
    }
    function assertExportDeclaration(node3, opts) {
      assert2("ExportDeclaration", node3, opts);
    }
    function assertModuleSpecifier(node3, opts) {
      assert2("ModuleSpecifier", node3, opts);
    }
    function assertAccessor(node3, opts) {
      assert2("Accessor", node3, opts);
    }
    function assertPrivate(node3, opts) {
      assert2("Private", node3, opts);
    }
    function assertFlow(node3, opts) {
      assert2("Flow", node3, opts);
    }
    function assertFlowType(node3, opts) {
      assert2("FlowType", node3, opts);
    }
    function assertFlowBaseAnnotation(node3, opts) {
      assert2("FlowBaseAnnotation", node3, opts);
    }
    function assertFlowDeclaration(node3, opts) {
      assert2("FlowDeclaration", node3, opts);
    }
    function assertFlowPredicate(node3, opts) {
      assert2("FlowPredicate", node3, opts);
    }
    function assertEnumBody(node3, opts) {
      assert2("EnumBody", node3, opts);
    }
    function assertEnumMember(node3, opts) {
      assert2("EnumMember", node3, opts);
    }
    function assertJSX(node3, opts) {
      assert2("JSX", node3, opts);
    }
    function assertMiscellaneous(node3, opts) {
      assert2("Miscellaneous", node3, opts);
    }
    function assertTypeScript(node3, opts) {
      assert2("TypeScript", node3, opts);
    }
    function assertTSTypeElement(node3, opts) {
      assert2("TSTypeElement", node3, opts);
    }
    function assertTSType(node3, opts) {
      assert2("TSType", node3, opts);
    }
    function assertTSBaseType(node3, opts) {
      assert2("TSBaseType", node3, opts);
    }
    function assertNumberLiteral(node3, opts) {
      (0, _deprecationWarning.default)("assertNumberLiteral", "assertNumericLiteral");
      assert2("NumberLiteral", node3, opts);
    }
    function assertRegexLiteral(node3, opts) {
      (0, _deprecationWarning.default)("assertRegexLiteral", "assertRegExpLiteral");
      assert2("RegexLiteral", node3, opts);
    }
    function assertRestProperty(node3, opts) {
      (0, _deprecationWarning.default)("assertRestProperty", "assertRestElement");
      assert2("RestProperty", node3, opts);
    }
    function assertSpreadProperty(node3, opts) {
      (0, _deprecationWarning.default)("assertSpreadProperty", "assertSpreadElement");
      assert2("SpreadProperty", node3, opts);
    }
    function assertModuleDeclaration(node3, opts) {
      (0, _deprecationWarning.default)("assertModuleDeclaration", "assertImportOrExportDeclaration");
      assert2("ModuleDeclaration", node3, opts);
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js
var require_createTypeAnnotationBasedOnTypeof = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createTypeAnnotationBasedOnTypeof.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_generated2();
    var _default = exports2.default = createTypeAnnotationBasedOnTypeof;
    function createTypeAnnotationBasedOnTypeof(type) {
      switch (type) {
        case "string":
          return (0, _index.stringTypeAnnotation)();
        case "number":
          return (0, _index.numberTypeAnnotation)();
        case "undefined":
          return (0, _index.voidTypeAnnotation)();
        case "boolean":
          return (0, _index.booleanTypeAnnotation)();
        case "function":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Function"));
        case "object":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Object"));
        case "symbol":
          return (0, _index.genericTypeAnnotation)((0, _index.identifier)("Symbol"));
        case "bigint":
          return (0, _index.anyTypeAnnotation)();
      }
      throw new Error("Invalid typeof value: " + type);
    }
  }
});

// node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js
var require_removeTypeDuplicates = __commonJS({
  "node_modules/@babel/types/lib/modifications/flow/removeTypeDuplicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node3) {
      return (0, _index.isIdentifier)(node3) ? node3.name : `${node3.id.name}.${getQualifiedName(node3.qualification)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types3 = [];
      for (let i = 0; i < nodes.length; i++) {
        const node3 = nodes[i];
        if (!node3) continue;
        if (types3.includes(node3)) {
          continue;
        }
        if ((0, _index.isAnyTypeAnnotation)(node3)) {
          return [node3];
        }
        if ((0, _index.isFlowBaseAnnotation)(node3)) {
          bases.set(node3.type, node3);
          continue;
        }
        if ((0, _index.isUnionTypeAnnotation)(node3)) {
          if (!typeGroups.has(node3.types)) {
            nodes.push(...node3.types);
            typeGroups.add(node3.types);
          }
          continue;
        }
        if ((0, _index.isGenericTypeAnnotation)(node3)) {
          const name2 = getQualifiedName(node3.id);
          if (generics.has(name2)) {
            let existing = generics.get(name2);
            if (existing.typeParameters) {
              if (node3.typeParameters) {
                existing.typeParameters.params.push(...node3.typeParameters.params);
                existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params);
              }
            } else {
              existing = node3.typeParameters;
            }
          } else {
            generics.set(name2, node3);
          }
          continue;
        }
        types3.push(node3);
      }
      for (const [, baseType] of bases) {
        types3.push(baseType);
      }
      for (const [, genericName] of generics) {
        types3.push(genericName);
      }
      return types3;
    }
  }
});

// node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js
var require_createFlowUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/flow/createFlowUnionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createFlowUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    function createFlowUnionType(types3) {
      const flattened = (0, _removeTypeDuplicates.default)(types3);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.unionTypeAnnotation)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js
var require_removeTypeDuplicates2 = __commonJS({
  "node_modules/@babel/types/lib/modifications/typescript/removeTypeDuplicates.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeTypeDuplicates;
    var _index = require_generated();
    function getQualifiedName(node3) {
      return (0, _index.isIdentifier)(node3) ? node3.name : (0, _index.isThisExpression)(node3) ? "this" : `${node3.right.name}.${getQualifiedName(node3.left)}`;
    }
    function removeTypeDuplicates(nodesIn) {
      const nodes = Array.from(nodesIn);
      const generics = /* @__PURE__ */ new Map();
      const bases = /* @__PURE__ */ new Map();
      const typeGroups = /* @__PURE__ */ new Set();
      const types3 = [];
      for (let i = 0; i < nodes.length; i++) {
        const node3 = nodes[i];
        if (!node3) continue;
        if (types3.includes(node3)) {
          continue;
        }
        if ((0, _index.isTSAnyKeyword)(node3)) {
          return [node3];
        }
        if ((0, _index.isTSBaseType)(node3)) {
          bases.set(node3.type, node3);
          continue;
        }
        if ((0, _index.isTSUnionType)(node3)) {
          if (!typeGroups.has(node3.types)) {
            nodes.push(...node3.types);
            typeGroups.add(node3.types);
          }
          continue;
        }
        const typeArgumentsKey = "typeParameters";
        if ((0, _index.isTSTypeReference)(node3) && node3[typeArgumentsKey]) {
          const typeArguments = node3[typeArgumentsKey];
          const name2 = getQualifiedName(node3.typeName);
          if (generics.has(name2)) {
            let existing = generics.get(name2);
            const existingTypeArguments = existing[typeArgumentsKey];
            if (existingTypeArguments) {
              existingTypeArguments.params.push(...typeArguments.params);
              existingTypeArguments.params = removeTypeDuplicates(existingTypeArguments.params);
            } else {
              existing = typeArguments;
            }
          } else {
            generics.set(name2, node3);
          }
          continue;
        }
        types3.push(node3);
      }
      for (const [, baseType] of bases) {
        types3.push(baseType);
      }
      for (const [, genericName] of generics) {
        types3.push(genericName);
      }
      return types3;
    }
  }
});

// node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js
var require_createTSUnionType = __commonJS({
  "node_modules/@babel/types/lib/builders/typescript/createTSUnionType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createTSUnionType;
    var _index = require_generated2();
    var _removeTypeDuplicates = require_removeTypeDuplicates2();
    var _index2 = require_generated();
    function createTSUnionType(typeAnnotations) {
      const types3 = typeAnnotations.map((type) => {
        return (0, _index2.isTSTypeAnnotation)(type) ? type.typeAnnotation : type;
      });
      const flattened = (0, _removeTypeDuplicates.default)(types3);
      if (flattened.length === 1) {
        return flattened[0];
      } else {
        return (0, _index.tsUnionType)(flattened);
      }
    }
  }
});

// node_modules/@babel/types/lib/builders/productions.js
var require_productions = __commonJS({
  "node_modules/@babel/types/lib/builders/productions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildUndefinedNode = buildUndefinedNode;
    var _index = require_generated2();
    function buildUndefinedNode() {
      return (0, _index.unaryExpression)("void", (0, _index.numericLiteral)(0), true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneNode.js
var require_cloneNode = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneNode;
    var _index = require_definitions();
    var _index2 = require_generated();
    var {
      hasOwn
    } = {
      hasOwn: Function.call.bind(Object.prototype.hasOwnProperty)
    };
    function cloneIfNode(obj, deep2, withoutLoc, commentsCache) {
      if (obj && typeof obj.type === "string") {
        return cloneNodeInternal(obj, deep2, withoutLoc, commentsCache);
      }
      return obj;
    }
    function cloneIfNodeOrArray(obj, deep2, withoutLoc, commentsCache) {
      if (Array.isArray(obj)) {
        return obj.map((node3) => cloneIfNode(node3, deep2, withoutLoc, commentsCache));
      }
      return cloneIfNode(obj, deep2, withoutLoc, commentsCache);
    }
    function cloneNode(node3, deep2 = true, withoutLoc = false) {
      return cloneNodeInternal(node3, deep2, withoutLoc, /* @__PURE__ */ new Map());
    }
    function cloneNodeInternal(node3, deep2 = true, withoutLoc = false, commentsCache) {
      if (!node3) return node3;
      const {
        type
      } = node3;
      const newNode = {
        type: node3.type
      };
      if ((0, _index2.isIdentifier)(node3)) {
        newNode.name = node3.name;
        if (hasOwn(node3, "optional") && typeof node3.optional === "boolean") {
          newNode.optional = node3.optional;
        }
        if (hasOwn(node3, "typeAnnotation")) {
          newNode.typeAnnotation = deep2 ? cloneIfNodeOrArray(node3.typeAnnotation, true, withoutLoc, commentsCache) : node3.typeAnnotation;
        }
        if (hasOwn(node3, "decorators")) {
          newNode.decorators = deep2 ? cloneIfNodeOrArray(node3.decorators, true, withoutLoc, commentsCache) : node3.decorators;
        }
      } else if (!hasOwn(_index.NODE_FIELDS, type)) {
        throw new Error(`Unknown node type: "${type}"`);
      } else {
        for (const field of Object.keys(_index.NODE_FIELDS[type])) {
          if (hasOwn(node3, field)) {
            if (deep2) {
              newNode[field] = (0, _index2.isFile)(node3) && field === "comments" ? maybeCloneComments(node3.comments, deep2, withoutLoc, commentsCache) : cloneIfNodeOrArray(node3[field], true, withoutLoc, commentsCache);
            } else {
              newNode[field] = node3[field];
            }
          }
        }
      }
      if (hasOwn(node3, "loc")) {
        if (withoutLoc) {
          newNode.loc = null;
        } else {
          newNode.loc = node3.loc;
        }
      }
      if (hasOwn(node3, "leadingComments")) {
        newNode.leadingComments = maybeCloneComments(node3.leadingComments, deep2, withoutLoc, commentsCache);
      }
      if (hasOwn(node3, "innerComments")) {
        newNode.innerComments = maybeCloneComments(node3.innerComments, deep2, withoutLoc, commentsCache);
      }
      if (hasOwn(node3, "trailingComments")) {
        newNode.trailingComments = maybeCloneComments(node3.trailingComments, deep2, withoutLoc, commentsCache);
      }
      if (hasOwn(node3, "extra")) {
        newNode.extra = Object.assign({}, node3.extra);
      }
      return newNode;
    }
    function maybeCloneComments(comments, deep2, withoutLoc, commentsCache) {
      if (!comments || !deep2) {
        return comments;
      }
      return comments.map((comment4) => {
        const cache2 = commentsCache.get(comment4);
        if (cache2) return cache2;
        const {
          type,
          value: value2,
          loc
        } = comment4;
        const ret = {
          type,
          value: value2,
          loc
        };
        if (withoutLoc) {
          ret.loc = null;
        }
        commentsCache.set(comment4, ret);
        return ret;
      });
    }
  }
});

// node_modules/@babel/types/lib/clone/clone.js
var require_clone = __commonJS({
  "node_modules/@babel/types/lib/clone/clone.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = clone;
    var _cloneNode = require_cloneNode();
    function clone(node3) {
      return (0, _cloneNode.default)(node3, false);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneDeep;
    var _cloneNode = require_cloneNode();
    function cloneDeep(node3) {
      return (0, _cloneNode.default)(node3);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js
var require_cloneDeepWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneDeepWithoutLoc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneDeepWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneDeepWithoutLoc(node3) {
      return (0, _cloneNode.default)(node3, true, true);
    }
  }
});

// node_modules/@babel/types/lib/clone/cloneWithoutLoc.js
var require_cloneWithoutLoc = __commonJS({
  "node_modules/@babel/types/lib/clone/cloneWithoutLoc.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = cloneWithoutLoc;
    var _cloneNode = require_cloneNode();
    function cloneWithoutLoc(node3) {
      return (0, _cloneNode.default)(node3, false, true);
    }
  }
});

// node_modules/@babel/types/lib/comments/addComments.js
var require_addComments = __commonJS({
  "node_modules/@babel/types/lib/comments/addComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = addComments;
    function addComments(node3, type, comments) {
      if (!comments || !node3) return node3;
      const key = `${type}Comments`;
      if (node3[key]) {
        if (type === "leading") {
          node3[key] = comments.concat(node3[key]);
        } else {
          node3[key].push(...comments);
        }
      } else {
        node3[key] = comments;
      }
      return node3;
    }
  }
});

// node_modules/@babel/types/lib/comments/addComment.js
var require_addComment = __commonJS({
  "node_modules/@babel/types/lib/comments/addComment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = addComment;
    var _addComments = require_addComments();
    function addComment(node3, type, content, line) {
      return (0, _addComments.default)(node3, type, [{
        type: line ? "CommentLine" : "CommentBlock",
        value: content
      }]);
    }
  }
});

// node_modules/@babel/types/lib/utils/inherit.js
var require_inherit = __commonJS({
  "node_modules/@babel/types/lib/utils/inherit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inherit;
    function inherit(key, child, parent) {
      if (child && parent) {
        child[key] = Array.from(new Set([].concat(child[key], parent[key]).filter(Boolean)));
      }
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritInnerComments.js
var require_inheritInnerComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritInnerComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritInnerComments;
    var _inherit = require_inherit();
    function inheritInnerComments(child, parent) {
      (0, _inherit.default)("innerComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritLeadingComments.js
var require_inheritLeadingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritLeadingComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritLeadingComments;
    var _inherit = require_inherit();
    function inheritLeadingComments(child, parent) {
      (0, _inherit.default)("leadingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritTrailingComments.js
var require_inheritTrailingComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritTrailingComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritTrailingComments;
    var _inherit = require_inherit();
    function inheritTrailingComments(child, parent) {
      (0, _inherit.default)("trailingComments", child, parent);
    }
  }
});

// node_modules/@babel/types/lib/comments/inheritsComments.js
var require_inheritsComments = __commonJS({
  "node_modules/@babel/types/lib/comments/inheritsComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inheritsComments;
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritInnerComments = require_inheritInnerComments();
    function inheritsComments(child, parent) {
      (0, _inheritTrailingComments.default)(child, parent);
      (0, _inheritLeadingComments.default)(child, parent);
      (0, _inheritInnerComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/comments/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/@babel/types/lib/comments/removeComments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeComments;
    var _index = require_constants();
    function removeComments(node3) {
      _index.COMMENT_KEYS.forEach((key) => {
        node3[key] = null;
      });
      return node3;
    }
  }
});

// node_modules/@babel/types/lib/constants/generated/index.js
var require_generated4 = __commonJS({
  "node_modules/@babel/types/lib/constants/generated/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WHILE_TYPES = exports2.USERWHITESPACABLE_TYPES = exports2.UNARYLIKE_TYPES = exports2.TYPESCRIPT_TYPES = exports2.TSTYPE_TYPES = exports2.TSTYPEELEMENT_TYPES = exports2.TSENTITYNAME_TYPES = exports2.TSBASETYPE_TYPES = exports2.TERMINATORLESS_TYPES = exports2.STATEMENT_TYPES = exports2.STANDARDIZED_TYPES = exports2.SCOPABLE_TYPES = exports2.PUREISH_TYPES = exports2.PROPERTY_TYPES = exports2.PRIVATE_TYPES = exports2.PATTERN_TYPES = exports2.PATTERNLIKE_TYPES = exports2.OBJECTMEMBER_TYPES = exports2.MODULESPECIFIER_TYPES = exports2.MODULEDECLARATION_TYPES = exports2.MISCELLANEOUS_TYPES = exports2.METHOD_TYPES = exports2.LVAL_TYPES = exports2.LOOP_TYPES = exports2.LITERAL_TYPES = exports2.JSX_TYPES = exports2.IMPORTOREXPORTDECLARATION_TYPES = exports2.IMMUTABLE_TYPES = exports2.FUNCTION_TYPES = exports2.FUNCTIONPARENT_TYPES = exports2.FOR_TYPES = exports2.FORXSTATEMENT_TYPES = exports2.FLOW_TYPES = exports2.FLOWTYPE_TYPES = exports2.FLOWPREDICATE_TYPES = exports2.FLOWDECLARATION_TYPES = exports2.FLOWBASEANNOTATION_TYPES = exports2.EXPRESSION_TYPES = exports2.EXPRESSIONWRAPPER_TYPES = exports2.EXPORTDECLARATION_TYPES = exports2.ENUMMEMBER_TYPES = exports2.ENUMBODY_TYPES = exports2.DECLARATION_TYPES = exports2.CONDITIONAL_TYPES = exports2.COMPLETIONSTATEMENT_TYPES = exports2.CLASS_TYPES = exports2.BLOCK_TYPES = exports2.BLOCKPARENT_TYPES = exports2.BINARY_TYPES = exports2.ACCESSOR_TYPES = void 0;
    var _index = require_definitions();
    var STANDARDIZED_TYPES = exports2.STANDARDIZED_TYPES = _index.FLIPPED_ALIAS_KEYS["Standardized"];
    var EXPRESSION_TYPES = exports2.EXPRESSION_TYPES = _index.FLIPPED_ALIAS_KEYS["Expression"];
    var BINARY_TYPES2 = exports2.BINARY_TYPES = _index.FLIPPED_ALIAS_KEYS["Binary"];
    var SCOPABLE_TYPES = exports2.SCOPABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Scopable"];
    var BLOCKPARENT_TYPES = exports2.BLOCKPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["BlockParent"];
    var BLOCK_TYPES = exports2.BLOCK_TYPES = _index.FLIPPED_ALIAS_KEYS["Block"];
    var STATEMENT_TYPES = exports2.STATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["Statement"];
    var TERMINATORLESS_TYPES = exports2.TERMINATORLESS_TYPES = _index.FLIPPED_ALIAS_KEYS["Terminatorless"];
    var COMPLETIONSTATEMENT_TYPES = exports2.COMPLETIONSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["CompletionStatement"];
    var CONDITIONAL_TYPES = exports2.CONDITIONAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Conditional"];
    var LOOP_TYPES = exports2.LOOP_TYPES = _index.FLIPPED_ALIAS_KEYS["Loop"];
    var WHILE_TYPES = exports2.WHILE_TYPES = _index.FLIPPED_ALIAS_KEYS["While"];
    var EXPRESSIONWRAPPER_TYPES = exports2.EXPRESSIONWRAPPER_TYPES = _index.FLIPPED_ALIAS_KEYS["ExpressionWrapper"];
    var FOR_TYPES = exports2.FOR_TYPES = _index.FLIPPED_ALIAS_KEYS["For"];
    var FORXSTATEMENT_TYPES = exports2.FORXSTATEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["ForXStatement"];
    var FUNCTION_TYPES = exports2.FUNCTION_TYPES = _index.FLIPPED_ALIAS_KEYS["Function"];
    var FUNCTIONPARENT_TYPES = exports2.FUNCTIONPARENT_TYPES = _index.FLIPPED_ALIAS_KEYS["FunctionParent"];
    var PUREISH_TYPES = exports2.PUREISH_TYPES = _index.FLIPPED_ALIAS_KEYS["Pureish"];
    var DECLARATION_TYPES = exports2.DECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["Declaration"];
    var PATTERNLIKE_TYPES = exports2.PATTERNLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["PatternLike"];
    var LVAL_TYPES = exports2.LVAL_TYPES = _index.FLIPPED_ALIAS_KEYS["LVal"];
    var TSENTITYNAME_TYPES = exports2.TSENTITYNAME_TYPES = _index.FLIPPED_ALIAS_KEYS["TSEntityName"];
    var LITERAL_TYPES = exports2.LITERAL_TYPES = _index.FLIPPED_ALIAS_KEYS["Literal"];
    var IMMUTABLE_TYPES = exports2.IMMUTABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["Immutable"];
    var USERWHITESPACABLE_TYPES = exports2.USERWHITESPACABLE_TYPES = _index.FLIPPED_ALIAS_KEYS["UserWhitespacable"];
    var METHOD_TYPES = exports2.METHOD_TYPES = _index.FLIPPED_ALIAS_KEYS["Method"];
    var OBJECTMEMBER_TYPES = exports2.OBJECTMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["ObjectMember"];
    var PROPERTY_TYPES = exports2.PROPERTY_TYPES = _index.FLIPPED_ALIAS_KEYS["Property"];
    var UNARYLIKE_TYPES = exports2.UNARYLIKE_TYPES = _index.FLIPPED_ALIAS_KEYS["UnaryLike"];
    var PATTERN_TYPES = exports2.PATTERN_TYPES = _index.FLIPPED_ALIAS_KEYS["Pattern"];
    var CLASS_TYPES = exports2.CLASS_TYPES = _index.FLIPPED_ALIAS_KEYS["Class"];
    var IMPORTOREXPORTDECLARATION_TYPES = exports2.IMPORTOREXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ImportOrExportDeclaration"];
    var EXPORTDECLARATION_TYPES = exports2.EXPORTDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["ExportDeclaration"];
    var MODULESPECIFIER_TYPES = exports2.MODULESPECIFIER_TYPES = _index.FLIPPED_ALIAS_KEYS["ModuleSpecifier"];
    var ACCESSOR_TYPES = exports2.ACCESSOR_TYPES = _index.FLIPPED_ALIAS_KEYS["Accessor"];
    var PRIVATE_TYPES = exports2.PRIVATE_TYPES = _index.FLIPPED_ALIAS_KEYS["Private"];
    var FLOW_TYPES = exports2.FLOW_TYPES = _index.FLIPPED_ALIAS_KEYS["Flow"];
    var FLOWTYPE_TYPES = exports2.FLOWTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowType"];
    var FLOWBASEANNOTATION_TYPES = exports2.FLOWBASEANNOTATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowBaseAnnotation"];
    var FLOWDECLARATION_TYPES = exports2.FLOWDECLARATION_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowDeclaration"];
    var FLOWPREDICATE_TYPES = exports2.FLOWPREDICATE_TYPES = _index.FLIPPED_ALIAS_KEYS["FlowPredicate"];
    var ENUMBODY_TYPES = exports2.ENUMBODY_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumBody"];
    var ENUMMEMBER_TYPES = exports2.ENUMMEMBER_TYPES = _index.FLIPPED_ALIAS_KEYS["EnumMember"];
    var JSX_TYPES = exports2.JSX_TYPES = _index.FLIPPED_ALIAS_KEYS["JSX"];
    var MISCELLANEOUS_TYPES = exports2.MISCELLANEOUS_TYPES = _index.FLIPPED_ALIAS_KEYS["Miscellaneous"];
    var TYPESCRIPT_TYPES = exports2.TYPESCRIPT_TYPES = _index.FLIPPED_ALIAS_KEYS["TypeScript"];
    var TSTYPEELEMENT_TYPES = exports2.TSTYPEELEMENT_TYPES = _index.FLIPPED_ALIAS_KEYS["TSTypeElement"];
    var TSTYPE_TYPES = exports2.TSTYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSType"];
    var TSBASETYPE_TYPES = exports2.TSBASETYPE_TYPES = _index.FLIPPED_ALIAS_KEYS["TSBaseType"];
    var MODULEDECLARATION_TYPES = exports2.MODULEDECLARATION_TYPES = IMPORTOREXPORTDECLARATION_TYPES;
  }
});

// node_modules/@babel/types/lib/converters/toBlock.js
var require_toBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/toBlock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toBlock;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toBlock(node3, parent) {
      if ((0, _index.isBlockStatement)(node3)) {
        return node3;
      }
      let blockNodes = [];
      if ((0, _index.isEmptyStatement)(node3)) {
        blockNodes = [];
      } else {
        if (!(0, _index.isStatement)(node3)) {
          if ((0, _index.isFunction)(parent)) {
            node3 = (0, _index2.returnStatement)(node3);
          } else {
            node3 = (0, _index2.expressionStatement)(node3);
          }
        }
        blockNodes = [node3];
      }
      return (0, _index2.blockStatement)(blockNodes);
    }
  }
});

// node_modules/@babel/types/lib/converters/ensureBlock.js
var require_ensureBlock = __commonJS({
  "node_modules/@babel/types/lib/converters/ensureBlock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = ensureBlock;
    var _toBlock = require_toBlock();
    function ensureBlock(node3, key = "body") {
      const result = (0, _toBlock.default)(node3[key], node3);
      node3[key] = result;
      return result;
    }
  }
});

// node_modules/@babel/types/lib/converters/toIdentifier.js
var require_toIdentifier = __commonJS({
  "node_modules/@babel/types/lib/converters/toIdentifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toIdentifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var _helperValidatorIdentifier = require_lib();
    function toIdentifier(input) {
      input = input + "";
      let name2 = "";
      for (const c of input) {
        name2 += (0, _helperValidatorIdentifier.isIdentifierChar)(c.codePointAt(0)) ? c : "-";
      }
      name2 = name2.replace(/^[-0-9]+/, "");
      name2 = name2.replace(/[-\s]+(.)?/g, function(match2, c) {
        return c ? c.toUpperCase() : "";
      });
      if (!(0, _isValidIdentifier.default)(name2)) {
        name2 = `_${name2}`;
      }
      return name2 || "_";
    }
  }
});

// node_modules/@babel/types/lib/converters/toBindingIdentifierName.js
var require_toBindingIdentifierName = __commonJS({
  "node_modules/@babel/types/lib/converters/toBindingIdentifierName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toBindingIdentifierName;
    var _toIdentifier = require_toIdentifier();
    function toBindingIdentifierName(name2) {
      name2 = (0, _toIdentifier.default)(name2);
      if (name2 === "eval" || name2 === "arguments") name2 = "_" + name2;
      return name2;
    }
  }
});

// node_modules/@babel/types/lib/converters/toComputedKey.js
var require_toComputedKey = __commonJS({
  "node_modules/@babel/types/lib/converters/toComputedKey.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toComputedKey;
    var _index = require_generated();
    var _index2 = require_generated2();
    function toComputedKey(node3, key = node3.key || node3.property) {
      if (!node3.computed && (0, _index.isIdentifier)(key)) key = (0, _index2.stringLiteral)(key.name);
      return key;
    }
  }
});

// node_modules/@babel/types/lib/converters/toExpression.js
var require_toExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_generated();
    var _default = exports2.default = toExpression;
    function toExpression(node3) {
      if ((0, _index.isExpressionStatement)(node3)) {
        node3 = node3.expression;
      }
      if ((0, _index.isExpression)(node3)) {
        return node3;
      }
      if ((0, _index.isClass)(node3)) {
        node3.type = "ClassExpression";
      } else if ((0, _index.isFunction)(node3)) {
        node3.type = "FunctionExpression";
      }
      if (!(0, _index.isExpression)(node3)) {
        throw new Error(`cannot turn ${node3.type} to an expression`);
      }
      return node3;
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverseFast.js
var require_traverseFast = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverseFast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = traverseFast;
    var _index = require_definitions();
    function traverseFast(node3, enter, opts) {
      if (!node3) return;
      const keys = _index.VISITOR_KEYS[node3.type];
      if (!keys) return;
      opts = opts || {};
      enter(node3, opts);
      for (const key of keys) {
        const subNode = node3[key];
        if (Array.isArray(subNode)) {
          for (const node4 of subNode) {
            traverseFast(node4, enter, opts);
          }
        } else {
          traverseFast(subNode, enter, opts);
        }
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removeProperties.js
var require_removeProperties = __commonJS({
  "node_modules/@babel/types/lib/modifications/removeProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removeProperties;
    var _index = require_constants();
    var CLEAR_KEYS = ["tokens", "start", "end", "loc", "raw", "rawValue"];
    var CLEAR_KEYS_PLUS_COMMENTS = [..._index.COMMENT_KEYS, "comments", ...CLEAR_KEYS];
    function removeProperties(node3, opts = {}) {
      const map = opts.preserveComments ? CLEAR_KEYS : CLEAR_KEYS_PLUS_COMMENTS;
      for (const key of map) {
        if (node3[key] != null) node3[key] = void 0;
      }
      for (const key of Object.keys(node3)) {
        if (key[0] === "_" && node3[key] != null) node3[key] = void 0;
      }
      const symbols = Object.getOwnPropertySymbols(node3);
      for (const sym of symbols) {
        node3[sym] = null;
      }
    }
  }
});

// node_modules/@babel/types/lib/modifications/removePropertiesDeep.js
var require_removePropertiesDeep = __commonJS({
  "node_modules/@babel/types/lib/modifications/removePropertiesDeep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = removePropertiesDeep;
    var _traverseFast = require_traverseFast();
    var _removeProperties = require_removeProperties();
    function removePropertiesDeep(tree, opts) {
      (0, _traverseFast.default)(tree, _removeProperties.default, opts);
      return tree;
    }
  }
});

// node_modules/@babel/types/lib/converters/toKeyAlias.js
var require_toKeyAlias = __commonJS({
  "node_modules/@babel/types/lib/converters/toKeyAlias.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toKeyAlias;
    var _index = require_generated();
    var _cloneNode = require_cloneNode();
    var _removePropertiesDeep = require_removePropertiesDeep();
    function toKeyAlias(node3, key = node3.key) {
      let alias;
      if (node3.kind === "method") {
        return toKeyAlias.increment() + "";
      } else if ((0, _index.isIdentifier)(key)) {
        alias = key.name;
      } else if ((0, _index.isStringLiteral)(key)) {
        alias = JSON.stringify(key.value);
      } else {
        alias = JSON.stringify((0, _removePropertiesDeep.default)((0, _cloneNode.default)(key)));
      }
      if (node3.computed) {
        alias = `[${alias}]`;
      }
      if (node3.static) {
        alias = `static:${alias}`;
      }
      return alias;
    }
    toKeyAlias.uid = 0;
    toKeyAlias.increment = function() {
      if (toKeyAlias.uid >= Number.MAX_SAFE_INTEGER) {
        return toKeyAlias.uid = 0;
      } else {
        return toKeyAlias.uid++;
      }
    };
  }
});

// node_modules/@babel/types/lib/converters/toStatement.js
var require_toStatement = __commonJS({
  "node_modules/@babel/types/lib/converters/toStatement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_generated();
    var _index2 = require_generated2();
    var _default = exports2.default = toStatement;
    function toStatement(node3, ignore) {
      if ((0, _index.isStatement)(node3)) {
        return node3;
      }
      let mustHaveId = false;
      let newType;
      if ((0, _index.isClass)(node3)) {
        mustHaveId = true;
        newType = "ClassDeclaration";
      } else if ((0, _index.isFunction)(node3)) {
        mustHaveId = true;
        newType = "FunctionDeclaration";
      } else if ((0, _index.isAssignmentExpression)(node3)) {
        return (0, _index2.expressionStatement)(node3);
      }
      if (mustHaveId && !node3.id) {
        newType = false;
      }
      if (!newType) {
        if (ignore) {
          return false;
        } else {
          throw new Error(`cannot turn ${node3.type} to a statement`);
        }
      }
      node3.type = newType;
      return node3;
    }
  }
});

// node_modules/@babel/types/lib/converters/valueToNode.js
var require_valueToNode = __commonJS({
  "node_modules/@babel/types/lib/converters/valueToNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _isValidIdentifier = require_isValidIdentifier();
    var _index = require_generated2();
    var _default = exports2.default = valueToNode;
    var objectToString2 = Function.call.bind(Object.prototype.toString);
    function isRegExp(value2) {
      return objectToString2(value2) === "[object RegExp]";
    }
    function isPlainObject(value2) {
      if (typeof value2 !== "object" || value2 === null || Object.prototype.toString.call(value2) !== "[object Object]") {
        return false;
      }
      const proto2 = Object.getPrototypeOf(value2);
      return proto2 === null || Object.getPrototypeOf(proto2) === null;
    }
    function valueToNode(value2) {
      if (value2 === void 0) {
        return (0, _index.identifier)("undefined");
      }
      if (value2 === true || value2 === false) {
        return (0, _index.booleanLiteral)(value2);
      }
      if (value2 === null) {
        return (0, _index.nullLiteral)();
      }
      if (typeof value2 === "string") {
        return (0, _index.stringLiteral)(value2);
      }
      if (typeof value2 === "number") {
        let result;
        if (Number.isFinite(value2)) {
          result = (0, _index.numericLiteral)(Math.abs(value2));
        } else {
          let numerator;
          if (Number.isNaN(value2)) {
            numerator = (0, _index.numericLiteral)(0);
          } else {
            numerator = (0, _index.numericLiteral)(1);
          }
          result = (0, _index.binaryExpression)("/", numerator, (0, _index.numericLiteral)(0));
        }
        if (value2 < 0 || Object.is(value2, -0)) {
          result = (0, _index.unaryExpression)("-", result);
        }
        return result;
      }
      if (isRegExp(value2)) {
        const pattern2 = value2.source;
        const flags = /\/([a-z]*)$/.exec(value2.toString())[1];
        return (0, _index.regExpLiteral)(pattern2, flags);
      }
      if (Array.isArray(value2)) {
        return (0, _index.arrayExpression)(value2.map(valueToNode));
      }
      if (isPlainObject(value2)) {
        const props = [];
        for (const key of Object.keys(value2)) {
          let nodeKey;
          if ((0, _isValidIdentifier.default)(key)) {
            nodeKey = (0, _index.identifier)(key);
          } else {
            nodeKey = (0, _index.stringLiteral)(key);
          }
          props.push((0, _index.objectProperty)(nodeKey, valueToNode(value2[key])));
        }
        return (0, _index.objectExpression)(props);
      }
      throw new Error("don't know how to turn this value into a node");
    }
  }
});

// node_modules/@babel/types/lib/modifications/appendToMemberExpression.js
var require_appendToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/appendToMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = appendToMemberExpression;
    var _index = require_generated2();
    function appendToMemberExpression(member, append2, computed = false) {
      member.object = (0, _index.memberExpression)(member.object, member.property, member.computed);
      member.property = append2;
      member.computed = !!computed;
      return member;
    }
  }
});

// node_modules/@babel/types/lib/modifications/inherits.js
var require_inherits = __commonJS({
  "node_modules/@babel/types/lib/modifications/inherits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inherits;
    var _index = require_constants();
    var _inheritsComments = require_inheritsComments();
    function inherits(child, parent) {
      if (!child || !parent) return child;
      for (const key of _index.INHERIT_KEYS.optional) {
        if (child[key] == null) {
          child[key] = parent[key];
        }
      }
      for (const key of Object.keys(parent)) {
        if (key[0] === "_" && key !== "__clone") {
          child[key] = parent[key];
        }
      }
      for (const key of _index.INHERIT_KEYS.force) {
        child[key] = parent[key];
      }
      (0, _inheritsComments.default)(child, parent);
      return child;
    }
  }
});

// node_modules/@babel/types/lib/modifications/prependToMemberExpression.js
var require_prependToMemberExpression = __commonJS({
  "node_modules/@babel/types/lib/modifications/prependToMemberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = prependToMemberExpression;
    var _index = require_generated2();
    var _index2 = require_lib3();
    function prependToMemberExpression(member, prepend) {
      if ((0, _index2.isSuper)(member.object)) {
        throw new Error("Cannot prepend node to super property access (`super.foo`).");
      }
      member.object = (0, _index.memberExpression)(prepend, member.object);
      return member;
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js
var require_getAssignmentIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getAssignmentIdentifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getAssignmentIdentifiers;
    function getAssignmentIdentifiers(node3) {
      const search = [].concat(node3);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id3 = search.pop();
        if (!id3) continue;
        switch (id3.type) {
          case "ArrayPattern":
            search.push(...id3.elements);
            break;
          case "AssignmentExpression":
          case "AssignmentPattern":
          case "ForInStatement":
          case "ForOfStatement":
            search.push(id3.left);
            break;
          case "ObjectPattern":
            search.push(...id3.properties);
            break;
          case "ObjectProperty":
            search.push(id3.value);
            break;
          case "RestElement":
          case "UpdateExpression":
            search.push(id3.argument);
            break;
          case "UnaryExpression":
            if (id3.operator === "delete") {
              search.push(id3.argument);
            }
            break;
          case "Identifier":
            ids[id3.name] = id3;
            break;
          default:
            break;
        }
      }
      return ids;
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js
var require_getBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getBindingIdentifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getBindingIdentifiers;
    var _index = require_generated();
    function getBindingIdentifiers(node3, duplicates, outerOnly, newBindingsOnly) {
      const search = [].concat(node3);
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id3 = search.shift();
        if (!id3) continue;
        if (newBindingsOnly && ((0, _index.isAssignmentExpression)(id3) || (0, _index.isUnaryExpression)(id3) || (0, _index.isUpdateExpression)(id3))) {
          continue;
        }
        if ((0, _index.isIdentifier)(id3)) {
          if (duplicates) {
            const _ids = ids[id3.name] = ids[id3.name] || [];
            _ids.push(id3);
          } else {
            ids[id3.name] = id3;
          }
          continue;
        }
        if ((0, _index.isExportDeclaration)(id3) && !(0, _index.isExportAllDeclaration)(id3)) {
          if ((0, _index.isDeclaration)(id3.declaration)) {
            search.push(id3.declaration);
          }
          continue;
        }
        if (outerOnly) {
          if ((0, _index.isFunctionDeclaration)(id3)) {
            search.push(id3.id);
            continue;
          }
          if ((0, _index.isFunctionExpression)(id3)) {
            continue;
          }
        }
        const keys2 = getBindingIdentifiers.keys[id3.type];
        if (keys2) {
          for (let i = 0; i < keys2.length; i++) {
            const key = keys2[i];
            const nodes = id3[key];
            if (nodes) {
              if (Array.isArray(nodes)) {
                search.push(...nodes);
              } else {
                search.push(nodes);
              }
            }
          }
        }
      }
      return ids;
    }
    var keys = {
      DeclareClass: ["id"],
      DeclareFunction: ["id"],
      DeclareModule: ["id"],
      DeclareVariable: ["id"],
      DeclareInterface: ["id"],
      DeclareTypeAlias: ["id"],
      DeclareOpaqueType: ["id"],
      InterfaceDeclaration: ["id"],
      TypeAlias: ["id"],
      OpaqueType: ["id"],
      CatchClause: ["param"],
      LabeledStatement: ["label"],
      UnaryExpression: ["argument"],
      AssignmentExpression: ["left"],
      ImportSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportDefaultSpecifier: ["local"],
      ImportDeclaration: ["specifiers"],
      TSImportEqualsDeclaration: ["id"],
      ExportSpecifier: ["exported"],
      ExportNamespaceSpecifier: ["exported"],
      ExportDefaultSpecifier: ["exported"],
      FunctionDeclaration: ["id", "params"],
      FunctionExpression: ["id", "params"],
      ArrowFunctionExpression: ["params"],
      ObjectMethod: ["params"],
      ClassMethod: ["params"],
      ClassPrivateMethod: ["params"],
      ForInStatement: ["left"],
      ForOfStatement: ["left"],
      ClassDeclaration: ["id"],
      ClassExpression: ["id"],
      RestElement: ["argument"],
      UpdateExpression: ["argument"],
      ObjectProperty: ["value"],
      AssignmentPattern: ["left"],
      ArrayPattern: ["elements"],
      ObjectPattern: ["properties"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id"]
    };
    getBindingIdentifiers.keys = keys;
  }
});

// node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js
var require_getOuterBindingIdentifiers = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getOuterBindingIdentifiers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _default = exports2.default = getOuterBindingIdentifiers;
    function getOuterBindingIdentifiers(node3, duplicates) {
      return (0, _getBindingIdentifiers.default)(node3, duplicates, true);
    }
  }
});

// node_modules/@babel/types/lib/retrievers/getFunctionName.js
var require_getFunctionName = __commonJS({
  "node_modules/@babel/types/lib/retrievers/getFunctionName.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getFunctionName;
    var _index = require_generated();
    function getNameFromLiteralId(id3) {
      if ((0, _index.isNullLiteral)(id3)) {
        return "null";
      }
      if ((0, _index.isRegExpLiteral)(id3)) {
        return `/${id3.pattern}/${id3.flags}`;
      }
      if ((0, _index.isTemplateLiteral)(id3)) {
        return id3.quasis.map((quasi) => quasi.value.raw).join("");
      }
      if (id3.value !== void 0) {
        return String(id3.value);
      }
      return null;
    }
    function getObjectMemberKey(node3) {
      if (!node3.computed || (0, _index.isLiteral)(node3.key)) {
        return node3.key;
      }
    }
    function getFunctionName(node3, parent) {
      if ("id" in node3 && node3.id) {
        return {
          name: node3.id.name,
          originalNode: node3.id
        };
      }
      let prefix = "";
      let id3;
      if ((0, _index.isObjectProperty)(parent, {
        value: node3
      })) {
        id3 = getObjectMemberKey(parent);
      } else if ((0, _index.isObjectMethod)(node3) || (0, _index.isClassMethod)(node3)) {
        id3 = getObjectMemberKey(node3);
        if (node3.kind === "get") prefix = "get ";
        else if (node3.kind === "set") prefix = "set ";
      } else if ((0, _index.isVariableDeclarator)(parent, {
        init: node3
      })) {
        id3 = parent.id;
      } else if ((0, _index.isAssignmentExpression)(parent, {
        operator: "=",
        right: node3
      })) {
        id3 = parent.left;
      }
      if (!id3) return null;
      const name2 = (0, _index.isLiteral)(id3) ? getNameFromLiteralId(id3) : (0, _index.isIdentifier)(id3) ? id3.name : (0, _index.isPrivateName)(id3) ? id3.id.name : null;
      if (name2 == null) return null;
      return {
        name: prefix + name2,
        originalNode: id3
      };
    }
  }
});

// node_modules/@babel/types/lib/traverse/traverse.js
var require_traverse = __commonJS({
  "node_modules/@babel/types/lib/traverse/traverse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = traverse;
    var _index = require_definitions();
    function traverse(node3, handlers, state) {
      if (typeof handlers === "function") {
        handlers = {
          enter: handlers
        };
      }
      const {
        enter,
        exit
      } = handlers;
      traverseSimpleImpl(node3, enter, exit, state, []);
    }
    function traverseSimpleImpl(node3, enter, exit, state, ancestors) {
      const keys = _index.VISITOR_KEYS[node3.type];
      if (!keys) return;
      if (enter) enter(node3, ancestors, state);
      for (const key of keys) {
        const subNode = node3[key];
        if (Array.isArray(subNode)) {
          for (let i = 0; i < subNode.length; i++) {
            const child = subNode[i];
            if (!child) continue;
            ancestors.push({
              node: node3,
              key,
              index: i
            });
            traverseSimpleImpl(child, enter, exit, state, ancestors);
            ancestors.pop();
          }
        } else if (subNode) {
          ancestors.push({
            node: node3,
            key
          });
          traverseSimpleImpl(subNode, enter, exit, state, ancestors);
          ancestors.pop();
        }
      }
      if (exit) exit(node3, ancestors, state);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBinding.js
var require_isBinding = __commonJS({
  "node_modules/@babel/types/lib/validators/isBinding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBinding;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    function isBinding(node3, parent, grandparent) {
      if (grandparent && node3.type === "Identifier" && parent.type === "ObjectProperty" && grandparent.type === "ObjectExpression") {
        return false;
      }
      const keys = _getBindingIdentifiers.default.keys[parent.type];
      if (keys) {
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const val = parent[key];
          if (Array.isArray(val)) {
            if (val.includes(node3)) return true;
          } else {
            if (val === node3) return true;
          }
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isLet.js
var require_isLet = __commonJS({
  "node_modules/@babel/types/lib/validators/isLet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isLet;
    var _index = require_generated();
    var _index2 = require_constants();
    function isLet(node3) {
      return (0, _index.isVariableDeclaration)(node3) && (node3.kind !== "var" || node3[_index2.BLOCK_SCOPED_SYMBOL]);
    }
  }
});

// node_modules/@babel/types/lib/validators/isBlockScoped.js
var require_isBlockScoped = __commonJS({
  "node_modules/@babel/types/lib/validators/isBlockScoped.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isBlockScoped;
    var _index = require_generated();
    var _isLet = require_isLet();
    function isBlockScoped(node3) {
      return (0, _index.isFunctionDeclaration)(node3) || (0, _index.isClassDeclaration)(node3) || (0, _isLet.default)(node3);
    }
  }
});

// node_modules/@babel/types/lib/validators/isImmutable.js
var require_isImmutable = __commonJS({
  "node_modules/@babel/types/lib/validators/isImmutable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isImmutable;
    var _isType = require_isType();
    var _index = require_generated();
    function isImmutable(node3) {
      if ((0, _isType.default)(node3.type, "Immutable")) return true;
      if ((0, _index.isIdentifier)(node3)) {
        if (node3.name === "undefined") {
          return true;
        } else {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/types/lib/validators/isNodesEquivalent.js
var require_isNodesEquivalent = __commonJS({
  "node_modules/@babel/types/lib/validators/isNodesEquivalent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isNodesEquivalent;
    var _index = require_definitions();
    function isNodesEquivalent(a, b) {
      if (typeof a !== "object" || typeof b !== "object" || a == null || b == null) {
        return a === b;
      }
      if (a.type !== b.type) {
        return false;
      }
      const fields = Object.keys(_index.NODE_FIELDS[a.type] || a.type);
      const visitorKeys = _index.VISITOR_KEYS[a.type];
      for (const field of fields) {
        const val_a = a[field];
        const val_b = b[field];
        if (typeof val_a !== typeof val_b) {
          return false;
        }
        if (val_a == null && val_b == null) {
          continue;
        } else if (val_a == null || val_b == null) {
          return false;
        }
        if (Array.isArray(val_a)) {
          if (!Array.isArray(val_b)) {
            return false;
          }
          if (val_a.length !== val_b.length) {
            return false;
          }
          for (let i = 0; i < val_a.length; i++) {
            if (!isNodesEquivalent(val_a[i], val_b[i])) {
              return false;
            }
          }
          continue;
        }
        if (typeof val_a === "object" && !(visitorKeys != null && visitorKeys.includes(field))) {
          for (const key of Object.keys(val_a)) {
            if (val_a[key] !== val_b[key]) {
              return false;
            }
          }
          continue;
        }
        if (!isNodesEquivalent(val_a, val_b)) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isReferenced.js
var require_isReferenced = __commonJS({
  "node_modules/@babel/types/lib/validators/isReferenced.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isReferenced;
    function isReferenced(node3, parent, grandparent) {
      switch (parent.type) {
        case "MemberExpression":
        case "OptionalMemberExpression":
          if (parent.property === node3) {
            return !!parent.computed;
          }
          return parent.object === node3;
        case "JSXMemberExpression":
          return parent.object === node3;
        case "VariableDeclarator":
          return parent.init === node3;
        case "ArrowFunctionExpression":
          return parent.body === node3;
        case "PrivateName":
          return false;
        case "ClassMethod":
        case "ClassPrivateMethod":
        case "ObjectMethod":
          if (parent.key === node3) {
            return !!parent.computed;
          }
          return false;
        case "ObjectProperty":
          if (parent.key === node3) {
            return !!parent.computed;
          }
          return !grandparent || grandparent.type !== "ObjectPattern";
        case "ClassProperty":
        case "ClassAccessorProperty":
          if (parent.key === node3) {
            return !!parent.computed;
          }
          return true;
        case "ClassPrivateProperty":
          return parent.key !== node3;
        case "ClassDeclaration":
        case "ClassExpression":
          return parent.superClass === node3;
        case "AssignmentExpression":
          return parent.right === node3;
        case "AssignmentPattern":
          return parent.right === node3;
        case "LabeledStatement":
          return false;
        case "CatchClause":
          return false;
        case "RestElement":
          return false;
        case "BreakStatement":
        case "ContinueStatement":
          return false;
        case "FunctionDeclaration":
        case "FunctionExpression":
          return false;
        case "ExportNamespaceSpecifier":
        case "ExportDefaultSpecifier":
          return false;
        case "ExportSpecifier":
          if (grandparent != null && grandparent.source) {
            return false;
          }
          return parent.local === node3;
        case "ImportDefaultSpecifier":
        case "ImportNamespaceSpecifier":
        case "ImportSpecifier":
          return false;
        case "ImportAttribute":
          return false;
        case "JSXAttribute":
          return false;
        case "ObjectPattern":
        case "ArrayPattern":
          return false;
        case "MetaProperty":
          return false;
        case "ObjectTypeProperty":
          return parent.key !== node3;
        case "TSEnumMember":
          return parent.id !== node3;
        case "TSPropertySignature":
          if (parent.key === node3) {
            return !!parent.computed;
          }
          return true;
      }
      return true;
    }
  }
});

// node_modules/@babel/types/lib/validators/isScope.js
var require_isScope = __commonJS({
  "node_modules/@babel/types/lib/validators/isScope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isScope;
    var _index = require_generated();
    function isScope(node3, parent) {
      if ((0, _index.isBlockStatement)(node3) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return false;
      }
      if ((0, _index.isPattern)(node3) && ((0, _index.isFunction)(parent) || (0, _index.isCatchClause)(parent))) {
        return true;
      }
      return (0, _index.isScopable)(node3);
    }
  }
});

// node_modules/@babel/types/lib/validators/isSpecifierDefault.js
var require_isSpecifierDefault = __commonJS({
  "node_modules/@babel/types/lib/validators/isSpecifierDefault.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isSpecifierDefault;
    var _index = require_generated();
    function isSpecifierDefault(specifier) {
      return (0, _index.isImportDefaultSpecifier)(specifier) || (0, _index.isIdentifier)(specifier.imported || specifier.exported, {
        name: "default"
      });
    }
  }
});

// node_modules/@babel/types/lib/validators/isValidES3Identifier.js
var require_isValidES3Identifier = __commonJS({
  "node_modules/@babel/types/lib/validators/isValidES3Identifier.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isValidES3Identifier;
    var _isValidIdentifier = require_isValidIdentifier();
    var RESERVED_WORDS_ES3_ONLY = /* @__PURE__ */ new Set(["abstract", "boolean", "byte", "char", "double", "enum", "final", "float", "goto", "implements", "int", "interface", "long", "native", "package", "private", "protected", "public", "short", "static", "synchronized", "throws", "transient", "volatile"]);
    function isValidES3Identifier(name2) {
      return (0, _isValidIdentifier.default)(name2) && !RESERVED_WORDS_ES3_ONLY.has(name2);
    }
  }
});

// node_modules/@babel/types/lib/validators/isVar.js
var require_isVar = __commonJS({
  "node_modules/@babel/types/lib/validators/isVar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isVar;
    var _index = require_generated();
    var _index2 = require_constants();
    function isVar(node3) {
      return (0, _index.isVariableDeclaration)(node3, {
        kind: "var"
      }) && !node3[_index2.BLOCK_SCOPED_SYMBOL];
    }
  }
});

// node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js
var require_gatherSequenceExpressions = __commonJS({
  "node_modules/@babel/types/lib/converters/gatherSequenceExpressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = gatherSequenceExpressions;
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _index = require_generated();
    var _index2 = require_generated2();
    var _productions = require_productions();
    var _cloneNode = require_cloneNode();
    function gatherSequenceExpressions(nodes, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node3 of nodes) {
        if (!(0, _index.isEmptyStatement)(node3)) {
          ensureLastUndefined = false;
        }
        if ((0, _index.isExpression)(node3)) {
          exprs.push(node3);
        } else if ((0, _index.isExpressionStatement)(node3)) {
          exprs.push(node3.expression);
        } else if ((0, _index.isVariableDeclaration)(node3)) {
          if (node3.kind !== "var") return;
          for (const declar of node3.declarations) {
            const bindings = (0, _getBindingIdentifiers.default)(declar);
            for (const key of Object.keys(bindings)) {
              declars.push({
                kind: node3.kind,
                id: (0, _cloneNode.default)(bindings[key])
              });
            }
            if (declar.init) {
              exprs.push((0, _index2.assignmentExpression)("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if ((0, _index.isIfStatement)(node3)) {
          const consequent = node3.consequent ? gatherSequenceExpressions([node3.consequent], declars) : (0, _productions.buildUndefinedNode)();
          const alternate = node3.alternate ? gatherSequenceExpressions([node3.alternate], declars) : (0, _productions.buildUndefinedNode)();
          if (!consequent || !alternate) return;
          exprs.push((0, _index2.conditionalExpression)(node3.test, consequent, alternate));
        } else if ((0, _index.isBlockStatement)(node3)) {
          const body = gatherSequenceExpressions(node3.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if ((0, _index.isEmptyStatement)(node3)) {
          if (nodes.indexOf(node3) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) {
        exprs.push((0, _productions.buildUndefinedNode)());
      }
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return (0, _index2.sequenceExpression)(exprs);
      }
    }
  }
});

// node_modules/@babel/types/lib/converters/toSequenceExpression.js
var require_toSequenceExpression = __commonJS({
  "node_modules/@babel/types/lib/converters/toSequenceExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = toSequenceExpression;
    var _gatherSequenceExpressions = require_gatherSequenceExpressions();
    function toSequenceExpression(nodes, scope) {
      if (!(nodes != null && nodes.length)) return;
      const declars = [];
      const result = (0, _gatherSequenceExpressions.default)(nodes, declars);
      if (!result) return;
      for (const declar of declars) {
        scope.push(declar);
      }
      return result;
    }
  }
});

// node_modules/@babel/types/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@babel/types/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _exportNames = {
      react: true,
      assertNode: true,
      createTypeAnnotationBasedOnTypeof: true,
      createUnionTypeAnnotation: true,
      createFlowUnionType: true,
      createTSUnionType: true,
      cloneNode: true,
      clone: true,
      cloneDeep: true,
      cloneDeepWithoutLoc: true,
      cloneWithoutLoc: true,
      addComment: true,
      addComments: true,
      inheritInnerComments: true,
      inheritLeadingComments: true,
      inheritsComments: true,
      inheritTrailingComments: true,
      removeComments: true,
      ensureBlock: true,
      toBindingIdentifierName: true,
      toBlock: true,
      toComputedKey: true,
      toExpression: true,
      toIdentifier: true,
      toKeyAlias: true,
      toStatement: true,
      valueToNode: true,
      appendToMemberExpression: true,
      inherits: true,
      prependToMemberExpression: true,
      removeProperties: true,
      removePropertiesDeep: true,
      removeTypeDuplicates: true,
      getAssignmentIdentifiers: true,
      getBindingIdentifiers: true,
      getOuterBindingIdentifiers: true,
      getFunctionName: true,
      traverse: true,
      traverseFast: true,
      shallowEqual: true,
      is: true,
      isBinding: true,
      isBlockScoped: true,
      isImmutable: true,
      isLet: true,
      isNode: true,
      isNodesEquivalent: true,
      isPlaceholderType: true,
      isReferenced: true,
      isScope: true,
      isSpecifierDefault: true,
      isType: true,
      isValidES3Identifier: true,
      isValidIdentifier: true,
      isVar: true,
      matchesPattern: true,
      validate: true,
      buildMatchMemberExpression: true,
      __internal__deprecationWarning: true
    };
    Object.defineProperty(exports2, "__internal__deprecationWarning", {
      enumerable: true,
      get: function() {
        return _deprecationWarning.default;
      }
    });
    Object.defineProperty(exports2, "addComment", {
      enumerable: true,
      get: function() {
        return _addComment.default;
      }
    });
    Object.defineProperty(exports2, "addComments", {
      enumerable: true,
      get: function() {
        return _addComments.default;
      }
    });
    Object.defineProperty(exports2, "appendToMemberExpression", {
      enumerable: true,
      get: function() {
        return _appendToMemberExpression.default;
      }
    });
    Object.defineProperty(exports2, "assertNode", {
      enumerable: true,
      get: function() {
        return _assertNode.default;
      }
    });
    Object.defineProperty(exports2, "buildMatchMemberExpression", {
      enumerable: true,
      get: function() {
        return _buildMatchMemberExpression.default;
      }
    });
    Object.defineProperty(exports2, "clone", {
      enumerable: true,
      get: function() {
        return _clone.default;
      }
    });
    Object.defineProperty(exports2, "cloneDeep", {
      enumerable: true,
      get: function() {
        return _cloneDeep.default;
      }
    });
    Object.defineProperty(exports2, "cloneDeepWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneDeepWithoutLoc.default;
      }
    });
    Object.defineProperty(exports2, "cloneNode", {
      enumerable: true,
      get: function() {
        return _cloneNode.default;
      }
    });
    Object.defineProperty(exports2, "cloneWithoutLoc", {
      enumerable: true,
      get: function() {
        return _cloneWithoutLoc.default;
      }
    });
    Object.defineProperty(exports2, "createFlowUnionType", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports2, "createTSUnionType", {
      enumerable: true,
      get: function() {
        return _createTSUnionType.default;
      }
    });
    Object.defineProperty(exports2, "createTypeAnnotationBasedOnTypeof", {
      enumerable: true,
      get: function() {
        return _createTypeAnnotationBasedOnTypeof.default;
      }
    });
    Object.defineProperty(exports2, "createUnionTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _createFlowUnionType.default;
      }
    });
    Object.defineProperty(exports2, "ensureBlock", {
      enumerable: true,
      get: function() {
        return _ensureBlock.default;
      }
    });
    Object.defineProperty(exports2, "getAssignmentIdentifiers", {
      enumerable: true,
      get: function() {
        return _getAssignmentIdentifiers.default;
      }
    });
    Object.defineProperty(exports2, "getBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports2, "getFunctionName", {
      enumerable: true,
      get: function() {
        return _getFunctionName.default;
      }
    });
    Object.defineProperty(exports2, "getOuterBindingIdentifiers", {
      enumerable: true,
      get: function() {
        return _getOuterBindingIdentifiers.default;
      }
    });
    Object.defineProperty(exports2, "inheritInnerComments", {
      enumerable: true,
      get: function() {
        return _inheritInnerComments.default;
      }
    });
    Object.defineProperty(exports2, "inheritLeadingComments", {
      enumerable: true,
      get: function() {
        return _inheritLeadingComments.default;
      }
    });
    Object.defineProperty(exports2, "inheritTrailingComments", {
      enumerable: true,
      get: function() {
        return _inheritTrailingComments.default;
      }
    });
    Object.defineProperty(exports2, "inherits", {
      enumerable: true,
      get: function() {
        return _inherits.default;
      }
    });
    Object.defineProperty(exports2, "inheritsComments", {
      enumerable: true,
      get: function() {
        return _inheritsComments.default;
      }
    });
    Object.defineProperty(exports2, "is", {
      enumerable: true,
      get: function() {
        return _is.default;
      }
    });
    Object.defineProperty(exports2, "isBinding", {
      enumerable: true,
      get: function() {
        return _isBinding.default;
      }
    });
    Object.defineProperty(exports2, "isBlockScoped", {
      enumerable: true,
      get: function() {
        return _isBlockScoped.default;
      }
    });
    Object.defineProperty(exports2, "isImmutable", {
      enumerable: true,
      get: function() {
        return _isImmutable.default;
      }
    });
    Object.defineProperty(exports2, "isLet", {
      enumerable: true,
      get: function() {
        return _isLet.default;
      }
    });
    Object.defineProperty(exports2, "isNode", {
      enumerable: true,
      get: function() {
        return _isNode.default;
      }
    });
    Object.defineProperty(exports2, "isNodesEquivalent", {
      enumerable: true,
      get: function() {
        return _isNodesEquivalent.default;
      }
    });
    Object.defineProperty(exports2, "isPlaceholderType", {
      enumerable: true,
      get: function() {
        return _isPlaceholderType.default;
      }
    });
    Object.defineProperty(exports2, "isReferenced", {
      enumerable: true,
      get: function() {
        return _isReferenced.default;
      }
    });
    Object.defineProperty(exports2, "isScope", {
      enumerable: true,
      get: function() {
        return _isScope.default;
      }
    });
    Object.defineProperty(exports2, "isSpecifierDefault", {
      enumerable: true,
      get: function() {
        return _isSpecifierDefault.default;
      }
    });
    Object.defineProperty(exports2, "isType", {
      enumerable: true,
      get: function() {
        return _isType.default;
      }
    });
    Object.defineProperty(exports2, "isValidES3Identifier", {
      enumerable: true,
      get: function() {
        return _isValidES3Identifier.default;
      }
    });
    Object.defineProperty(exports2, "isValidIdentifier", {
      enumerable: true,
      get: function() {
        return _isValidIdentifier.default;
      }
    });
    Object.defineProperty(exports2, "isVar", {
      enumerable: true,
      get: function() {
        return _isVar.default;
      }
    });
    Object.defineProperty(exports2, "matchesPattern", {
      enumerable: true,
      get: function() {
        return _matchesPattern.default;
      }
    });
    Object.defineProperty(exports2, "prependToMemberExpression", {
      enumerable: true,
      get: function() {
        return _prependToMemberExpression.default;
      }
    });
    exports2.react = void 0;
    Object.defineProperty(exports2, "removeComments", {
      enumerable: true,
      get: function() {
        return _removeComments.default;
      }
    });
    Object.defineProperty(exports2, "removeProperties", {
      enumerable: true,
      get: function() {
        return _removeProperties.default;
      }
    });
    Object.defineProperty(exports2, "removePropertiesDeep", {
      enumerable: true,
      get: function() {
        return _removePropertiesDeep.default;
      }
    });
    Object.defineProperty(exports2, "removeTypeDuplicates", {
      enumerable: true,
      get: function() {
        return _removeTypeDuplicates.default;
      }
    });
    Object.defineProperty(exports2, "shallowEqual", {
      enumerable: true,
      get: function() {
        return _shallowEqual.default;
      }
    });
    Object.defineProperty(exports2, "toBindingIdentifierName", {
      enumerable: true,
      get: function() {
        return _toBindingIdentifierName.default;
      }
    });
    Object.defineProperty(exports2, "toBlock", {
      enumerable: true,
      get: function() {
        return _toBlock.default;
      }
    });
    Object.defineProperty(exports2, "toComputedKey", {
      enumerable: true,
      get: function() {
        return _toComputedKey.default;
      }
    });
    Object.defineProperty(exports2, "toExpression", {
      enumerable: true,
      get: function() {
        return _toExpression.default;
      }
    });
    Object.defineProperty(exports2, "toIdentifier", {
      enumerable: true,
      get: function() {
        return _toIdentifier.default;
      }
    });
    Object.defineProperty(exports2, "toKeyAlias", {
      enumerable: true,
      get: function() {
        return _toKeyAlias.default;
      }
    });
    Object.defineProperty(exports2, "toStatement", {
      enumerable: true,
      get: function() {
        return _toStatement.default;
      }
    });
    Object.defineProperty(exports2, "traverse", {
      enumerable: true,
      get: function() {
        return _traverse.default;
      }
    });
    Object.defineProperty(exports2, "traverseFast", {
      enumerable: true,
      get: function() {
        return _traverseFast.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "valueToNode", {
      enumerable: true,
      get: function() {
        return _valueToNode.default;
      }
    });
    var _isReactComponent = require_isReactComponent();
    var _isCompatTag = require_isCompatTag();
    var _buildChildren = require_buildChildren();
    var _assertNode = require_assertNode();
    var _index = require_generated3();
    Object.keys(_index).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index[key];
        }
      });
    });
    var _createTypeAnnotationBasedOnTypeof = require_createTypeAnnotationBasedOnTypeof();
    var _createFlowUnionType = require_createFlowUnionType();
    var _createTSUnionType = require_createTSUnionType();
    var _productions = require_productions();
    Object.keys(_productions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _productions[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _productions[key];
        }
      });
    });
    var _index2 = require_generated2();
    Object.keys(_index2).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index2[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index2[key];
        }
      });
    });
    var _cloneNode = require_cloneNode();
    var _clone = require_clone();
    var _cloneDeep = require_cloneDeep();
    var _cloneDeepWithoutLoc = require_cloneDeepWithoutLoc();
    var _cloneWithoutLoc = require_cloneWithoutLoc();
    var _addComment = require_addComment();
    var _addComments = require_addComments();
    var _inheritInnerComments = require_inheritInnerComments();
    var _inheritLeadingComments = require_inheritLeadingComments();
    var _inheritsComments = require_inheritsComments();
    var _inheritTrailingComments = require_inheritTrailingComments();
    var _removeComments = require_removeComments();
    var _index3 = require_generated4();
    Object.keys(_index3).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index3[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index3[key];
        }
      });
    });
    var _index4 = require_constants();
    Object.keys(_index4).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index4[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index4[key];
        }
      });
    });
    var _ensureBlock = require_ensureBlock();
    var _toBindingIdentifierName = require_toBindingIdentifierName();
    var _toBlock = require_toBlock();
    var _toComputedKey = require_toComputedKey();
    var _toExpression = require_toExpression();
    var _toIdentifier = require_toIdentifier();
    var _toKeyAlias = require_toKeyAlias();
    var _toStatement = require_toStatement();
    var _valueToNode = require_valueToNode();
    var _index5 = require_definitions();
    Object.keys(_index5).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index5[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index5[key];
        }
      });
    });
    var _appendToMemberExpression = require_appendToMemberExpression();
    var _inherits = require_inherits();
    var _prependToMemberExpression = require_prependToMemberExpression();
    var _removeProperties = require_removeProperties();
    var _removePropertiesDeep = require_removePropertiesDeep();
    var _removeTypeDuplicates = require_removeTypeDuplicates();
    var _getAssignmentIdentifiers = require_getAssignmentIdentifiers();
    var _getBindingIdentifiers = require_getBindingIdentifiers();
    var _getOuterBindingIdentifiers = require_getOuterBindingIdentifiers();
    var _getFunctionName = require_getFunctionName();
    var _traverse = require_traverse();
    Object.keys(_traverse).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _traverse[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _traverse[key];
        }
      });
    });
    var _traverseFast = require_traverseFast();
    var _shallowEqual = require_shallowEqual();
    var _is = require_is();
    var _isBinding = require_isBinding();
    var _isBlockScoped = require_isBlockScoped();
    var _isImmutable = require_isImmutable();
    var _isLet = require_isLet();
    var _isNode = require_isNode();
    var _isNodesEquivalent = require_isNodesEquivalent();
    var _isPlaceholderType = require_isPlaceholderType();
    var _isReferenced = require_isReferenced();
    var _isScope = require_isScope();
    var _isSpecifierDefault = require_isSpecifierDefault();
    var _isType = require_isType();
    var _isValidES3Identifier = require_isValidES3Identifier();
    var _isValidIdentifier = require_isValidIdentifier();
    var _isVar = require_isVar();
    var _matchesPattern = require_matchesPattern();
    var _validate = require_validate();
    var _buildMatchMemberExpression = require_buildMatchMemberExpression();
    var _index6 = require_generated();
    Object.keys(_index6).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports2 && exports2[key] === _index6[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _index6[key];
        }
      });
    });
    var _deprecationWarning = require_deprecationWarning();
    var _toSequenceExpression = require_toSequenceExpression();
    var react = exports2.react = {
      isReactComponent: _isReactComponent.default,
      isCompatTag: _isCompatTag.default,
      buildChildren: _buildChildren.default
    };
    {
      exports2.toSequenceExpression = _toSequenceExpression.default;
    }
    if (process.env.BABEL_TYPES_8_BREAKING) {
      console.warn("BABEL_TYPES_8_BREAKING is not supported anymore. Use the latest Babel 8.0.0 pre-release instead!");
    }
  }
});

// node_modules/@babel/template/lib/formatters.js
var require_formatters = __commonJS({
  "node_modules/@babel/template/lib/formatters.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.statements = exports2.statement = exports2.smart = exports2.program = exports2.expression = void 0;
    var _t = require_lib3();
    var {
      assertExpressionStatement
    } = _t;
    function makeStatementFormatter(fn) {
      return {
        code: (str2) => `/* @babel/template */;
${str2}`,
        validate: () => {
        },
        unwrap: (ast) => {
          return fn(ast.program.body.slice(1));
        }
      };
    }
    var smart = exports2.smart = makeStatementFormatter((body) => {
      if (body.length > 1) {
        return body;
      } else {
        return body[0];
      }
    });
    var statements = exports2.statements = makeStatementFormatter((body) => body);
    var statement = exports2.statement = makeStatementFormatter((body) => {
      if (body.length === 0) {
        throw new Error("Found nothing to return.");
      }
      if (body.length > 1) {
        throw new Error("Found multiple statements but wanted one");
      }
      return body[0];
    });
    var expression = exports2.expression = {
      code: (str2) => `(
${str2}
)`,
      validate: (ast) => {
        if (ast.program.body.length > 1) {
          throw new Error("Found multiple statements but wanted one");
        }
        if (expression.unwrap(ast).start === 0) {
          throw new Error("Parse result included parens.");
        }
      },
      unwrap: ({
        program: program2
      }) => {
        const [stmt] = program2.body;
        assertExpressionStatement(stmt);
        return stmt.expression;
      }
    };
    var program = exports2.program = {
      code: (str2) => str2,
      validate: () => {
      },
      unwrap: (ast) => ast.program
    };
  }
});

// node_modules/@babel/template/lib/options.js
var require_options = __commonJS({
  "node_modules/@babel/template/lib/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.merge = merge3;
    exports2.normalizeReplacements = normalizeReplacements;
    exports2.validate = validate;
    var _excluded = ["placeholderWhitelist", "placeholderPattern", "preserveComments", "syntacticPlaceholders"];
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    function merge3(a, b) {
      const {
        placeholderWhitelist = a.placeholderWhitelist,
        placeholderPattern = a.placeholderPattern,
        preserveComments = a.preserveComments,
        syntacticPlaceholders = a.syntacticPlaceholders
      } = b;
      return {
        parser: Object.assign({}, a.parser, b.parser),
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      };
    }
    function validate(opts) {
      if (opts != null && typeof opts !== "object") {
        throw new Error("Unknown template options.");
      }
      const _ref = opts || {}, {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = _ref, parser2 = _objectWithoutPropertiesLoose(_ref, _excluded);
      if (placeholderWhitelist != null && !(placeholderWhitelist instanceof Set)) {
        throw new Error("'.placeholderWhitelist' must be a Set, null, or undefined");
      }
      if (placeholderPattern != null && !(placeholderPattern instanceof RegExp) && placeholderPattern !== false) {
        throw new Error("'.placeholderPattern' must be a RegExp, false, null, or undefined");
      }
      if (preserveComments != null && typeof preserveComments !== "boolean") {
        throw new Error("'.preserveComments' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders != null && typeof syntacticPlaceholders !== "boolean") {
        throw new Error("'.syntacticPlaceholders' must be a boolean, null, or undefined");
      }
      if (syntacticPlaceholders === true && (placeholderWhitelist != null || placeholderPattern != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      return {
        parser: parser2,
        placeholderWhitelist: placeholderWhitelist || void 0,
        placeholderPattern: placeholderPattern == null ? void 0 : placeholderPattern,
        preserveComments: preserveComments == null ? void 0 : preserveComments,
        syntacticPlaceholders: syntacticPlaceholders == null ? void 0 : syntacticPlaceholders
      };
    }
    function normalizeReplacements(replacements) {
      if (Array.isArray(replacements)) {
        return replacements.reduce((acc, replacement, i) => {
          acc["$" + i] = replacement;
          return acc;
        }, {});
      } else if (typeof replacements === "object" || replacements == null) {
        return replacements || void 0;
      }
      throw new Error("Template replacements must be an array, object, null, or undefined");
    }
  }
});

// node_modules/@babel/parser/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@babel/parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    var Position = class {
      constructor(line, col, index4) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index4;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position, columnOffset) {
      const {
        line,
        column,
        index: index4
      } = position;
      return new Position(line, column + columnOffset, index4 + columnOffset);
    }
    var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = (node3) => node3.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node3.prefix}`] : NodeDescriptions[node3.type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      DynamicImportPhaseRequiresImportExpressions: ({
        phase
      }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedImportAssert` parser plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArity: `\`import()\` requires exactly one or two arguments.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name2) => JSON.stringify(name2)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name2) => JSON.stringify(name2)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword
      }) => `Unexpected keyword '${keyword}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationExport: "Using declaration cannot be exported.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = Object.assign({
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`
    }, {
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    });
    var _excluded = ["message"];
    function defineHidden(obj, key, value2) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value: value2
      });
    }
    function toParseErrorConstructor({
      toMessage,
      code: code2,
      reasonCode,
      syntaxPlugin
    }) {
      const hasMissingPlugin = reasonCode === "MissingPlugin" || reasonCode === "MissingOneOfPlugins";
      {
        const oldReasonCodes = {
          AccessorCannotDeclareThisParameter: "AccesorCannotDeclareThisParameter",
          AccessorCannotHaveTypeParameters: "AccesorCannotHaveTypeParameters",
          ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference",
          SetAccessorCannotHaveOptionalParameter: "SetAccesorCannotHaveOptionalParameter",
          SetAccessorCannotHaveRestParameter: "SetAccesorCannotHaveRestParameter",
          SetAccessorCannotHaveReturnType: "SetAccesorCannotHaveReturnType"
        };
        if (oldReasonCodes[reasonCode]) {
          reasonCode = oldReasonCodes[reasonCode];
        }
      }
      return function constructor(loc, details) {
        const error = new SyntaxError();
        error.code = code2;
        error.reasonCode = reasonCode;
        error.loc = loc;
        error.pos = loc.index;
        error.syntaxPlugin = syntaxPlugin;
        if (hasMissingPlugin) {
          error.missingPlugin = details.missingPlugin;
        }
        defineHidden(error, "clone", function clone(overrides = {}) {
          var _overrides$loc;
          const {
            line,
            column,
            index: index4
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor(new Position(line, column, index4), Object.assign({}, details, overrides.details));
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get() {
            const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            this.message = message;
            return message;
          },
          set(value2) {
            Object.defineProperty(this, "message", {
              value: value2,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref = typeof template === "string" ? {
          message: () => template
        } : typeof template === "function" ? {
          message: template
        } : template, {
          message
        } = _ref, rest = _objectWithoutPropertiesLoose(_ref, _excluded);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    function createDefaultOptions() {
      return {
        sourceType: "script",
        sourceFilename: void 0,
        startIndex: 0,
        startColumn: 0,
        startLine: 1,
        allowAwaitOutsideFunction: false,
        allowReturnOutsideFunction: false,
        allowNewTargetOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowSuperOutsideMethod: false,
        allowUndeclaredExports: false,
        plugins: [],
        strictMode: null,
        ranges: false,
        tokens: false,
        createImportExpressions: false,
        createParenthesizedExpressions: false,
        errorRecovery: false,
        attachComment: true,
        annexB: true
      };
    }
    function getOptions2(opts) {
      const options2 = createDefaultOptions();
      if (opts == null) {
        return options2;
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      for (const key of Object.keys(options2)) {
        if (opts[key] != null) options2[key] = opts[key];
      }
      if (options2.startLine === 1) {
        if (opts.startIndex == null && options2.startColumn > 0) {
          options2.startIndex = options2.startColumn;
        } else if (opts.startColumn == null && options2.startIndex > 0) {
          options2.startColumn = options2.startIndex;
        }
      } else if (opts.startColumn == null || opts.startIndex == null) {
        if (opts.startIndex != null) {
          throw new Error("With a `startLine > 1` you must also specify `startIndex` and `startColumn`.");
        }
      }
      return options2;
    }
    var {
      defineProperty
    } = Object;
    var toUnenumerable = (object2, key) => {
      if (object2) {
        defineProperty(object2, key, {
          enumerable: false,
          value: object2[key]
        });
      }
    };
    function toESTreeLocation(node3) {
      toUnenumerable(node3.loc.start, "index");
      toUnenumerable(node3.loc.end, "index");
      return node3;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.optionFlags & 128) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern: pattern2,
        flags
      }) {
        let regex2 = null;
        try {
          regex2 = new RegExp(pattern2, flags);
        } catch (_) {
        }
        const node3 = this.estreeParseLiteral(regex2);
        node3.regex = {
          pattern: pattern2,
          flags
        };
        return node3;
      }
      parseBigIntLiteral(value2) {
        let bigInt;
        try {
          bigInt = BigInt(value2);
        } catch (_unused) {
          bigInt = null;
        }
        const node3 = this.estreeParseLiteral(bigInt);
        node3.bigint = String(node3.value || value2);
        return node3;
      }
      parseDecimalLiteral(value2) {
        const decimal = null;
        const node3 = this.estreeParseLiteral(decimal);
        node3.decimal = String(node3.value || value2);
        return node3;
      }
      estreeParseLiteral(value2) {
        return this.parseLiteral(value2, "Literal");
      }
      parseStringLiteral(value2) {
        return this.estreeParseLiteral(value2);
      }
      parseNumericLiteral(value2) {
        return this.estreeParseLiteral(value2);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value2) {
        return this.estreeParseLiteral(value2);
      }
      directiveToStmt(directive) {
        const expression = directive.value;
        delete directive.value;
        expression.type = "Literal";
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = directive;
        stmt.type = "ExpressionStatement";
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      initFunction(node3, isAsync) {
        super.initFunction(node3, isAsync);
        node3.expression = false;
      }
      checkDeclaration(node3) {
        if (node3 != null && this.isObjectProperty(node3)) {
          this.checkDeclaration(node3.value);
        } else {
          super.checkDeclaration(node3);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node3, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node3, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node3.directives.map((d) => this.directiveToStmt(d));
        node3.body = directiveStatements.concat(node3.body);
        delete node3.directives;
      }
      parsePrivateName() {
        const node3 = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node3;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node3);
      }
      convertPrivateNameToPrivateIdentifier(node3) {
        const name2 = super.getPrivateNameSV(node3);
        node3 = node3;
        delete node3.id;
        node3.name = name2;
        node3.type = "PrivateIdentifier";
        return node3;
      }
      isPrivateName(node3) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node3);
          }
        }
        return node3.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node3) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node3);
          }
        }
        return node3.name;
      }
      parseLiteral(value2, type) {
        const node3 = super.parseLiteral(value2, type);
        node3.raw = node3.extra.raw;
        delete node3.extra;
        return node3;
      }
      parseFunctionBody(node3, allowExpression, isMethod = false) {
        super.parseFunctionBody(node3, allowExpression, isMethod);
        node3.expression = node3.body.type !== "BlockStatement";
      }
      parseMethod(node3, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node3.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node3.value = funcNode;
        const {
          typeParameters
        } = node3;
        if (typeParameters) {
          delete node3.typeParameters;
          funcNode.typeParameters = typeParameters;
          this.resetStartLocationFromNode(funcNode, typeParameters);
        }
        if (type === "ClassPrivateMethod") {
          node3.computed = false;
        }
        return this.finishNode(node3, "MethodDefinition");
      }
      nameIsConstructor(key) {
        if (key.type === "Literal") return key.value === "constructor";
        return super.nameIsConstructor(key);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          propertyNode.type = "PropertyDefinition";
        }
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        {
          propertyNode.type = "PropertyDefinition";
        }
        propertyNode.computed = false;
        return propertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node3 = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
        if (node3) {
          node3.type = "Property";
          if (node3.kind === "method") {
            node3.kind = "init";
          }
          node3.shorthand = false;
        }
        return node3;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node3 = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node3) {
          node3.kind = "init";
          node3.type = "Property";
        }
        return node3;
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node3, isBinding) {
        if (node3 != null && this.isObjectProperty(node3)) {
          return this.isAssignable(node3.value, isBinding);
        }
        return super.isAssignable(node3, isBinding);
      }
      toAssignable(node3, isLHS = false) {
        if (node3 != null && this.isObjectProperty(node3)) {
          const {
            key,
            value: value2
          } = node3;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value2, isLHS);
        } else {
          super.toAssignable(node3, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
          this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === "Property" && prop.method) {
          this.raise(Errors.PatternHasMethod, prop.key);
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node3 = super.finishCallExpression(unfinished, optional);
        if (node3.callee.type === "Import") {
          var _ref, _ref2;
          node3.type = "ImportExpression";
          node3.source = node3.arguments[0];
          node3.options = (_ref = node3.arguments[1]) != null ? _ref : null;
          node3.attributes = (_ref2 = node3.arguments[1]) != null ? _ref2 : null;
          delete node3.arguments;
          delete node3.callee;
        }
        return node3;
      }
      toReferencedArguments(node3) {
        if (node3.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node3);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node3 = super.parseExport(unfinished, decorators);
        switch (node3.type) {
          case "ExportAllDeclaration":
            node3.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node3.specifiers.length === 1 && node3.specifiers[0].type === "ExportNamespaceSpecifier") {
              node3.type = "ExportAllDeclaration";
              node3.exported = node3.specifiers[0].exported;
              delete node3.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node3;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node3.start) {
                this.resetStartLocation(node3, exportStartLoc);
              }
            }
            break;
        }
        return node3;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const node3 = super.parseSubscript(base, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node3.type === "OptionalMemberExpression" || node3.type === "OptionalCallExpression") {
            node3.type = node3.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node3);
            chain.expression = node3;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node3.type === "MemberExpression" || node3.type === "CallExpression") {
          node3.optional = false;
        }
        return node3;
      }
      isOptionalMemberExpression(node3) {
        if (node3.type === "ChainExpression") {
          return node3.expression.type === "MemberExpression";
        }
        return super.isOptionalMemberExpression(node3);
      }
      hasPropertyAsPrivateName(node3) {
        if (node3.type === "ChainExpression") {
          node3 = node3.expression;
        }
        return super.hasPropertyAsPrivateName(node3);
      }
      isObjectProperty(node3) {
        return node3.type === "Property" && node3.kind === "init" && !node3.method;
      }
      isObjectMethod(node3) {
        return node3.type === "Property" && (node3.method || node3.kind === "get" || node3.kind === "set");
      }
      finishNodeAt(node3, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node3, type, endLoc));
      }
      resetStartLocation(node3, startLoc) {
        super.resetStartLocation(node3, startLoc);
        toESTreeLocation(node3);
      }
      resetEndLocation(node3, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node3, endLoc);
        toESTreeLocation(node3);
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types3 = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    {
      types3.template = new TokContext("`", true);
    }
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name2, options2 = {}) {
      options2.keyword = name2;
      const token = createToken(name2, options2);
      keywords$1.set(name2, token);
      return token;
    }
    function createBinop(name2, binop) {
      return createToken(name2, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes2 = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name2, options2 = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name2);
      tokenBinops.push((_options$binop = options2.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options2.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options2.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options2.prefix) != null ? _options$prefix : false);
      tokenTypes2.push(new ExportedTokenType(name2, options2));
      return tokenTypeCounter;
    }
    function createKeywordLike(name2, options2 = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name2, tokenTypeCounter);
      tokenLabels.push(name2);
      tokenBinops.push((_options$binop2 = options2.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options2.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options2.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options2.prefix) != null ? _options$prefix2 : false);
      tokenTypes2.push(new ExportedTokenType("name", options2));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _defer: createKeywordLike("defer", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _source: createKeywordLike("source", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      placeholder: createToken("%%", {
        startsExpr: true
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd")
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 133;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 133;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 137;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes2[token];
    }
    {
      tokenTypes2[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes2[5].updateContext = tokenTypes2[7].updateContext = tokenTypes2[23].updateContext = (context) => {
        context.push(types3.brace);
      };
      tokenTypes2[22].updateContext = (context) => {
        if (context[context.length - 1] === types3.template) {
          context.pop();
        } else {
          context.push(types3.template);
        }
      };
      tokenTypes2[143].updateContext = (context) => {
        context.push(types3.j_expr, types3.j_oTag);
      };
    }
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C8A\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CD\uA7D0\uA7D1\uA7D3\uA7D5-\uA7DC\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0897-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code2, set2) {
      let pos = 65536;
      for (let i = 0, length = set2.length; i < length; i += 2) {
        pos += set2[i];
        if (pos > code2) return false;
        pos += set2[i + 1];
        if (pos >= code2) return true;
      }
      return false;
    }
    function isIdentifierStart(code2) {
      if (code2 < 65) return code2 === 36;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code2) {
      if (code2 < 48) return code2 === 36;
      if (code2 < 58) return true;
      if (code2 < 65) return false;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
    }
    var reservedWords2 = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords2 = new Set(reservedWords2.keyword);
    var reservedWordsStrictSet = new Set(reservedWords2.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords2.strictBind);
    function isReservedWord(word2, inModule) {
      return inModule && word2 === "await" || word2 === "enum";
    }
    function isStrictReservedWord(word2, inModule) {
      return isReservedWord(word2, inModule) || reservedWordsStrictSet.has(word2);
    }
    function isStrictBindOnlyReservedWord(word2) {
      return reservedWordsStrictBindSet.has(word2);
    }
    function isStrictBindReservedWord(word2, inModule) {
      return isStrictReservedWord(word2, inModule) || isStrictBindOnlyReservedWord(word2);
    }
    function isKeyword(word2) {
      return keywords2.has(word2);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word2) {
      return reservedWordLikeSet.has(word2);
    }
    var Scope = class {
      constructor(flags) {
        this.flags = 0;
        this.names = /* @__PURE__ */ new Map();
        this.firstLexicalName = "";
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser2, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser2;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 128) {
            return true;
          }
          if (flags & (387 | 64)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name2, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name2, bindingType, loc);
          let type = scope.names.get(name2) || 0;
          if (bindingType & 16) {
            type = type | 4;
          } else {
            if (!scope.firstLexicalName) {
              scope.firstLexicalName = name2;
            }
            type = type | 2;
          }
          scope.names.set(name2, type);
          if (bindingType & 8) {
            this.maybeExportDefined(scope, name2);
          }
        } else if (bindingType & 4) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name2, bindingType, loc);
            scope.names.set(name2, (scope.names.get(name2) || 0) | 1);
            this.maybeExportDefined(scope, name2);
            if (scope.flags & 387) break;
          }
        }
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name2);
        }
      }
      maybeExportDefined(scope, name2) {
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name2);
        }
      }
      checkRedeclarationInScope(scope, name2, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name2, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name2
          });
        }
      }
      isRedeclaredInScope(scope, name2, bindingType) {
        if (!(bindingType & 1)) return false;
        if (bindingType & 8) {
          return scope.names.has(name2);
        }
        const type = scope.names.get(name2);
        if (bindingType & 16) {
          return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
        }
        return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name2) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
      }
      checkLocalExport(id3) {
        const {
          name: name2
        } = id3;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.names.has(name2)) {
          this.undefinedExports.set(name2, id3.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 387) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (387 | 64) && !(flags & 4)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name2, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name2, bindingType, loc);
          this.maybeExportDefined(scope, name2);
          scope.declareFunctions.add(name2);
          return;
        }
        super.declareName(name2, bindingType, loc);
      }
      isRedeclaredInScope(scope, name2, bindingType) {
        if (super.isRedeclaredInScope(scope, name2, bindingType)) return true;
        if (bindingType & 2048 && !scope.declareFunctions.has(name2)) {
          const type = scope.names.get(name2);
          return (type & 4) > 0 || (type & 2) > 0;
        }
        return false;
      }
      checkLocalExport(id3) {
        if (!this.scopeStack[0].declareFunctions.has(id3.name)) {
          super.checkLocalExport(id3);
        }
      }
    };
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      sourceToOffsetPos(sourcePos) {
        return sourcePos + this.startIndex;
      }
      offsetToSourcePos(offsetPos) {
        return offsetPos - this.startIndex;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin3, name2) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin3)) == null ? void 0 : _this$plugins$get[name2];
      }
    };
    function setTrailingComments(node3, comments) {
      if (node3.trailingComments === void 0) {
        node3.trailingComments = comments;
      } else {
        node3.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node3, comments) {
      if (node3.leadingComments === void 0) {
        node3.leadingComments = comments;
      } else {
        node3.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node3, comments) {
      if (node3.innerComments === void 0) {
        node3.innerComments = comments;
      } else {
        node3.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node3, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node3, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment4) {
        if (this.filename) comment4.loc.filename = this.filename;
        const {
          commentsLen
        } = this.state;
        if (this.comments.length !== commentsLen) {
          this.comments.length = commentsLen;
        }
        this.comments.push(comment4);
        this.state.commentsLen++;
      }
      processComment(node3) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node3.end) {
          lastCommentWS.leadingNode = node3;
          i--;
        }
        const {
          start: nodeStart
        } = node3;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node3;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node3;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node3,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(this.offsetToSourcePos(commentStart) - 1) === 44) {
            switch (node3.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node3, node3.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node3, node3.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node3, node3.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node3, node3.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node3, node3.specifiers, commentWS);
                break;
              case "TSEnumDeclaration":
                {
                  adjustInnerComments(node3, node3.members, commentWS);
                }
                break;
              case "TSEnumBody":
                adjustInnerComments(node3, node3.members, commentWS);
                break;
              default: {
                setInnerComments(node3, comments);
              }
            }
          } else {
            setInnerComments(node3, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node3) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0) return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node3) {
          commentWS.leadingNode = null;
        }
      }
      resetPreviousIdentifierLeadingComments(node3) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0) return;
        if (commentStack[length - 1].trailingNode === node3) {
          commentStack[length - 1].trailingNode = null;
        } else if (length >= 2 && commentStack[length - 2].trailingNode === node3) {
          commentStack[length - 2].trailingNode = null;
        }
      }
      takeSurroundingComments(node3, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node3;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node3;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var lineBreak = /\r\n|[\r\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code2) {
      switch (code2) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    function hasNewLine(input, start, end) {
      for (let i = start; i < end; i++) {
        if (isNewLine(input.charCodeAt(i))) {
          return true;
        }
      }
      return false;
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    function isWhitespace(code2) {
      switch (code2) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State = class _State {
      constructor() {
        this.flags = 1024;
        this.startIndex = void 0;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.labels = [];
        this.commentsLen = 0;
        this.commentStack = [];
        this.pos = 0;
        this.type = 140;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.context = [types3.brace];
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      get strict() {
        return (this.flags & 1) > 0;
      }
      set strict(v) {
        if (v) this.flags |= 1;
        else this.flags &= -2;
      }
      init({
        strictMode,
        sourceType,
        startIndex,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.startIndex = startIndex;
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, startIndex);
      }
      get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
      }
      set maybeInArrowParameters(v) {
        if (v) this.flags |= 2;
        else this.flags &= -3;
      }
      get inType() {
        return (this.flags & 4) > 0;
      }
      set inType(v) {
        if (v) this.flags |= 4;
        else this.flags &= -5;
      }
      get noAnonFunctionType() {
        return (this.flags & 8) > 0;
      }
      set noAnonFunctionType(v) {
        if (v) this.flags |= 8;
        else this.flags &= -9;
      }
      get hasFlowComment() {
        return (this.flags & 16) > 0;
      }
      set hasFlowComment(v) {
        if (v) this.flags |= 16;
        else this.flags &= -17;
      }
      get isAmbientContext() {
        return (this.flags & 32) > 0;
      }
      set isAmbientContext(v) {
        if (v) this.flags |= 32;
        else this.flags &= -33;
      }
      get inAbstractClass() {
        return (this.flags & 64) > 0;
      }
      set inAbstractClass(v) {
        if (v) this.flags |= 64;
        else this.flags &= -65;
      }
      get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
      }
      set inDisallowConditionalTypesContext(v) {
        if (v) this.flags |= 128;
        else this.flags &= -129;
      }
      get soloAwait() {
        return (this.flags & 256) > 0;
      }
      set soloAwait(v) {
        if (v) this.flags |= 256;
        else this.flags &= -257;
      }
      get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
      }
      set inFSharpPipelineDirectBody(v) {
        if (v) this.flags |= 512;
        else this.flags &= -513;
      }
      get canStartJSXElement() {
        return (this.flags & 1024) > 0;
      }
      set canStartJSXElement(v) {
        if (v) this.flags |= 1024;
        else this.flags &= -1025;
      }
      get containsEsc() {
        return (this.flags & 2048) > 0;
      }
      set containsEsc(v) {
        if (v) this.flags |= 2048;
        else this.flags &= -2049;
      }
      get hasTopLevelAwait() {
        return (this.flags & 4096) > 0;
      }
      set hasTopLevelAwait(v) {
        if (v) this.flags |= 4096;
        else this.flags &= -4097;
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos + this.startIndex);
      }
      clone() {
        const state = new _State();
        state.flags = this.flags;
        state.startIndex = this.startIndex;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
      }
    };
    var _isDigit = function isDigit(code2) {
      return code2 >= 48 && code2 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code2;
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCharCode(code2));
        }
        case 117: {
          let code2;
          ({
            code: code2,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCodePoint(code2));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match2 = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match2[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        if (code2 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code2 >= 97) {
          val = code2 - 97 + 10;
        } else if (code2 >= 65) {
          val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
          val = code2 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code2;
      if (ch === 123) {
        ++pos;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code2 !== null && code2 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code2,
        pos
      };
    }
    function buildPosition(pos, lineStart, curLine) {
      return new Position(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token = class {
      constructor(state) {
        const startIndex = state.startIndex || 0;
        this.type = state.type;
        this.value = state.value;
        this.start = startIndex + state.start;
        this.end = startIndex + state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options2, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!(this.optionFlags & 1024)) return false;
            this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
          }
        });
        this.state = new State();
        this.state.init(options2);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.optionFlags & 128) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos) {
        let cp2 = this.input.charCodeAt(pos);
        if ((cp2 & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp2 = 65536 + ((cp2 & 1023) << 10) + (trail & 1023);
          }
        }
        return cp2;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at2]) => this.raise(toParseError, at2));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(140);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead) return;
        const comment4 = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end + commentEnd.length),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 128) this.pushToken(comment4);
        return comment4;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead) return;
        const end = this.state.pos;
        const value2 = this.input.slice(start + startSkip, end);
        const comment4 = {
          type: "CommentLine",
          value: value2,
          start: this.sourceToOffsetPos(start),
          end: this.sourceToOffsetPos(end),
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.optionFlags & 128) this.pushToken(comment4);
        return comment4;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = this.optionFlags & 2048 ? [] : null;
        loop: while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment4 = this.skipBlockComment("*/");
                  if (comment4 !== void 0) {
                    this.addComment(comment4);
                    comments == null || comments.push(comment4);
                  }
                  break;
                }
                case 47: {
                  const comment4 = this.skipLineComment(2);
                  if (comment4 !== void 0) {
                    this.addComment(comment4);
                    comments == null || comments.push(comment4);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule && this.optionFlags & 4096) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment4 = this.skipLineComment(3);
                  if (comment4 !== void 0) {
                    this.addComment(comment4);
                    comments == null || comments.push(comment4);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule && this.optionFlags & 4096) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  const comment4 = this.skipLineComment(4);
                  if (comment4 !== void 0) {
                    this.addComment(comment4);
                    comments == null || comments.push(comment4);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
        if ((comments == null ? void 0 : comments.length) > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: this.sourceToOffsetPos(spaceStart),
            end: this.sourceToOffsetPos(end),
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart(next)) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(139, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value2 = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value2);
        return true;
      }
      readToken_mult_modulo(code2) {
        let type = code2 === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code2 === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code2 === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code2 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code2 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code2 === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code2 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code2) {
        switch (code2) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code2);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code2);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code2);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code2);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code2);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code2)) {
              this.readWord(code2);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
          unexpected: String.fromCodePoint(code2)
        });
      }
      finishOp(type, size) {
        const str2 = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str2);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped2, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          if (escaped2) {
            escaped2 = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped2 = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while (pos < this.length) {
          const cp2 = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp2);
          if (VALID_REGEX_FLAGS.has(cp2)) {
            if (cp2 === 118) {
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            } else if (cp2 === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, nextPos());
            }
          } else if (isIdentifierChar(cp2) || cp2 === 92) {
            this.raise(Errors.MalformedRegExpFlags, nextPos());
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(138, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n;
      }
      readRadixNumber(radix) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, startLoc);
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        if (isBigInt) {
          const str2 = this.input.slice(start, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(136, str2);
          return;
        }
        this.finishToken(135, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
          if (!this.state.strict) {
            const underscorePos = integer.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, startLoc);
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, startLoc);
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, startLoc);
          }
          ++this.state.pos;
          var isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        const str2 = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(136, str2);
          return;
        }
        if (isDecimal) {
          this.finishToken(137, str2);
          return;
        }
        const val = isOctal ? parseInt(str2, 8) : parseFloat(str2);
        this.finishToken(135, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code: code2,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code2;
      }
      readString(quote3) {
        const {
          str: str2,
          pos,
          curLine,
          lineStart
        } = readStringContents(quote3 === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(134, str2);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str: str2,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, this.sourceToOffsetPos(firstInvalidLoc.pos));
        }
        if (this.input.codePointAt(pos) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str2 + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str2 + "${");
        }
      }
      recordStrictModeErrors(toParseError, at2) {
        const index4 = at2.index;
        if (this.state.strict && !this.state.strictErrors.has(index4)) {
          this.raise(toParseError, at2);
        } else {
          this.state.strictErrors.set(index4, [toParseError, at2]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word2 = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word2 += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
              }
              word2 += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word2 + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word2 = this.readWord1(firstCode);
        const type = keywords$1.get(word2);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(132, word2);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, at2, details = {}) {
        const loc = at2 instanceof Position ? at2 : at2.loc.start;
        const error = toParseError(loc, details);
        if (!(this.optionFlags & 1024)) throw error;
        if (!this.isLookahead) this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, at2, details = {}) {
        const loc = at2 instanceof Position ? at2 : at2.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.loc.index === pos) {
            return errors[i] = toParseError(loc, details);
          }
          if (error.loc.index < pos) break;
        }
        return this.raise(toParseError, at2, details);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
          expected: type ? tokenLabelName(type) : null
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name2) => this.hasPlugin(name2))) {
          throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, buildPosition(pos, lineStart, curLine));
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser2) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser2;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name2, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name2)) {
              current.undefinedPrivateNames.set(name2, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
              identifierName: name2
            });
          }
        }
      }
      declarePrivateName(name2, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name2);
        if (elementType & 3) {
          const accessor = redefined && loneAccessors.get(name2);
          if (accessor) {
            const oldStatic = accessor & 4;
            const newStatic = elementType & 4;
            const oldKind = accessor & 3;
            const newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined) loneAccessors.delete(name2);
          } else if (!redefined) {
            loneAccessors.set(name2, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
            identifierName: name2
          });
        }
        privateNames.add(name2);
        undefinedPrivateNames.delete(name2);
      }
      usePrivateName(name2, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name2)) return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name2, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name2
          });
        }
      }
    };
    var ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, at2) {
        const index4 = at2.index;
        this.declarationErrors.set(index4, [ParsingErrorClass, at2]);
      }
      clearDeclarationError(index4) {
        this.declarationErrors.delete(index4);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser2) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser2;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, node3) {
        const origin = node3.loc.start;
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, node3) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        const origin = node3.loc.start;
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(at2) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === 2) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at2);
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration()) return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, loc);
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node3, key, value2, enumerable = true) {
        if (!node3) return;
        let {
          extra
        } = node3;
        if (extra == null) {
          extra = {};
          node3.extra = extra;
        }
        if (enumerable) {
          extra[key] = value2;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value: value2
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name2) {
        const nameEnd = nameStart + name2.length;
        if (this.input.slice(nameStart, nameEnd) === name2) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name2) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name2);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null) {
            throw this.raise(toParseError, this.state.startLoc);
          }
          this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(140) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return hasNewLine(this.input, this.offsetToSourcePos(this.state.lastTokEndLoc.index), this.state.start);
      }
      hasFollowingLineBreak() {
        return hasNewLine(this.input, this.state.end, this.nextTokenStart());
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
      }
      expect(type, loc) {
        if (!this.eat(type)) {
          this.unexpected(loc, type);
        }
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node3 = fn((node4 = null) => {
            abortSignal.node = node4;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node: node3,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node: node3,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node3) {
        return node3.type === "PrivateName";
      }
      getPrivateNameSV(node3) {
        return node3.id.name;
      }
      hasPropertyAsPrivateName(node3) {
        return (node3.type === "MemberExpression" || node3.type === "OptionalMemberExpression") && this.isPrivateName(node3.property);
      }
      isObjectProperty(node3) {
        return node3.type === "ObjectProperty";
      }
      isObjectMethod(node3) {
        return node3.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        if (this.inModule) {
          paramFlags |= 2;
        }
        this.scope.enter(1);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node2 = class {
      constructor(parser2, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if ((parser2 == null ? void 0 : parser2.optionFlags) & 64) this.range = [pos, 0];
        if (parser2 != null && parser2.filename) this.loc.filename = parser2.filename;
      }
    };
    var NodePrototype = Node2.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node2(void 0, this.start, this.loc.start);
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node3) {
      return cloneIdentifier(node3);
    }
    function cloneIdentifier(node3) {
      const {
        type,
        start,
        end,
        loc,
        range: range2,
        extra,
        name: name2
      } = node3;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range2;
      cloned.extra = extra;
      cloned.name = name2;
      if (type === "Placeholder") {
        cloned.expectedNode = node3.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node3) {
      const {
        type,
        start,
        end,
        loc,
        range: range2,
        extra
      } = node3;
      if (type === "Placeholder") {
        return clonePlaceholder(node3);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range2;
      if (node3.raw !== void 0) {
        cloned.raw = node3.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node3.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        const loc = this.state.startLoc;
        return new Node2(this, loc.index, loc);
      }
      startNodeAt(loc) {
        return new Node2(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node3, type) {
        return this.finishNodeAt(node3, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node3, type, endLoc) {
        node3.type = type;
        node3.end = endLoc.index;
        node3.loc.end = endLoc;
        if (this.optionFlags & 64) node3.range[1] = endLoc.index;
        if (this.optionFlags & 2048) {
          this.processComment(node3);
        }
        return node3;
      }
      resetStartLocation(node3, startLoc) {
        node3.start = startLoc.index;
        node3.loc.start = startLoc;
        if (this.optionFlags & 64) node3.range[0] = startLoc.index;
      }
      resetEndLocation(node3, endLoc = this.state.lastTokEndLoc) {
        node3.end = endLoc.index;
        node3.loc.end = endLoc;
        if (this.optionFlags & 64) node3.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node3, locationNode) {
        this.resetStartLocation(node3, locationNode.loc.start);
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node3) {
      return node3.importKind === "type" || node3.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list2, test) {
      const list1 = [];
      const list22 = [];
      for (let i = 0; i < list2.length; i++) {
        (test(list2[i], i, list2) ? list1 : list22).push(list2[i]);
      }
      return [list1, list22];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      finishToken(type, val) {
        if (type !== 134 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        super.finishToken(type, val);
      }
      addComment(comment4) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment4.value);
          if (!matches) ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        super.addComment(comment4);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node3 = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
        }
        if (this.eat(10)) {
          node3.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node3, "DeclaredPredicate");
        } else {
          return this.finishNode(node3, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node3) {
        this.next();
        this.flowParseInterfaceish(node3, true);
        return this.finishNode(node3, "DeclareClass");
      }
      flowParseDeclareFunction(node3) {
        this.next();
        const id3 = node3.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node3.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id3.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id3);
        this.semicolon();
        this.scope.declareName(node3.id.name, 2048, node3.id.loc.start);
        return this.finishNode(node3, "DeclareFunction");
      }
      flowParseDeclare(node3, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node3);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node3);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node3);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node3);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
            }
            return this.flowParseDeclareModule(node3);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node3);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node3);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node3);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node3, insideModule);
        } else {
          this.unexpected();
        }
      }
      flowParseDeclareVariable(node3) {
        this.next();
        node3.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node3.id.name, 5, node3.id.loc.start);
        this.semicolon();
        return this.finishNode(node3, "DeclareVariable");
      }
      flowParseDeclareModule(node3) {
        this.scope.enter(0);
        if (this.match(134)) {
          node3.id = super.parseExprAtom();
        } else {
          node3.id = this.parseIdentifier();
        }
        const bodyNode = node3.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
            }
            super.parseImport(bodyNode2);
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node3.kind = kind || "CommonJS";
        return this.finishNode(node3, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node3, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node3.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node3.declaration = this.flowParseType();
            this.semicolon();
          }
          node3.default = true;
          return this.finishNode(node3, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node3.declaration = this.flowParseDeclare(this.startNode());
            node3.default = false;
            return this.finishNode(node3, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node3 = this.parseExport(node3, null);
            if (node3.type === "ExportNamedDeclaration") {
              node3.type = "ExportDeclaration";
              node3.default = false;
              delete node3.exportKind;
            }
            node3.type = "Declare" + node3.type;
            return node3;
          }
        }
        this.unexpected();
      }
      flowParseDeclareModuleExports(node3) {
        this.next();
        this.expectContextual(111);
        node3.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node3, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node3) {
        this.next();
        const finished = this.flowParseTypeAlias(node3);
        finished.type = "DeclareTypeAlias";
        return finished;
      }
      flowParseDeclareOpaqueType(node3) {
        this.next();
        const finished = this.flowParseOpaqueType(node3, true);
        finished.type = "DeclareOpaqueType";
        return finished;
      }
      flowParseDeclareInterface(node3) {
        this.next();
        this.flowParseInterfaceish(node3, false);
        return this.finishNode(node3, "DeclareInterface");
      }
      flowParseInterfaceish(node3, isClass) {
        node3.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node3.id.name, isClass ? 17 : 8201, node3.id.loc.start);
        if (this.match(47)) {
          node3.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node3.typeParameters = null;
        }
        node3.extends = [];
        if (this.eat(81)) {
          do {
            node3.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node3.implements = [];
          node3.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node3.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node3.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node3.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node3 = this.startNode();
        node3.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node3.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node3.typeParameters = null;
        }
        return this.finishNode(node3, "InterfaceExtends");
      }
      flowParseInterface(node3) {
        this.flowParseInterfaceish(node3, false);
        return this.finishNode(node3, "InterfaceDeclaration");
      }
      checkNotUnderscore(word2) {
        if (word2 === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
        }
      }
      checkReservedType(word2, startLoc, declaration) {
        if (!reservedTypes.has(word2)) return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word2
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node3) {
        node3.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node3.id.name, 8201, node3.id.loc.start);
        if (this.match(47)) {
          node3.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node3.typeParameters = null;
        }
        node3.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node3, "TypeAlias");
      }
      flowParseOpaqueType(node3, declare) {
        this.expectContextual(130);
        node3.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node3.id.name, 8201, node3.id.loc.start);
        if (this.match(47)) {
          node3.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node3.typeParameters = null;
        }
        node3.supertype = null;
        if (this.match(14)) {
          node3.supertype = this.flowParseTypeInitialiser(14);
        }
        node3.impltype = null;
        if (!declare) {
          node3.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node3, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node3 = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node3.name = ident.name;
        node3.variance = variance;
        node3.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node3.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
          }
        }
        return this.finishNode(node3, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node3 = this.startNode();
        node3.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node3.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node3, "TypeParameterDeclaration");
      }
      flowInTopLevelContext(cb) {
        if (this.curContext() !== types3.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      flowParseTypeParameterInstantiationInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.flowParseTypeParameterInstantiation();
      }
      flowParseTypeParameterInstantiation() {
        const node3 = this.startNode();
        const oldInType = this.state.inType;
        this.state.inType = true;
        node3.params = [];
        this.flowInTopLevelContext(() => {
          this.expect(47);
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = false;
          while (!this.match(48)) {
            node3.params.push(this.flowParseType());
            if (!this.match(48)) {
              this.expect(12);
            }
          }
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        });
        this.state.inType = oldInType;
        if (!this.state.inType && this.curContext() === types3.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node3, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        if (this.reScan_lt() !== 47) return;
        const node3 = this.startNode();
        const oldInType = this.state.inType;
        node3.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node3.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node3, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node3 = this.startNode();
        this.expectContextual(129);
        node3.extends = [];
        if (this.eat(81)) {
          do {
            node3.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node3.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node3, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(135) || this.match(134) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node3, isStatic, variance) {
        node3.static = isStatic;
        if (this.lookahead().type === 14) {
          node3.id = this.flowParseObjectPropertyKey();
          node3.key = this.flowParseTypeInitialiser();
        } else {
          node3.id = null;
          node3.key = this.flowParseType();
        }
        this.expect(3);
        node3.value = this.flowParseTypeInitialiser();
        node3.variance = variance;
        return this.finishNode(node3, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node3, isStatic) {
        node3.static = isStatic;
        node3.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node3.method = true;
          node3.optional = false;
          node3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node3.loc.start));
        } else {
          node3.method = false;
          if (this.eat(17)) {
            node3.optional = true;
          }
          node3.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node3, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node3) {
        node3.params = [];
        node3.rest = null;
        node3.typeParameters = null;
        node3.this = null;
        if (this.match(47)) {
          node3.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node3.this = this.flowParseFunctionTypeParam(true);
          node3.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node3.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node3.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node3.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node3, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node3, isStatic) {
        const valueNode = this.startNode();
        node3.static = isStatic;
        node3.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node3, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node3 = this.startNode();
          if (allowProto && this.isContextual(118)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node3, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node3, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node3, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node3, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node3, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, variance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, variance);
          }
          node3.argument = this.flowParseType();
          return this.finishNode(node3, "ObjectTypeSpreadProperty");
        } else {
          node3.key = this.flowParseObjectPropertyKey();
          node3.static = isStatic;
          node3.proto = protoStartLoc != null;
          node3.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node3.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node3.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node3.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node3);
            }
            if (!allowSpread && node3.key.name === "constructor" && node3.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, node3.value.this);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node3.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node3.value = this.flowParseTypeInitialiser();
            node3.variance = variance;
          }
          node3.optional = optional;
          return this.finishNode(node3, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(Errors.BadSetterRestParameter, property);
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id3) {
        var _startLoc;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        let node3 = id3 || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node22 = this.startNodeAt(startLoc);
          node22.qualification = node3;
          node22.id = this.flowParseRestrictedIdentifier(true);
          node3 = this.finishNode(node22, "QualifiedTypeIdentifier");
        }
        return node3;
      }
      flowParseGenericType(startLoc, id3) {
        const node3 = this.startNodeAt(startLoc);
        node3.typeParameters = null;
        node3.id = this.flowParseQualifiedTypeIdentifier(startLoc, id3);
        if (this.match(47)) {
          node3.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node3, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node3 = this.startNode();
        this.expect(87);
        node3.argument = this.flowParsePrimaryType();
        return this.finishNode(node3, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node3 = this.startNode();
        node3.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node3.types.push(this.flowParseType());
          if (this.match(3)) break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node3, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first2) {
        let name2 = null;
        let optional = false;
        let typeAnnotation = null;
        const node3 = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first2) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node3);
          }
          name2 = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, node3);
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node3.name = name2;
        node3.optional = optional;
        node3.typeAnnotation = typeAnnotation;
        return this.finishNode(node3, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node3 = this.startNodeAt(type.loc.start);
        node3.name = null;
        node3.optional = false;
        node3.typeAnnotation = type;
        return this.finishNode(node3, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node3, id3) {
        switch (id3.name) {
          case "any":
            return this.finishNode(node3, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node3, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node3, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node3, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node3, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node3, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node3, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id3.name);
            return this.flowParseGenericType(startLoc, id3);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node3 = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47: {
            const node4 = this.startNode();
            node4.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node4.params = tmp.params;
            node4.rest = tmp.rest;
            node4.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node4.returnType = this.flowParseType();
            return this.finishNode(node4, "FunctionTypeAnnotation");
          }
          case 10: {
            const node4 = this.startNode();
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node4.params = tmp.params;
            node4.rest = tmp.rest;
            node4.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node4.returnType = this.flowParseType();
            node4.typeParameters = null;
            return this.finishNode(node4, "FunctionTypeAnnotation");
          }
          case 134:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node3.value = this.match(85);
            this.next();
            return this.finishNode(node3, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node3);
              }
              if (this.match(136)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node3);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            this.unexpected();
            return;
          case 135:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 136:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node3, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node3, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node3, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node3, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node3, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node3, this.parseIdentifier());
            }
        }
        this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node3 = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node3.elementType = type;
            this.next();
            type = this.finishNode(node3, "ArrayTypeAnnotation");
          } else {
            node3.objectType = type;
            node3.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node3.optional = optional;
              type = this.finishNode(node3, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node3, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node3 = this.startNode();
        if (this.eat(17)) {
          node3.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node3, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node3 = this.startNodeAt(param.loc.start);
          node3.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node3.rest = null;
          node3.this = null;
          node3.returnType = this.flowParseType();
          node3.typeParameters = null;
          return this.finishNode(node3, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node3 = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node3.types = [type];
        while (this.eat(45)) {
          node3.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node3.types.length === 1 ? type : this.finishNode(node3, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node3 = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node3.types = [type];
        while (this.eat(43)) {
          node3.types.push(this.flowParseIntersectionType());
        }
        return node3.types.length === 1 ? type : this.finishNode(node3, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node3 = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node3);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node3 = this.startNode();
        node3.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node3, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node3) {
        node3.expression.typeAnnotation = node3.typeAnnotation;
        this.resetEndLocation(node3.expression, node3.typeAnnotation.loc.end);
        return node3.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node3, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node3, () => super.parseFunctionBody(node3, true, isMethod));
          return;
        }
        super.parseFunctionBody(node3, false, isMethod);
      }
      parseFunctionBodyAndFinish(node3, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node3.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node3.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node3, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node3 = this.startNode();
            this.next();
            return this.flowParseInterface(node3);
          }
        } else if (this.isContextual(126)) {
          const node3 = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node3);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node3, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node3);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node3);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node3);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node3, false);
            }
          }
        }
        return super.parseExpressionStatement(node3, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (type === 126 || tokenIsFlowInterfaceOrTypeOrOpaque(type)) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.isContextual(126)) {
          const node3 = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node3);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node3 = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node3.test = expr;
        node3.consequent = consequent;
        node3.alternate = this.forwardNoArrowParamsConversionAt(node3, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node3, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node3, disallowInvalid) {
        const stack = [node3];
        const arrows = [];
        while (stack.length !== 0) {
          const node4 = stack.pop();
          if (node4.type === "ArrowFunctionExpression" && node4.body.type !== "BlockStatement") {
            if (node4.typeParameters || !node4.returnType) {
              this.finishArrowValidation(node4);
            } else {
              arrows.push(node4);
            }
            stack.push(node4.body);
          } else if (node4.type === "ConditionalExpression") {
            stack.push(node4.consequent);
            stack.push(node4.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node4) => this.finishArrowValidation(node4));
          return [arrows, []];
        }
        return partition(arrows, (node4) => node4.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node3) {
        var _node$extra;
        this.toAssignableList(node3.params, (_node$extra = node3.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(2 | 4);
        super.checkParams(node3, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node3, parse7) {
        let result;
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node3.start))) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse7();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse7();
        }
        return result;
      }
      parseParenItem(node3, startLoc) {
        const newNode = super.parseParenItem(node3, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node3);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = newNode;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      }
      assertModuleNodeAllowed(node3) {
        if (node3.type === "ImportDeclaration" && (node3.importKind === "type" || node3.importKind === "typeof") || node3.type === "ExportNamedDeclaration" && node3.exportKind === "type" || node3.type === "ExportAllDeclaration" && node3.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node3);
      }
      parseExportDeclaration(node3) {
        if (this.isContextual(130)) {
          node3.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node3.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node3);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node3.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(129)) {
          node3.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.isContextual(126)) {
          node3.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node3);
        }
      }
      eatExportStar(node3) {
        if (super.eatExportStar(node3)) return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node3.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node3) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node3);
        if (hasNamespace && node3.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node3, isStatement, optionalId) {
        super.parseClassId(node3, isStatement, optionalId);
        if (this.match(47)) {
          node3.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, startLoc);
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
          }
        }
      }
      isIterator(word2) {
        return word2 === "iterator" || word2 === "asyncIterator";
      }
      readIterator() {
        const word2 = super.readWord1();
        const fullWord = "@@" + word2;
        if (!this.isIterator(word2) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      }
      getTokenFromCode(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
          this.finishOp(code2 === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code2 === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          super.getTokenFromCode(code2);
        }
      }
      isAssignable(node3, isBinding) {
        if (node3.type === "TypeCastExpression") {
          return this.isAssignable(node3.expression, isBinding);
        } else {
          return super.isAssignable(node3, isBinding);
        }
      }
      toAssignable(node3, isLHS = false) {
        if (!isLHS && node3.type === "AssignmentExpression" && node3.left.type === "TypeCastExpression") {
          node3.left = this.typeCastToParameter(node3.left);
        }
        super.toAssignable(node3, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
          }
        }
        return exprList;
      }
      parseArrayLike(close2, canBePattern, isTuple, refExpressionErrors) {
        const node3 = super.parseArrayLike(close2, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node3.elements);
        }
        return node3;
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
      }
      parseClassProperty(node3) {
        if (this.match(14)) {
          node3.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node3);
      }
      parseClassPrivateProperty(node3) {
        if (this.match(14)) {
          node3.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node3);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node3) {
        super.parseClassSuper(node3);
        if (node3.superClass && (this.match(47) || this.match(51))) {
          {
            node3.superTypeParameters = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        if (this.isContextual(113)) {
          this.next();
          const implemented = node3.implements = [];
          do {
            const node4 = this.startNode();
            node4.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node4.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node4.typeParameters = null;
            }
            implemented.push(this.finishNode(node4, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
          }
        }
      }
      parsePropertyNamePrefixOperator(node3) {
        node3.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10)) this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, param);
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, param);
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, param);
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node3 = super.parseMaybeDefault(startLoc, left);
        if (node3.type === "AssignmentPattern" && node3.typeAnnotation && node3.right.start < node3.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, node3.typeAnnotation);
        }
        return node3;
      }
      checkImportReflection(node3) {
        super.checkImportReflection(node3);
        if (node3.module && node3.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, node3.specifiers[0].loc.start);
        }
      }
      parseImportSpecifierLocal(node3, specifier, type) {
        specifier.local = hasTypeImportKind(node3) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node3.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          if (!isExport) return true;
          const ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node3, isExport, phase, loc) {
        super.applyImportPhase(node3, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node3.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55)) this.unexpected();
          node3.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node3, isConstructor) {
        const kind = node3.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node3.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node3, isConstructor);
      }
      parseVarId(decl2, kind) {
        super.parseVarId(decl2, kind);
        if (this.match(14)) {
          decl2.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl2.id);
        }
      }
      parseAsyncArrowFromCallExpression(node3, call2) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node3.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node3, call2);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types3.j_oTag || currentContext === types3.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression") abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node3) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node3.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon()) this.unexpected();
            if (!this.match(19)) this.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node3.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node3);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node3, params) {
        if (this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node3.start))) {
          node3.params = params;
        } else {
          super.setArrowFunctionParameters(node3, params);
        }
      }
      checkParams(node3, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(this.offsetToSourcePos(node3.start))) {
          return;
        }
        for (let i = 0; i < node3.params.length; i++) {
          if (this.isThisParam(node3.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node3.params[i]);
          }
        }
        super.checkParams(node3, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.sourceToOffsetPos(this.state.start)));
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
          this.next();
          const node3 = this.startNodeAt(startLoc);
          node3.callee = base;
          node3.arguments = super.parseCallExpressionArguments(11);
          base = this.finishNode(node3, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error) return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node3 = this.startNodeAt(startLoc);
          node3.callee = base;
          node3.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          this.expect(10);
          node3.arguments = this.parseCallExpressionArguments(11);
          node3.optional = true;
          return this.finishCallExpression(node3, true);
        } else if (!noCalls && this.shouldParseTypes() && (this.match(47) || this.match(51))) {
          const node3 = this.startNodeAt(startLoc);
          node3.callee = base;
          const result = this.tryParse(() => {
            node3.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node3.arguments = super.parseCallExpressionArguments(11);
            if (subscriptState.optionalChainMember) {
              node3.optional = false;
            }
            return this.finishCallExpression(node3, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node3) {
        super.parseNewCallee(node3);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node3.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node3 = this.startNodeAt(startLoc);
        this.parseFunctionParams(node3, false);
        if (!this.parseArrow(node3)) return;
        return super.parseArrowExpression(node3, void 0, true);
      }
      readToken_mult_modulo(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code2);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code2);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node3, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node3, details);
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 135: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 134: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id3 = this.parseIdentifier(true);
        const init2 = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id: id3,
          init: init2
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id: id3,
            init: init2
          } = this.flowEnumMemberRaw();
          const memberName = id3.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, id3, {
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, id3, {
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id3;
          switch (init2.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init2.loc, context, "boolean");
              memberNode.init = init2.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init2.loc, context, "number");
              memberNode.init = init2.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init2.loc, context, "string");
              memberNode.init = init2.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init2.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init2.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init2.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102)) return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName
          });
        }
        const {
          value: value2
        } = this.state;
        this.next();
        if (value2 !== "boolean" && value2 !== "number" && value2 !== "string" && value2 !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
            enumName,
            invalidEnumType: value2
          });
        }
        return value2;
      }
      flowEnumBody(node3, id3) {
        const enumName = id3.name;
        const nameLoc = id3.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node3.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node3.explicitType = true;
            node3.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node3, "EnumBooleanBody");
          case "number":
            node3.explicitType = true;
            node3.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node3, "EnumNumberBody");
          case "string":
            node3.explicitType = true;
            node3.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node3, "EnumStringBody");
          case "symbol":
            node3.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node3, "EnumSymbolBody");
          default: {
            const empty = () => {
              node3.members = [];
              this.expect(8);
              return this.finishNode(node3, "EnumStringBody");
            };
            node3.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node3.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node3, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node3.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node3, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node3.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node3, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                enumName
              });
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node3) {
        const id3 = this.parseIdentifier();
        node3.id = id3;
        node3.body = this.flowEnumBody(this.startNode(), id3);
        return this.finishNode(node3, "EnumDeclaration");
      }
      jsxParseOpeningElementAfterName(node3) {
        if (this.shouldParseTypes()) {
          if (this.match(47) || this.match(51)) {
            node3.typeArguments = this.flowParseTypeParameterInstantiationInExpression();
          }
        }
        return super.jsxParseOpeningElementAfterName(node3);
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      maybeUnwrapTypeCastExpression(node3) {
        return node3.type === "TypeCastExpression" ? node3.expression : node3;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object2) {
      return object2 ? object2.type === "JSXOpeningFragment" || object2.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object2) {
      if (object2.type === "JSXIdentifier") {
        return object2.name;
      }
      if (object2.type === "JSXNamespacedName") {
        return object2.namespace.name + ":" + object2.name.name;
      }
      if (object2.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object2.object) + "." + getQualifiedJSXName(object2.property);
      }
      throw new Error("Node had unexpected type: " + object2.type);
    }
    var jsx = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(143);
                } else {
                  super.getTokenFromCode(ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(142, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote3) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote3) break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(134, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(141, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node3 = this.startNode();
        if (this.match(141)) {
          node3.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node3.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node3, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name2 = this.jsxParseIdentifier();
        if (!this.eat(14)) return name2;
        const node3 = this.startNodeAt(startLoc);
        node3.namespace = name2;
        node3.name = this.jsxParseIdentifier();
        return this.finishNode(node3, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node3 = this.jsxParseNamespacedName();
        if (node3.type === "JSXNamespacedName") {
          return node3;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node3;
          newNode.property = this.jsxParseIdentifier();
          node3 = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node3;
      }
      jsxParseAttributeValue() {
        let node3;
        switch (this.state.type) {
          case 5:
            node3 = this.startNode();
            this.setContext(types3.brace);
            this.next();
            node3 = this.jsxParseExpressionContainer(node3, types3.j_oTag);
            if (node3.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, node3);
            }
            return node3;
          case 143:
          case 134:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      }
      jsxParseEmptyExpression() {
        const node3 = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node3, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node3) {
        this.next();
        node3.expression = this.parseExpression();
        this.setContext(types3.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node3, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node3, previousContext) {
        if (this.match(8)) {
          node3.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node3.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node3, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node3 = this.startNode();
        if (this.match(5)) {
          this.setContext(types3.brace);
          this.next();
          this.expect(21);
          node3.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types3.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node3, "JSXSpreadAttribute");
        }
        node3.name = this.jsxParseNamespacedName();
        node3.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node3, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node3 = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node3, "JSXOpeningFragment");
        }
        node3.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node3);
      }
      jsxParseOpeningElementAfterName(node3) {
        const attributes = [];
        while (!this.match(56) && !this.match(144)) {
          attributes.push(this.jsxParseAttribute());
        }
        node3.attributes = attributes;
        node3.selfClosing = this.eat(56);
        this.expect(144);
        return this.finishNode(node3, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node3 = this.startNodeAt(startLoc);
        if (this.eat(144)) {
          return this.finishNode(node3, "JSXClosingFragment");
        }
        node3.name = this.jsxParseElementName();
        this.expect(144);
        return this.finishNode(node3, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node3 = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (; ; ) {
            switch (this.state.type) {
              case 143:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 142:
                children.push(this.parseLiteral(this.state.value, "JSXText"));
                break;
              case 5: {
                const node4 = this.startNode();
                this.setContext(types3.brace);
                this.next();
                if (this.match(21)) {
                  children.push(this.jsxParseSpreadChild(node4));
                } else {
                  children.push(this.jsxParseExpressionContainer(node4, types3.j_expr));
                }
                break;
              }
              default:
                this.unexpected();
            }
          }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node3.openingFragment = openingElement;
          node3.closingFragment = closingElement;
        } else {
          node3.openingElement = openingElement;
          node3.closingElement = closingElement;
        }
        node3.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        return isFragment(openingElement) ? this.finishNode(node3, "JSXFragment") : this.finishNode(node3, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(143)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(143);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace) super.skipSpace();
      }
      getTokenFromCode(code2) {
        const context = this.curContext();
        if (context === types3.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types3.j_oTag || context === types3.j_cTag) {
          if (isIdentifierStart(code2)) {
            this.jsxReadWord();
            return;
          }
          if (code2 === 62) {
            ++this.state.pos;
            this.finishToken(144);
            return;
          }
          if ((code2 === 34 || code2 === 39) && context === types3.j_oTag) {
            this.jsxReadString(code2);
            return;
          }
        }
        if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(143);
          return;
        }
        super.getTokenFromCode(code2);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 143) {
          context.splice(-2, 2, types3.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 143) {
          context.push(types3.j_oTag);
        } else if (type === 144) {
          const out = context[context.length - 1];
          if (out === types3.j_oTag && prevType === 56 || out === types3.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types3.j_expr;
          } else {
            this.setContext(types3.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.tsNames = /* @__PURE__ */ new Map();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags === 256) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags === 256) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name2, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name2)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].has(name2)) return true;
          }
        }
        return false;
      }
      declareName(name2, bindingType, loc) {
        if (bindingType & 4096) {
          if (this.hasImport(name2, true)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
              identifierName: name2
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name2);
          return;
        }
        const scope = this.currentScope();
        let type = scope.tsNames.get(name2) || 0;
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name2);
          scope.tsNames.set(name2, type | 16);
          return;
        }
        super.declareName(name2, bindingType, loc);
        if (bindingType & 2) {
          if (!(bindingType & 1)) {
            this.checkRedeclarationInScope(scope, name2, bindingType, loc);
            this.maybeExportDefined(scope, name2);
          }
          type = type | 1;
        }
        if (bindingType & 256) {
          type = type | 2;
        }
        if (bindingType & 512) {
          type = type | 4;
        }
        if (bindingType & 128) {
          type = type | 8;
        }
        if (type) scope.tsNames.set(name2, type);
      }
      isRedeclaredInScope(scope, name2, bindingType) {
        const type = scope.tsNames.get(name2);
        if ((type & 2) > 0) {
          if (bindingType & 256) {
            const isConst = !!(bindingType & 512);
            const wasConst = (type & 4) > 0;
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & 128 && (type & 8) > 0) {
          if (scope.names.get(name2) & 2) {
            return !!(bindingType & 1);
          } else {
            return false;
          }
        }
        if (bindingType & 2 && (type & 1) > 0) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name2, bindingType);
      }
      checkLocalExport(id3) {
        const {
          name: name2
        } = id3;
        if (this.hasImport(name2)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          const type = scope.tsNames.get(name2);
          if ((type & 1) > 0 || (type & 16) > 0) {
            return;
          }
        }
        super.checkLocalExport(id3);
      }
    };
    var unwrapParenthesizedExpression = (node3) => {
      return node3.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node3.expression) : node3;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node3, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node3.type === "ParenthesizedExpression" || (_node$extra = node3.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node3);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node3);
            } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
              this.raise(Errors.InvalidParenthesizedAssignment, node3);
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, node3);
          }
        }
        switch (node3.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node3.type = "ObjectPattern";
            for (let i = 0, length = node3.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node3.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node3.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, node3.extra.trailingCommaLoc);
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value: value2
            } = node3;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value2, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            node3.type = "ArrayPattern";
            this.toAssignableList(node3.elements, (_node$extra3 = node3.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node3.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, node3.left.loc.end);
            }
            node3.type = "AssignmentPattern";
            delete node3.operator;
            this.toAssignable(node3.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === "SpreadElement") {
          prop.type = "RestElement";
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, prop);
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          const elt = exprList[i];
          if (!elt) continue;
          if (elt.type === "SpreadElement") {
            elt.type = "RestElement";
            const arg = elt.argument;
            this.checkToRestConversion(arg, true);
            this.toAssignable(arg, isLHS);
          } else {
            this.toAssignable(elt, isLHS);
          }
          if (elt.type === "RestElement") {
            if (i < end) {
              this.raise(Errors.RestTrailingComma, elt);
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, trailingCommaLoc);
            }
          }
        }
      }
      isAssignable(node3, isBinding) {
        switch (node3.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node3.properties.length - 1;
            return node3.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node3.value);
          case "SpreadElement":
            return this.isAssignable(node3.argument);
          case "ArrayExpression":
            return node3.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node3.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node3.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node3 = this.startNode();
        this.next();
        node3.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node3, "SpreadElement");
      }
      parseRestBinding() {
        const node3 = this.startNode();
        this.next();
        node3.argument = this.parseBindingAtom();
        return this.finishNode(node3, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node3 = this.startNode();
            this.next();
            node3.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node3, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close2, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first2 = true;
        while (!this.eat(close2)) {
          if (first2) {
            first2 = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close2)) {
            break;
          } else if (this.match(21)) {
            let rest = this.parseRestBinding();
            if (this.hasPlugin("flow") || flags & 2) {
              rest = this.parseFunctionParamType(rest);
            }
            elts.push(rest);
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close2);
              break;
            }
          } else {
            const decorators = [];
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
            elts.push(this.parseAssignableListItem(flags, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(this.startNode());
        }
        const prop = this.startNode();
        if (type === 139) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseAssignableListItem(flags, decorators) {
        const left = this.parseMaybeDefault();
        if (this.hasPlugin("flow") || flags & 2) {
          this.parseFunctionParamType(left);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseFunctionParamType(param) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        var _startLoc, _left;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(29)) return left;
        const node3 = this.startNodeAt(startLoc);
        node3.left = left;
        node3.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node3, "AssignmentPattern");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "AssignmentPattern":
            return "left";
          case "RestElement":
            return "argument";
          case "ObjectProperty":
            return "value";
          case "ParenthesizedExpression":
            return "expression";
          case "ArrayPattern":
            return "elements";
          case "ObjectPattern":
            return "properties";
        }
        return false;
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, ancestor, binding = 64, checkClashes = false, strictModeChanged = false, hasParenthesizedAncestor = false) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression)) return;
        const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression || type === "MemberExpression") {
          if (isOptionalMemberExpression) {
            this.expectPlugin("optionalChainingAssign", expression.loc.start);
            if (ancestor.type !== "AssignmentExpression") {
              this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                ancestor
              });
            }
          }
          if (binding !== 64) {
            this.raise(Errors.InvalidPropertyBindingPattern, expression);
          }
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          const {
            name: name2
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name2)) {
              this.raise(Errors.ParamDupe, expression);
            } else {
              checkClashes.add(name2);
            }
          }
          return;
        }
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true) return;
        if (validity === false) {
          const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, expression, {
            ancestor
          });
          return;
        }
        let key, isParenthesizedExpression;
        if (typeof validity === "string") {
          key = validity;
          isParenthesizedExpression = type === "ParenthesizedExpression";
        } else {
          [key, isParenthesizedExpression] = validity;
        }
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor;
        const val = expression[key];
        if (Array.isArray(val)) {
          for (const child of val) {
            if (child) {
              this.checkLVal(child, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
            }
          }
        } else if (val) {
          this.checkLVal(val, nextAncestor, binding, checkClashes, strictModeChanged, isParenthesizedExpression);
        }
      }
      checkIdentifier(at2, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at2.name, this.inModule) : isStrictBindOnlyReservedWord(at2.name))) {
          if (bindingType === 64) {
            this.raise(Errors.StrictEvalArguments, at2, {
              referenceName: at2.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, at2, {
              bindingName: at2.name
            });
          }
        }
        if (bindingType & 8192 && at2.name === "let") {
          this.raise(Errors.LetInLexicalBinding, at2);
        }
        if (!(bindingType & 64)) {
          this.declareNameFromIdentifier(at2, bindingType);
        }
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node3, allowPattern) {
        switch (node3.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node3.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern) break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, node3);
        }
      }
      checkCommaAfterRest(close2) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close2 ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        return true;
      }
    };
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert2(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      AccessorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccessorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers
      }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccessorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccessorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccessorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
    });
    function keywordTypeFromName(value2) {
      switch (value2) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(139) || this.isLiteralPropertyName();
      }
      tsNextTokenOnSameLineAndCanFollowModifier() {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          return false;
        }
        return this.tsTokenCanFollowModifier();
      }
      tsNextTokenCanFollowModifier() {
        if (this.match(106)) {
          this.next();
          return this.tsTokenCanFollowModifier();
        }
        return this.tsNextTokenOnSameLineAndCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.includes(modifier)) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, loc, {
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, loc, {
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, startLoc, {
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node3 = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(134)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
          {
            node3.argument = super.parseExprAtom();
          }
        } else {
          {
            node3.argument = this.parseStringLiteral(this.state.value);
          }
        }
        if (this.eat(12) && !this.match(11)) {
          node3.options = super.parseMaybeAssignAllowIn();
          this.eat(12);
        } else {
          node3.options = null;
        }
        this.expect(11);
        if (this.eat(16)) {
          node3.qualifier = this.tsParseEntityName(1 | 2);
        }
        if (this.match(47)) {
          {
            node3.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node3, "TSImportType");
      }
      tsParseEntityName(flags) {
        let entity;
        if (flags & 1 && this.match(78)) {
          if (flags & 2) {
            entity = this.parseIdentifier(true);
          } else {
            const node3 = this.startNode();
            this.next();
            entity = this.finishNode(node3, "ThisExpression");
          }
        } else {
          entity = this.parseIdentifier(!!(flags & 1));
        }
        while (this.eat(16)) {
          const node3 = this.startNodeAtNode(entity);
          node3.left = entity;
          node3.right = this.parseIdentifier(!!(flags & 1));
          entity = this.finishNode(node3, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node3 = this.startNode();
        node3.typeName = this.tsParseEntityName(1);
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node3.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node3, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node3 = this.startNodeAtNode(lhs);
        node3.parameterName = lhs;
        node3.typeAnnotation = this.tsParseTypeAnnotation(false);
        node3.asserts = false;
        return this.finishNode(node3, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node3 = this.startNode();
        this.next();
        return this.finishNode(node3, "TSThisType");
      }
      tsParseTypeQuery() {
        const node3 = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node3.exprName = this.tsParseImportType();
        } else {
          {
            node3.exprName = this.tsParseEntityName(1 | 2);
          }
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          {
            node3.typeParameters = this.tsParseTypeArguments();
          }
        }
        return this.finishNode(node3, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        const node3 = this.startNode();
        parseModifiers(node3);
        node3.name = this.tsParseTypeParameterName();
        node3.constraint = this.tsEatThenParseType(81);
        node3.default = this.tsEatThenParseType(29);
        return this.finishNode(node3, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node3 = this.startNode();
        if (this.match(47) || this.match(143)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node3.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node3.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, node3);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node3, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node3, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        const list2 = super.parseBindingList(11, 41, 2);
        for (const pattern2 of list2) {
          const {
            type
          } = pattern2;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern2, {
              type
            });
          }
        }
        return list2;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node3) {
        this.tsFillSignature(14, node3);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node3, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node3) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        const id3 = this.parseIdentifier();
        id3.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id3);
        this.expect(3);
        node3.parameters = [id3];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node3.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node3, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node3, readonly) {
        if (this.eat(17)) node3.optional = true;
        const nodeAny = node3;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, node3);
          }
          const method = nodeAny;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccessorCannotHaveTypeParameters, this.state.curPosition());
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, this.state.curPosition());
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccessorCannotDeclareThisParameter, this.state.curPosition());
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccessorCannotHaveOptionalParameter, this.state.curPosition());
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccessorCannotHaveRestParameter, this.state.curPosition());
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccessorCannotHaveReturnType, method[returnTypeKey]);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node3 = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node3);
        }
        if (this.match(77)) {
          const id3 = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node3);
          } else {
            node3.key = this.createIdentifier(id3, "new");
            return this.tsParsePropertyOrMethodSignature(node3, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node3);
        const idx = this.tsTryParseIndexSignature(node3);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node3);
        if (!node3.computed && node3.key.type === "Identifier" && (node3.key.name === "get" || node3.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node3.kind = node3.key.name;
          super.parsePropertyName(node3);
        }
        return this.tsParsePropertyOrMethodSignature(node3, !!node3.readonly);
      }
      tsParseTypeLiteral() {
        const node3 = this.startNode();
        node3.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node3, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedType() {
        const node3 = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node3.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node3.readonly = true;
        }
        this.expect(0);
        {
          const typeParameter = this.startNode();
          typeParameter.name = this.tsParseTypeParameterName();
          typeParameter.constraint = this.tsExpectThenParseType(58);
          node3.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        }
        node3.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node3.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node3.optional = true;
        }
        node3.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node3, "TSMappedType");
      }
      tsParseTupleType() {
        const node3 = this.startNode();
        node3.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        node3.elementTypes.forEach((elementNode) => {
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node3, "TSTupleType");
      }
      tsParseTupleElementType() {
        const restStartLoc = this.state.startLoc;
        const rest = this.eat(21);
        const {
          startLoc
        } = this.state;
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          const wordName = this.state.value;
          const typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          let labeledNode;
          if (label) {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
            }
          } else {
            labeledNode = this.startNodeAt(startLoc);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, type);
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAt(startLoc);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(restStartLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node3 = this.startNode();
        this.expect(10);
        node3.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node3, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node3 = this.startNode();
        if (type === "TSConstructorType") {
          node3.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node3));
        return this.finishNode(node3, type);
      }
      tsParseLiteralTypeNode() {
        const node3 = this.startNode();
        switch (this.state.type) {
          case 135:
          case 136:
          case 134:
          case 85:
          case 86:
            node3.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node3, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        {
          const node3 = this.startNode();
          node3.literal = super.parseTemplate(false);
          return this.finishNode(node3, "TSLiteralType");
        }
      }
      parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 134:
          case 135:
          case 136:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node3 = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 135 && nextToken.type !== 136) {
                this.unexpected();
              }
              node3.literal = this.parseMaybeUnary();
              return this.finishNode(node3, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node3 = this.startNode();
                this.next();
                return this.finishNode(node3, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        const {
          startLoc
        } = this.state;
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node3 = this.startNodeAt(startLoc);
            node3.elementType = type;
            this.expect(3);
            type = this.finishNode(node3, "TSArrayType");
          } else {
            const node3 = this.startNodeAt(startLoc);
            node3.objectType = type;
            node3.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node3, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node3 = this.startNode();
        const operator = this.state.value;
        this.next();
        node3.operator = operator;
        node3.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node3);
        }
        return this.finishNode(node3, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node3) {
        switch (node3.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node3);
        }
      }
      tsParseInferType() {
        const node3 = this.startNode();
        this.expectContextual(115);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node3.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node3, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node3 = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types4 = [];
        do {
          types4.push(parseConstituentType());
        } while (this.eat(operator));
        if (types4.length === 1 && !hasLeadingOperator) {
          return types4[0];
        }
        node3.types = types4;
        return this.finishNode(node3, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, 1);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node3 = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node3.parameterName = thisTypePredicate;
              node3.asserts = true;
              node3.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node3, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node3);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t);
            }
            node3.parameterName = this.parseIdentifier();
            node3.asserts = asserts;
            node3.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node3, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node3.parameterName = typePredicateVariable;
          node3.typeAnnotation = type;
          node3.asserts = asserts;
          t.typeAnnotation = this.finishNode(node3, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id3 = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id3;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(14);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseType() {
        assert2(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node3 = this.startNodeAtNode(type);
        node3.checkType = type;
        node3.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node3.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node3.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node3, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.lookahead().type === 77;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        const node3 = this.startNode();
        node3.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node3.expression = this.parseMaybeUnary();
        return this.finishNode(node3, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node3 = this.startNode();
          {
            node3.expression = this.tsParseEntityName(1 | 2);
            if (this.match(47)) {
              node3.typeParameters = this.tsParseTypeArguments();
            }
            return this.finishNode(node3, "TSExpressionWithTypeArguments");
          }
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
            token
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node3, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual(129);
        if (properties.declare) node3.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node3.id = this.parseIdentifier();
          this.checkIdentifier(node3.id, 130);
        } else {
          node3.id = null;
          this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        node3.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node3.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node3.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node3, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node3) {
        node3.id = this.parseIdentifier();
        this.checkIdentifier(node3.id, 2);
        node3.typeAnnotation = this.tsInType(() => {
          node3.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
          this.expect(29);
          if (this.isContextual(114) && this.lookahead().type !== 16) {
            const node4 = this.startNode();
            this.next();
            return this.finishNode(node4, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node3, "TSTypeAliasDeclaration");
      }
      tsInTopLevelContext(cb) {
        if (this.curContext() !== types3.brace) {
          const oldContext = this.state.context;
          this.state.context = [oldContext[0]];
          try {
            return cb();
          } finally {
            this.state.context = oldContext;
          }
        } else {
          return cb();
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        if (this.match(token)) {
          return this.tsNextThenParseType();
        }
      }
      tsExpectThenParseType(token) {
        return this.tsInType(() => {
          this.expect(token);
          return this.tsParseType();
        });
      }
      tsNextThenParseType() {
        return this.tsInType(() => {
          this.next();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node3 = this.startNode();
        node3.id = this.match(134) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node3.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node3, "TSEnumMember");
      }
      tsParseEnumDeclaration(node3, properties = {}) {
        if (properties.const) node3.const = true;
        if (properties.declare) node3.declare = true;
        this.expectContextual(126);
        node3.id = this.parseIdentifier();
        this.checkIdentifier(node3.id, node3.const ? 8971 : 8459);
        {
          this.expect(5);
          node3.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
          this.expect(8);
        }
        return this.finishNode(node3, "TSEnumDeclaration");
      }
      tsParseEnumBody() {
        const node3 = this.startNode();
        this.expect(5);
        node3.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node3, "TSEnumBody");
      }
      tsParseModuleBlock() {
        const node3 = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node3.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node3, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node3, nested = false) {
        node3.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node3.id, 1024);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node3.body = inner;
        } else {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node3.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node3, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node3) {
        if (this.isContextual(112)) {
          node3.kind = "global";
          {
            node3.global = true;
          }
          node3.id = this.parseIdentifier();
        } else if (this.match(134)) {
          node3.kind = "module";
          node3.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node3.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node3, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node3, maybeDefaultIdentifier, isExport) {
        {
          node3.isExport = isExport || false;
        }
        node3.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node3.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node3.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        node3.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node3, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(0);
      }
      tsParseExternalModuleReference() {
        const node3 = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(134)) {
          this.unexpected();
        }
        node3.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node3, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node) return;
        if (result.error) this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        }
        this.state = state;
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let startType = this.state.type;
        let kind;
        if (this.isContextual(100)) {
          startType = 74;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, false);
            case 80:
              nany.declare = true;
              return this.parseClass(nany, true, false);
            case 126:
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            case 75:
            case 74:
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            case 129: {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result) return result;
            }
            default:
              if (tokenIsIdentifier(startType)) {
                return this.tsParseDeclaration(nany, this.state.value, true, null);
              }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(node3, expr, decorators) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node3);
            if (declaration) {
              declaration.declare = true;
            }
            return declaration;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(256);
              this.prodParam.enter(0);
              const mod = node3;
              mod.kind = "global";
              {
                node3.global = true;
              }
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node3, expr.name, false, decorators);
        }
      }
      tsParseDeclaration(node3, value2, next, decorators) {
        switch (value2) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node3, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(134)) {
                return this.tsParseAmbientExternalModuleDeclaration(node3);
              } else if (tokenIsIdentifier(this.state.type)) {
                node3.kind = "module";
                return this.tsParseModuleOrNamespaceDeclaration(node3);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              node3.kind = "namespace";
              return this.tsParseModuleOrNamespaceDeclaration(node3);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node3);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47)) return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node3 = this.startNodeAt(startLoc);
          node3.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node3);
          node3.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node3;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) return;
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node3 = this.startNode();
        node3.params = this.tsInType(() => this.tsInTopLevelContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node3.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, node3);
        } else if (!this.state.inType && this.curContext() === types3.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node3, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(flags, decorators) {
        const startLoc = this.state.startLoc;
        const modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        const accessibility = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        if (!(flags & 4) && (accessibility || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        const left = this.parseMaybeDefault();
        if (flags & 2) {
          this.parseFunctionParamType(left);
        }
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node3) {
        return node3.type === "TSParameterProperty" && super.isSimpleParameter(node3.parameter) || super.isSimpleParameter(node3);
      }
      tsDisallowOptionalPattern(node3) {
        for (const param of node3.params) {
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, param);
          }
        }
      }
      setArrowFunctionParameters(node3, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node3, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node3);
      }
      parseFunctionBodyAndFinish(node3, type, isMethod = false) {
        if (this.match(14)) {
          node3.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node3, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, node3);
          if (node3.declare) {
            return super.parseFunctionBodyAndFinish(node3, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node3);
        return super.parseFunctionBodyAndFinish(node3, type, isMethod);
      }
      registerFunctionStatementId(node3) {
        if (!node3.body && node3.id) {
          this.checkIdentifier(node3.id, 1024);
        } else {
          super.registerFunctionStatementId(node3);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node3) => {
          if ((node3 == null ? void 0 : node3.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, node3.typeAnnotation);
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close2, canBePattern, isTuple, refExpressionErrors) {
        const node3 = super.parseArrayLike(close2, canBePattern, isTuple, refExpressionErrors);
        if (node3.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node3.elements);
        }
        return node3;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              {
                result2.typeParameters = typeArguments;
              }
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node4 = this.startNodeAt(startLoc);
              node4.callee = base;
              node4.arguments = this.parseCallExpressionArguments(11);
              this.tsCheckForInvalidTypeCasts(node4.arguments);
              {
                node4.typeParameters = typeArguments;
              }
              if (state.optionalChainMember) {
                node4.optional = isOptionalCall;
              }
              return this.finishCallExpression(node4, state.optionalChainMember);
            }
            const tokenType2 = this.state.type;
            if (tokenType2 === 48 || tokenType2 === 52 || tokenType2 !== 10 && tokenCanStartExpression(tokenType2) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node3 = this.startNodeAt(startLoc);
            node3.expression = base;
            {
              node3.typeParameters = typeArguments;
            }
            return this.finishNode(node3, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
              this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node3) {
        var _callee$extra;
        super.parseNewCallee(node3);
        const {
          callee
        } = node3;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          {
            node3.typeParameters = callee.typeParameters;
          }
          node3.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          const node3 = this.startNodeAt(leftStartLoc);
          node3.expression = left;
          node3.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node3, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node3, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word2, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word2, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node3) {
        super.checkImportReflection(node3);
        if (node3.module && node3.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, node3.specifiers[0].loc.start);
        }
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          const ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node3, isExport, phase, loc) {
        super.applyImportPhase(node3, isExport, phase, loc);
        if (isExport) {
          node3.exportKind = phase === "type" ? "type" : "value";
        } else {
          node3.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImport(node3) {
        if (this.match(134)) {
          node3.importKind = "value";
          return super.parseImport(node3);
        }
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node3.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node3);
        } else if (this.isContextual(130)) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node3, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node3, maybeDefaultIdentifier);
          } else {
            importNode = super.parseImportSpecifiersAndAfter(node3, maybeDefaultIdentifier);
          }
        } else {
          importNode = super.parseImport(node3);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        return importNode;
      }
      parseExport(node3, decorators) {
        if (this.match(83)) {
          const nodeImportEquals = node3;
          this.next();
          let maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
          } else {
            nodeImportEquals.importKind = "value";
          }
          const declaration = this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
          {
            return declaration;
          }
        } else if (this.eat(29)) {
          const assign = node3;
          assign.expression = super.parseExpression();
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl2 = node3;
          this.expectContextual(128);
          decl2.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl2, "TSNamespaceExportDeclaration");
        } else {
          return super.parseExport(node3, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(124) && this.lookahead().type === 80;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node3, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node3, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext) return declaration;
        for (const {
          id: id3,
          init: init2
        } of declaration.declarations) {
          if (!init2) continue;
          if (kind !== "const" || !!id3.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init2);
          } else if (!isValidAmbientConstInitializer(init2, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitializerMustBeStringOrNumericLiteralOrLiteralEnumReference, init2);
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const node3 = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node3, {
            const: true
          });
        }
        if (this.isContextual(126)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, member);
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, member);
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, member);
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, member);
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
      }
      parseExpressionStatement(node3, expr, decorators) {
        const decl2 = expr.type === "Identifier" ? this.tsParseExpressionStatement(node3, expr, decorators) : void 0;
        return decl2 || super.parseExpressionStatement(node3, expr, decorators);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) {
          return super.parseConditional(expr, startLoc, refExpressionErrors);
        }
        const result = this.tryParse(() => super.parseConditional(expr, startLoc));
        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }
          return expr;
        }
        if (result.error) this.state = result.failState;
        return result.node;
      }
      parseParenItem(node3, startLoc) {
        const newNode = super.parseParenItem(node3, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node3);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node3;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node3;
      }
      parseExportDeclaration(node3) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node3));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        const isIdentifier2 = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier2 && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node3);
        if (!declaration) return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node3.exportKind = "type";
        }
        if (isDeclare && declaration.type !== "TSImportEqualsDeclaration") {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node3, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113)) {
          return;
        }
        super.parseClassId(node3, isStatement, optionalId, node3.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters) node3.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node3) {
        if (!node3.optional) {
          if (this.eat(35)) {
            node3.definite = true;
          } else if (this.eat(17)) {
            node3.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node3.typeAnnotation = type;
      }
      parseClassProperty(node3) {
        this.parseClassPropertyAnnotation(node3);
        if (this.state.isAmbientContext && !(node3.readonly && !node3.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        if (node3.abstract && this.match(29)) {
          const {
            key
          } = node3;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: key.type === "Identifier" && !node3.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
          });
        }
        return super.parseClassProperty(node3);
      }
      parseClassPrivateProperty(node3) {
        if (node3.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, node3);
        }
        if (node3.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, node3, {
            modifier: node3.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node3);
        return super.parseClassPrivateProperty(node3);
      }
      parseClassAccessorProperty(node3) {
        this.parseClassPropertyAnnotation(node3);
        if (node3.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, node3);
        }
        return super.parseClassAccessorProperty(node3);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, method, {
            kind
          });
        }
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node3, kind) {
        if (node3.type === "TSDeclareMethod") return;
        if (node3.type === "MethodDefinition" && !hasOwnProperty.call(node3.value, "body")) {
          return;
        }
        super.declareClassPrivateMethodInScope(node3, kind);
      }
      parseClassSuper(node3) {
        super.parseClassSuper(node3);
        if (node3.superClass && (this.match(47) || this.match(51))) {
          {
            node3.superTypeParameters = this.tsParseTypeArgumentsInExpression();
          }
        }
        if (this.eatContextual(113)) {
          node3.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node3, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node3.typeParameters = typeParameters;
        super.parseFunctionParams(node3, isConstructor);
      }
      parseVarId(decl2, kind) {
        super.parseVarId(decl2, kind);
        if (decl2.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl2.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl2.id.typeAnnotation = type;
          this.resetEndLocation(decl2.id);
        }
      }
      parseAsyncArrowFromCallExpression(node3, call2) {
        if (this.match(14)) {
          node3.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node3, call2);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(143) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types3.j_oTag || currentContext === types3.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state) state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert2(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error) return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node3) {
        var _node$extra;
        if (node3.params.length === 1 && !node3.params[0].constraint && !((_node$extra = node3.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, node3);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node3) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19)) abort();
            return returnType;
          });
          if (result.aborted) return;
          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node3.returnType = result.node;
          }
        }
        return super.parseArrow(node3);
      }
      parseFunctionParamType(param) {
        if (this.eat(17)) {
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node3, isBinding) {
        switch (node3.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node3.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node3, isBinding);
        }
      }
      toAssignable(node3, isLHS = false) {
        switch (node3.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node3, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node3);
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, node3);
            }
            this.toAssignable(node3.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node3.left.type === "TSTypeCastExpression") {
              node3.left = this.typeCastToParameter(node3.left);
            }
          default:
            super.toAssignable(node3, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node3, isLHS) {
        switch (node3.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node3.expression, isLHS);
            break;
          default:
            super.toAssignable(node3, isLHS);
        }
      }
      checkToRestConversion(node3, allowPattern) {
        switch (node3.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node3.expression, false);
            break;
          default:
            super.checkToRestConversion(node3, allowPattern);
        }
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        switch (type) {
          case "TSTypeCastExpression":
            return true;
          case "TSParameterProperty":
            return "parameter";
          case "TSNonNullExpression":
          case "TSInstantiationExpression":
            return "expression";
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
            return (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true];
          default:
            return super.isValidLVal(type, isUnparenthesizedInAssign, binding);
        }
      }
      parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call2 = super.parseMaybeDecoratorArguments(expr, startLoc);
            {
              call2.typeParameters = typeArguments;
            }
            return call2;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr, startLoc);
      }
      checkCommaAfterRest(close2) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close2) {
          this.next();
          return false;
        }
        return super.checkCommaAfterRest(close2);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node3 = super.parseMaybeDefault(startLoc, left);
        if (node3.type === "AssignmentPattern" && node3.typeAnnotation && node3.right.start < node3.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, node3.typeAnnotation);
        }
        return node3;
      }
      getTokenFromCode(code2) {
        if (this.state.inType) {
          if (code2 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code2 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code2);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      typeCastToParameter(node3) {
        node3.expression.typeAnnotation = node3.typeAnnotation;
        this.resetEndLocation(node3.expression, node3.typeAnnotation.loc.end);
        return node3.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node3) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments) {
            {
              node3.typeParameters = typeArguments;
            }
          }
        }
        return super.jsxParseOpeningElementAfterName(node3);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const {
          isAmbientContext: oldIsAmbientContext,
          strict: oldStrict
        } = this.state;
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
          this.state.strict = oldStrict;
        }
      }
      parseClass(node3, isStatement, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node3.abstract;
        try {
          return super.parseClass(node3, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node3, decorators) {
        if (this.match(80)) {
          node3.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node3, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node3.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node3);
            return this.tsParseInterfaceDeclaration(node3);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(node3, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node3, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract) {
          const hasEstreePlugin = this.hasPlugin("estree");
          const methodFn = hasEstreePlugin ? method.value : method;
          if (methodFn.body) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, method, {
              methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(this.offsetToSourcePos(key.start), this.offsetToSourcePos(key.end))}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node3, isString3, isInTypeExport, isMaybeTypeOnly) {
        if (!isString3 && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node3, false, isInTypeExport);
          return this.finishNode(node3, "ExportSpecifier");
        }
        node3.exportKind = "value";
        return super.parseExportSpecifier(node3, isString3, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
      }
      parseTypeOnlyImportExportSpecifier(node3, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node3[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        node3[leftOfAsKey] = leftOfAs;
        node3[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node3[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node3[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node3[rightOfAsKey]) {
          node3[rightOfAsKey] = cloneIdentifier(node3[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node3[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression") return false;
      const {
        computed,
        property
      } = expression;
      if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      const {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type === "Literal") {
          const {
            value: value2
          } = expression;
          if (typeof value2 === "string" || typeof value2 === "boolean") {
            return true;
          }
        }
      } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber2(expression, estree2) || isNegativeNumber(expression, estree2)) {
        return true;
      }
      if (type === "TemplateLiteral" && expression.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression)) {
        return true;
      }
      return false;
    }
    function isNumber2(expression, estree2) {
      if (estree2) {
        return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
      }
      return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        const {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber2(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier") return true;
      if (expression.type !== "MemberExpression" || expression.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(133)) {
          const node3 = this.startNode();
          this.next();
          this.assertNoSpace();
          node3.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(133);
          return this.finishPlaceholder(node3, expectedNode);
        }
      }
      finishPlaceholder(node3, expectedNode) {
        let placeholder = node3;
        if (!placeholder.expectedNode || !placeholder.type) {
          placeholder = this.finishNode(placeholder, "Placeholder");
        }
        placeholder.expectedNode = expectedNode;
        return placeholder;
      }
      getTokenFromCode(code2) {
        if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(133, 2);
        } else {
          super.getTokenFromCode(code2);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word2, startLoc, checkKeywords, isBinding) {
        if (word2 !== void 0) {
          super.checkReservedWord(word2, startLoc, checkKeywords, isBinding);
        }
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
      }
      toAssignable(node3, isLHS) {
        if (node3 && node3.type === "Placeholder" && node3.expectedNode === "Expression") {
          node3.expectedNode = "Pattern";
        } else {
          super.toAssignable(node3, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
          return true;
        }
        const nextToken = this.lookahead();
        if (nextToken.type === 133) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node3, isBreak) {
        if (node3.label && node3.label.type === "Placeholder") return;
        super.verifyBreakContinue(node3, isBreak);
      }
      parseExpressionStatement(node3, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return super.parseExpressionStatement(node3, expr);
        }
        if (this.match(14)) {
          const stmt = node3;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        const stmtPlaceholder = node3;
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node3, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(133) || this.match(5)) {
            node3.id = placeholder;
          } else if (optionalId || !isStatement) {
            node3.id = null;
            node3.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node3, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        } else {
          this.parseClassId(node3, isStatement, optionalId);
        }
        super.parseClassSuper(node3);
        node3.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node3.superClass, oldStrict);
        return this.finishNode(node3, type);
      }
      parseExport(node3, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseExport(node3, decorators);
        const node22 = node3;
        if (!this.isContextual(98) && !this.match(12)) {
          node22.specifiers = [];
          node22.source = null;
          node22.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node22, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node22.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node22, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(133), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node3, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node3.specifiers) != null && _specifiers.length) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node3, maybeDefaultIdentifier);
      }
      checkExport(node3) {
        const {
          specifiers
        } = node3;
        if (specifiers != null && specifiers.length) {
          node3.specifiers = specifiers.filter((node4) => node4.exported.type === "Placeholder");
        }
        super.checkExport(node3);
        node3.specifiers = specifiers;
      }
      parseImport(node3) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseImport(node3);
        node3.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node3.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node3, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node3.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node3);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node3);
        }
        this.expectContextual(98);
        node3.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node3, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.offsetToSourcePos(this.state.lastTokEndLoc.index)) {
          this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node3 = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name2 = this.parseIdentifierName();
            const identifier = this.createIdentifier(node3, name2);
            identifier.type = "V8IntrinsicIdentifier";
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    function validatePlugins(pluginsMap) {
      if (pluginsMap.has("decorators")) {
        if (pluginsMap.has("decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = pluginsMap.get("decorators").decoratorsBeforeExport;
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        const allowCallParenthesized = pluginsMap.get("decorators").allowCallParenthesized;
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (pluginsMap.has("flow") && pluginsMap.has("typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (pluginsMap.has("placeholders") && pluginsMap.has("v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (pluginsMap.has("pipelineOperator")) {
        var _pluginsMap$get;
        const proposal = pluginsMap.get("pipelineOperator").proposal;
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const tupleSyntaxIsHash = ((_pluginsMap$get = pluginsMap.get("recordAndTuple")) == null ? void 0 : _pluginsMap$get.syntaxType) === "hash";
        if (proposal === "hack") {
          if (pluginsMap.has("placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (pluginsMap.has("v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = pluginsMap.get("pipelineOperator").topicToken;
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(["recordAndTuple", pluginsMap.get("recordAndTuple")])}\`.`);
        }
      }
      if (pluginsMap.has("moduleAttributes")) {
        {
          if (pluginsMap.has("deprecatedImportAssert") || pluginsMap.has("importAssertions")) {
            throw new Error("Cannot combine importAssertions, deprecatedImportAssert and moduleAttributes plugins.");
          }
          const moduleAttributesVersionPluginOption = pluginsMap.get("moduleAttributes").version;
          if (moduleAttributesVersionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (pluginsMap.has("importAssertions")) {
        if (pluginsMap.has("deprecatedImportAssert")) {
          throw new Error("Cannot combine importAssertions and deprecatedImportAssert plugins.");
        }
      }
      if (!pluginsMap.has("deprecatedImportAssert") && pluginsMap.has("importAttributes") && pluginsMap.get("importAttributes").deprecatedAssertSyntax) {
        {
          pluginsMap.set("deprecatedImportAssert", {});
        }
      }
      if (pluginsMap.has("recordAndTuple")) {
        const syntaxType = pluginsMap.get("recordAndTuple").syntaxType;
        if (syntaxType != null) {
          {
            const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
            if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            }
          }
        }
      }
      if (pluginsMap.has("asyncDoExpressions") && !pluginsMap.has("doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (pluginsMap.has("optionalChainingAssign") && pluginsMap.get("optionalChainingAssign").version !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return;
        }
        const key = prop.key;
        const name2 = key.type === "Identifier" ? key.name : key.value;
        if (name2 === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, key);
            return;
          }
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, key);
            }
          }
          protoRef.used = true;
        }
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && this.offsetToSourcePos(expr.start) === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(140)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        if (this.optionFlags & 128) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node3 = this.startNodeAt(startLoc);
          node3.expressions = [expr];
          while (this.eat(12)) {
            node3.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node3.expressions);
          return this.finishNode(node3, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$loc;
        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        if (this.isContextual(108)) {
          if (this.prodParam.hasYield) {
            let left2 = this.parseYield();
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node3 = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node3.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node3.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node3.left = left;
          }
          this.next();
          node3.right = this.parseMaybeAssign();
          this.checkLVal(left, this.finishNode(node3, "AssignmentExpression"));
          return node3;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node3 = this.startNodeAt(startLoc);
          node3.test = expr;
          node3.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node3.alternate = this.parseMaybeAssign();
          return this.finishNode(node3, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(139) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value2 = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, left, {
              identifierName: value2
            });
          }
          this.classScope.usePrivateName(value2, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node3 = this.startNodeAt(leftStartLoc);
            node3.left = left;
            node3.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
              }
            }
            node3.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node3, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
            if (this.getPluginOption("pipelineOperator", "proposal") === "smart") {
              return this.withTopicBindingContext(() => {
                if (this.prodParam.hasYield && this.isContextual(108)) {
                  throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                }
                return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
              });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, startLoc);
        }
        return body;
      }
      checkExponentialAfterUnary(node3) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, node3.argument);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.recordAwaitIfAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary) this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node3 = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node3.operator = this.state.value;
          node3.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node3.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node3.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, node3);
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, node3);
            }
          }
          if (!update) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node3);
            }
            return this.finishNode(node3, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node3, update, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousAwait()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node3, update, refExpressionErrors) {
        if (update) {
          const updateExpressionNode = node3;
          this.checkLVal(updateExpressionNode.argument, this.finishNode(updateExpressionNode, "UpdateExpression"));
          return node3;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node4 = this.startNodeAt(startLoc);
          node4.operator = this.state.value;
          node4.prefix = false;
          node4.argument = expr;
          this.next();
          this.checkLVal(expr, expr = this.finishNode(node4, "UpdateExpression"));
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls) {
            this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
            if (this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            state.stop = true;
            return base;
          }
        }
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node3 = this.startNodeAt(startLoc);
        node3.object = base;
        node3.computed = computed;
        if (computed) {
          node3.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(139)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, startLoc);
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node3.property = this.parsePrivateName();
        } else {
          node3.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node3.optional = optional;
          return this.finishNode(node3, "OptionalMemberExpression");
        } else {
          return this.finishNode(node3, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node3 = this.startNodeAt(startLoc);
        node3.object = base;
        this.next();
        node3.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node3, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node3 = this.startNodeAt(startLoc);
        node3.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node3.optional = optional;
        }
        if (optional) {
          node3.arguments = this.parseCallExpressionArguments(11);
        } else {
          node3.arguments = this.parseCallExpressionArguments(11, base.type !== "Super", node3, refExpressionErrors);
        }
        let finishedNode = this.finishCallExpression(node3, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node3, isParenthesizedExpr) {
        this.toReferencedListDeep(node3.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node3 = this.startNodeAt(startLoc);
        node3.tag = base;
        node3.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        return this.finishNode(node3, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && this.offsetToSourcePos(base.start) === this.state.potentialArrowAt;
      }
      finishCallExpression(node3, optional) {
        if (node3.callee.type === "Import") {
          if (node3.arguments.length === 0 || node3.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, node3);
          } else {
            for (const arg of node3.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, arg);
              }
            }
          }
        }
        return this.finishNode(node3, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close2, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first2 = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close2)) {
          if (first2) {
            first2 = false;
          } else {
            this.expect(12);
            if (this.match(close2)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node3, call2) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call2);
        this.expect(19);
        this.parseArrowExpression(node3, call2.arguments, true, (_call$extra = call2.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call2.innerComments) {
          setInnerComments(node3, call2.innerComments);
        }
        if (call2.callee.trailingComments) {
          setInnerComments(node3, call2.callee.trailingComments);
        }
        return node3;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node3;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node3 = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaProperty(node3);
            }
            if (this.match(10)) {
              if (this.optionFlags & 256) {
                return this.parseImportCall(node3);
              } else {
                return this.finishNode(node3, "Import");
              }
            } else {
              this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
              return this.finishNode(node3, "Import");
            }
          case 78:
            node3 = this.startNode();
            this.next();
            return this.finishNode(node3, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 135:
            return this.parseNumericLiteral(this.state.value);
          case 136:
            return this.parseBigIntLiteral(this.state.value);
          case 134:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 2:
          case 1: {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 6:
          case 7: {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node3 = this.startNode();
            this.next();
            node3.object = null;
            const callee = node3.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node3, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, callee);
            }
          }
          case 139: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            this.unexpected();
            break;
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            } else {
              this.unexpected();
            }
            break;
          }
          default:
            if (type === 137) {
              return this.parseDecimalLiteral(this.state.value);
            }
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id3 = this.parseIdentifier();
              if (!containsEsc && id3.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id3);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id3));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id3));
                  } else {
                    return id3;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id3);
                  return this.parseDo(this.startNodeAtNode(id3), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id3), [id3], false);
              }
              return id3;
            } else {
              this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node3 = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType2 = this.state.type;
        this.next();
        return this.finishTopicReference(node3, startLoc, pipeProposal, tokenType2);
      }
      finishTopicReference(node3, startLoc, pipeProposal, tokenType2) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType2)) {
          if (pipeProposal === "hack") {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PipeTopicUnbound, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node3, "TopicReference");
          } else {
            if (!this.topicReferenceIsAllowedInCurrentContext()) {
              this.raise(Errors.PrimaryTopicNotAllowed, startLoc);
            }
            this.registerTopicReference();
            return this.finishNode(node3, "PipelinePrimaryTopicReference");
          }
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
            token: tokenLabelName(tokenType2)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType2) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType2)
            }]);
          }
          case "smart":
            return tokenType2 === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
      }
      parseAsyncArrowUnaryFunction(node3) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        this.expect(19);
        return this.parseArrowExpression(node3, params, true);
      }
      parseDo(node3, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node3.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(2);
          node3.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node3.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node3, "DoExpression");
      }
      parseSuper() {
        const node3 = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !(this.optionFlags & 16)) {
          this.raise(Errors.SuperNotAllowed, node3);
        } else if (!this.scope.allowSuper && !(this.optionFlags & 16)) {
          this.raise(Errors.UnexpectedSuper, node3);
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, node3);
        }
        return this.finishNode(node3, "Super");
      }
      parsePrivateName() {
        const node3 = this.startNode();
        const id3 = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name2 = this.state.value;
        this.next();
        node3.id = this.createIdentifier(id3, name2);
        return this.finishNode(node3, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node3 = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node3), "function");
          this.next();
          if (this.match(103)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node3, meta, "sent");
        }
        return this.parseFunction(node3);
      }
      parseMetaProperty(node3, meta, propertyName) {
        node3.meta = meta;
        const containsEsc = this.state.containsEsc;
        node3.property = this.parseIdentifier(true);
        if (node3.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, node3.property, {
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node3, "MetaProperty");
      }
      parseImportMetaProperty(node3) {
        const id3 = this.createIdentifier(this.startNodeAtNode(node3), "import");
        this.next();
        if (this.isContextual(101)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, id3);
          }
          this.sawUnambiguousESM = true;
        } else if (this.isContextual(105) || this.isContextual(97)) {
          const isSource = this.isContextual(105);
          this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
          if (!(this.optionFlags & 256)) {
            throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
              phase: this.state.value
            });
          }
          this.next();
          node3.phase = isSource ? "source" : "defer";
          return this.parseImportCall(node3);
        }
        return this.parseMetaProperty(node3, id3, "meta");
      }
      parseLiteralAtNode(value2, type, node3) {
        this.addExtra(node3, "rawValue", value2);
        this.addExtra(node3, "raw", this.input.slice(this.offsetToSourcePos(node3.start), this.state.end));
        node3.value = value2;
        this.next();
        return this.finishNode(node3, type);
      }
      parseLiteral(value2, type) {
        const node3 = this.startNode();
        return this.parseLiteralAtNode(value2, type, node3);
      }
      parseStringLiteral(value2) {
        return this.parseLiteral(value2, "StringLiteral");
      }
      parseNumericLiteral(value2) {
        return this.parseLiteral(value2, "NumericLiteral");
      }
      parseBigIntLiteral(value2) {
        return this.parseLiteral(value2, "BigIntLiteral");
      }
      parseDecimalLiteral(value2) {
        return this.parseLiteral(value2, "DecimalLiteral");
      }
      parseRegExpLiteral(value2) {
        const node3 = this.startNode();
        this.addExtra(node3, "raw", this.input.slice(this.offsetToSourcePos(node3.start), this.state.end));
        node3.pattern = value2.pattern;
        node3.flags = value2.flags;
        this.next();
        return this.finishNode(node3, "RegExpLiteral");
      }
      parseBooleanLiteral(value2) {
        const node3 = this.startNode();
        node3.value = value2;
        this.next();
        return this.finishNode(node3, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node3 = this.startNode();
        this.next();
        return this.finishNode(node3, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first2 = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first2) {
            first2 = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc) this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(startLoc, val);
      }
      wrapParenthesis(startLoc, expression) {
        if (!(this.optionFlags & 512)) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node3) {
        if (this.eat(19)) {
          return node3;
        }
      }
      parseParenItem(node3, startLoc) {
        return node3;
      }
      parseNewOrNewTarget() {
        const node3 = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node3), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node3, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass && !(this.optionFlags & 4)) {
            this.raise(Errors.UnexpectedNewTarget, metaProp);
          }
          return metaProp;
        }
        return this.parseNew(node3);
      }
      parseNew(node3) {
        this.parseNewCallee(node3);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node3.arguments = args;
        } else {
          node3.arguments = [];
        }
        return this.finishNode(node3, "NewExpression");
      }
      parseNewCallee(node3) {
        const isImport = this.match(83);
        const callee = this.parseNoCallExpr();
        node3.callee = callee;
        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
          this.raise(Errors.ImportCallNotNewExpression, callee);
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value: value2
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value2 === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value2 === null ? null : value2.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node3 = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        while (!curElt.tail) {
          substitutions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        node3.expressions = substitutions;
        node3.quasis = quasis;
        return this.finishNode(node3, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close2, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = /* @__PURE__ */ Object.create(null);
        let first2 = true;
        const node3 = this.startNode();
        node3.properties = [];
        this.next();
        while (!this.match(close2)) {
          if (first2) {
            first2 = false;
          } else {
            this.expect(12);
            if (this.match(close2)) {
              this.addTrailingCommaExtraToNode(node3);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            this.checkProto(prop, isRecord, propHash, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, prop);
          }
          {
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
          }
          node3.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node3, type);
      }
      addTrailingCommaExtraToNode(node3) {
        this.addExtra(node3, "trailingComma", this.state.lastTokStartLoc.index);
        this.addExtra(node3, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length) this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const {
            key
          } = prop;
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, method);
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern) this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
            }
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node3 = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node3) this.unexpected();
        return node3;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value: value2
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 135:
                key = this.parseNumericLiteral(value2);
                break;
              case 134:
                key = this.parseStringLiteral(value2);
                break;
              case 136:
                key = this.parseBigIntLiteral(value2);
                break;
              case 139: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                if (type === 137) {
                  key = this.parseDecimalLiteral(value2);
                  break;
                }
                this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 139) {
            prop.computed = false;
          }
        }
      }
      initFunction(node3, isAsync) {
        node3.id = null;
        node3.generator = false;
        node3.async = isAsync;
      }
      parseMethod(node3, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node3, isAsync);
        node3.generator = isGenerator;
        this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync, node3.generator));
        this.parseFunctionParams(node3, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node3, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close2, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node3 = this.startNode();
        this.next();
        node3.elements = this.parseExprList(close2, !isTuple, refExpressionErrors, node3);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node3, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node3, params, isAsync, trailingCommaLoc) {
        this.scope.enter(2 | 4);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= 8;
        }
        this.prodParam.enter(flags);
        this.initFunction(node3, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node3, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node3, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node3, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node3, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node3.params = params;
      }
      parseFunctionBodyAndFinish(node3, type, isMethod = false) {
        this.parseFunctionBody(node3, false, isMethod);
        return this.finishNode(node3, type);
      }
      parseFunctionBody(node3, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node3.body = this.parseMaybeAssign();
          this.checkParams(node3, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | 4);
          node3.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node3.params);
            if (hasStrictModeDirective && nonSimple) {
              this.raise(Errors.IllegalLanguageModeDirective, (node3.kind === "method" || node3.kind === "constructor") && !!node3.key ? node3.key.loc.end : node3);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node3, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node3.id) {
              this.checkIdentifier(node3.id, 65, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node3) {
        return node3.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (!this.isSimpleParameter(params[i])) return false;
        }
        return true;
      }
      checkParams(node3, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node3.params) {
          this.checkLVal(param, formalParameters, 5, checkClashes, strictModeChanged);
        }
      }
      parseExprList(close2, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first2 = true;
        while (!this.eat(close2)) {
          if (first2) {
            first2 = false;
          } else {
            this.expect(12);
            if (this.match(close2)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
          }
          const node3 = this.startNode();
          this.next();
          elt = this.finishNode(node3, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node3 = this.startNode();
        const name2 = this.parseIdentifierName(liberal);
        return this.createIdentifier(node3, name2);
      }
      createIdentifier(node3, name2) {
        node3.name = name2;
        node3.loc.identifierName = name2;
        return this.finishNode(node3, "Identifier");
      }
      parseIdentifierName(liberal) {
        let name2;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name2 = this.state.value;
        } else {
          this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(132);
          }
        } else {
          this.checkReservedWord(name2, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name2;
      }
      checkReservedWord(word2, startLoc, checkKeywords, isBinding) {
        if (word2.length > 10) {
          return;
        }
        if (!canBeReservedWord(word2)) {
          return;
        }
        if (checkKeywords && isKeyword(word2)) {
          this.raise(Errors.UnexpectedKeyword, startLoc, {
            keyword: word2
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word2, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, startLoc, {
            reservedWord: word2
          });
          return;
        } else if (word2 === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, startLoc);
            return;
          }
        } else if (word2 === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, startLoc);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word2 === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, startLoc);
            return;
          }
        }
      }
      recordAwaitIfAllowed() {
        const isAwaitAllowed = this.prodParam.hasAwait || this.optionFlags & 1 && !this.scope.inFunction;
        if (isAwaitAllowed && !this.scope.inFunction) {
          this.state.hasTopLevelAwait = true;
        }
        return isAwaitAllowed;
      }
      parseAwait(startLoc) {
        const node3 = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node3);
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, node3);
        }
        if (!this.scope.inFunction && !(this.optionFlags & 1)) {
          if (this.isAmbiguousAwait()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node3.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node3, "AwaitExpression");
      }
      isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak()) return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 138 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield() {
        const node3 = this.startNode();
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node3);
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 140:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating) break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node3.delegate = delegating;
        node3.argument = argument;
        return this.finishNode(node3, "YieldExpression");
      }
      parseImportCall(node3) {
        this.next();
        node3.source = this.parseMaybeAssignAllowIn();
        node3.options = null;
        if (this.eat(12)) {
          if (!this.match(11)) {
            node3.options = this.parseMaybeAssignAllowIn();
            if (this.eat(12) && !this.match(11)) {
              do {
                this.parseMaybeAssignAllowIn();
              } while (this.eat(12) && !this.match(11));
              this.raise(Errors.ImportCallArity, node3);
            }
          }
        }
        this.expect(11);
        return this.finishNode(node3, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, startLoc);
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node3 = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node3.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node3, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: 1
    };
    var switchLabel = {
      kind: 2
    };
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input, startIndex) {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {
          type
        } = token;
        if (typeof type === "number") {
          {
            if (type === 139) {
              const {
                loc,
                start,
                value: value2,
                end
              } = token;
              const hashEndPos = start + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(132),
                value: value2,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start,
                value: value2,
                end
              } = token;
              const backquoteEnd = start + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start - startIndex) === 96) {
                startToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token({
                  type: getExportedToken(8),
                  value: "}",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value2 === null ? null : value2.slice(1, -1);
                endToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value2 === null ? null : value2.slice(1, -2);
                endToken = new Token({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.comments;
        if (this.optionFlags & 128) {
          file.tokens = babel7CompatTokens(this.tokens, this.input, this.startIndex);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program, end = 140, sourceType = this.options.sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule) {
          if (!(this.optionFlags & 32) && this.scope.undefinedExports.size > 0) {
            for (const [localName, at2] of Array.from(this.scope.undefinedExports)) {
              this.raise(Errors.ModuleExportUndefined, at2, {
                localName
              });
            }
          }
          this.addExtra(program, "topLevelAwait", this.state.hasTopLevelAwait);
        }
        let finishedProgram;
        if (end === 140) {
          finishedProgram = this.finishNode(program, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(this.offsetToSourcePos(directiveLiteral.start), this.offsetToSourcePos(directiveLiteral.end));
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node3 = this.startNode();
        node3.value = this.state.value;
        this.next();
        return this.finishNode(node3, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(100)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart(ch)) {
          keywordRelationalOperator.lastIndex = pos;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifierOrBrace() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
      }
      startsUsingForOf() {
        const {
          type,
          containsEsc
        } = this.lookahead();
        if (type === 102 && !containsEsc) {
          return false;
        } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      startsAwaitUsing() {
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          const nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next)) {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        return false;
      }
      parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
      }
      parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
          flags |= 4;
          if (allowLabeledFunction) {
            flags |= 8;
          }
        }
        return this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const startType = this.state.type;
        const node3 = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch (startType) {
          case 60:
            return this.parseBreakContinueStatement(node3, true);
          case 63:
            return this.parseBreakContinueStatement(node3, false);
          case 64:
            return this.parseDebuggerStatement(node3);
          case 90:
            return this.parseDoWhileStatement(node3);
          case 91:
            return this.parseForStatement(node3);
          case 68:
            if (this.lookaheadCharCode() === 46) break;
            if (!allowFunctionDeclaration) {
              this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            return this.parseFunctionStatement(node3, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration) this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node3), true);
          case 69:
            return this.parseIfStatement(node3);
          case 70:
            return this.parseReturnStatement(node3);
          case 71:
            return this.parseSwitchStatement(node3);
          case 72:
            return this.parseThrowStatement(node3);
          case 73:
            return this.parseTryStatement(node3);
          case 96:
            if (!this.state.containsEsc && this.startsAwaitUsing()) {
              if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, node3);
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, node3);
              }
              this.next();
              return this.parseVarStatement(node3, "await using");
            }
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
              break;
            }
            this.expectPlugin("explicitResourceManagement");
            if (!this.scope.inModule && this.scope.inTopLevel) {
              this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            return this.parseVarStatement(node3, "using");
          case 100: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak()) break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node3, kind);
          }
          case 92:
            return this.parseWhileStatement(node3);
          case 76:
            return this.parseWithStatement(node3);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node3);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!(this.optionFlags & 8) && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            this.next();
            let result;
            if (startType === 83) {
              result = this.parseImport(node3);
              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node3, decorators);
              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
              }
              this.next();
              return this.parseFunctionStatement(node3, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(startType) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node3, maybeName, expr, flags);
        } else {
          return this.parseExpressionStatement(node3, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node3) {
        if (!(this.optionFlags & 8) && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, node3);
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy")) return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          var _classNode$decorators;
          if ((_classNode$decorators = classNode.decorators) != null && _classNode$decorators.length) {
            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
              this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
            }
            classNode.decorators.unshift(...maybeDecorators);
          } else {
            classNode.decorators = maybeDecorators;
          }
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, this.state.startLoc);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node3 = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node3.expression = this.parseMaybeDecoratorArguments(expr, startLoc2);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node3.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node4 = this.startNodeAt(startLoc);
              node4.object = expr;
              if (this.match(139)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node4.property = this.parsePrivateName();
              } else {
                node4.property = this.parseIdentifier(true);
              }
              node4.computed = false;
              expr = this.finishNode(node4, "MemberExpression");
            }
            node3.expression = this.parseMaybeDecoratorArguments(expr, startLoc);
          }
        } else {
          node3.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node3, "Decorator");
      }
      parseMaybeDecoratorArguments(expr, startLoc) {
        if (this.eat(10)) {
          const node3 = this.startNodeAt(startLoc);
          node3.callee = expr;
          node3.arguments = this.parseCallExpressionArguments(11);
          this.toReferencedList(node3.arguments);
          return this.finishNode(node3, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node3, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node3.label = null;
        } else {
          node3.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node3, isBreak);
        return this.finishNode(node3, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node3, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node3.label == null || lab.name === node3.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === 1)) {
              break;
            }
            if (node3.label && isBreak) break;
          }
        }
        if (i === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, node3, {
            type
          });
        }
      }
      parseDebuggerStatement(node3) {
        this.next();
        this.semicolon();
        return this.finishNode(node3, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node3) {
        this.next();
        this.state.labels.push(loopLabel);
        node3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node3.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node3, "DoWhileStatement");
      }
      parseForStatement(node3) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isContextual(96) && this.recordAwaitIfAllowed()) {
          awaitAt = this.state.startLoc;
          this.next();
        }
        this.scope.enter(0);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node3, null);
        }
        const startsWithLet = this.isContextual(100);
        {
          const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
          const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            let kind;
            if (startsWithAwaitUsing) {
              kind = "await using";
              if (!this.recordAwaitIfAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
              }
              this.next();
            } else {
              kind = this.state.value;
            }
            this.next();
            this.parseVar(initNode, true, kind);
            const init3 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && starsWithUsingDeclaration) {
              this.raise(Errors.ForInUsing, init3);
            }
            if ((isForIn || this.isContextual(102)) && init3.declarations.length === 1) {
              return this.parseForIn(node3, init3, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node3, init3);
          }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init2 = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, init2);
          }
          if (awaitAt === null && startsWithAsync && init2.type === "Identifier") {
            this.raise(Errors.ForOfAsync, init2);
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init2, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init2, {
            type
          });
          return this.parseForIn(node3, init2, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node3, init2);
      }
      parseFunctionStatement(node3, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node3, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
      }
      parseIfStatement(node3) {
        this.next();
        node3.test = this.parseHeaderExpression();
        node3.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node3.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node3, "IfStatement");
      }
      parseReturnStatement(node3) {
        if (!this.prodParam.hasReturn && !(this.optionFlags & 2)) {
          this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        this.next();
        if (this.isLineTerminator()) {
          node3.argument = null;
        } else {
          node3.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node3, "ReturnStatement");
      }
      parseSwitchStatement(node3) {
        this.next();
        node3.discriminant = this.parseHeaderExpression();
        const cases = node3.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(0);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur) this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node3, "SwitchStatement");
      }
      parseThrowStatement(node3) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        node3.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node3, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
        this.checkLVal(param, {
          type: "CatchClause"
        }, 9);
        return param;
      }
      parseTryStatement(node3) {
        this.next();
        node3.block = this.parseBlock();
        node3.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(0);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node3.handler = this.finishNode(clause, "CatchClause");
        }
        node3.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node3.handler && !node3.finalizer) {
          this.raise(Errors.NoCatchOrFinally, node3);
        }
        return this.finishNode(node3, "TryStatement");
      }
      parseVarStatement(node3, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node3, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node3, "VariableDeclaration");
      }
      parseWhileStatement(node3) {
        this.next();
        node3.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node3, "WhileStatement");
      }
      parseWithStatement(node3) {
        if (this.state.strict) {
          this.raise(Errors.StrictWith, this.state.startLoc);
        }
        this.next();
        node3.object = this.parseHeaderExpression();
        node3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node3, "WithStatement");
      }
      parseEmptyStatement(node3) {
        this.next();
        return this.finishNode(node3, "EmptyStatement");
      }
      parseLabeledStatement(node3, maybeName, expr, flags) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, expr, {
              labelName: maybeName
            });
          }
        }
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node3.start) {
            label.statementStart = this.sourceToOffsetPos(this.state.start);
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.sourceToOffsetPos(this.state.start)
        });
        node3.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node3.label = expr;
        return this.finishNode(node3, "LabeledStatement");
      }
      parseExpressionStatement(node3, expr, decorators) {
        node3.expression = expr;
        this.semicolon();
        return this.finishNode(node3, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node3 = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(0);
        }
        this.parseBlockBody(node3, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node3, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node3, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node3.body = [];
        const directives = node3.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node3, init2) {
        node3.init = init2;
        this.semicolon(false);
        node3.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node3.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node3, "ForStatement");
      }
      parseForIn(node3, init2, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null) this.unexpected(awaitAt);
        } else {
          node3.await = awaitAt !== null;
        }
        if (init2.type === "VariableDeclaration" && init2.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init2.kind !== "var" || init2.declarations[0].id.type !== "Identifier")) {
          this.raise(Errors.ForInOfLoopInitializer, init2, {
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          });
        }
        if (init2.type === "AssignmentPattern") {
          this.raise(Errors.InvalidLhs, init2, {
            ancestor: {
              type: "ForStatement"
            }
          });
        }
        node3.left = init2;
        node3.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node3.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node3, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node3, isFor, kind, allowMissingInitializer = false) {
        const declarations = node3.declarations = [];
        node3.kind = kind;
        for (; ; ) {
          const decl2 = this.startNode();
          this.parseVarId(decl2, kind);
          decl2.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          if (decl2.init === null && !allowMissingInitializer) {
            if (decl2.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind: "destructuring"
              });
            } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind
              });
            }
          }
          declarations.push(this.finishNode(decl2, "VariableDeclarator"));
          if (!this.eat(12)) break;
        }
        return node3;
      }
      parseVarId(decl2, kind) {
        const id3 = this.parseBindingAtom();
        if (kind === "using" || kind === "await using") {
          if (id3.type === "ArrayPattern" || id3.type === "ObjectPattern") {
            this.raise(Errors.UsingDeclarationHasBindingPattern, id3.loc.start);
          }
        }
        this.checkLVal(id3, {
          type: "VariableDeclarator"
        }, kind === "var" ? 5 : 8201);
        decl2.id = id3;
      }
      parseAsyncFunctionExpression(node3) {
        return this.parseFunction(node3, 8);
      }
      parseFunction(node3, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration = !!(flags & 1);
        const requireId = isDeclaration && !(flags & 4);
        const isAsync = !!(flags & 8);
        this.initFunction(node3, isAsync);
        if (this.match(55)) {
          if (hangingDeclaration) {
            this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
          }
          this.next();
          node3.generator = true;
        }
        if (isDeclaration) {
          node3.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(2);
        this.prodParam.enter(functionFlags(isAsync, node3.generator));
        if (!isDeclaration) {
          node3.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node3, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node3, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) {
          this.registerFunctionStatementId(node3);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node3;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node3, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node3.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node3) {
        if (!node3.id) return;
        this.scope.declareName(node3.id.name, !this.options.annexB || this.state.strict || node3.generator || node3.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node3.id.loc.start);
      }
      parseClass(node3, isStatement, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node3, isStatement, optionalId);
        this.parseClassSuper(node3);
        node3.body = this.parseClassBody(!!node3.superClass, oldStrict);
        return this.finishNode(node3, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      nameIsConstructor(key) {
        return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(Errors.DecoratorConstructor, member);
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(106);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(139);
          this.parseClassElementName(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key.name : null;
        const isPrivate = this.isPrivateName(key);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(Errors.DuplicateConstructor, key);
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(Errors.OverrideOnConstructor, key);
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(139);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAsync, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = maybeContextualKw;
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key);
          const isPrivate2 = this.match(139);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value: value2
        } = this.state;
        if ((type === 132 || type === 134) && member.static && value2 === "prototype") {
          this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        if (type === 139) {
          if (value2 === "constructor") {
            this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
          }
          const key = this.parsePrivateName();
          member.key = key;
          return key;
        }
        this.parsePropertyName(member);
        return member.key;
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(64 | 128 | 16);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(Errors.DecoratorStaticBlock, member);
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node3 = this.parseClassPrivateProperty(prop);
        classBody.body.push(node3);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node3.key), 0, node3.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        const node3 = this.parseClassAccessorProperty(prop);
        classBody.body.push(node3);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node3.key), 0, node3.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node3 = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node3);
        const kind = node3.kind === "get" ? node3.static ? 6 : 2 : node3.kind === "set" ? node3.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node3, kind);
      }
      declareClassPrivateMethodInScope(node3, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node3.key), kind, node3.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node3) {
        this.parseInitializer(node3);
        this.semicolon();
        return this.finishNode(node3, "ClassPrivateProperty");
      }
      parseClassProperty(node3) {
        this.parseInitializer(node3);
        this.semicolon();
        return this.finishNode(node3, "ClassProperty");
      }
      parseClassAccessorProperty(node3) {
        this.parseInitializer(node3);
        this.semicolon();
        return this.finishNode(node3, "ClassAccessorProperty");
      }
      parseInitializer(node3) {
        this.scope.enter(64 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node3.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node3, isStatement, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
          node3.id = this.parseIdentifier();
          if (isStatement) {
            this.declareNameFromIdentifier(node3.id, bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node3.id = null;
          } else {
            throw this.raise(Errors.MissingClassName, this.state.startLoc);
          }
        }
      }
      parseClassSuper(node3) {
        node3.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node3, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node3, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node3, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node3);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node3);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault) this.unexpected();
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node3);
          }
          this.parseExportFrom(node3, true);
          return this.finishNode(node3, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node3);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
          this.unexpected(null, 5);
        }
        if (hasNamespace && parseAfterNamespace) {
          this.unexpected(null, 98);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node3);
          }
          this.parseExportFrom(node3, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node3);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          const node22 = node3;
          this.checkExport(node22, true, false, !!node22.source);
          if (((_node2$declaration = node22.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, node22.declaration, node22);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node3);
          }
          return this.finishNode(node22, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const node22 = node3;
          const decl2 = this.parseExportDefaultExpression();
          node22.declaration = decl2;
          if (decl2.type === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, decl2, node22);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node3);
          }
          this.checkExport(node22, true, true);
          return this.finishNode(node22, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
      }
      eatExportStar(node3) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node3, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
          const id3 = maybeDefaultIdentifier || this.parseIdentifier(true);
          const specifier = this.startNodeAtNode(id3);
          specifier.exported = id3;
          node3.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node3) {
        if (this.isContextual(93)) {
          var _ref, _ref$specifiers;
          (_ref$specifiers = (_ref = node3).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node3.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node3) {
        if (this.match(5)) {
          const node22 = node3;
          if (!node22.specifiers) node22.specifiers = [];
          const isTypeExport = node22.exportKind === "type";
          node22.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node22.source = null;
          node22.declaration = null;
          if (this.hasPlugin("importAssertions")) {
            node22.assertions = [];
          }
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node3) {
        if (this.shouldParseExportDeclaration()) {
          node3.specifiers = [];
          node3.source = null;
          if (this.hasPlugin("importAssertions")) {
            node3.assertions = [];
          }
          node3.declaration = this.parseExportDeclaration(node3);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95)) return false;
        const next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
          this.next();
          return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(expr, 1 | 4 | 8);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet()) {
          throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node3) {
        if (this.match(80)) {
          const node4 = this.parseClass(this.startNode(), true, false);
          return node4;
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 100) {
            return false;
          }
          if ((type === 130 || type === 129) && !this.state.containsEsc) {
            const {
              type: nextType
            } = this.lookahead();
            if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node3, expect) {
        if (this.eatContextual(98)) {
          node3.source = this.parseImportSource();
          this.checkExport(node3);
          this.maybeParseImportAttributes(node3);
          this.checkJSONModuleImport(node3);
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
              this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
            }
            return true;
          }
        }
        if (this.isContextual(107)) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        if (this.isContextual(96) && this.startsAwaitUsing()) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node3, checkNames, isDefault, isFrom) {
        if (checkNames) {
          var _node$specifiers;
          if (isDefault) {
            this.checkDuplicateExports(node3, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node3.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
              }
            }
          } else if ((_node$specifiers = node3.specifiers) != null && _node$specifiers.length) {
            for (const specifier of node3.specifiers) {
              const {
                exported
              } = specifier;
              const exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, specifier, {
                    localName: local.value,
                    exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node3.declaration) {
            const decl2 = node3.declaration;
            if (decl2.type === "FunctionDeclaration" || decl2.type === "ClassDeclaration") {
              const {
                id: id3
              } = decl2;
              if (!id3) throw new Error("Assertion failure");
              this.checkDuplicateExports(node3, id3.name);
            } else if (decl2.type === "VariableDeclaration") {
              for (const declaration of decl2.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
      }
      checkDeclaration(node3) {
        if (node3.type === "Identifier") {
          this.checkDuplicateExports(node3, node3.name);
        } else if (node3.type === "ObjectPattern") {
          for (const prop of node3.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node3.type === "ArrayPattern") {
          for (const elem of node3.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node3.type === "ObjectProperty") {
          this.checkDeclaration(node3.value);
        } else if (node3.type === "RestElement") {
          this.checkDeclaration(node3.argument);
        } else if (node3.type === "AssignmentPattern") {
          this.checkDeclaration(node3.left);
        }
      }
      checkDuplicateExports(node3, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
          if (exportName === "default") {
            this.raise(Errors.DuplicateDefaultExport, node3);
          } else {
            this.raise(Errors.DuplicateExport, node3, {
              exportName
            });
          }
        }
        this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first2 = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first2) {
            first2 = false;
          } else {
            this.expect(12);
            if (this.eat(8)) break;
          }
          const isMaybeTypeOnly = this.isContextual(130);
          const isString3 = this.match(134);
          const node3 = this.startNode();
          node3.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node3, isString3, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node3, isString3, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node3.exported = this.parseModuleExportName();
        } else if (isString3) {
          node3.exported = cloneStringLiteral(node3.local);
        } else if (!node3.exported) {
          node3.exported = cloneIdentifier(node3.local);
        }
        return this.finishNode(node3, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(134)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = loneSurrogate.exec(result.value);
          if (surrogate) {
            this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
              surrogateCharCode: surrogate[0].charCodeAt(0)
            });
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(node3) {
        if (node3.assertions != null) {
          return node3.assertions.some(({
            key,
            value: value2
          }) => {
            return value2.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
          });
        }
        return false;
      }
      checkImportReflection(node3) {
        const {
          specifiers
        } = node3;
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        if (node3.phase === "source") {
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
          }
        } else if (node3.phase === "defer") {
          if (singleBindingType !== "ImportNamespaceSpecifier") {
            this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
          }
        } else if (node3.module) {
          var _node$assertions;
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
          }
          if (((_node$assertions = node3.assertions) == null ? void 0 : _node$assertions.length) > 0) {
            this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
          }
        }
      }
      checkJSONModuleImport(node3) {
        if (this.isJSONModuleImport(node3) && node3.type !== "ExportAllDeclaration") {
          const {
            specifiers
          } = node3;
          if (specifiers != null) {
            const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier") {
                imported = specifier.local;
              } else if (specifier.type === "ImportSpecifier") {
                imported = specifier.imported;
              }
              if (imported !== void 0) {
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
              }
            });
            if (nonDefaultNamedSpecifier !== void 0) {
              this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
            }
          }
        }
      }
      isPotentialImportPhase(isExport) {
        if (isExport) return false;
        return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
      }
      applyImportPhase(node3, isExport, phase, loc) {
        if (isExport) {
          return;
        }
        if (phase === "module") {
          this.expectPlugin("importReflection", loc);
          node3.module = true;
        } else if (this.hasPlugin("importReflection")) {
          node3.module = false;
        }
        if (phase === "source") {
          this.expectPlugin("sourcePhaseImports", loc);
          node3.phase = "source";
        } else if (phase === "defer") {
          this.expectPlugin("deferredImportEvaluation", loc);
          node3.phase = "defer";
        } else if (this.hasPlugin("sourcePhaseImports")) {
          node3.phase = null;
        }
      }
      parseMaybeImportPhase(node3, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
          this.applyImportPhase(node3, isExport, null);
          return null;
        }
        const phaseIdentifier = this.parseIdentifier(true);
        const {
          type
        } = this.state;
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
        if (isImportPhase) {
          this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
          this.applyImportPhase(node3, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
          return null;
        } else {
          this.applyImportPhase(node3, isExport, null);
          return phaseIdentifier;
        }
      }
      isPrecedingIdImportPhase(phase) {
        const {
          type
        } = this.state;
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      }
      parseImport(node3) {
        if (this.match(134)) {
          return this.parseImportSourceAndAttributes(node3);
        }
        return this.parseImportSpecifiersAndAfter(node3, this.parseMaybeImportPhase(node3, false));
      }
      parseImportSpecifiersAndAfter(node3, maybeDefaultIdentifier) {
        node3.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node3, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node3);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node3);
        this.expectContextual(98);
        return this.parseImportSourceAndAttributes(node3);
      }
      parseImportSourceAndAttributes(node3) {
        var _node$specifiers2;
        (_node$specifiers2 = node3.specifiers) != null ? _node$specifiers2 : node3.specifiers = [];
        node3.source = this.parseImportSource();
        this.maybeParseImportAttributes(node3);
        this.checkImportReflection(node3);
        this.checkJSONModuleImport(node3);
        this.semicolon();
        return this.finishNode(node3, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(134)) this.unexpected();
        return this.parseExprAtom();
      }
      parseImportSpecifierLocal(node3, specifier, type) {
        specifier.local = this.parseIdentifier();
        node3.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
          type
        }, bindingType);
        return this.finishNode(specifier, type);
      }
      parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node3 = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
              key: keyName
            });
          }
          attrNames.add(keyName);
          if (this.match(134)) {
            node3.key = this.parseStringLiteral(keyName);
          } else {
            node3.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node3.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node3, "ImportAttribute"));
        } while (this.eat(12));
        this.expect(8);
        return attrs;
      }
      parseModuleAttributes() {
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node3 = this.startNode();
          node3.key = this.parseIdentifier(true);
          if (node3.key.name !== "type") {
            this.raise(Errors.ModuleAttributeDifferentFromType, node3.key);
          }
          if (attributes.has(node3.key.name)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, node3.key, {
              key: node3.key.name
            });
          }
          attributes.add(node3.key.name);
          this.expect(14);
          if (!this.match(134)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node3.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node3, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAttributes(node3) {
        let attributes;
        {
          var useWith = false;
        }
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
            return;
          }
          this.next();
          if (this.hasPlugin("moduleAttributes")) {
            attributes = this.parseModuleAttributes();
          } else {
            attributes = this.parseImportAttributes();
          }
          {
            useWith = true;
          }
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          if (!this.hasPlugin("deprecatedImportAssert") && !this.hasPlugin("importAssertions")) {
            this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
          }
          if (!this.hasPlugin("importAssertions")) {
            this.addExtra(node3, "deprecatedAssertSyntax", true);
          }
          this.next();
          attributes = this.parseImportAttributes();
        } else {
          attributes = [];
        }
        if (!useWith && this.hasPlugin("importAssertions")) {
          node3.assertions = attributes;
        } else {
          node3.attributes = attributes;
        }
      }
      maybeParseDefaultImportSpecifier(node3, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
          const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
          specifier.local = maybeDefaultIdentifier;
          node3.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
          return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          this.parseImportSpecifierLocal(node3, this.startNode(), "ImportDefaultSpecifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node3) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node3, specifier, "ImportNamespaceSpecifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node3) {
        let first2 = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first2) {
            first2 = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
            }
            this.expect(12);
            if (this.eat(8)) break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(134);
          const isMaybeTypeOnly = this.isContextual(130);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node3.importKind === "type" || node3.importKind === "typeof", isMaybeTypeOnly, void 0);
          node3.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: imported.value
            });
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = cloneIdentifier(imported);
          }
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser3 = class extends StatementParser {
      constructor(options2, input, pluginsMap) {
        options2 = getOptions2(options2);
        super(options2, input);
        this.options = options2;
        this.initializeScopes();
        this.plugins = pluginsMap;
        this.filename = options2.sourceFilename;
        this.startIndex = options2.startIndex;
        let optionFlags = 0;
        if (options2.allowAwaitOutsideFunction) {
          optionFlags |= 1;
        }
        if (options2.allowReturnOutsideFunction) {
          optionFlags |= 2;
        }
        if (options2.allowImportExportEverywhere) {
          optionFlags |= 8;
        }
        if (options2.allowSuperOutsideMethod) {
          optionFlags |= 16;
        }
        if (options2.allowUndeclaredExports) {
          optionFlags |= 32;
        }
        if (options2.allowNewTargetOutsideFunction) {
          optionFlags |= 4;
        }
        if (options2.ranges) {
          optionFlags |= 64;
        }
        if (options2.tokens) {
          optionFlags |= 128;
        }
        if (options2.createImportExpressions) {
          optionFlags |= 256;
        }
        if (options2.createParenthesizedExpressions) {
          optionFlags |= 512;
        }
        if (options2.errorRecovery) {
          optionFlags |= 1024;
        }
        if (options2.attachComment) {
          optionFlags |= 2048;
        }
        if (options2.annexB) {
          optionFlags |= 4096;
        }
        this.optionFlags = optionFlags;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        file.comments.length = this.state.commentsLen;
        return file;
      }
    };
    function parse6(input, options2) {
      var _options;
      if (((_options = options2) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options2 = Object.assign({}, options2);
        try {
          options2.sourceType = "module";
          const parser2 = getParser(options2, input);
          const ast = parser2.parse();
          if (parser2.sawUnambiguousESM) {
            return ast;
          }
          if (parser2.ambiguousScriptDifferentAst) {
            try {
              options2.sourceType = "script";
              return getParser(options2, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options2.sourceType = "script";
            return getParser(options2, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options2, input).parse();
      }
    }
    function parseExpression(input, options2) {
      const parser2 = getParser(options2, input);
      if (parser2.options.strictMode) {
        parser2.state.strict = true;
      }
      return parser2.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes3 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes3[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes3;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options2, input) {
      let cls = Parser3;
      const pluginsMap = /* @__PURE__ */ new Map();
      if (options2 != null && options2.plugins) {
        for (const plugin3 of options2.plugins) {
          let name2, opts;
          if (typeof plugin3 === "string") {
            name2 = plugin3;
          } else {
            [name2, opts] = plugin3;
          }
          if (!pluginsMap.has(name2)) {
            pluginsMap.set(name2, opts || {});
          }
        }
        validatePlugins(pluginsMap);
        cls = getParserClass(pluginsMap);
      }
      return new cls(options2, input, pluginsMap);
    }
    var parserClassCache = /* @__PURE__ */ new Map();
    function getParserClass(pluginsMap) {
      const pluginList = [];
      for (const name2 of mixinPluginNames) {
        if (pluginsMap.has(name2)) {
          pluginList.push(name2);
        }
      }
      const key = pluginList.join("|");
      let cls = parserClassCache.get(key);
      if (!cls) {
        cls = Parser3;
        for (const plugin3 of pluginList) {
          cls = mixinPlugins[plugin3](cls);
        }
        parserClassCache.set(key, cls);
      }
      return cls;
    }
    exports2.parse = parse6;
    exports2.parseExpression = parseExpression;
    exports2.tokTypes = tokTypes;
  }
});

// node_modules/js-tokens/index.js
var require_js_tokens = __commonJS({
  "node_modules/js-tokens/index.js"(exports2) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;
    exports2.matchToToken = function(match2) {
      var token = { type: "invalid", value: match2[0], closed: void 0 };
      if (match2[1]) token.type = "string", token.closed = !!(match2[3] || match2[4]);
      else if (match2[5]) token.type = "comment";
      else if (match2[6]) token.type = "comment", token.closed = !!match2[7];
      else if (match2[8]) token.type = "regex";
      else if (match2[9]) token.type = "number";
      else if (match2[10]) token.type = "name";
      else if (match2[11]) token.type = "punctuator";
      else if (match2[12]) token.type = "whitespace";
      return token;
    };
  }
});

// node_modules/@babel/code-frame/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/@babel/code-frame/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var picocolors2 = require_picocolors();
    var jsTokens = require_js_tokens();
    var helperValidatorIdentifier = require_lib();
    function isColorSupported2() {
      return typeof process === "object" && (process.env.FORCE_COLOR === "0" || process.env.FORCE_COLOR === "false") ? false : picocolors2.isColorSupported;
    }
    var compose = (f, g) => (v) => f(g(v));
    function buildDefs(colors) {
      return {
        keyword: colors.cyan,
        capitalized: colors.yellow,
        jsxIdentifier: colors.yellow,
        punctuator: colors.yellow,
        number: colors.magenta,
        string: colors.green,
        regex: colors.magenta,
        comment: colors.gray,
        invalid: compose(compose(colors.white, colors.bgRed), colors.bold),
        gutter: colors.gray,
        marker: compose(colors.red, colors.bold),
        message: compose(colors.red, colors.bold),
        reset: colors.reset
      };
    }
    var defsOn = buildDefs(picocolors2.createColors(true));
    var defsOff = buildDefs(picocolors2.createColors(false));
    function getDefs(enabled) {
      return enabled ? defsOn : defsOff;
    }
    var sometimesKeywords = /* @__PURE__ */ new Set(["as", "async", "from", "get", "of", "set"]);
    var NEWLINE$1 = /\r\n|[\n\r\u2028\u2029]/;
    var BRACKET = /^[()[\]{}]$/;
    var tokenize2;
    {
      const JSX_TAG = /^[a-z][\w-]*$/i;
      const getTokenType = function(token, offset, text2) {
        if (token.type === "name") {
          if (helperValidatorIdentifier.isKeyword(token.value) || helperValidatorIdentifier.isStrictReservedWord(token.value, true) || sometimesKeywords.has(token.value)) {
            return "keyword";
          }
          if (JSX_TAG.test(token.value) && (text2[offset - 1] === "<" || text2.slice(offset - 2, offset) === "</")) {
            return "jsxIdentifier";
          }
          if (token.value[0] !== token.value[0].toLowerCase()) {
            return "capitalized";
          }
        }
        if (token.type === "punctuator" && BRACKET.test(token.value)) {
          return "bracket";
        }
        if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
          return "punctuator";
        }
        return token.type;
      };
      tokenize2 = function* (text2) {
        let match2;
        while (match2 = jsTokens.default.exec(text2)) {
          const token = jsTokens.matchToToken(match2);
          yield {
            type: getTokenType(token, match2.index, text2),
            value: token.value
          };
        }
      };
    }
    function highlight(text2) {
      if (text2 === "") return "";
      const defs = getDefs(true);
      let highlighted = "";
      for (const {
        type,
        value: value2
      } of tokenize2(text2)) {
        if (type in defs) {
          highlighted += value2.split(NEWLINE$1).map((str2) => defs[type](str2)).join("\n");
        } else {
          highlighted += value2;
        }
      }
      return highlighted;
    }
    var deprecationWarningShown = false;
    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    function getMarkerLines(loc, source, opts) {
      const startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      const endLoc = Object.assign({}, startLoc, loc.end);
      const {
        linesAbove = 2,
        linesBelow = 3
      } = opts || {};
      const startLine = startLoc.line;
      const startColumn = startLoc.column;
      const endLine = endLoc.line;
      const endColumn = endLoc.column;
      let start = Math.max(startLine - (linesAbove + 1), 0);
      let end = Math.min(source.length, endLine + linesBelow);
      if (startLine === -1) {
        start = 0;
      }
      if (endLine === -1) {
        end = source.length;
      }
      const lineDiff = endLine - startLine;
      const markerLines = {};
      if (lineDiff) {
        for (let i = 0; i <= lineDiff; i++) {
          const lineNumber = i + startLine;
          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            const sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            const sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }
      return {
        start,
        end,
        markerLines
      };
    }
    function codeFrameColumns(rawLines, loc, opts = {}) {
      const shouldHighlight = opts.forceColor || isColorSupported2() && opts.highlightCode;
      const defs = getDefs(shouldHighlight);
      const lines = rawLines.split(NEWLINE);
      const {
        start,
        end,
        markerLines
      } = getMarkerLines(loc, lines, opts);
      const hasColumns = loc.start && typeof loc.start.column === "number";
      const numberMaxWidth = String(end).length;
      const highlightedLines = shouldHighlight ? highlight(rawLines) : rawLines;
      let frame = highlightedLines.split(NEWLINE, end).slice(start, end).map((line, index5) => {
        const number = start + 1 + index5;
        const paddedNumber = ` ${number}`.slice(-numberMaxWidth);
        const gutter = ` ${paddedNumber} |`;
        const hasMarker = markerLines[number];
        const lastMarkerLine = !markerLines[number + 1];
        if (hasMarker) {
          let markerLine = "";
          if (Array.isArray(hasMarker)) {
            const markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            const numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", defs.gutter(gutter.replace(/\d/g, " ")), " ", markerSpacing, defs.marker("^").repeat(numberOfMarkers)].join("");
            if (lastMarkerLine && opts.message) {
              markerLine += " " + defs.message(opts.message);
            }
          }
          return [defs.marker(">"), defs.gutter(gutter), line.length > 0 ? ` ${line}` : "", markerLine].join("");
        } else {
          return ` ${defs.gutter(gutter)}${line.length > 0 ? ` ${line}` : ""}`;
        }
      }).join("\n");
      if (opts.message && !hasColumns) {
        frame = `${" ".repeat(numberMaxWidth + 1)}${opts.message}
${frame}`;
      }
      if (shouldHighlight) {
        return defs.reset(frame);
      } else {
        return frame;
      }
    }
    function index4(rawLines, lineNumber, colNumber, opts = {}) {
      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        const message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          const deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }
      colNumber = Math.max(colNumber, 0);
      const location2 = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location2, opts);
    }
    exports2.codeFrameColumns = codeFrameColumns;
    exports2.default = index4;
    exports2.highlight = highlight;
  }
});

// node_modules/@babel/template/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/@babel/template/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = parseAndBuildMetadata;
    var _t = require_lib3();
    var _parser = require_lib4();
    var _codeFrame = require_lib5();
    var {
      isCallExpression,
      isExpressionStatement,
      isFunction: isFunction2,
      isIdentifier: isIdentifier2,
      isJSXIdentifier,
      isNewExpression,
      isPlaceholder,
      isStatement,
      isStringLiteral,
      removePropertiesDeep,
      traverse
    } = _t;
    var PATTERN = /^[_$A-Z0-9]+$/;
    function parseAndBuildMetadata(formatter2, code, opts) {
      const {
        placeholderWhitelist,
        placeholderPattern,
        preserveComments,
        syntacticPlaceholders
      } = opts;
      const ast = parseWithCodeFrame(code, opts.parser, syntacticPlaceholders);
      removePropertiesDeep(ast, {
        preserveComments
      });
      formatter2.validate(ast);
      const state = {
        syntactic: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        legacy: {
          placeholders: [],
          placeholderNames: /* @__PURE__ */ new Set()
        },
        placeholderWhitelist,
        placeholderPattern,
        syntacticPlaceholders
      };
      traverse(ast, placeholderVisitorHandler, state);
      return Object.assign({
        ast
      }, state.syntactic.placeholders.length ? state.syntactic : state.legacy);
    }
    function placeholderVisitorHandler(node3, ancestors, state) {
      var _state$placeholderWhi;
      let name2;
      let hasSyntacticPlaceholders = state.syntactic.placeholders.length > 0;
      if (isPlaceholder(node3)) {
        if (state.syntacticPlaceholders === false) {
          throw new Error("%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false.");
        }
        name2 = node3.name.name;
        hasSyntacticPlaceholders = true;
      } else if (hasSyntacticPlaceholders || state.syntacticPlaceholders) {
        return;
      } else if (isIdentifier2(node3) || isJSXIdentifier(node3)) {
        name2 = node3.name;
      } else if (isStringLiteral(node3)) {
        name2 = node3.value;
      } else {
        return;
      }
      if (hasSyntacticPlaceholders && (state.placeholderPattern != null || state.placeholderWhitelist != null)) {
        throw new Error("'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'");
      }
      if (!hasSyntacticPlaceholders && (state.placeholderPattern === false || !(state.placeholderPattern || PATTERN).test(name2)) && !((_state$placeholderWhi = state.placeholderWhitelist) != null && _state$placeholderWhi.has(name2))) {
        return;
      }
      ancestors = ancestors.slice();
      const {
        node: parent,
        key
      } = ancestors[ancestors.length - 1];
      let type;
      if (isStringLiteral(node3) || isPlaceholder(node3, {
        expectedNode: "StringLiteral"
      })) {
        type = "string";
      } else if (isNewExpression(parent) && key === "arguments" || isCallExpression(parent) && key === "arguments" || isFunction2(parent) && key === "params") {
        type = "param";
      } else if (isExpressionStatement(parent) && !isPlaceholder(node3)) {
        type = "statement";
        ancestors = ancestors.slice(0, -1);
      } else if (isStatement(node3) && isPlaceholder(node3)) {
        type = "statement";
      } else {
        type = "other";
      }
      const {
        placeholders,
        placeholderNames
      } = !hasSyntacticPlaceholders ? state.legacy : state.syntactic;
      placeholders.push({
        name: name2,
        type,
        resolve: (ast) => resolveAncestors(ast, ancestors),
        isDuplicate: placeholderNames.has(name2)
      });
      placeholderNames.add(name2);
    }
    function resolveAncestors(ast, ancestors) {
      let parent = ast;
      for (let i = 0; i < ancestors.length - 1; i++) {
        const {
          key: key2,
          index: index5
        } = ancestors[i];
        if (index5 === void 0) {
          parent = parent[key2];
        } else {
          parent = parent[key2][index5];
        }
      }
      const {
        key,
        index: index4
      } = ancestors[ancestors.length - 1];
      return {
        parent,
        key,
        index: index4
      };
    }
    function parseWithCodeFrame(code, parserOpts, syntacticPlaceholders) {
      const plugins2 = (parserOpts.plugins || []).slice();
      if (syntacticPlaceholders !== false) {
        plugins2.push("placeholders");
      }
      parserOpts = Object.assign({
        allowReturnOutsideFunction: true,
        allowSuperOutsideMethod: true,
        sourceType: "module"
      }, parserOpts, {
        plugins: plugins2
      });
      try {
        return (0, _parser.parse)(code, parserOpts);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += "\n" + (0, _codeFrame.codeFrameColumns)(code, {
            start: loc
          });
          err.code = "BABEL_TEMPLATE_PARSE_ERROR";
        }
        throw err;
      }
    }
  }
});

// node_modules/@babel/template/lib/populate.js
var require_populate = __commonJS({
  "node_modules/@babel/template/lib/populate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = populatePlaceholders;
    var _t = require_lib3();
    var {
      blockStatement,
      cloneNode,
      emptyStatement,
      expressionStatement,
      identifier,
      isStatement,
      isStringLiteral,
      stringLiteral,
      validate
    } = _t;
    function populatePlaceholders(metadata, replacements) {
      const ast = cloneNode(metadata.ast);
      if (replacements) {
        metadata.placeholders.forEach((placeholder) => {
          if (!hasOwnProperty.call(replacements, placeholder.name)) {
            const placeholderName = placeholder.name;
            throw new Error(`Error: No substitution given for "${placeholderName}". If this is not meant to be a
            placeholder you may want to consider passing one of the following options to @babel/template:
            - { placeholderPattern: false, placeholderWhitelist: new Set(['${placeholderName}'])}
            - { placeholderPattern: /^${placeholderName}$/ }`);
          }
        });
        Object.keys(replacements).forEach((key) => {
          if (!metadata.placeholderNames.has(key)) {
            throw new Error(`Unknown substitution "${key}" given`);
          }
        });
      }
      metadata.placeholders.slice().reverse().forEach((placeholder) => {
        try {
          applyReplacement(placeholder, ast, replacements && replacements[placeholder.name] || null);
        } catch (e) {
          e.message = `@babel/template placeholder "${placeholder.name}": ${e.message}`;
          throw e;
        }
      });
      return ast;
    }
    function applyReplacement(placeholder, ast, replacement) {
      if (placeholder.isDuplicate) {
        if (Array.isArray(replacement)) {
          replacement = replacement.map((node3) => cloneNode(node3));
        } else if (typeof replacement === "object") {
          replacement = cloneNode(replacement);
        }
      }
      const {
        parent,
        key,
        index: index4
      } = placeholder.resolve(ast);
      if (placeholder.type === "string") {
        if (typeof replacement === "string") {
          replacement = stringLiteral(replacement);
        }
        if (!replacement || !isStringLiteral(replacement)) {
          throw new Error("Expected string substitution");
        }
      } else if (placeholder.type === "statement") {
        if (index4 === void 0) {
          if (!replacement) {
            replacement = emptyStatement();
          } else if (Array.isArray(replacement)) {
            replacement = blockStatement(replacement);
          } else if (typeof replacement === "string") {
            replacement = expressionStatement(identifier(replacement));
          } else if (!isStatement(replacement)) {
            replacement = expressionStatement(replacement);
          }
        } else {
          if (replacement && !Array.isArray(replacement)) {
            if (typeof replacement === "string") {
              replacement = identifier(replacement);
            }
            if (!isStatement(replacement)) {
              replacement = expressionStatement(replacement);
            }
          }
        }
      } else if (placeholder.type === "param") {
        if (typeof replacement === "string") {
          replacement = identifier(replacement);
        }
        if (index4 === void 0) throw new Error("Assertion failure.");
      } else {
        if (typeof replacement === "string") {
          replacement = identifier(replacement);
        }
        if (Array.isArray(replacement)) {
          throw new Error("Cannot replace single expression with an array.");
        }
      }
      function set2(parent2, key2, value2) {
        const node3 = parent2[key2];
        parent2[key2] = value2;
        if (node3.type === "Identifier" || node3.type === "Placeholder") {
          if (node3.typeAnnotation) {
            value2.typeAnnotation = node3.typeAnnotation;
          }
          if (node3.optional) {
            value2.optional = node3.optional;
          }
          if (node3.decorators) {
            value2.decorators = node3.decorators;
          }
        }
      }
      if (index4 === void 0) {
        validate(parent, key, replacement);
        set2(parent, key, replacement);
      } else {
        const items = parent[key].slice();
        if (placeholder.type === "statement" || placeholder.type === "param") {
          if (replacement == null) {
            items.splice(index4, 1);
          } else if (Array.isArray(replacement)) {
            items.splice(index4, 1, ...replacement);
          } else {
            set2(items, index4, replacement);
          }
        } else {
          set2(items, index4, replacement);
        }
        validate(parent, key, items);
        parent[key] = items;
      }
    }
  }
});

// node_modules/@babel/template/lib/string.js
var require_string = __commonJS({
  "node_modules/@babel/template/lib/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = stringTemplate;
    var _options = require_options();
    var _parse = require_parse2();
    var _populate = require_populate();
    function stringTemplate(formatter2, code, opts) {
      code = formatter2.code(code);
      let metadata;
      return (arg) => {
        const replacements = (0, _options.normalizeReplacements)(arg);
        if (!metadata) metadata = (0, _parse.default)(formatter2, code, opts);
        return formatter2.unwrap((0, _populate.default)(metadata, replacements));
      };
    }
  }
});

// node_modules/@babel/template/lib/literal.js
var require_literal = __commonJS({
  "node_modules/@babel/template/lib/literal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = literalTemplate;
    var _options = require_options();
    var _parse = require_parse2();
    var _populate = require_populate();
    function literalTemplate(formatter2, tpl, opts) {
      const {
        metadata,
        names
      } = buildLiteralData(formatter2, tpl, opts);
      return (arg) => {
        const defaultReplacements = {};
        arg.forEach((replacement, i) => {
          defaultReplacements[names[i]] = replacement;
        });
        return (arg2) => {
          const replacements = (0, _options.normalizeReplacements)(arg2);
          if (replacements) {
            Object.keys(replacements).forEach((key) => {
              if (hasOwnProperty.call(defaultReplacements, key)) {
                throw new Error("Unexpected replacement overlap.");
              }
            });
          }
          return formatter2.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));
        };
      };
    }
    function buildLiteralData(formatter2, tpl, opts) {
      let prefix = "BABEL_TPL$";
      const raw = tpl.join("");
      do {
        prefix = "$$" + prefix;
      } while (raw.includes(prefix));
      const {
        names,
        code
      } = buildTemplateCode(tpl, prefix);
      const metadata = (0, _parse.default)(formatter2, formatter2.code(code), {
        parser: opts.parser,
        placeholderWhitelist: new Set(names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),
        placeholderPattern: opts.placeholderPattern,
        preserveComments: opts.preserveComments,
        syntacticPlaceholders: opts.syntacticPlaceholders
      });
      return {
        metadata,
        names
      };
    }
    function buildTemplateCode(tpl, prefix) {
      const names = [];
      let code = tpl[0];
      for (let i = 1; i < tpl.length; i++) {
        const value2 = `${prefix}${i - 1}`;
        names.push(value2);
        code += value2 + tpl[i];
      }
      return {
        names,
        code
      };
    }
  }
});

// node_modules/@babel/template/lib/builder.js
var require_builder = __commonJS({
  "node_modules/@babel/template/lib/builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createTemplateBuilder;
    var _options = require_options();
    var _string2 = require_string();
    var _literal = require_literal();
    var NO_PLACEHOLDER = (0, _options.validate)({
      placeholderPattern: false
    });
    function createTemplateBuilder(formatter2, defaultOpts) {
      const templateFnCache = /* @__PURE__ */ new WeakMap();
      const templateAstCache = /* @__PURE__ */ new WeakMap();
      const cachedOpts = defaultOpts || (0, _options.validate)(null);
      return Object.assign((tpl, ...args) => {
        if (typeof tpl === "string") {
          if (args.length > 1) throw new Error("Unexpected extra params.");
          return extendedTrace((0, _string2.default)(formatter2, tpl, (0, _options.merge)(cachedOpts, (0, _options.validate)(args[0]))));
        } else if (Array.isArray(tpl)) {
          let builder = templateFnCache.get(tpl);
          if (!builder) {
            builder = (0, _literal.default)(formatter2, tpl, cachedOpts);
            templateFnCache.set(tpl, builder);
          }
          return extendedTrace(builder(args));
        } else if (typeof tpl === "object" && tpl) {
          if (args.length > 0) throw new Error("Unexpected extra params.");
          return createTemplateBuilder(formatter2, (0, _options.merge)(cachedOpts, (0, _options.validate)(tpl)));
        }
        throw new Error(`Unexpected template param ${typeof tpl}`);
      }, {
        ast: (tpl, ...args) => {
          if (typeof tpl === "string") {
            if (args.length > 1) throw new Error("Unexpected extra params.");
            return (0, _string2.default)(formatter2, tpl, (0, _options.merge)((0, _options.merge)(cachedOpts, (0, _options.validate)(args[0])), NO_PLACEHOLDER))();
          } else if (Array.isArray(tpl)) {
            let builder = templateAstCache.get(tpl);
            if (!builder) {
              builder = (0, _literal.default)(formatter2, tpl, (0, _options.merge)(cachedOpts, NO_PLACEHOLDER));
              templateAstCache.set(tpl, builder);
            }
            return builder(args)();
          }
          throw new Error(`Unexpected template param ${typeof tpl}`);
        }
      });
    }
    function extendedTrace(fn) {
      let rootStack = "";
      try {
        throw new Error();
      } catch (error) {
        if (error.stack) {
          rootStack = error.stack.split("\n").slice(3).join("\n");
        }
      }
      return (arg) => {
        try {
          return fn(arg);
        } catch (err) {
          err.stack += `
    =============
${rootStack}`;
          throw err;
        }
      };
    }
  }
});

// node_modules/@babel/template/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/@babel/template/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.statements = exports2.statement = exports2.smart = exports2.program = exports2.expression = exports2.default = void 0;
    var formatters = require_formatters();
    var _builder = require_builder();
    var smart = exports2.smart = (0, _builder.default)(formatters.smart);
    var statement = exports2.statement = (0, _builder.default)(formatters.statement);
    var statements = exports2.statements = (0, _builder.default)(formatters.statements);
    var expression = exports2.expression = (0, _builder.default)(formatters.expression);
    var program = exports2.program = (0, _builder.default)(formatters.program);
    var _default = exports2.default = Object.assign(smart.bind(void 0), {
      smart,
      statement,
      statements,
      expression,
      program,
      ast: smart.ast
    });
  }
});

// node_modules/@babel/helpers/lib/helpers-generated.js
var require_helpers_generated = __commonJS({
  "node_modules/@babel/helpers/lib/helpers-generated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _template = require_lib6();
    function helper(minVersion, source, metadata) {
      return Object.freeze({
        minVersion,
        ast: () => _template.default.program.ast(source, {
          preserveComments: true
        }),
        metadata
      });
    }
    var helpers = exports2.default = {
      __proto__: null,
      OverloadYield: helper("7.18.14", "function _OverloadYield(e,d){this.v=e,this.k=d}", {
        globals: [],
        locals: {
          _OverloadYield: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_OverloadYield",
        dependencies: {}
      }),
      applyDecoratedDescriptor: helper("7.0.0-beta.0", 'function _applyDecoratedDescriptor(i,e,r,n,l){var a={};return Object.keys(n).forEach((function(i){a[i]=n[i]})),a.enumerable=!!a.enumerable,a.configurable=!!a.configurable,("value"in a||a.initializer)&&(a.writable=!0),a=r.slice().reverse().reduce((function(r,n){return n(i,e,r)||r}),a),l&&void 0!==a.initializer&&(a.value=a.initializer?a.initializer.call(l):void 0,a.initializer=void 0),void 0===a.initializer?(Object.defineProperty(i,e,a),null):a}', {
        globals: ["Object"],
        locals: {
          _applyDecoratedDescriptor: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_applyDecoratedDescriptor",
        dependencies: {}
      }),
      applyDecs2311: helper("7.24.0", 'function applyDecs2311(e,t,n,r,o,i){var a,c,u,s,f,l,p,d=Symbol.metadata||Symbol.for("Symbol.metadata"),m=Object.defineProperty,h=Object.create,y=[h(null),h(null)],v=t.length;function g(t,n,r){return function(o,i){n&&(i=o,o=e);for(var a=0;a<t.length;a++)i=t[a].apply(o,r?[i]:[]);return r?i:o}}function b(e,t,n,r){if("function"!=typeof e&&(r||void 0!==e))throw new TypeError(t+" must "+(n||"be")+" a function"+(r?"":" or undefined"));return e}function applyDec(e,t,n,r,o,i,u,s,f,l,p){function d(e){if(!p(e))throw new TypeError("Attempted to access private element on non-instance")}var h=[].concat(t[0]),v=t[3],w=!u,D=1===o,S=3===o,j=4===o,E=2===o;function I(t,n,r){return function(o,i){return n&&(i=o,o=e),r&&r(o),P[t].call(o,i)}}if(!w){var P={},k=[],F=S?"get":j||D?"set":"value";if(f?(l||D?P={get:setFunctionName((function(){return v(this)}),r,"get"),set:function(e){t[4](this,e)}}:P[F]=v,l||setFunctionName(P[F],r,E?"":F)):l||(P=Object.getOwnPropertyDescriptor(e,r)),!l&&!f){if((c=y[+s][r])&&7!=(c^o))throw Error("Decorating two elements with the same name ("+P[F].name+") is not supported yet");y[+s][r]=o<3?1:o}}for(var N=e,O=h.length-1;O>=0;O-=n?2:1){var T=b(h[O],"A decorator","be",!0),z=n?h[O-1]:void 0,A={},H={kind:["field","accessor","method","getter","setter","class"][o],name:r,metadata:a,addInitializer:function(e,t){if(e.v)throw new TypeError("attempted to call addInitializer after decoration was finished");b(t,"An initializer","be",!0),i.push(t)}.bind(null,A)};if(w)c=T.call(z,N,H),A.v=1,b(c,"class decorators","return")&&(N=c);else if(H.static=s,H.private=f,c=H.access={has:f?p.bind():function(e){return r in e}},j||(c.get=f?E?function(e){return d(e),P.value}:I("get",0,d):function(e){return e[r]}),E||S||(c.set=f?I("set",0,d):function(e,t){e[r]=t}),N=T.call(z,D?{get:P.get,set:P.set}:P[F],H),A.v=1,D){if("object"==typeof N&&N)(c=b(N.get,"accessor.get"))&&(P.get=c),(c=b(N.set,"accessor.set"))&&(P.set=c),(c=b(N.init,"accessor.init"))&&k.unshift(c);else if(void 0!==N)throw new TypeError("accessor decorators must return an object with get, set, or init properties or undefined")}else b(N,(l?"field":"method")+" decorators","return")&&(l?k.unshift(N):P[F]=N)}return o<2&&u.push(g(k,s,1),g(i,s,0)),l||w||(f?D?u.splice(-1,0,I("get",s),I("set",s)):u.push(E?P[F]:b.call.bind(P[F])):m(e,r,P)),N}function w(e){return m(e,d,{configurable:!0,enumerable:!0,value:a})}return void 0!==i&&(a=i[d]),a=h(null==a?null:a),f=[],l=function(e){e&&f.push(g(e))},p=function(t,r){for(var i=0;i<n.length;i++){var a=n[i],c=a[1],l=7&c;if((8&c)==t&&!l==r){var p=a[2],d=!!a[3],m=16&c;applyDec(t?e:e.prototype,a,m,d?"#"+p:toPropertyKey(p),l,l<2?[]:t?s=s||[]:u=u||[],f,!!t,d,r,t&&d?function(t){return checkInRHS(t)===e}:o)}}},p(8,0),p(0,0),p(8,1),p(0,1),l(u),l(s),c=f,v||w(e),{e:c,get c(){var n=[];return v&&[w(e=applyDec(e,[t],r,e.name,5,n)),g(n,1)]}}}', {
        globals: ["Symbol", "Object", "TypeError", "Error"],
        locals: {
          applyDecs2311: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "applyDecs2311",
        dependencies: {
          checkInRHS: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.10.consequent.body.body.0.argument.left.callee"],
          setFunctionName: ["body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.3.consequent.body.1.test.expressions.0.consequent.expressions.1.right.callee"],
          toPropertyKey: ["body.0.body.body.5.argument.expressions.4.right.body.body.0.body.body.1.consequent.body.1.expression.arguments.3.alternate.callee"]
        }
      }),
      arrayLikeToArray: helper("7.9.0", "function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n}", {
        globals: ["Array"],
        locals: {
          _arrayLikeToArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_arrayLikeToArray",
        dependencies: {}
      }),
      arrayWithHoles: helper("7.0.0-beta.0", "function _arrayWithHoles(r){if(Array.isArray(r))return r}", {
        globals: ["Array"],
        locals: {
          _arrayWithHoles: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_arrayWithHoles",
        dependencies: {}
      }),
      arrayWithoutHoles: helper("7.0.0-beta.0", "function _arrayWithoutHoles(r){if(Array.isArray(r))return arrayLikeToArray(r)}", {
        globals: ["Array"],
        locals: {
          _arrayWithoutHoles: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_arrayWithoutHoles",
        dependencies: {
          arrayLikeToArray: ["body.0.body.body.0.consequent.argument.callee"]
        }
      }),
      assertClassBrand: helper("7.24.0", 'function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}', {
        globals: ["TypeError"],
        locals: {
          _assertClassBrand: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_assertClassBrand",
        dependencies: {}
      }),
      assertThisInitialized: helper("7.0.0-beta.0", `function _assertThisInitialized(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}`, {
        globals: ["ReferenceError"],
        locals: {
          _assertThisInitialized: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_assertThisInitialized",
        dependencies: {}
      }),
      asyncGeneratorDelegate: helper("7.0.0-beta.0", 'function _asyncGeneratorDelegate(t){var e={},n=!1;function pump(e,r){return n=!0,r=new Promise((function(n){n(t[e](r))})),{done:!1,value:new OverloadYield(r,1)}}return e["undefined"!=typeof Symbol&&Symbol.iterator||"@@iterator"]=function(){return this},e.next=function(t){return n?(n=!1,t):pump("next",t)},"function"==typeof t.throw&&(e.throw=function(t){if(n)throw n=!1,t;return pump("throw",t)}),"function"==typeof t.return&&(e.return=function(t){return n?(n=!1,t):pump("return",t)}),e}', {
        globals: ["Promise", "Symbol"],
        locals: {
          _asyncGeneratorDelegate: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_asyncGeneratorDelegate",
        dependencies: {
          OverloadYield: ["body.0.body.body.1.body.body.0.argument.expressions.2.properties.1.value.callee"]
        }
      }),
      asyncIterator: helper("7.15.9", 'function _asyncIterator(r){var n,t,o,e=2;for("undefined"!=typeof Symbol&&(t=Symbol.asyncIterator,o=Symbol.iterator);e--;){if(t&&null!=(n=r[t]))return n.call(r);if(o&&null!=(n=r[o]))return new AsyncFromSyncIterator(n.call(r));t="@@asyncIterator",o="@@iterator"}throw new TypeError("Object is not async iterable")}function AsyncFromSyncIterator(r){function AsyncFromSyncIteratorContinuation(r){if(Object(r)!==r)return Promise.reject(new TypeError(r+" is not an object."));var n=r.done;return Promise.resolve(r.value).then((function(r){return{value:r,done:n}}))}return AsyncFromSyncIterator=function(r){this.s=r,this.n=r.next},AsyncFromSyncIterator.prototype={s:null,n:null,next:function(){return AsyncFromSyncIteratorContinuation(this.n.apply(this.s,arguments))},return:function(r){var n=this.s.return;return void 0===n?Promise.resolve({value:r,done:!0}):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))},throw:function(r){var n=this.s.return;return void 0===n?Promise.reject(r):AsyncFromSyncIteratorContinuation(n.apply(this.s,arguments))}},new AsyncFromSyncIterator(r)}', {
        globals: ["Symbol", "TypeError", "Object", "Promise"],
        locals: {
          _asyncIterator: ["body.0.id"],
          AsyncFromSyncIterator: ["body.1.id", "body.0.body.body.1.body.body.1.consequent.argument.callee", "body.1.body.body.1.argument.expressions.1.left.object", "body.1.body.body.1.argument.expressions.2.callee", "body.1.body.body.1.argument.expressions.0.left"]
        },
        exportBindingAssignments: [],
        exportName: "_asyncIterator",
        dependencies: {}
      }),
      asyncToGenerator: helper("7.0.0-beta.0", 'function asyncGeneratorStep(n,t,e,r,o,a,c){try{var i=n[a](c),u=i.value}catch(n){return void e(n)}i.done?t(u):Promise.resolve(u).then(r,o)}function _asyncToGenerator(n){return function(){var t=this,e=arguments;return new Promise((function(r,o){var a=n.apply(t,e);function _next(n){asyncGeneratorStep(a,r,o,_next,_throw,"next",n)}function _throw(n){asyncGeneratorStep(a,r,o,_next,_throw,"throw",n)}_next(void 0)}))}}', {
        globals: ["Promise"],
        locals: {
          asyncGeneratorStep: ["body.0.id", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.1.body.body.0.expression.callee", "body.1.body.body.0.argument.body.body.1.argument.arguments.0.body.body.2.body.body.0.expression.callee"],
          _asyncToGenerator: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_asyncToGenerator",
        dependencies: {}
      }),
      awaitAsyncGenerator: helper("7.0.0-beta.0", "function _awaitAsyncGenerator(e){return new OverloadYield(e,0)}", {
        globals: [],
        locals: {
          _awaitAsyncGenerator: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_awaitAsyncGenerator",
        dependencies: {
          OverloadYield: ["body.0.body.body.0.argument.callee"]
        }
      }),
      callSuper: helper("7.23.8", "function _callSuper(t,o,e){return o=getPrototypeOf(o),possibleConstructorReturn(t,isNativeReflectConstruct()?Reflect.construct(o,e||[],getPrototypeOf(t).constructor):o.apply(t,e))}", {
        globals: ["Reflect"],
        locals: {
          _callSuper: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_callSuper",
        dependencies: {
          getPrototypeOf: ["body.0.body.body.0.argument.expressions.0.right.callee", "body.0.body.body.0.argument.expressions.1.arguments.1.consequent.arguments.2.object.callee"],
          isNativeReflectConstruct: ["body.0.body.body.0.argument.expressions.1.arguments.1.test.callee"],
          possibleConstructorReturn: ["body.0.body.body.0.argument.expressions.1.callee"]
        }
      }),
      checkInRHS: helper("7.20.5", `function _checkInRHS(e){if(Object(e)!==e)throw TypeError("right-hand side of 'in' should be an object, got "+(null!==e?typeof e:"null"));return e}`, {
        globals: ["Object", "TypeError"],
        locals: {
          _checkInRHS: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_checkInRHS",
        dependencies: {}
      }),
      checkPrivateRedeclaration: helper("7.14.1", 'function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}', {
        globals: ["TypeError"],
        locals: {
          _checkPrivateRedeclaration: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_checkPrivateRedeclaration",
        dependencies: {}
      }),
      classCallCheck: helper("7.0.0-beta.0", 'function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")}', {
        globals: ["TypeError"],
        locals: {
          _classCallCheck: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classCallCheck",
        dependencies: {}
      }),
      classNameTDZError: helper("7.0.0-beta.0", `function _classNameTDZError(e){throw new ReferenceError('Class "'+e+'" cannot be referenced in computed property keys.')}`, {
        globals: ["ReferenceError"],
        locals: {
          _classNameTDZError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classNameTDZError",
        dependencies: {}
      }),
      classPrivateFieldGet2: helper("7.24.0", "function _classPrivateFieldGet2(s,a){return s.get(assertClassBrand(s,a))}", {
        globals: [],
        locals: {
          _classPrivateFieldGet2: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldGet2",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
        }
      }),
      classPrivateFieldInitSpec: helper("7.14.1", "function _classPrivateFieldInitSpec(e,t,a){checkPrivateRedeclaration(e,t),t.set(e,a)}", {
        globals: [],
        locals: {
          _classPrivateFieldInitSpec: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldInitSpec",
        dependencies: {
          checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
        }
      }),
      classPrivateFieldLooseBase: helper("7.0.0-beta.0", 'function _classPrivateFieldBase(e,t){if(!{}.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}', {
        globals: ["TypeError"],
        locals: {
          _classPrivateFieldBase: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldBase",
        dependencies: {}
      }),
      classPrivateFieldLooseKey: helper("7.0.0-beta.0", 'var id=0;function _classPrivateFieldKey(e){return"__private_"+id+++"_"+e}', {
        globals: [],
        locals: {
          id: ["body.0.declarations.0.id", "body.1.body.body.0.argument.left.left.right.argument", "body.1.body.body.0.argument.left.left.right.argument"],
          _classPrivateFieldKey: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldKey",
        dependencies: {}
      }),
      classPrivateFieldSet2: helper("7.24.0", "function _classPrivateFieldSet2(s,a,r){return s.set(assertClassBrand(s,a),r),r}", {
        globals: [],
        locals: {
          _classPrivateFieldSet2: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateFieldSet2",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
        }
      }),
      classPrivateGetter: helper("7.24.0", "function _classPrivateGetter(s,r,a){return a(assertClassBrand(s,r))}", {
        globals: [],
        locals: {
          _classPrivateGetter: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateGetter",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.arguments.0.callee"]
        }
      }),
      classPrivateMethodInitSpec: helper("7.14.1", "function _classPrivateMethodInitSpec(e,a){checkPrivateRedeclaration(e,a),a.add(e)}", {
        globals: [],
        locals: {
          _classPrivateMethodInitSpec: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateMethodInitSpec",
        dependencies: {
          checkPrivateRedeclaration: ["body.0.body.body.0.expression.expressions.0.callee"]
        }
      }),
      classPrivateSetter: helper("7.24.0", "function _classPrivateSetter(s,r,a,t){return r(assertClassBrand(s,a),t),t}", {
        globals: [],
        locals: {
          _classPrivateSetter: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classPrivateSetter",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.arguments.0.callee"]
        }
      }),
      classStaticPrivateMethodGet: helper("7.3.2", "function _classStaticPrivateMethodGet(s,a,t){return assertClassBrand(a,s),t}", {
        globals: [],
        locals: {
          _classStaticPrivateMethodGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_classStaticPrivateMethodGet",
        dependencies: {
          assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
        }
      }),
      construct: helper("7.0.0-beta.0", "function _construct(t,e,r){if(isNativeReflectConstruct())return Reflect.construct.apply(null,arguments);var o=[null];o.push.apply(o,e);var p=new(t.bind.apply(t,o));return r&&setPrototypeOf(p,r.prototype),p}", {
        globals: ["Reflect"],
        locals: {
          _construct: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_construct",
        dependencies: {
          isNativeReflectConstruct: ["body.0.body.body.0.test.callee"],
          setPrototypeOf: ["body.0.body.body.4.argument.expressions.0.right.callee"]
        }
      }),
      createClass: helper("7.0.0-beta.0", 'function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e}', {
        globals: ["Object"],
        locals: {
          _defineProperties: ["body.0.id", "body.1.body.body.0.argument.expressions.0.right.callee", "body.1.body.body.0.argument.expressions.1.right.callee"],
          _createClass: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createClass",
        dependencies: {
          toPropertyKey: ["body.0.body.body.0.body.body.1.expression.expressions.3.arguments.1.callee"]
        }
      }),
      createForOfIteratorHelper: helper("7.9.0", 'function _createForOfIteratorHelper(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(!t){if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var n=0,F=function(){};return{s:F,n:function(){return n>=r.length?{done:!0}:{done:!1,value:r[n++]}},e:function(r){throw r},f:F}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var o,a=!0,u=!1;return{s:function(){t=t.call(r)},n:function(){var r=t.next();return a=r.done,r},e:function(r){u=!0,o=r},f:function(){try{a||null==t.return||t.return()}finally{if(u)throw o}}}}', {
        globals: ["Symbol", "Array", "TypeError"],
        locals: {
          _createForOfIteratorHelper: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createForOfIteratorHelper",
        dependencies: {
          unsupportedIterableToArray: ["body.0.body.body.1.consequent.body.0.test.left.right.right.callee"]
        }
      }),
      createForOfIteratorHelperLoose: helper("7.9.0", 'function _createForOfIteratorHelperLoose(r,e){var t="undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(t)return(t=t.call(r)).next.bind(t);if(Array.isArray(r)||(t=unsupportedIterableToArray(r))||e&&r&&"number"==typeof r.length){t&&(r=t);var o=0;return function(){return o>=r.length?{done:!0}:{done:!1,value:r[o++]}}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
        globals: ["Symbol", "Array", "TypeError"],
        locals: {
          _createForOfIteratorHelperLoose: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createForOfIteratorHelperLoose",
        dependencies: {
          unsupportedIterableToArray: ["body.0.body.body.2.test.left.right.right.callee"]
        }
      }),
      createSuper: helper("7.9.0", "function _createSuper(t){var r=isNativeReflectConstruct();return function(){var e,o=getPrototypeOf(t);if(r){var s=getPrototypeOf(this).constructor;e=Reflect.construct(o,arguments,s)}else e=o.apply(this,arguments);return possibleConstructorReturn(this,e)}}", {
        globals: ["Reflect"],
        locals: {
          _createSuper: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createSuper",
        dependencies: {
          getPrototypeOf: ["body.0.body.body.1.argument.body.body.0.declarations.1.init.callee", "body.0.body.body.1.argument.body.body.1.consequent.body.0.declarations.0.init.object.callee"],
          isNativeReflectConstruct: ["body.0.body.body.0.declarations.0.init.callee"],
          possibleConstructorReturn: ["body.0.body.body.1.argument.body.body.2.argument.callee"]
        }
      }),
      decorate: helper("7.1.5", `function _decorate(e,r,t,i){var o=_getDecoratorsApi();if(i)for(var n=0;n<i.length;n++)o=i[n](o);var s=r((function(e){o.initializeInstanceElements(e,a.elements)}),t),a=o.decorateClass(_coalesceClassElements(s.d.map(_createElementDescriptor)),e);return o.initializeClassElements(s.F,a.elements),o.runClassFinishers(s.F,a.finishers)}function _getDecoratorsApi(){_getDecoratorsApi=function(){return e};var e={elementsDefinitionOrder:[["method"],["field"]],initializeInstanceElements:function(e,r){["method","field"].forEach((function(t){r.forEach((function(r){r.kind===t&&"own"===r.placement&&this.defineClassElement(e,r)}),this)}),this)},initializeClassElements:function(e,r){var t=e.prototype;["method","field"].forEach((function(i){r.forEach((function(r){var o=r.placement;if(r.kind===i&&("static"===o||"prototype"===o)){var n="static"===o?e:t;this.defineClassElement(n,r)}}),this)}),this)},defineClassElement:function(e,r){var t=r.descriptor;if("field"===r.kind){var i=r.initializer;t={enumerable:t.enumerable,writable:t.writable,configurable:t.configurable,value:void 0===i?void 0:i.call(e)}}Object.defineProperty(e,r.key,t)},decorateClass:function(e,r){var t=[],i=[],o={static:[],prototype:[],own:[]};if(e.forEach((function(e){this.addElementPlacement(e,o)}),this),e.forEach((function(e){if(!_hasDecorators(e))return t.push(e);var r=this.decorateElement(e,o);t.push(r.element),t.push.apply(t,r.extras),i.push.apply(i,r.finishers)}),this),!r)return{elements:t,finishers:i};var n=this.decorateConstructor(t,r);return i.push.apply(i,n.finishers),n.finishers=i,n},addElementPlacement:function(e,r,t){var i=r[e.placement];if(!t&&-1!==i.indexOf(e.key))throw new TypeError("Duplicated element ("+e.key+")");i.push(e.key)},decorateElement:function(e,r){for(var t=[],i=[],o=e.decorators,n=o.length-1;n>=0;n--){var s=r[e.placement];s.splice(s.indexOf(e.key),1);var a=this.fromElementDescriptor(e),l=this.toElementFinisherExtras((0,o[n])(a)||a);e=l.element,this.addElementPlacement(e,r),l.finisher&&i.push(l.finisher);var c=l.extras;if(c){for(var p=0;p<c.length;p++)this.addElementPlacement(c[p],r);t.push.apply(t,c)}}return{element:e,finishers:i,extras:t}},decorateConstructor:function(e,r){for(var t=[],i=r.length-1;i>=0;i--){var o=this.fromClassDescriptor(e),n=this.toClassDescriptor((0,r[i])(o)||o);if(void 0!==n.finisher&&t.push(n.finisher),void 0!==n.elements){e=n.elements;for(var s=0;s<e.length-1;s++)for(var a=s+1;a<e.length;a++)if(e[s].key===e[a].key&&e[s].placement===e[a].placement)throw new TypeError("Duplicated element ("+e[s].key+")")}}return{elements:e,finishers:t}},fromElementDescriptor:function(e){var r={kind:e.kind,key:e.key,placement:e.placement,descriptor:e.descriptor};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),"field"===e.kind&&(r.initializer=e.initializer),r},toElementDescriptors:function(e){if(void 0!==e)return toArray(e).map((function(e){var r=this.toElementDescriptor(e);return this.disallowProperty(e,"finisher","An element descriptor"),this.disallowProperty(e,"extras","An element descriptor"),r}),this)},toElementDescriptor:function(e){var r=e.kind+"";if("method"!==r&&"field"!==r)throw new TypeError('An element descriptor\\'s .kind property must be either "method" or "field", but a decorator created an element descriptor with .kind "'+r+'"');var t=toPropertyKey(e.key),i=e.placement+"";if("static"!==i&&"prototype"!==i&&"own"!==i)throw new TypeError('An element descriptor\\'s .placement property must be one of "static", "prototype" or "own", but a decorator created an element descriptor with .placement "'+i+'"');var o=e.descriptor;this.disallowProperty(e,"elements","An element descriptor");var n={kind:r,key:t,placement:i,descriptor:Object.assign({},o)};return"field"!==r?this.disallowProperty(e,"initializer","A method descriptor"):(this.disallowProperty(o,"get","The property descriptor of a field descriptor"),this.disallowProperty(o,"set","The property descriptor of a field descriptor"),this.disallowProperty(o,"value","The property descriptor of a field descriptor"),n.initializer=e.initializer),n},toElementFinisherExtras:function(e){return{element:this.toElementDescriptor(e),finisher:_optionalCallableProperty(e,"finisher"),extras:this.toElementDescriptors(e.extras)}},fromClassDescriptor:function(e){var r={kind:"class",elements:e.map(this.fromElementDescriptor,this)};return Object.defineProperty(r,Symbol.toStringTag,{value:"Descriptor",configurable:!0}),r},toClassDescriptor:function(e){var r=e.kind+"";if("class"!==r)throw new TypeError('A class descriptor\\'s .kind property must be "class", but a decorator created a class descriptor with .kind "'+r+'"');this.disallowProperty(e,"key","A class descriptor"),this.disallowProperty(e,"placement","A class descriptor"),this.disallowProperty(e,"descriptor","A class descriptor"),this.disallowProperty(e,"initializer","A class descriptor"),this.disallowProperty(e,"extras","A class descriptor");var t=_optionalCallableProperty(e,"finisher");return{elements:this.toElementDescriptors(e.elements),finisher:t}},runClassFinishers:function(e,r){for(var t=0;t<r.length;t++){var i=(0,r[t])(e);if(void 0!==i){if("function"!=typeof i)throw new TypeError("Finishers must return a constructor.");e=i}}return e},disallowProperty:function(e,r,t){if(void 0!==e[r])throw new TypeError(t+" can't have a ."+r+" property.")}};return e}function _createElementDescriptor(e){var r,t=toPropertyKey(e.key);"method"===e.kind?r={value:e.value,writable:!0,configurable:!0,enumerable:!1}:"get"===e.kind?r={get:e.value,configurable:!0,enumerable:!1}:"set"===e.kind?r={set:e.value,configurable:!0,enumerable:!1}:"field"===e.kind&&(r={configurable:!0,writable:!0,enumerable:!0});var i={kind:"field"===e.kind?"field":"method",key:t,placement:e.static?"static":"field"===e.kind?"own":"prototype",descriptor:r};return e.decorators&&(i.decorators=e.decorators),"field"===e.kind&&(i.initializer=e.value),i}function _coalesceGetterSetter(e,r){void 0!==e.descriptor.get?r.descriptor.get=e.descriptor.get:r.descriptor.set=e.descriptor.set}function _coalesceClassElements(e){for(var r=[],isSameElement=function(e){return"method"===e.kind&&e.key===o.key&&e.placement===o.placement},t=0;t<e.length;t++){var i,o=e[t];if("method"===o.kind&&(i=r.find(isSameElement)))if(_isDataDescriptor(o.descriptor)||_isDataDescriptor(i.descriptor)){if(_hasDecorators(o)||_hasDecorators(i))throw new ReferenceError("Duplicated methods ("+o.key+") can't be decorated.");i.descriptor=o.descriptor}else{if(_hasDecorators(o)){if(_hasDecorators(i))throw new ReferenceError("Decorators can't be placed on different accessors with for the same property ("+o.key+").");i.decorators=o.decorators}_coalesceGetterSetter(o,i)}else r.push(o)}return r}function _hasDecorators(e){return e.decorators&&e.decorators.length}function _isDataDescriptor(e){return void 0!==e&&!(void 0===e.value&&void 0===e.writable)}function _optionalCallableProperty(e,r){var t=e[r];if(void 0!==t&&"function"!=typeof t)throw new TypeError("Expected '"+r+"' to be a function");return t}`, {
        globals: ["Object", "TypeError", "Symbol", "ReferenceError"],
        locals: {
          _decorate: ["body.0.id"],
          _getDecoratorsApi: ["body.1.id", "body.0.body.body.0.declarations.0.init.callee", "body.1.body.body.0.expression.left"],
          _createElementDescriptor: ["body.2.id", "body.0.body.body.2.declarations.1.init.arguments.0.arguments.0.arguments.0"],
          _coalesceGetterSetter: ["body.3.id", "body.4.body.body.0.body.body.1.consequent.alternate.body.1.expression.callee"],
          _coalesceClassElements: ["body.4.id", "body.0.body.body.2.declarations.1.init.arguments.0.callee"],
          _hasDecorators: ["body.5.id", "body.1.body.body.1.declarations.0.init.properties.4.value.body.body.1.test.expressions.1.arguments.0.body.body.0.test.argument.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.left.callee", "body.4.body.body.0.body.body.1.consequent.consequent.body.0.test.right.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.test.callee", "body.4.body.body.0.body.body.1.consequent.alternate.body.0.consequent.body.0.test.callee"],
          _isDataDescriptor: ["body.6.id", "body.4.body.body.0.body.body.1.consequent.test.left.callee", "body.4.body.body.0.body.body.1.consequent.test.right.callee"],
          _optionalCallableProperty: ["body.7.id", "body.1.body.body.1.declarations.0.init.properties.11.value.body.body.0.argument.properties.1.value.callee", "body.1.body.body.1.declarations.0.init.properties.13.value.body.body.3.declarations.0.init.callee"]
        },
        exportBindingAssignments: [],
        exportName: "_decorate",
        dependencies: {
          toArray: ["body.1.body.body.1.declarations.0.init.properties.9.value.body.body.0.consequent.argument.callee.object.callee"],
          toPropertyKey: ["body.1.body.body.1.declarations.0.init.properties.10.value.body.body.2.declarations.0.init.callee", "body.2.body.body.0.declarations.1.init.callee"]
        }
      }),
      defaults: helper("7.0.0-beta.0", "function _defaults(e,r){for(var t=Object.getOwnPropertyNames(r),o=0;o<t.length;o++){var n=t[o],a=Object.getOwnPropertyDescriptor(r,n);a&&a.configurable&&void 0===e[n]&&Object.defineProperty(e,n,a)}return e}", {
        globals: ["Object"],
        locals: {
          _defaults: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_defaults",
        dependencies: {}
      }),
      defineAccessor: helper("7.20.7", "function _defineAccessor(e,r,n,t){var c={configurable:!0,enumerable:!0};return c[e]=t,Object.defineProperty(r,n,c)}", {
        globals: ["Object"],
        locals: {
          _defineAccessor: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_defineAccessor",
        dependencies: {}
      }),
      defineProperty: helper("7.0.0-beta.0", "function _defineProperty(e,r,t){return(r=toPropertyKey(r))in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}", {
        globals: ["Object"],
        locals: {
          _defineProperty: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_defineProperty",
        dependencies: {
          toPropertyKey: ["body.0.body.body.0.argument.expressions.0.test.left.right.callee"]
        }
      }),
      extends: helper("7.0.0-beta.0", "function _extends(){return _extends=Object.assign?Object.assign.bind():function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)({}).hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},_extends.apply(null,arguments)}", {
        globals: ["Object"],
        locals: {
          _extends: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_extends",
        dependencies: {}
      }),
      get: helper("7.0.0-beta.0", 'function _get(){return _get="undefined"!=typeof Reflect&&Reflect.get?Reflect.get.bind():function(e,t,r){var p=superPropBase(e,t);if(p){var n=Object.getOwnPropertyDescriptor(p,t);return n.get?n.get.call(arguments.length<3?e:r):n.value}},_get.apply(null,arguments)}', {
        globals: ["Reflect", "Object"],
        locals: {
          _get: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee.object", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_get",
        dependencies: {
          superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.0.init.callee"]
        }
      }),
      getPrototypeOf: helper("7.0.0-beta.0", "function _getPrototypeOf(t){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(t){return t.__proto__||Object.getPrototypeOf(t)},_getPrototypeOf(t)}", {
        globals: ["Object"],
        locals: {
          _getPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_getPrototypeOf",
        dependencies: {}
      }),
      identity: helper("7.17.0", "function _identity(t){return t}", {
        globals: [],
        locals: {
          _identity: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_identity",
        dependencies: {}
      }),
      importDeferProxy: helper("7.23.0", "function _importDeferProxy(e){var t=null,constValue=function(e){return function(){return e}},proxy=function(r){return function(n,o,f){return null===t&&(t=e()),r(t,o,f)}};return new Proxy({},{defineProperty:constValue(!1),deleteProperty:constValue(!1),get:proxy(Reflect.get),getOwnPropertyDescriptor:proxy(Reflect.getOwnPropertyDescriptor),getPrototypeOf:constValue(null),isExtensible:constValue(!1),has:proxy(Reflect.has),ownKeys:proxy(Reflect.ownKeys),preventExtensions:constValue(!0),set:constValue(!1),setPrototypeOf:constValue(!1)})}", {
        globals: ["Proxy", "Reflect"],
        locals: {
          _importDeferProxy: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_importDeferProxy",
        dependencies: {}
      }),
      inherits: helper("7.0.0-beta.0", 'function _inherits(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),Object.defineProperty(t,"prototype",{writable:!1}),e&&setPrototypeOf(t,e)}', {
        globals: ["TypeError", "Object"],
        locals: {
          _inherits: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_inherits",
        dependencies: {
          setPrototypeOf: ["body.0.body.body.1.expression.expressions.2.right.callee"]
        }
      }),
      inheritsLoose: helper("7.0.0-beta.0", "function _inheritsLoose(t,o){t.prototype=Object.create(o.prototype),t.prototype.constructor=t,setPrototypeOf(t,o)}", {
        globals: ["Object"],
        locals: {
          _inheritsLoose: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_inheritsLoose",
        dependencies: {
          setPrototypeOf: ["body.0.body.body.0.expression.expressions.2.callee"]
        }
      }),
      initializerDefineProperty: helper("7.0.0-beta.0", "function _initializerDefineProperty(e,i,r,l){r&&Object.defineProperty(e,i,{enumerable:r.enumerable,configurable:r.configurable,writable:r.writable,value:r.initializer?r.initializer.call(l):void 0})}", {
        globals: ["Object"],
        locals: {
          _initializerDefineProperty: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_initializerDefineProperty",
        dependencies: {}
      }),
      initializerWarningHelper: helper("7.0.0-beta.0", 'function _initializerWarningHelper(r,e){throw Error("Decorating class property failed. Please ensure that transform-class-properties is enabled and runs after the decorators transform.")}', {
        globals: ["Error"],
        locals: {
          _initializerWarningHelper: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_initializerWarningHelper",
        dependencies: {}
      }),
      instanceof: helper("7.0.0-beta.0", 'function _instanceof(n,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?!!e[Symbol.hasInstance](n):n instanceof e}', {
        globals: ["Symbol"],
        locals: {
          _instanceof: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_instanceof",
        dependencies: {}
      }),
      interopRequireDefault: helper("7.0.0-beta.0", "function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}", {
        globals: [],
        locals: {
          _interopRequireDefault: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_interopRequireDefault",
        dependencies: {}
      }),
      interopRequireWildcard: helper("7.14.0", 'function _getRequireWildcardCache(e){if("function"!=typeof WeakMap)return null;var r=new WeakMap,t=new WeakMap;return(_getRequireWildcardCache=function(e){return e?t:r})(e)}function _interopRequireWildcard(e,r){if(!r&&e&&e.__esModule)return e;if(null===e||"object"!=typeof e&&"function"!=typeof e)return{default:e};var t=_getRequireWildcardCache(r);if(t&&t.has(e))return t.get(e);var n={__proto__:null},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if("default"!==u&&{}.hasOwnProperty.call(e,u)){var i=a?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}', {
        globals: ["WeakMap", "Object"],
        locals: {
          _getRequireWildcardCache: ["body.0.id", "body.1.body.body.2.declarations.0.init.callee", "body.0.body.body.2.argument.callee.left"],
          _interopRequireWildcard: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_interopRequireWildcard",
        dependencies: {}
      }),
      isNativeFunction: helper("7.0.0-beta.0", 'function _isNativeFunction(t){try{return-1!==Function.toString.call(t).indexOf("[native code]")}catch(n){return"function"==typeof t}}', {
        globals: ["Function"],
        locals: {
          _isNativeFunction: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_isNativeFunction",
        dependencies: {}
      }),
      isNativeReflectConstruct: helper("7.9.0", "function _isNativeReflectConstruct(){try{var t=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){})))}catch(t){}return(_isNativeReflectConstruct=function(){return!!t})()}", {
        globals: ["Boolean", "Reflect"],
        locals: {
          _isNativeReflectConstruct: ["body.0.id", "body.0.body.body.1.argument.callee.left"]
        },
        exportBindingAssignments: ["body.0.body.body.1.argument.callee"],
        exportName: "_isNativeReflectConstruct",
        dependencies: {}
      }),
      iterableToArray: helper("7.0.0-beta.0", 'function _iterableToArray(r){if("undefined"!=typeof Symbol&&null!=r[Symbol.iterator]||null!=r["@@iterator"])return Array.from(r)}', {
        globals: ["Symbol", "Array"],
        locals: {
          _iterableToArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_iterableToArray",
        dependencies: {}
      }),
      iterableToArrayLimit: helper("7.0.0-beta.0", 'function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}}', {
        globals: ["Symbol", "Object"],
        locals: {
          _iterableToArrayLimit: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_iterableToArrayLimit",
        dependencies: {}
      }),
      jsx: helper("7.0.0-beta.0", 'var REACT_ELEMENT_TYPE;function _createRawReactElement(e,r,E,l){REACT_ELEMENT_TYPE||(REACT_ELEMENT_TYPE="function"==typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103);var o=e&&e.defaultProps,n=arguments.length-3;if(r||0===n||(r={children:void 0}),1===n)r.children=l;else if(n>1){for(var t=Array(n),f=0;f<n;f++)t[f]=arguments[f+3];r.children=t}if(r&&o)for(var i in o)void 0===r[i]&&(r[i]=o[i]);else r||(r=o||{});return{$$typeof:REACT_ELEMENT_TYPE,type:e,key:void 0===E?null:""+E,ref:null,props:r,_owner:null}}', {
        globals: ["Symbol", "Array"],
        locals: {
          REACT_ELEMENT_TYPE: ["body.0.declarations.0.id", "body.1.body.body.0.expression.left", "body.1.body.body.4.argument.properties.0.value", "body.1.body.body.0.expression.right.left"],
          _createRawReactElement: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_createRawReactElement",
        dependencies: {}
      }),
      maybeArrayLike: helper("7.9.0", 'function _maybeArrayLike(r,a,e){if(a&&!Array.isArray(a)&&"number"==typeof a.length){var y=a.length;return arrayLikeToArray(a,void 0!==e&&e<y?e:y)}return r(a,e)}', {
        globals: ["Array"],
        locals: {
          _maybeArrayLike: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_maybeArrayLike",
        dependencies: {
          arrayLikeToArray: ["body.0.body.body.0.consequent.body.1.argument.callee"]
        }
      }),
      newArrowCheck: helper("7.0.0-beta.0", 'function _newArrowCheck(n,r){if(n!==r)throw new TypeError("Cannot instantiate an arrow function")}', {
        globals: ["TypeError"],
        locals: {
          _newArrowCheck: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_newArrowCheck",
        dependencies: {}
      }),
      nonIterableRest: helper("7.0.0-beta.0", 'function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
        globals: ["TypeError"],
        locals: {
          _nonIterableRest: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_nonIterableRest",
        dependencies: {}
      }),
      nonIterableSpread: helper("7.0.0-beta.0", 'function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}', {
        globals: ["TypeError"],
        locals: {
          _nonIterableSpread: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_nonIterableSpread",
        dependencies: {}
      }),
      nullishReceiverError: helper("7.22.6", 'function _nullishReceiverError(r){throw new TypeError("Cannot set property of null or undefined.")}', {
        globals: ["TypeError"],
        locals: {
          _nullishReceiverError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_nullishReceiverError",
        dependencies: {}
      }),
      objectDestructuringEmpty: helper("7.0.0-beta.0", 'function _objectDestructuringEmpty(t){if(null==t)throw new TypeError("Cannot destructure "+t)}', {
        globals: ["TypeError"],
        locals: {
          _objectDestructuringEmpty: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectDestructuringEmpty",
        dependencies: {}
      }),
      objectSpread2: helper("7.5.0", "function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,o)}return t}function _objectSpread2(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach((function(r){defineProperty(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}", {
        globals: ["Object"],
        locals: {
          ownKeys: ["body.0.id", "body.1.body.body.0.body.body.1.expression.consequent.callee.object.callee", "body.1.body.body.0.body.body.1.expression.alternate.alternate.callee.object.callee"],
          _objectSpread2: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectSpread2",
        dependencies: {
          defineProperty: ["body.1.body.body.0.body.body.1.expression.consequent.arguments.0.body.body.0.expression.callee"]
        }
      }),
      objectWithoutProperties: helper("7.0.0-beta.0", "function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=objectWithoutPropertiesLoose(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)o=s[r],t.includes(o)||{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}", {
        globals: ["Object"],
        locals: {
          _objectWithoutProperties: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectWithoutProperties",
        dependencies: {
          objectWithoutPropertiesLoose: ["body.0.body.body.1.declarations.2.init.callee"]
        }
      }),
      objectWithoutPropertiesLoose: helper("7.0.0-beta.0", "function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(e.includes(n))continue;t[n]=r[n]}return t}", {
        globals: [],
        locals: {
          _objectWithoutPropertiesLoose: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_objectWithoutPropertiesLoose",
        dependencies: {}
      }),
      possibleConstructorReturn: helper("7.0.0-beta.0", 'function _possibleConstructorReturn(t,e){if(e&&("object"==typeof e||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return assertThisInitialized(t)}', {
        globals: ["TypeError"],
        locals: {
          _possibleConstructorReturn: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_possibleConstructorReturn",
        dependencies: {
          assertThisInitialized: ["body.0.body.body.2.argument.callee"]
        }
      }),
      readOnlyError: helper("7.0.0-beta.0", `function _readOnlyError(r){throw new TypeError('"'+r+'" is read-only')}`, {
        globals: ["TypeError"],
        locals: {
          _readOnlyError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_readOnlyError",
        dependencies: {}
      }),
      regeneratorRuntime: helper("7.18.0", `function _regeneratorRuntime(){"use strict";
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */_regeneratorRuntime=function(){return e};var t,e={},r=Object.prototype,n=r.hasOwnProperty,o=Object.defineProperty||function(t,e,r){t[e]=r.value},i="function"==typeof Symbol?Symbol:{},a=i.iterator||"@@iterator",c=i.asyncIterator||"@@asyncIterator",u=i.toStringTag||"@@toStringTag";function define(t,e,r){return Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}),t[e]}try{define({},"")}catch(t){define=function(t,e,r){return t[e]=r}}function wrap(t,e,r,n){var i=e&&e.prototype instanceof Generator?e:Generator,a=Object.create(i.prototype),c=new Context(n||[]);return o(a,"_invoke",{value:makeInvokeMethod(t,r,c)}),a}function tryCatch(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}e.wrap=wrap;var h="suspendedStart",l="suspendedYield",f="executing",s="completed",y={};function Generator(){}function GeneratorFunction(){}function GeneratorFunctionPrototype(){}var p={};define(p,a,(function(){return this}));var d=Object.getPrototypeOf,v=d&&d(d(values([])));v&&v!==r&&n.call(v,a)&&(p=v);var g=GeneratorFunctionPrototype.prototype=Generator.prototype=Object.create(p);function defineIteratorMethods(t){["next","throw","return"].forEach((function(e){define(t,e,(function(t){return this._invoke(e,t)}))}))}function AsyncIterator(t,e){function invoke(r,o,i,a){var c=tryCatch(t[r],t,o);if("throw"!==c.type){var u=c.arg,h=u.value;return h&&"object"==typeof h&&n.call(h,"__await")?e.resolve(h.__await).then((function(t){invoke("next",t,i,a)}),(function(t){invoke("throw",t,i,a)})):e.resolve(h).then((function(t){u.value=t,i(u)}),(function(t){return invoke("throw",t,i,a)}))}a(c.arg)}var r;o(this,"_invoke",{value:function(t,n){function callInvokeWithMethodAndArg(){return new e((function(e,r){invoke(t,n,e,r)}))}return r=r?r.then(callInvokeWithMethodAndArg,callInvokeWithMethodAndArg):callInvokeWithMethodAndArg()}})}function makeInvokeMethod(e,r,n){var o=h;return function(i,a){if(o===f)throw Error("Generator is already running");if(o===s){if("throw"===i)throw a;return{value:t,done:!0}}for(n.method=i,n.arg=a;;){var c=n.delegate;if(c){var u=maybeInvokeDelegate(c,n);if(u){if(u===y)continue;return u}}if("next"===n.method)n.sent=n._sent=n.arg;else if("throw"===n.method){if(o===h)throw o=s,n.arg;n.dispatchException(n.arg)}else"return"===n.method&&n.abrupt("return",n.arg);o=f;var p=tryCatch(e,r,n);if("normal"===p.type){if(o=n.done?s:l,p.arg===y)continue;return{value:p.arg,done:n.done}}"throw"===p.type&&(o=s,n.method="throw",n.arg=p.arg)}}}function maybeInvokeDelegate(e,r){var n=r.method,o=e.iterator[n];if(o===t)return r.delegate=null,"throw"===n&&e.iterator.return&&(r.method="return",r.arg=t,maybeInvokeDelegate(e,r),"throw"===r.method)||"return"!==n&&(r.method="throw",r.arg=new TypeError("The iterator does not provide a '"+n+"' method")),y;var i=tryCatch(o,e.iterator,r.arg);if("throw"===i.type)return r.method="throw",r.arg=i.arg,r.delegate=null,y;var a=i.arg;return a?a.done?(r[e.resultName]=a.value,r.next=e.nextLoc,"return"!==r.method&&(r.method="next",r.arg=t),r.delegate=null,y):a:(r.method="throw",r.arg=new TypeError("iterator result is not an object"),r.delegate=null,y)}function pushTryEntry(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function resetTryEntry(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function Context(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(pushTryEntry,this),this.reset(!0)}function values(e){if(e||""===e){var r=e[a];if(r)return r.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,i=function next(){for(;++o<e.length;)if(n.call(e,o))return next.value=e[o],next.done=!1,next;return next.value=t,next.done=!0,next};return i.next=i}}throw new TypeError(typeof e+" is not iterable")}return GeneratorFunction.prototype=GeneratorFunctionPrototype,o(g,"constructor",{value:GeneratorFunctionPrototype,configurable:!0}),o(GeneratorFunctionPrototype,"constructor",{value:GeneratorFunction,configurable:!0}),GeneratorFunction.displayName=define(GeneratorFunctionPrototype,u,"GeneratorFunction"),e.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===GeneratorFunction||"GeneratorFunction"===(e.displayName||e.name))},e.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,GeneratorFunctionPrototype):(t.__proto__=GeneratorFunctionPrototype,define(t,u,"GeneratorFunction")),t.prototype=Object.create(g),t},e.awrap=function(t){return{__await:t}},defineIteratorMethods(AsyncIterator.prototype),define(AsyncIterator.prototype,c,(function(){return this})),e.AsyncIterator=AsyncIterator,e.async=function(t,r,n,o,i){void 0===i&&(i=Promise);var a=new AsyncIterator(wrap(t,r,n,o),i);return e.isGeneratorFunction(r)?a:a.next().then((function(t){return t.done?t.value:a.next()}))},defineIteratorMethods(g),define(g,u,"Generator"),define(g,a,(function(){return this})),define(g,"toString",(function(){return"[object Generator]"})),e.keys=function(t){var e=Object(t),r=[];for(var n in e)r.push(n);return r.reverse(),function next(){for(;r.length;){var t=r.pop();if(t in e)return next.value=t,next.done=!1,next}return next.done=!0,next}},e.values=values,Context.prototype={constructor:Context,reset:function(e){if(this.prev=0,this.next=0,this.sent=this._sent=t,this.done=!1,this.delegate=null,this.method="next",this.arg=t,this.tryEntries.forEach(resetTryEntry),!e)for(var r in this)"t"===r.charAt(0)&&n.call(this,r)&&!isNaN(+r.slice(1))&&(this[r]=t)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(e){if(this.done)throw e;var r=this;function handle(n,o){return a.type="throw",a.arg=e,r.next=n,o&&(r.method="next",r.arg=t),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var i=this.tryEntries[o],a=i.completion;if("root"===i.tryLoc)return handle("end");if(i.tryLoc<=this.prev){var c=n.call(i,"catchLoc"),u=n.call(i,"finallyLoc");if(c&&u){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0);if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return handle(i.catchLoc,!0)}else{if(!u)throw Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return handle(i.finallyLoc)}}}},abrupt:function(t,e){for(var r=this.tryEntries.length-1;r>=0;--r){var o=this.tryEntries[r];if(o.tryLoc<=this.prev&&n.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var i=o;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=t,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,y):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),y},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),resetTryEntry(r),y}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var o=n.arg;resetTryEntry(r)}return o}}throw Error("illegal catch attempt")},delegateYield:function(e,r,n){return this.delegate={iterator:values(e),resultName:r,nextLoc:n},"next"===this.method&&(this.arg=t),y}},e}`, {
        globals: ["Object", "Symbol", "Error", "TypeError", "isNaN", "Promise"],
        locals: {
          _regeneratorRuntime: ["body.0.id", "body.0.body.body.0.expression.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.expression"],
        exportName: "_regeneratorRuntime",
        dependencies: {}
      }),
      set: helper("7.0.0-beta.0", 'function set(e,r,t,o){return set="undefined"!=typeof Reflect&&Reflect.set?Reflect.set:function(e,r,t,o){var f,i=superPropBase(e,r);if(i){if((f=Object.getOwnPropertyDescriptor(i,r)).set)return f.set.call(o,t),!0;if(!f.writable)return!1}if(f=Object.getOwnPropertyDescriptor(o,r)){if(!f.writable)return!1;f.value=t,Object.defineProperty(o,r,f)}else defineProperty(o,r,t);return!0},set(e,r,t,o)}function _set(e,r,t,o,f){if(!set(e,r,t,o||e)&&f)throw new TypeError("failed to set property");return t}', {
        globals: ["Reflect", "Object", "TypeError"],
        locals: {
          set: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.0.test.left.argument.callee", "body.0.body.body.0.argument.expressions.0.left"],
          _set: ["body.1.id"]
        },
        exportBindingAssignments: [],
        exportName: "_set",
        dependencies: {
          superPropBase: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.0.declarations.1.init.callee"],
          defineProperty: ["body.0.body.body.0.argument.expressions.0.right.alternate.body.body.2.alternate.expression.callee"]
        }
      }),
      setFunctionName: helper("7.23.6", 'function setFunctionName(e,t,n){"symbol"==typeof t&&(t=(t=t.description)?"["+t+"]":"");try{Object.defineProperty(e,"name",{configurable:!0,value:n?n+" "+t:t})}catch(e){}return e}', {
        globals: ["Object"],
        locals: {
          setFunctionName: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "setFunctionName",
        dependencies: {}
      }),
      setPrototypeOf: helper("7.0.0-beta.0", "function _setPrototypeOf(t,e){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(t,e){return t.__proto__=e,t},_setPrototypeOf(t,e)}", {
        globals: ["Object"],
        locals: {
          _setPrototypeOf: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_setPrototypeOf",
        dependencies: {}
      }),
      skipFirstGeneratorNext: helper("7.0.0-beta.0", "function _skipFirstGeneratorNext(t){return function(){var r=t.apply(this,arguments);return r.next(),r}}", {
        globals: [],
        locals: {
          _skipFirstGeneratorNext: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_skipFirstGeneratorNext",
        dependencies: {}
      }),
      slicedToArray: helper("7.0.0-beta.0", "function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()}", {
        globals: [],
        locals: {
          _slicedToArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_slicedToArray",
        dependencies: {
          arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
          iterableToArrayLimit: ["body.0.body.body.0.argument.left.left.right.callee"],
          unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
          nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
        }
      }),
      superPropBase: helper("7.0.0-beta.0", "function _superPropBase(t,o){for(;!{}.hasOwnProperty.call(t,o)&&null!==(t=getPrototypeOf(t)););return t}", {
        globals: [],
        locals: {
          _superPropBase: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_superPropBase",
        dependencies: {
          getPrototypeOf: ["body.0.body.body.0.test.right.right.right.callee"]
        }
      }),
      superPropGet: helper("7.25.0", 'function _superPropGet(t,o,e,r){var p=get(getPrototypeOf(1&r?t.prototype:t),o,e);return 2&r&&"function"==typeof p?function(t){return p.apply(e,t)}:p}', {
        globals: [],
        locals: {
          _superPropGet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_superPropGet",
        dependencies: {
          get: ["body.0.body.body.0.declarations.0.init.callee"],
          getPrototypeOf: ["body.0.body.body.0.declarations.0.init.arguments.0.callee"]
        }
      }),
      superPropSet: helper("7.25.0", "function _superPropSet(t,e,o,r,p,f){return set(getPrototypeOf(f?t.prototype:t),e,o,r,p)}", {
        globals: [],
        locals: {
          _superPropSet: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_superPropSet",
        dependencies: {
          set: ["body.0.body.body.0.argument.callee"],
          getPrototypeOf: ["body.0.body.body.0.argument.arguments.0.callee"]
        }
      }),
      taggedTemplateLiteral: helper("7.0.0-beta.0", "function _taggedTemplateLiteral(e,t){return t||(t=e.slice(0)),Object.freeze(Object.defineProperties(e,{raw:{value:Object.freeze(t)}}))}", {
        globals: ["Object"],
        locals: {
          _taggedTemplateLiteral: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_taggedTemplateLiteral",
        dependencies: {}
      }),
      taggedTemplateLiteralLoose: helper("7.0.0-beta.0", "function _taggedTemplateLiteralLoose(e,t){return t||(t=e.slice(0)),e.raw=t,e}", {
        globals: [],
        locals: {
          _taggedTemplateLiteralLoose: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_taggedTemplateLiteralLoose",
        dependencies: {}
      }),
      tdz: helper("7.5.5", 'function _tdzError(e){throw new ReferenceError(e+" is not defined - temporal dead zone")}', {
        globals: ["ReferenceError"],
        locals: {
          _tdzError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_tdzError",
        dependencies: {}
      }),
      temporalRef: helper("7.0.0-beta.0", "function _temporalRef(r,e){return r===undef?err(e):r}", {
        globals: [],
        locals: {
          _temporalRef: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_temporalRef",
        dependencies: {
          temporalUndefined: ["body.0.body.body.0.argument.test.right"],
          tdz: ["body.0.body.body.0.argument.consequent.callee"]
        }
      }),
      temporalUndefined: helper("7.0.0-beta.0", "function _temporalUndefined(){}", {
        globals: [],
        locals: {
          _temporalUndefined: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_temporalUndefined",
        dependencies: {}
      }),
      toArray: helper("7.0.0-beta.0", "function _toArray(r){return arrayWithHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableRest()}", {
        globals: [],
        locals: {
          _toArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_toArray",
        dependencies: {
          arrayWithHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
          iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
          unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
          nonIterableRest: ["body.0.body.body.0.argument.right.callee"]
        }
      }),
      toConsumableArray: helper("7.0.0-beta.0", "function _toConsumableArray(r){return arrayWithoutHoles(r)||iterableToArray(r)||unsupportedIterableToArray(r)||nonIterableSpread()}", {
        globals: [],
        locals: {
          _toConsumableArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_toConsumableArray",
        dependencies: {
          arrayWithoutHoles: ["body.0.body.body.0.argument.left.left.left.callee"],
          iterableToArray: ["body.0.body.body.0.argument.left.left.right.callee"],
          unsupportedIterableToArray: ["body.0.body.body.0.argument.left.right.callee"],
          nonIterableSpread: ["body.0.body.body.0.argument.right.callee"]
        }
      }),
      toPrimitive: helper("7.1.5", 'function toPrimitive(t,r){if("object"!=typeof t||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=typeof i)return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)}', {
        globals: ["Symbol", "TypeError", "String", "Number"],
        locals: {
          toPrimitive: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "toPrimitive",
        dependencies: {}
      }),
      toPropertyKey: helper("7.1.5", 'function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==typeof i?i:i+""}', {
        globals: [],
        locals: {
          toPropertyKey: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "toPropertyKey",
        dependencies: {
          toPrimitive: ["body.0.body.body.0.declarations.0.init.callee"]
        }
      }),
      toSetter: helper("7.24.0", 'function _toSetter(t,e,n){e||(e=[]);var r=e.length++;return Object.defineProperty({},"_",{set:function(o){e[r]=o,t.apply(n,e)}})}', {
        globals: ["Object"],
        locals: {
          _toSetter: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_toSetter",
        dependencies: {}
      }),
      typeof: helper("7.0.0-beta.0", 'function _typeof(o){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},_typeof(o)}', {
        globals: ["Symbol"],
        locals: {
          _typeof: ["body.0.id", "body.0.body.body.0.argument.expressions.1.callee", "body.0.body.body.0.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.argument.expressions.0"],
        exportName: "_typeof",
        dependencies: {}
      }),
      unsupportedIterableToArray: helper("7.9.0", 'function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}}', {
        globals: ["Array"],
        locals: {
          _unsupportedIterableToArray: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_unsupportedIterableToArray",
        dependencies: {
          arrayLikeToArray: ["body.0.body.body.0.consequent.body.0.consequent.argument.callee", "body.0.body.body.0.consequent.body.2.argument.expressions.1.alternate.consequent.callee"]
        }
      }),
      usingCtx: helper("7.23.9", 'function _usingCtx(){var r="function"==typeof SuppressedError?SuppressedError:function(r,e){var n=Error();return n.name="SuppressedError",n.error=r,n.suppressed=e,n},e={},n=[];function using(r,e){if(null!=e){if(Object(e)!==e)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(r)var o=e[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(void 0===o&&(o=e[Symbol.dispose||Symbol.for("Symbol.dispose")],r))var t=o;if("function"!=typeof o)throw new TypeError("Object is not disposable.");t&&(o=function(){try{t.call(e)}catch(r){return Promise.reject(r)}}),n.push({v:e,d:o,a:r})}else r&&n.push({d:e,a:r});return e}return{e:e,u:using.bind(null,!1),a:using.bind(null,!0),d:function(){var o,t=this.e,s=0;function next(){for(;o=n.pop();)try{if(!o.a&&1===s)return s=0,n.push(o),Promise.resolve().then(next);if(o.d){var r=o.d.call(o.v);if(o.a)return s|=2,Promise.resolve(r).then(next,err)}else s|=1}catch(r){return err(r)}if(1===s)return t!==e?Promise.reject(t):Promise.resolve();if(t!==e)throw t}function err(n){return t=t!==e?new r(n,t):n,next()}return next()}}}', {
        globals: ["SuppressedError", "Error", "Object", "TypeError", "Symbol", "Promise"],
        locals: {
          _usingCtx: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_usingCtx",
        dependencies: {}
      }),
      wrapAsyncGenerator: helper("7.0.0-beta.0", 'function _wrapAsyncGenerator(e){return function(){return new AsyncGenerator(e.apply(this,arguments))}}function AsyncGenerator(e){var r,t;function resume(r,t){try{var n=e[r](t),o=n.value,u=o instanceof OverloadYield;Promise.resolve(u?o.v:o).then((function(t){if(u){var i="return"===r?"return":"next";if(!o.k||t.done)return resume(i,t);t=e[i](t).value}settle(n.done?"return":"normal",t)}),(function(e){resume("throw",e)}))}catch(e){settle("throw",e)}}function settle(e,n){switch(e){case"return":r.resolve({value:n,done:!0});break;case"throw":r.reject(n);break;default:r.resolve({value:n,done:!1})}(r=r.next)?resume(r.key,r.arg):t=null}this._invoke=function(e,n){return new Promise((function(o,u){var i={key:e,arg:n,resolve:o,reject:u,next:null};t?t=t.next=i:(r=t=i,resume(e,n))}))},"function"!=typeof e.return&&(this.return=void 0)}AsyncGenerator.prototype["function"==typeof Symbol&&Symbol.asyncIterator||"@@asyncIterator"]=function(){return this},AsyncGenerator.prototype.next=function(e){return this._invoke("next",e)},AsyncGenerator.prototype.throw=function(e){return this._invoke("throw",e)},AsyncGenerator.prototype.return=function(e){return this._invoke("return",e)};', {
        globals: ["Promise", "Symbol"],
        locals: {
          _wrapAsyncGenerator: ["body.0.id"],
          AsyncGenerator: ["body.1.id", "body.0.body.body.0.argument.body.body.0.argument.callee", "body.2.expression.expressions.0.left.object.object", "body.2.expression.expressions.1.left.object.object", "body.2.expression.expressions.2.left.object.object", "body.2.expression.expressions.3.left.object.object"]
        },
        exportBindingAssignments: [],
        exportName: "_wrapAsyncGenerator",
        dependencies: {
          OverloadYield: ["body.1.body.body.1.body.body.0.block.body.0.declarations.2.init.right"]
        }
      }),
      wrapNativeSuper: helper("7.0.0-beta.0", 'function _wrapNativeSuper(t){var r="function"==typeof Map?new Map:void 0;return _wrapNativeSuper=function(t){if(null===t||!isNativeFunction(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,Wrapper)}function Wrapper(){return construct(t,arguments,getPrototypeOf(this).constructor)}return Wrapper.prototype=Object.create(t.prototype,{constructor:{value:Wrapper,enumerable:!1,writable:!0,configurable:!0}}),setPrototypeOf(Wrapper,t)},_wrapNativeSuper(t)}', {
        globals: ["Map", "TypeError", "Object"],
        locals: {
          _wrapNativeSuper: ["body.0.id", "body.0.body.body.1.argument.expressions.1.callee", "body.0.body.body.1.argument.expressions.0.left"]
        },
        exportBindingAssignments: ["body.0.body.body.1.argument.expressions.0"],
        exportName: "_wrapNativeSuper",
        dependencies: {
          getPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.arguments.2.object.callee"],
          setPrototypeOf: ["body.0.body.body.1.argument.expressions.0.right.body.body.4.argument.expressions.1.callee"],
          isNativeFunction: ["body.0.body.body.1.argument.expressions.0.right.body.body.0.test.right.argument.callee"],
          construct: ["body.0.body.body.1.argument.expressions.0.right.body.body.3.body.body.0.argument.callee"]
        }
      }),
      wrapRegExp: helper("7.19.0", 'function _wrapRegExp(){_wrapRegExp=function(e,r){return new BabelRegExp(e,void 0,r)};var e=RegExp.prototype,r=new WeakMap;function BabelRegExp(e,t,p){var o=RegExp(e,t);return r.set(o,p||r.get(e)),setPrototypeOf(o,BabelRegExp.prototype)}function buildGroups(e,t){var p=r.get(t);return Object.keys(p).reduce((function(r,t){var o=p[t];if("number"==typeof o)r[t]=e[o];else{for(var i=0;void 0===e[o[i]]&&i+1<o.length;)i++;r[t]=e[o[i]]}return r}),Object.create(null))}return inherits(BabelRegExp,RegExp),BabelRegExp.prototype.exec=function(r){var t=e.exec.call(this,r);if(t){t.groups=buildGroups(t,this);var p=t.indices;p&&(p.groups=buildGroups(p,this))}return t},BabelRegExp.prototype[Symbol.replace]=function(t,p){if("string"==typeof p){var o=r.get(this);return e[Symbol.replace].call(this,t,p.replace(/\\$<([^>]+)>/g,(function(e,r){var t=o[r];return"$"+(Array.isArray(t)?t.join("$"):t)})))}if("function"==typeof p){var i=this;return e[Symbol.replace].call(this,t,(function(){var e=arguments;return"object"!=typeof e[e.length-1]&&(e=[].slice.call(e)).push(buildGroups(e,i)),p.apply(this,e)}))}return e[Symbol.replace].call(this,t,p)},_wrapRegExp.apply(this,arguments)}', {
        globals: ["RegExp", "WeakMap", "Object", "Symbol", "Array"],
        locals: {
          _wrapRegExp: ["body.0.id", "body.0.body.body.4.argument.expressions.3.callee.object", "body.0.body.body.0.expression.left"]
        },
        exportBindingAssignments: ["body.0.body.body.0.expression"],
        exportName: "_wrapRegExp",
        dependencies: {
          setPrototypeOf: ["body.0.body.body.2.body.body.1.argument.expressions.1.callee"],
          inherits: ["body.0.body.body.4.argument.expressions.0.callee"]
        }
      }),
      writeOnlyError: helper("7.12.13", `function _writeOnlyError(r){throw new TypeError('"'+r+'" is write-only')}`, {
        globals: ["TypeError"],
        locals: {
          _writeOnlyError: ["body.0.id"]
        },
        exportBindingAssignments: [],
        exportName: "_writeOnlyError",
        dependencies: {}
      })
    };
    {
      Object.assign(helpers, {
        AwaitValue: helper("7.0.0-beta.0", "function _AwaitValue(t){this.wrapped=t}", {
          globals: [],
          locals: {
            _AwaitValue: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_AwaitValue",
          dependencies: {}
        }),
        applyDecs: helper("7.17.8", 'function old_createMetadataMethodsForProperty(e,t,a,r){return{getMetadata:function(o){old_assertNotFinished(r,"getMetadata"),old_assertMetadataKey(o);var i=e[o];if(void 0!==i)if(1===t){var n=i.public;if(void 0!==n)return n[a]}else if(2===t){var l=i.private;if(void 0!==l)return l.get(a)}else if(Object.hasOwnProperty.call(i,"constructor"))return i.constructor},setMetadata:function(o,i){old_assertNotFinished(r,"setMetadata"),old_assertMetadataKey(o);var n=e[o];if(void 0===n&&(n=e[o]={}),1===t){var l=n.public;void 0===l&&(l=n.public={}),l[a]=i}else if(2===t){var s=n.priv;void 0===s&&(s=n.private=new Map),s.set(a,i)}else n.constructor=i}}}function old_convertMetadataMapToFinal(e,t){var a=e[Symbol.metadata||Symbol.for("Symbol.metadata")],r=Object.getOwnPropertySymbols(t);if(0!==r.length){for(var o=0;o<r.length;o++){var i=r[o],n=t[i],l=a?a[i]:null,s=n.public,c=l?l.public:null;s&&c&&Object.setPrototypeOf(s,c);var d=n.private;if(d){var u=Array.from(d.values()),f=l?l.private:null;f&&(u=u.concat(f)),n.private=u}l&&Object.setPrototypeOf(n,l)}a&&Object.setPrototypeOf(t,a),e[Symbol.metadata||Symbol.for("Symbol.metadata")]=t}}function old_createAddInitializerMethod(e,t){return function(a){old_assertNotFinished(t,"addInitializer"),old_assertCallable(a,"An initializer"),e.push(a)}}function old_memberDec(e,t,a,r,o,i,n,l,s){var c;switch(i){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var d,u,f={kind:c,name:l?"#"+t:toPropertyKey(t),isStatic:n,isPrivate:l},p={v:!1};if(0!==i&&(f.addInitializer=old_createAddInitializerMethod(o,p)),l){d=2,u=Symbol(t);var v={};0===i?(v.get=a.get,v.set=a.set):2===i?v.get=function(){return a.value}:(1!==i&&3!==i||(v.get=function(){return a.get.call(this)}),1!==i&&4!==i||(v.set=function(e){a.set.call(this,e)})),f.access=v}else d=1,u=t;try{return e(s,Object.assign(f,old_createMetadataMethodsForProperty(r,d,u,p)))}finally{p.v=!0}}function old_assertNotFinished(e,t){if(e.v)throw Error("attempted to call "+t+" after decoration was finished")}function old_assertMetadataKey(e){if("symbol"!=typeof e)throw new TypeError("Metadata keys must be symbols, received: "+e)}function old_assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function old_assertValidReturnValue(e,t){var a=typeof t;if(1===e){if("object"!==a||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&old_assertCallable(t.get,"accessor.get"),void 0!==t.set&&old_assertCallable(t.set,"accessor.set"),void 0!==t.init&&old_assertCallable(t.init,"accessor.init"),void 0!==t.initializer&&old_assertCallable(t.initializer,"accessor.initializer")}else if("function"!==a)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function old_getInit(e){var t;return null==(t=e.init)&&(t=e.initializer)&&void 0!==console&&console.warn(".initializer has been renamed to .init as of March 2022"),t}function old_applyMemberDec(e,t,a,r,o,i,n,l,s){var c,d,u,f,p,v,y,h=a[0];if(n?(0===o||1===o?(c={get:a[3],set:a[4]},u="get"):3===o?(c={get:a[3]},u="get"):4===o?(c={set:a[3]},u="set"):c={value:a[3]},0!==o&&(1===o&&setFunctionName(a[4],"#"+r,"set"),setFunctionName(a[3],"#"+r,u))):0!==o&&(c=Object.getOwnPropertyDescriptor(t,r)),1===o?f={get:c.get,set:c.set}:2===o?f=c.value:3===o?f=c.get:4===o&&(f=c.set),"function"==typeof h)void 0!==(p=old_memberDec(h,r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?d=p:1===o?(d=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p);else for(var m=h.length-1;m>=0;m--){var b;void 0!==(p=old_memberDec(h[m],r,c,l,s,o,i,n,f))&&(old_assertValidReturnValue(o,p),0===o?b=p:1===o?(b=old_getInit(p),v=p.get||f.get,y=p.set||f.set,f={get:v,set:y}):f=p,void 0!==b&&(void 0===d?d=b:"function"==typeof d?d=[d,b]:d.push(b)))}if(0===o||1===o){if(void 0===d)d=function(e,t){return t};else if("function"!=typeof d){var g=d;d=function(e,t){for(var a=t,r=0;r<g.length;r++)a=g[r].call(e,a);return a}}else{var _=d;d=function(e,t){return _.call(e,t)}}e.push(d)}0!==o&&(1===o?(c.get=f.get,c.set=f.set):2===o?c.value=f:3===o?c.get=f:4===o&&(c.set=f),n?1===o?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===o?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,r,c))}function old_applyMemberDecs(e,t,a,r,o){for(var i,n,l=new Map,s=new Map,c=0;c<o.length;c++){var d=o[c];if(Array.isArray(d)){var u,f,p,v=d[1],y=d[2],h=d.length>3,m=v>=5;if(m?(u=t,f=r,0!=(v-=5)&&(p=n=n||[])):(u=t.prototype,f=a,0!==v&&(p=i=i||[])),0!==v&&!h){var b=m?s:l,g=b.get(y)||0;if(!0===g||3===g&&4!==v||4===g&&3!==v)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+y);!g&&v>2?b.set(y,v):b.set(y,!0)}old_applyMemberDec(e,u,d,y,v,m,h,f,p)}}old_pushInitializers(e,i),old_pushInitializers(e,n)}function old_pushInitializers(e,t){t&&e.push((function(e){for(var a=0;a<t.length;a++)t[a].call(e);return e}))}function old_applyClassDecs(e,t,a,r){if(r.length>0){for(var o=[],i=t,n=t.name,l=r.length-1;l>=0;l--){var s={v:!1};try{var c=Object.assign({kind:"class",name:n,addInitializer:old_createAddInitializerMethod(o,s)},old_createMetadataMethodsForProperty(a,0,n,s)),d=r[l](i,c)}finally{s.v=!0}void 0!==d&&(old_assertValidReturnValue(10,d),i=d)}e.push(i,(function(){for(var e=0;e<o.length;e++)o[e].call(i)}))}}function applyDecs(e,t,a){var r=[],o={},i={};return old_applyMemberDecs(r,e,i,o,t),old_convertMetadataMapToFinal(e.prototype,i),old_applyClassDecs(r,e,o,a),old_convertMetadataMapToFinal(e,o),r}', {
          globals: ["Object", "Map", "Symbol", "Array", "Error", "TypeError", "console"],
          locals: {
            old_createMetadataMethodsForProperty: ["body.0.id", "body.3.body.body.4.block.body.0.argument.arguments.1.arguments.1.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.1.callee"],
            old_convertMetadataMapToFinal: ["body.1.id", "body.13.body.body.1.argument.expressions.1.callee", "body.13.body.body.1.argument.expressions.3.callee"],
            old_createAddInitializerMethod: ["body.2.id", "body.3.body.body.3.test.expressions.0.right.right.callee", "body.12.body.body.0.consequent.body.0.body.body.1.block.body.0.declarations.0.init.arguments.0.properties.2.value.callee"],
            old_memberDec: ["body.3.id", "body.9.body.body.1.consequent.expression.left.right.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.left.right.right.callee"],
            old_assertNotFinished: ["body.4.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.0.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.0.callee", "body.2.body.body.0.argument.body.body.0.expression.expressions.0.callee"],
            old_assertMetadataKey: ["body.5.id", "body.0.body.body.0.argument.properties.0.value.body.body.0.expression.expressions.1.callee", "body.0.body.body.0.argument.properties.1.value.body.body.0.expression.expressions.1.callee"],
            old_assertCallable: ["body.6.id", "body.2.body.body.0.argument.body.body.0.expression.expressions.1.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.0.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.1.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.2.right.callee", "body.7.body.body.1.consequent.body.1.expression.expressions.3.right.callee"],
            old_assertValidReturnValue: ["body.7.id", "body.9.body.body.1.consequent.expression.right.expressions.0.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.0.callee", "body.12.body.body.0.consequent.body.0.body.body.2.expression.right.expressions.0.callee"],
            old_getInit: ["body.8.id", "body.9.body.body.1.consequent.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee", "body.9.body.body.1.alternate.body.body.1.expression.right.expressions.1.alternate.consequent.expressions.0.right.callee"],
            old_applyMemberDec: ["body.9.id", "body.10.body.body.0.body.body.1.consequent.body.2.expression.callee"],
            old_applyMemberDecs: ["body.10.id", "body.13.body.body.1.argument.expressions.0.callee"],
            old_pushInitializers: ["body.11.id", "body.10.body.body.1.expression.expressions.0.callee", "body.10.body.body.1.expression.expressions.1.callee"],
            old_applyClassDecs: ["body.12.id", "body.13.body.body.1.argument.expressions.2.callee"],
            applyDecs: ["body.13.id"]
          },
          exportBindingAssignments: [],
          exportName: "applyDecs",
          dependencies: {
            setFunctionName: ["body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.9.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
            toPropertyKey: ["body.3.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
          }
        }),
        applyDecs2203: helper("7.19.0", 'function applyDecs2203Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,a,n,i,s,o){var c;switch(n){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:s?"#"+t:t,static:i,private:s},p={v:!1};0!==n&&(f.addInitializer=createAddInitializerMethod(a,p)),0===n?s?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===n?l=function(){return r.value}:(1!==n&&3!==n||(l=function(){return r.get.call(this)}),1!==n&&4!==n||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(o,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,a,n,i,s,o){var c,l,u,f,p,d,h=r[0];if(s?c=0===n||1===n?{get:r[3],set:r[4]}:3===n?{get:r[3]}:4===n?{set:r[3]}:{value:r[3]}:0!==n&&(c=Object.getOwnPropertyDescriptor(t,a)),1===n?u={get:c.get,set:c.set}:2===n?u=c.value:3===n?u=c.get:4===n&&(u=c.set),"function"==typeof h)void 0!==(f=memberDec(h,a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?l=f:1===n?(l=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f);else for(var v=h.length-1;v>=0;v--){var g;void 0!==(f=memberDec(h[v],a,c,o,n,i,s,u))&&(assertValidReturnValue(n,f),0===n?g=f:1===n?(g=f.init,p=f.get||u.get,d=f.set||u.set,u={get:p,set:d}):u=f,void 0!==g&&(void 0===l?l=g:"function"==typeof l?l=[l,g]:l.push(g)))}if(0===n||1===n){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var y=l;l=function(e,t){for(var r=t,a=0;a<y.length;a++)r=y[a].call(e,r);return r}}else{var m=l;l=function(e,t){return m.call(e,t)}}e.push(l)}0!==n&&(1===n?(c.get=u.get,c.set=u.set):2===n?c.value=u:3===n?c.get=u:4===n&&(c.set=u),s?1===n?(e.push((function(e,t){return u.get.call(e,t)})),e.push((function(e,t){return u.set.call(e,t)}))):2===n?e.push(u):e.push((function(e,t){return u.call(e,t)})):Object.defineProperty(t,a,c))}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){var a=[];return function(e,t,r){for(var a,n,i=new Map,s=new Map,o=0;o<r.length;o++){var c=r[o];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=t,0!=(f-=5)&&(u=n=n||[])):(l=t.prototype,0!==f&&(u=a=a||[])),0!==f&&!d){var v=h?s:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(e,l,c,p,f,h,d,u)}}pushInitializers(e,a),pushInitializers(e,n)}(a,e,t),function(e,t,r){if(r.length>0){for(var a=[],n=t,i=t.name,s=r.length-1;s>=0;s--){var o={v:!1};try{var c=r[s](n,{kind:"class",name:i,addInitializer:createAddInitializerMethod(a,o)})}finally{o.v=!0}void 0!==c&&(assertValidReturnValue(10,c),n=c)}e.push(n,(function(){for(var e=0;e<a.length;e++)a[e].call(n)}))}}(a,e,r),a}}var applyDecs2203Impl;function applyDecs2203(e,t,r){return(applyDecs2203Impl=applyDecs2203Impl||applyDecs2203Factory())(e,t,r)}', {
          globals: ["Error", "TypeError", "Object", "Map", "Array"],
          locals: {
            applyDecs2203Factory: ["body.0.id", "body.2.body.body.0.argument.callee.right.right.callee"],
            applyDecs2203Impl: ["body.1.declarations.0.id", "body.2.body.body.0.argument.callee.right.left", "body.2.body.body.0.argument.callee.left"],
            applyDecs2203: ["body.2.id"]
          },
          exportBindingAssignments: [],
          exportName: "applyDecs2203",
          dependencies: {}
        }),
        applyDecs2203R: helper("7.20.0", 'function applyDecs2203RFactory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function memberDec(e,t,r,n,a,i,o,s){var c;switch(a){case 1:c="accessor";break;case 2:c="method";break;case 3:c="getter";break;case 4:c="setter";break;default:c="field"}var l,u,f={kind:c,name:o?"#"+t:toPropertyKey(t),static:i,private:o},p={v:!1};0!==a&&(f.addInitializer=createAddInitializerMethod(n,p)),0===a?o?(l=r.get,u=r.set):(l=function(){return this[t]},u=function(e){this[t]=e}):2===a?l=function(){return r.value}:(1!==a&&3!==a||(l=function(){return r.get.call(this)}),1!==a&&4!==a||(u=function(e){r.set.call(this,e)})),f.access=l&&u?{get:l,set:u}:l?{get:l}:{set:u};try{return e(s,f)}finally{p.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function applyMemberDec(e,t,r,n,a,i,o,s){var c,l,u,f,p,d,h,v=r[0];if(o?(0===a||1===a?(c={get:r[3],set:r[4]},u="get"):3===a?(c={get:r[3]},u="get"):4===a?(c={set:r[3]},u="set"):c={value:r[3]},0!==a&&(1===a&&setFunctionName(r[4],"#"+n,"set"),setFunctionName(r[3],"#"+n,u))):0!==a&&(c=Object.getOwnPropertyDescriptor(t,n)),1===a?f={get:c.get,set:c.set}:2===a?f=c.value:3===a?f=c.get:4===a&&(f=c.set),"function"==typeof v)void 0!==(p=memberDec(v,n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?l=p:1===a?(l=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p);else for(var g=v.length-1;g>=0;g--){var y;void 0!==(p=memberDec(v[g],n,c,s,a,i,o,f))&&(assertValidReturnValue(a,p),0===a?y=p:1===a?(y=p.init,d=p.get||f.get,h=p.set||f.set,f={get:d,set:h}):f=p,void 0!==y&&(void 0===l?l=y:"function"==typeof l?l=[l,y]:l.push(y)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var m=l;l=function(e,t){for(var r=t,n=0;n<m.length;n++)r=m[n].call(e,r);return r}}else{var b=l;l=function(e,t){return b.call(e,t)}}e.push(l)}0!==a&&(1===a?(c.get=f.get,c.set=f.set):2===a?c.value=f:3===a?c.get=f:4===a&&(c.set=f),o?1===a?(e.push((function(e,t){return f.get.call(e,t)})),e.push((function(e,t){return f.set.call(e,t)}))):2===a?e.push(f):e.push((function(e,t){return f.call(e,t)})):Object.defineProperty(t,n,c))}function applyMemberDecs(e,t){for(var r,n,a=[],i=new Map,o=new Map,s=0;s<t.length;s++){var c=t[s];if(Array.isArray(c)){var l,u,f=c[1],p=c[2],d=c.length>3,h=f>=5;if(h?(l=e,0!=(f-=5)&&(u=n=n||[])):(l=e.prototype,0!==f&&(u=r=r||[])),0!==f&&!d){var v=h?o:i,g=v.get(p)||0;if(!0===g||3===g&&4!==f||4===g&&3!==f)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+p);!g&&f>2?v.set(p,f):v.set(p,!0)}applyMemberDec(a,l,c,p,f,h,d,u)}}return pushInitializers(a,r),pushInitializers(a,n),a}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r){return{e:applyMemberDecs(e,t),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var o={v:!1};try{var s=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,o)})}finally{o.v=!0}void 0!==s&&(assertValidReturnValue(10,s),n=s)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2203R(e,t,r){return(applyDecs2203R=applyDecs2203RFactory())(e,t,r)}', {
          globals: ["Error", "TypeError", "Object", "Map", "Array"],
          locals: {
            applyDecs2203RFactory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
            applyDecs2203R: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
          },
          exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
          exportName: "applyDecs2203R",
          dependencies: {
            setFunctionName: ["body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.4.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
            toPropertyKey: ["body.0.body.body.1.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
          }
        }),
        applyDecs2301: helper("7.21.0", 'function applyDecs2301Factory(){function createAddInitializerMethod(e,t){return function(r){!function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished")}(t),assertCallable(r,"An initializer"),e.push(r)}}function assertInstanceIfPrivate(e,t){if(!e(t))throw new TypeError("Attempted to access private element on non-instance")}function memberDec(e,t,r,n,a,i,s,o,c){var u;switch(a){case 1:u="accessor";break;case 2:u="method";break;case 3:u="getter";break;case 4:u="setter";break;default:u="field"}var l,f,p={kind:u,name:s?"#"+t:toPropertyKey(t),static:i,private:s},d={v:!1};if(0!==a&&(p.addInitializer=createAddInitializerMethod(n,d)),s||0!==a&&2!==a)if(2===a)l=function(e){return assertInstanceIfPrivate(c,e),r.value};else{var h=0===a||1===a;(h||3===a)&&(l=s?function(e){return assertInstanceIfPrivate(c,e),r.get.call(e)}:function(e){return r.get.call(e)}),(h||4===a)&&(f=s?function(e,t){assertInstanceIfPrivate(c,e),r.set.call(e,t)}:function(e,t){r.set.call(e,t)})}else l=function(e){return e[t]},0===a&&(f=function(e,r){e[t]=r});var v=s?c.bind():function(e){return t in e};p.access=l&&f?{get:l,set:f,has:v}:l?{get:l,has:v}:{set:f,has:v};try{return e(o,p)}finally{d.v=!0}}function assertCallable(e,t){if("function"!=typeof e)throw new TypeError(t+" must be a function")}function assertValidReturnValue(e,t){var r=typeof t;if(1===e){if("object"!==r||null===t)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");void 0!==t.get&&assertCallable(t.get,"accessor.get"),void 0!==t.set&&assertCallable(t.set,"accessor.set"),void 0!==t.init&&assertCallable(t.init,"accessor.init")}else if("function"!==r)throw new TypeError((0===e?"field":10===e?"class":"method")+" decorators must return a function or void 0")}function curryThis2(e){return function(t){e(this,t)}}function applyMemberDec(e,t,r,n,a,i,s,o,c){var u,l,f,p,d,h,v,y,g=r[0];if(s?(0===a||1===a?(u={get:(d=r[3],function(){return d(this)}),set:curryThis2(r[4])},f="get"):3===a?(u={get:r[3]},f="get"):4===a?(u={set:r[3]},f="set"):u={value:r[3]},0!==a&&(1===a&&setFunctionName(u.set,"#"+n,"set"),setFunctionName(u[f||"value"],"#"+n,f))):0!==a&&(u=Object.getOwnPropertyDescriptor(t,n)),1===a?p={get:u.get,set:u.set}:2===a?p=u.value:3===a?p=u.get:4===a&&(p=u.set),"function"==typeof g)void 0!==(h=memberDec(g,n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?l=h:1===a?(l=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h);else for(var m=g.length-1;m>=0;m--){var b;void 0!==(h=memberDec(g[m],n,u,o,a,i,s,p,c))&&(assertValidReturnValue(a,h),0===a?b=h:1===a?(b=h.init,v=h.get||p.get,y=h.set||p.set,p={get:v,set:y}):p=h,void 0!==b&&(void 0===l?l=b:"function"==typeof l?l=[l,b]:l.push(b)))}if(0===a||1===a){if(void 0===l)l=function(e,t){return t};else if("function"!=typeof l){var I=l;l=function(e,t){for(var r=t,n=0;n<I.length;n++)r=I[n].call(e,r);return r}}else{var w=l;l=function(e,t){return w.call(e,t)}}e.push(l)}0!==a&&(1===a?(u.get=p.get,u.set=p.set):2===a?u.value=p:3===a?u.get=p:4===a&&(u.set=p),s?1===a?(e.push((function(e,t){return p.get.call(e,t)})),e.push((function(e,t){return p.set.call(e,t)}))):2===a?e.push(p):e.push((function(e,t){return p.call(e,t)})):Object.defineProperty(t,n,u))}function applyMemberDecs(e,t,r){for(var n,a,i,s=[],o=new Map,c=new Map,u=0;u<t.length;u++){var l=t[u];if(Array.isArray(l)){var f,p,d=l[1],h=l[2],v=l.length>3,y=d>=5,g=r;if(y?(f=e,0!=(d-=5)&&(p=a=a||[]),v&&!i&&(i=function(t){return checkInRHS(t)===e}),g=i):(f=e.prototype,0!==d&&(p=n=n||[])),0!==d&&!v){var m=y?c:o,b=m.get(h)||0;if(!0===b||3===b&&4!==d||4===b&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);!b&&d>2?m.set(h,d):m.set(h,!0)}applyMemberDec(s,f,l,h,d,y,v,p,g)}}return pushInitializers(s,n),pushInitializers(s,a),s}function pushInitializers(e,t){t&&e.push((function(e){for(var r=0;r<t.length;r++)t[r].call(e);return e}))}return function(e,t,r,n){return{e:applyMemberDecs(e,t,n),get c(){return function(e,t){if(t.length>0){for(var r=[],n=e,a=e.name,i=t.length-1;i>=0;i--){var s={v:!1};try{var o=t[i](n,{kind:"class",name:a,addInitializer:createAddInitializerMethod(r,s)})}finally{s.v=!0}void 0!==o&&(assertValidReturnValue(10,o),n=o)}return[n,function(){for(var e=0;e<r.length;e++)r[e].call(n)}]}}(e,r)}}}}function applyDecs2301(e,t,r,n){return(applyDecs2301=applyDecs2301Factory())(e,t,r,n)}', {
          globals: ["Error", "TypeError", "Object", "Map", "Array"],
          locals: {
            applyDecs2301Factory: ["body.0.id", "body.1.body.body.0.argument.callee.right.callee"],
            applyDecs2301: ["body.1.id", "body.1.body.body.0.argument.callee.left"]
          },
          exportBindingAssignments: ["body.1.body.body.0.argument.callee"],
          exportName: "applyDecs2301",
          dependencies: {
            checkInRHS: ["body.0.body.body.7.body.body.0.body.body.1.consequent.body.1.test.expressions.0.consequent.expressions.2.right.right.body.body.0.argument.left.callee"],
            setFunctionName: ["body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.0.right.callee", "body.0.body.body.6.body.body.1.test.expressions.0.consequent.expressions.1.right.expressions.1.callee"],
            toPropertyKey: ["body.0.body.body.2.body.body.2.declarations.2.init.properties.1.value.alternate.callee"]
          }
        }),
        applyDecs2305: helper("7.21.0", 'function applyDecs2305(e,t,r,n,o,a){function i(e,t,r){return function(n,o){return r&&r(n),e[t].call(n,o)}}function c(e,t){for(var r=0;r<e.length;r++)e[r].call(t);return t}function s(e,t,r,n){if("function"!=typeof e&&(n||void 0!==e))throw new TypeError(t+" must "+(r||"be")+" a function"+(n?"":" or undefined"));return e}function applyDec(e,t,r,n,o,a,c,u,l,f,p,d,h){function m(e){if(!h(e))throw new TypeError("Attempted to access private element on non-instance")}var y,v=t[0],g=t[3],b=!u;if(!b){r||Array.isArray(v)||(v=[v]);var w={},S=[],A=3===o?"get":4===o||d?"set":"value";f?(p||d?w={get:setFunctionName((function(){return g(this)}),n,"get"),set:function(e){t[4](this,e)}}:w[A]=g,p||setFunctionName(w[A],n,2===o?"":A)):p||(w=Object.getOwnPropertyDescriptor(e,n))}for(var P=e,j=v.length-1;j>=0;j-=r?2:1){var D=v[j],E=r?v[j-1]:void 0,I={},O={kind:["field","accessor","method","getter","setter","class"][o],name:n,metadata:a,addInitializer:function(e,t){if(e.v)throw Error("attempted to call addInitializer after decoration was finished");s(t,"An initializer","be",!0),c.push(t)}.bind(null,I)};try{if(b)(y=s(D.call(E,P,O),"class decorators","return"))&&(P=y);else{var k,F;O.static=l,O.private=f,f?2===o?k=function(e){return m(e),w.value}:(o<4&&(k=i(w,"get",m)),3!==o&&(F=i(w,"set",m))):(k=function(e){return e[n]},(o<2||4===o)&&(F=function(e,t){e[n]=t}));var N=O.access={has:f?h.bind():function(e){return n in e}};if(k&&(N.get=k),F&&(N.set=F),P=D.call(E,d?{get:w.get,set:w.set}:w[A],O),d){if("object"==typeof P&&P)(y=s(P.get,"accessor.get"))&&(w.get=y),(y=s(P.set,"accessor.set"))&&(w.set=y),(y=s(P.init,"accessor.init"))&&S.push(y);else if(void 0!==P)throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0")}else s(P,(p?"field":"method")+" decorators","return")&&(p?S.push(P):w[A]=P)}}finally{I.v=!0}}return(p||d)&&u.push((function(e,t){for(var r=S.length-1;r>=0;r--)t=S[r].call(e,t);return t})),p||b||(f?d?u.push(i(w,"get"),i(w,"set")):u.push(2===o?w[A]:i.call.bind(w[A])):Object.defineProperty(e,n,w)),P}function u(e,t){return Object.defineProperty(e,Symbol.metadata||Symbol.for("Symbol.metadata"),{configurable:!0,enumerable:!0,value:t})}if(arguments.length>=6)var l=a[Symbol.metadata||Symbol.for("Symbol.metadata")];var f=Object.create(null==l?null:l),p=function(e,t,r,n){var o,a,i=[],s=function(t){return checkInRHS(t)===e},u=new Map;function l(e){e&&i.push(c.bind(null,e))}for(var f=0;f<t.length;f++){var p=t[f];if(Array.isArray(p)){var d=p[1],h=p[2],m=p.length>3,y=16&d,v=!!(8&d),g=0==(d&=7),b=h+"/"+v;if(!g&&!m){var w=u.get(b);if(!0===w||3===w&&4!==d||4===w&&3!==d)throw Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: "+h);u.set(b,!(d>2)||d)}applyDec(v?e:e.prototype,p,y,m?"#"+h:toPropertyKey(h),d,n,v?a=a||[]:o=o||[],i,v,m,g,1===d,v&&m?s:r)}}return l(o),l(a),i}(e,t,o,f);return r.length||u(e,f),{e:p,get c(){var t=[];return r.length&&[u(applyDec(e,[r],n,e.name,5,f,t),f),c.bind(null,t,e)]}}}', {
          globals: ["TypeError", "Array", "Object", "Error", "Symbol", "Map"],
          locals: {
            applyDecs2305: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "applyDecs2305",
          dependencies: {
            checkInRHS: ["body.0.body.body.6.declarations.1.init.callee.body.body.0.declarations.3.init.body.body.0.argument.left.callee"],
            setFunctionName: ["body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.0.consequent.right.properties.0.value.callee", "body.0.body.body.3.body.body.2.consequent.body.2.expression.consequent.expressions.1.right.callee"],
            toPropertyKey: ["body.0.body.body.6.declarations.1.init.callee.body.body.2.body.body.1.consequent.body.2.expression.arguments.3.alternate.callee"]
          }
        }),
        classApplyDescriptorDestructureSet: helper("7.13.10", 'function _classApplyDescriptorDestructureSet(e,t){if(t.set)return"__destrObj"in t||(t.__destrObj={set value(r){t.set.call(e,r)}}),t.__destrObj;if(!t.writable)throw new TypeError("attempted to set read only private field");return t}', {
          globals: ["TypeError"],
          locals: {
            _classApplyDescriptorDestructureSet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classApplyDescriptorDestructureSet",
          dependencies: {}
        }),
        classApplyDescriptorGet: helper("7.13.10", "function _classApplyDescriptorGet(e,t){return t.get?t.get.call(e):t.value}", {
          globals: [],
          locals: {
            _classApplyDescriptorGet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classApplyDescriptorGet",
          dependencies: {}
        }),
        classApplyDescriptorSet: helper("7.13.10", 'function _classApplyDescriptorSet(e,t,l){if(t.set)t.set.call(e,l);else{if(!t.writable)throw new TypeError("attempted to set read only private field");t.value=l}}', {
          globals: ["TypeError"],
          locals: {
            _classApplyDescriptorSet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classApplyDescriptorSet",
          dependencies: {}
        }),
        classCheckPrivateStaticAccess: helper("7.13.10", "function _classCheckPrivateStaticAccess(s,a,r){return assertClassBrand(a,s,r)}", {
          globals: [],
          locals: {
            _classCheckPrivateStaticAccess: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classCheckPrivateStaticAccess",
          dependencies: {
            assertClassBrand: ["body.0.body.body.0.argument.callee"]
          }
        }),
        classCheckPrivateStaticFieldDescriptor: helper("7.13.10", 'function _classCheckPrivateStaticFieldDescriptor(t,e){if(void 0===t)throw new TypeError("attempted to "+e+" private static field before its declaration")}', {
          globals: ["TypeError"],
          locals: {
            _classCheckPrivateStaticFieldDescriptor: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classCheckPrivateStaticFieldDescriptor",
          dependencies: {}
        }),
        classExtractFieldDescriptor: helper("7.13.10", "function _classExtractFieldDescriptor(e,t){return classPrivateFieldGet2(t,e)}", {
          globals: [],
          locals: {
            _classExtractFieldDescriptor: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classExtractFieldDescriptor",
          dependencies: {
            classPrivateFieldGet2: ["body.0.body.body.0.argument.callee"]
          }
        }),
        classPrivateFieldDestructureSet: helper("7.4.4", "function _classPrivateFieldDestructureSet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorDestructureSet(e,r)}", {
          globals: [],
          locals: {
            _classPrivateFieldDestructureSet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classPrivateFieldDestructureSet",
          dependencies: {
            classApplyDescriptorDestructureSet: ["body.0.body.body.1.argument.callee"],
            classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
          }
        }),
        classPrivateFieldGet: helper("7.0.0-beta.0", "function _classPrivateFieldGet(e,t){var r=classPrivateFieldGet2(t,e);return classApplyDescriptorGet(e,r)}", {
          globals: [],
          locals: {
            _classPrivateFieldGet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classPrivateFieldGet",
          dependencies: {
            classApplyDescriptorGet: ["body.0.body.body.1.argument.callee"],
            classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
          }
        }),
        classPrivateFieldSet: helper("7.0.0-beta.0", "function _classPrivateFieldSet(e,t,r){var s=classPrivateFieldGet2(t,e);return classApplyDescriptorSet(e,s,r),r}", {
          globals: [],
          locals: {
            _classPrivateFieldSet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classPrivateFieldSet",
          dependencies: {
            classApplyDescriptorSet: ["body.0.body.body.1.argument.expressions.0.callee"],
            classPrivateFieldGet2: ["body.0.body.body.0.declarations.0.init.callee"]
          }
        }),
        classPrivateMethodGet: helper("7.1.6", "function _classPrivateMethodGet(s,a,r){return assertClassBrand(a,s),r}", {
          globals: [],
          locals: {
            _classPrivateMethodGet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classPrivateMethodGet",
          dependencies: {
            assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"]
          }
        }),
        classPrivateMethodSet: helper("7.1.6", 'function _classPrivateMethodSet(){throw new TypeError("attempted to reassign private method")}', {
          globals: ["TypeError"],
          locals: {
            _classPrivateMethodSet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classPrivateMethodSet",
          dependencies: {}
        }),
        classStaticPrivateFieldDestructureSet: helper("7.13.10", 'function _classStaticPrivateFieldDestructureSet(t,r,s){return assertClassBrand(r,t),classCheckPrivateStaticFieldDescriptor(s,"set"),classApplyDescriptorDestructureSet(t,s)}', {
          globals: [],
          locals: {
            _classStaticPrivateFieldDestructureSet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classStaticPrivateFieldDestructureSet",
          dependencies: {
            classApplyDescriptorDestructureSet: ["body.0.body.body.0.argument.expressions.2.callee"],
            assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
            classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
          }
        }),
        classStaticPrivateFieldSpecGet: helper("7.0.2", 'function _classStaticPrivateFieldSpecGet(t,s,r){return assertClassBrand(s,t),classCheckPrivateStaticFieldDescriptor(r,"get"),classApplyDescriptorGet(t,r)}', {
          globals: [],
          locals: {
            _classStaticPrivateFieldSpecGet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classStaticPrivateFieldSpecGet",
          dependencies: {
            classApplyDescriptorGet: ["body.0.body.body.0.argument.expressions.2.callee"],
            assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
            classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
          }
        }),
        classStaticPrivateFieldSpecSet: helper("7.0.2", 'function _classStaticPrivateFieldSpecSet(s,t,r,e){return assertClassBrand(t,s),classCheckPrivateStaticFieldDescriptor(r,"set"),classApplyDescriptorSet(s,r,e),e}', {
          globals: [],
          locals: {
            _classStaticPrivateFieldSpecSet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classStaticPrivateFieldSpecSet",
          dependencies: {
            classApplyDescriptorSet: ["body.0.body.body.0.argument.expressions.2.callee"],
            assertClassBrand: ["body.0.body.body.0.argument.expressions.0.callee"],
            classCheckPrivateStaticFieldDescriptor: ["body.0.body.body.0.argument.expressions.1.callee"]
          }
        }),
        classStaticPrivateMethodSet: helper("7.3.2", 'function _classStaticPrivateMethodSet(){throw new TypeError("attempted to set read only static private field")}', {
          globals: ["TypeError"],
          locals: {
            _classStaticPrivateMethodSet: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_classStaticPrivateMethodSet",
          dependencies: {}
        }),
        defineEnumerableProperties: helper("7.0.0-beta.0", 'function _defineEnumerableProperties(e,r){for(var t in r){var n=r[t];n.configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,t,n)}if(Object.getOwnPropertySymbols)for(var a=Object.getOwnPropertySymbols(r),b=0;b<a.length;b++){var i=a[b];(n=r[i]).configurable=n.enumerable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,i,n)}return e}', {
          globals: ["Object"],
          locals: {
            _defineEnumerableProperties: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_defineEnumerableProperties",
          dependencies: {}
        }),
        dispose: helper("7.22.0", 'function dispose_SuppressedError(r,e){return"undefined"!=typeof SuppressedError?dispose_SuppressedError=SuppressedError:(dispose_SuppressedError=function(r,e){this.suppressed=e,this.error=r,this.stack=Error().stack},dispose_SuppressedError.prototype=Object.create(Error.prototype,{constructor:{value:dispose_SuppressedError,writable:!0,configurable:!0}})),new dispose_SuppressedError(r,e)}function _dispose(r,e,s){function next(){for(;r.length>0;)try{var o=r.pop(),p=o.d.call(o.v);if(o.a)return Promise.resolve(p).then(next,err)}catch(r){return err(r)}if(s)throw e}function err(r){return e=s?new dispose_SuppressedError(e,r):r,s=!0,next()}return next()}', {
          globals: ["SuppressedError", "Error", "Object", "Promise"],
          locals: {
            dispose_SuppressedError: ["body.0.id", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.left.object", "body.0.body.body.0.argument.expressions.0.alternate.expressions.1.right.arguments.1.properties.0.value.properties.0.value", "body.0.body.body.0.argument.expressions.1.callee", "body.1.body.body.1.body.body.0.argument.expressions.0.right.consequent.callee", "body.0.body.body.0.argument.expressions.0.consequent.left", "body.0.body.body.0.argument.expressions.0.alternate.expressions.0.left"],
            _dispose: ["body.1.id"]
          },
          exportBindingAssignments: [],
          exportName: "_dispose",
          dependencies: {}
        }),
        objectSpread: helper("7.0.0-beta.0", 'function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?Object(arguments[r]):{},o=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&o.push.apply(o,Object.getOwnPropertySymbols(t).filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.forEach((function(r){defineProperty(e,r,t[r])}))}return e}', {
          globals: ["Object"],
          locals: {
            _objectSpread: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_objectSpread",
          dependencies: {
            defineProperty: ["body.0.body.body.0.body.body.1.expression.expressions.1.arguments.0.body.body.0.expression.callee"]
          }
        }),
        using: helper("7.22.0", 'function _using(o,n,e){if(null==n)return n;if(Object(n)!==n)throw new TypeError("using declarations can only be used with objects, functions, null, or undefined.");if(e)var r=n[Symbol.asyncDispose||Symbol.for("Symbol.asyncDispose")];if(null==r&&(r=n[Symbol.dispose||Symbol.for("Symbol.dispose")]),"function"!=typeof r)throw new TypeError("Property [Symbol.dispose] is not a function.");return o.push({v:n,d:r,a:e}),n}', {
          globals: ["Object", "TypeError", "Symbol"],
          locals: {
            _using: ["body.0.id"]
          },
          exportBindingAssignments: [],
          exportName: "_using",
          dependencies: {}
        })
      });
    }
  }
});

// node_modules/@babel/helpers/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/@babel/helpers/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    exports2.get = get;
    exports2.getDependencies = getDependencies;
    exports2.list = void 0;
    exports2.minVersion = minVersion;
    var _t = require_lib3();
    var _helpersGenerated = require_helpers_generated();
    var {
      cloneNode,
      identifier
    } = _t;
    function deep2(obj, path9, value2) {
      try {
        const parts = path9.split(".");
        let last = parts.shift();
        while (parts.length > 0) {
          obj = obj[last];
          last = parts.shift();
        }
        if (arguments.length > 2) {
          obj[last] = value2;
        } else {
          return obj[last];
        }
      } catch (e) {
        e.message += ` (when accessing ${path9})`;
        throw e;
      }
    }
    function permuteHelperAST(ast, metadata, bindingName, localBindings, getDependency, adjustAst) {
      const {
        locals,
        dependencies,
        exportBindingAssignments,
        exportName
      } = metadata;
      const bindings = new Set(localBindings || []);
      if (bindingName) bindings.add(bindingName);
      for (const [name2, paths] of (Object.entries || ((o) => Object.keys(o).map((k) => [k, o[k]])))(locals)) {
        let newName = name2;
        if (bindingName && name2 === exportName) {
          newName = bindingName;
        } else {
          while (bindings.has(newName)) newName = "_" + newName;
        }
        if (newName !== name2) {
          for (const path9 of paths) {
            deep2(ast, path9, identifier(newName));
          }
        }
      }
      for (const [name2, paths] of (Object.entries || ((o) => Object.keys(o).map((k) => [k, o[k]])))(dependencies)) {
        const ref = typeof getDependency === "function" && getDependency(name2) || identifier(name2);
        for (const path9 of paths) {
          deep2(ast, path9, cloneNode(ref));
        }
      }
      adjustAst == null || adjustAst(ast, exportName, (map) => {
        exportBindingAssignments.forEach((p) => deep2(ast, p, map(deep2(ast, p))));
      });
    }
    var helperData = /* @__PURE__ */ Object.create(null);
    function loadHelper(name2) {
      if (!helperData[name2]) {
        const helper = _helpersGenerated.default[name2];
        if (!helper) {
          throw Object.assign(new ReferenceError(`Unknown helper ${name2}`), {
            code: "BABEL_HELPER_UNKNOWN",
            helper: name2
          });
        }
        helperData[name2] = {
          minVersion: helper.minVersion,
          build(getDependency, bindingName, localBindings, adjustAst) {
            const ast = helper.ast();
            permuteHelperAST(ast, helper.metadata, bindingName, localBindings, getDependency, adjustAst);
            return {
              nodes: ast.body,
              globals: helper.metadata.globals
            };
          },
          getDependencies() {
            return Object.keys(helper.metadata.dependencies);
          }
        };
      }
      return helperData[name2];
    }
    function get(name2, getDependency, bindingName, localBindings, adjustAst) {
      {
        if (typeof bindingName === "object") {
          const id3 = bindingName;
          if ((id3 == null ? void 0 : id3.type) === "Identifier") {
            bindingName = id3.name;
          } else {
            bindingName = void 0;
          }
        }
      }
      return loadHelper(name2).build(getDependency, bindingName, localBindings, adjustAst);
    }
    function minVersion(name2) {
      return loadHelper(name2).minVersion;
    }
    function getDependencies(name2) {
      return loadHelper(name2).getDependencies();
    }
    {
      exports2.ensure = (name2) => {
        loadHelper(name2);
      };
    }
    var list2 = exports2.list = Object.keys(_helpersGenerated.default).map((name2) => name2.replace(/^_/, ""));
    var _default = exports2.default = get;
  }
});

// node_modules/@babel/traverse/lib/path/lib/virtual-types.js
var require_virtual_types = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/virtual-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Var = exports2.User = exports2.Statement = exports2.SpreadProperty = exports2.Scope = exports2.RestProperty = exports2.ReferencedMemberExpression = exports2.ReferencedIdentifier = exports2.Referenced = exports2.Pure = exports2.NumericLiteralTypeAnnotation = exports2.Generated = exports2.ForAwaitStatement = exports2.Flow = exports2.Expression = exports2.ExistentialTypeParam = exports2.BlockScoped = exports2.BindingIdentifier = void 0;
    var ReferencedIdentifier = exports2.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
    var ReferencedMemberExpression = exports2.ReferencedMemberExpression = ["MemberExpression"];
    var BindingIdentifier = exports2.BindingIdentifier = ["Identifier"];
    var Statement = exports2.Statement = ["Statement"];
    var Expression = exports2.Expression = ["Expression"];
    var Scope = exports2.Scope = ["Scopable", "Pattern"];
    var Referenced = exports2.Referenced = null;
    var BlockScoped = exports2.BlockScoped = null;
    var Var = exports2.Var = ["VariableDeclaration"];
    var User = exports2.User = null;
    var Generated = exports2.Generated = null;
    var Pure = exports2.Pure = null;
    var Flow = exports2.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
    var RestProperty = exports2.RestProperty = ["RestElement"];
    var SpreadProperty = exports2.SpreadProperty = ["RestElement"];
    var ExistentialTypeParam = exports2.ExistentialTypeParam = ["ExistsTypeAnnotation"];
    var NumericLiteralTypeAnnotation = exports2.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
    var ForAwaitStatement = exports2.ForAwaitStatement = ["ForOfStatement"];
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options2) {
      options2 = options2 || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse6(val);
      } else if (type === "number" && isFinite(val)) {
        return options2.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse6(str2) {
      str2 = String(str2);
      if (str2.length > 100) {
        return;
      }
      var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str2
      );
      if (!match2) {
        return;
      }
      var n = parseFloat(match2[1]);
      var type = (match2[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return Math.round(ms2 / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms2 / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms2 / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms2 / s) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d) {
        return plural(ms2, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms2, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms2, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms2, msAbs, s, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n, name2) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module) {
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy2;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace2) {
        let hash3 = 0;
        for (let i = 0; i < namespace2.length; i++) {
          hash3 = (hash3 << 5) - hash3 + namespace2.charCodeAt(i);
          hash3 |= 0;
        }
        return createDebug.colors[Math.abs(hash3) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace2) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug2(...args) {
          if (!debug2.enabled) {
            return;
          }
          const self2 = debug2;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index4 = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
            if (match2 === "%%") {
              return "%";
            }
            index4++;
            const formatter2 = createDebug.formatters[format2];
            if (typeof formatter2 === "function") {
              const val = args[index4];
              match2 = formatter2.call(self2, val);
              args.splice(index4, 1);
              index4--;
            }
            return match2;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug2.namespace = namespace2;
        debug2.useColors = createDebug.useColors();
        debug2.color = createDebug.selectColor(namespace2);
        debug2.extend = extend;
        debug2.destroy = createDebug.destroy;
        Object.defineProperty(debug2, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace2);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug2);
        }
        return debug2;
      }
      function extend(namespace2, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace2);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace2) => "-" + namespace2)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name2) {
        if (name2[name2.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name2)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name2)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy2() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index4 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index4++;
        if (match2 === "%c") {
          lastC = index4;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports2);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module) {
    var tty = __require("tty");
    var util3 = __require("util");
    exports2.init = init2;
    exports2.log = log2;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load2;
    exports2.useColors = useColors;
    exports2.destroy = util3.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = __require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util3.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug2.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module.exports = require_common()(exports2);
    var { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util3.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module.exports = require_browser();
    } else {
      module.exports = require_node3();
    }
  }
});

// node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js
var require_virtual_types_validator = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/virtual-types-validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isBindingIdentifier = isBindingIdentifier;
    exports2.isBlockScoped = isBlockScoped;
    exports2.isExpression = isExpression;
    exports2.isFlow = isFlow;
    exports2.isForAwaitStatement = isForAwaitStatement;
    exports2.isGenerated = isGenerated;
    exports2.isPure = isPure;
    exports2.isReferenced = isReferenced;
    exports2.isReferencedIdentifier = isReferencedIdentifier;
    exports2.isReferencedMemberExpression = isReferencedMemberExpression;
    exports2.isRestProperty = isRestProperty;
    exports2.isScope = isScope;
    exports2.isSpreadProperty = isSpreadProperty;
    exports2.isStatement = isStatement;
    exports2.isUser = isUser;
    exports2.isVar = isVar;
    var _t = require_lib3();
    var {
      isBinding,
      isBlockScoped: nodeIsBlockScoped,
      isExportDeclaration,
      isExpression: nodeIsExpression,
      isFlow: nodeIsFlow,
      isForStatement,
      isForXStatement,
      isIdentifier: isIdentifier2,
      isImportDeclaration,
      isImportSpecifier,
      isJSXIdentifier,
      isJSXMemberExpression,
      isMemberExpression,
      isRestElement: nodeIsRestElement,
      isReferenced: nodeIsReferenced,
      isScope: nodeIsScope,
      isStatement: nodeIsStatement,
      isVar: nodeIsVar,
      isVariableDeclaration,
      react,
      isForOfStatement
    } = _t;
    var {
      isCompatTag
    } = react;
    function isReferencedIdentifier(opts) {
      const {
        node: node3,
        parent
      } = this;
      if (!isIdentifier2(node3, opts) && !isJSXMemberExpression(parent, opts)) {
        if (isJSXIdentifier(node3, opts)) {
          if (isCompatTag(node3.name)) return false;
        } else {
          return false;
        }
      }
      return nodeIsReferenced(node3, parent, this.parentPath.parent);
    }
    function isReferencedMemberExpression() {
      const {
        node: node3,
        parent
      } = this;
      return isMemberExpression(node3) && nodeIsReferenced(node3, parent);
    }
    function isBindingIdentifier() {
      const {
        node: node3,
        parent
      } = this;
      const grandparent = this.parentPath.parent;
      return isIdentifier2(node3) && isBinding(node3, parent, grandparent);
    }
    function isStatement() {
      const {
        node: node3,
        parent
      } = this;
      if (nodeIsStatement(node3)) {
        if (isVariableDeclaration(node3)) {
          if (isForXStatement(parent, {
            left: node3
          })) return false;
          if (isForStatement(parent, {
            init: node3
          })) return false;
        }
        return true;
      } else {
        return false;
      }
    }
    function isExpression() {
      if (this.isIdentifier()) {
        return this.isReferencedIdentifier();
      } else {
        return nodeIsExpression(this.node);
      }
    }
    function isScope() {
      return nodeIsScope(this.node, this.parent);
    }
    function isReferenced() {
      return nodeIsReferenced(this.node, this.parent);
    }
    function isBlockScoped() {
      return nodeIsBlockScoped(this.node);
    }
    function isVar() {
      return nodeIsVar(this.node);
    }
    function isUser() {
      return this.node && !!this.node.loc;
    }
    function isGenerated() {
      return !this.isUser();
    }
    function isPure(constantsOnly) {
      return this.scope.isPure(this.node, constantsOnly);
    }
    function isFlow() {
      const {
        node: node3
      } = this;
      if (nodeIsFlow(node3)) {
        return true;
      } else if (isImportDeclaration(node3)) {
        return node3.importKind === "type" || node3.importKind === "typeof";
      } else if (isExportDeclaration(node3)) {
        return node3.exportKind === "type";
      } else if (isImportSpecifier(node3)) {
        return node3.importKind === "type" || node3.importKind === "typeof";
      } else {
        return false;
      }
    }
    function isRestProperty() {
      var _this$parentPath;
      return nodeIsRestElement(this.node) && ((_this$parentPath = this.parentPath) == null ? void 0 : _this$parentPath.isObjectPattern());
    }
    function isSpreadProperty() {
      var _this$parentPath2;
      return nodeIsRestElement(this.node) && ((_this$parentPath2 = this.parentPath) == null ? void 0 : _this$parentPath2.isObjectExpression());
    }
    function isForAwaitStatement() {
      return isForOfStatement(this.node, {
        await: true
      });
    }
    {
      exports2.isExistentialTypeParam = function isExistentialTypeParam() {
        throw new Error("`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7.");
      };
      exports2.isNumericLiteralTypeAnnotation = function isNumericLiteralTypeAnnotation() {
        throw new Error("`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7.");
      };
    }
  }
});

// node_modules/@babel/traverse/lib/visitors.js
var require_visitors = __commonJS({
  "node_modules/@babel/traverse/lib/visitors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.environmentVisitor = environmentVisitor;
    exports2.explode = explode$1;
    exports2.isExplodedVisitor = isExplodedVisitor;
    exports2.merge = merge3;
    exports2.verify = verify$1;
    var virtualTypes = require_virtual_types();
    var virtualTypesValidators = require_virtual_types_validator();
    var _t = require_lib3();
    var _context = require_context2();
    var {
      DEPRECATED_KEYS,
      DEPRECATED_ALIASES,
      FLIPPED_ALIAS_KEYS,
      TYPES,
      __internal__deprecationWarning: deprecationWarning
    } = _t;
    function isVirtualType(type) {
      return type in virtualTypes;
    }
    function isExplodedVisitor(visitor) {
      return visitor == null ? void 0 : visitor._exploded;
    }
    function explode$1(visitor) {
      if (isExplodedVisitor(visitor)) return visitor;
      visitor._exploded = true;
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        const parts = nodeType.split("|");
        if (parts.length === 1) continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const part of parts) {
          visitor[part] = fns;
        }
      }
      verify$1(visitor);
      delete visitor.__esModule;
      ensureEntranceObjects(visitor);
      ensureCallbackArrays(visitor);
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        if (!isVirtualType(nodeType)) continue;
        const fns = visitor[nodeType];
        for (const type of Object.keys(fns)) {
          fns[type] = wrapCheck(nodeType, fns[type]);
        }
        delete visitor[nodeType];
        const types3 = virtualTypes[nodeType];
        if (types3 !== null) {
          for (const type of types3) {
            if (visitor[type]) {
              mergePair(visitor[type], fns);
            } else {
              visitor[type] = fns;
            }
          }
        } else {
          mergePair(visitor, fns);
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        let aliases = FLIPPED_ALIAS_KEYS[nodeType];
        if (nodeType in DEPRECATED_KEYS) {
          const deprecatedKey = DEPRECATED_KEYS[nodeType];
          deprecationWarning(nodeType, deprecatedKey, "Visitor ");
          aliases = [deprecatedKey];
        } else if (nodeType in DEPRECATED_ALIASES) {
          const deprecatedAlias = DEPRECATED_ALIASES[nodeType];
          deprecationWarning(nodeType, deprecatedAlias, "Visitor ");
          aliases = FLIPPED_ALIAS_KEYS[deprecatedAlias];
        }
        if (!aliases) continue;
        const fns = visitor[nodeType];
        delete visitor[nodeType];
        for (const alias of aliases) {
          const existing = visitor[alias];
          if (existing) {
            mergePair(existing, fns);
          } else {
            visitor[alias] = Object.assign({}, fns);
          }
        }
      }
      for (const nodeType of Object.keys(visitor)) {
        if (shouldIgnoreKey(nodeType)) continue;
        ensureCallbackArrays(visitor[nodeType]);
      }
      return visitor;
    }
    function verify$1(visitor) {
      if (visitor._verified) return;
      if (typeof visitor === "function") {
        throw new Error("You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?");
      }
      for (const nodeType of Object.keys(visitor)) {
        if (nodeType === "enter" || nodeType === "exit") {
          validateVisitorMethods(nodeType, visitor[nodeType]);
        }
        if (shouldIgnoreKey(nodeType)) continue;
        if (!TYPES.includes(nodeType)) {
          throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type in @babel/traverse ${"7.26.9"}`);
        }
        const visitors = visitor[nodeType];
        if (typeof visitors === "object") {
          for (const visitorKey of Object.keys(visitors)) {
            if (visitorKey === "enter" || visitorKey === "exit") {
              validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);
            } else {
              throw new Error(`You passed \`traverse()\` a visitor object with the property ${nodeType} that has the invalid property ${visitorKey}`);
            }
          }
        }
      }
      visitor._verified = true;
    }
    function validateVisitorMethods(path9, val) {
      const fns = [].concat(val);
      for (const fn of fns) {
        if (typeof fn !== "function") {
          throw new TypeError(`Non-function found defined in ${path9} with type ${typeof fn}`);
        }
      }
    }
    function merge3(visitors, states = [], wrapper) {
      const mergedVisitor = {
        _verified: true,
        _exploded: true
      };
      {
        Object.defineProperty(mergedVisitor, "_exploded", {
          enumerable: false
        });
        Object.defineProperty(mergedVisitor, "_verified", {
          enumerable: false
        });
      }
      for (let i = 0; i < visitors.length; i++) {
        const visitor = explode$1(visitors[i]);
        const state = states[i];
        let topVisitor = visitor;
        if (state || wrapper) {
          topVisitor = wrapWithStateOrWrapper(topVisitor, state, wrapper);
        }
        mergePair(mergedVisitor, topVisitor);
        for (const key of Object.keys(visitor)) {
          if (shouldIgnoreKey(key)) continue;
          let typeVisitor = visitor[key];
          if (state || wrapper) {
            typeVisitor = wrapWithStateOrWrapper(typeVisitor, state, wrapper);
          }
          const nodeVisitor = mergedVisitor[key] || (mergedVisitor[key] = {});
          mergePair(nodeVisitor, typeVisitor);
        }
      }
      return mergedVisitor;
    }
    function wrapWithStateOrWrapper(oldVisitor, state, wrapper) {
      const newVisitor = {};
      for (const phase of ["enter", "exit"]) {
        let fns = oldVisitor[phase];
        if (!Array.isArray(fns)) continue;
        fns = fns.map(function(fn) {
          let newFn = fn;
          if (state) {
            newFn = function(path9) {
              fn.call(state, path9, state);
            };
          }
          if (wrapper) {
            newFn = wrapper(state == null ? void 0 : state.key, phase, newFn);
          }
          if (newFn !== fn) {
            newFn.toString = () => fn.toString();
          }
          return newFn;
        });
        newVisitor[phase] = fns;
      }
      return newVisitor;
    }
    function ensureEntranceObjects(obj) {
      for (const key of Object.keys(obj)) {
        if (shouldIgnoreKey(key)) continue;
        const fns = obj[key];
        if (typeof fns === "function") {
          obj[key] = {
            enter: fns
          };
        }
      }
    }
    function ensureCallbackArrays(obj) {
      if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];
      if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];
    }
    function wrapCheck(nodeType, fn) {
      const fnKey = `is${nodeType}`;
      const validator = virtualTypesValidators[fnKey];
      const newFn = function(path9) {
        if (validator.call(path9)) {
          return fn.apply(this, arguments);
        }
      };
      newFn.toString = () => fn.toString();
      return newFn;
    }
    function shouldIgnoreKey(key) {
      if (key[0] === "_") return true;
      if (key === "enter" || key === "exit" || key === "shouldSkip") return true;
      if (key === "denylist" || key === "noScope" || key === "skipKeys") {
        return true;
      }
      {
        if (key === "blacklist") {
          return true;
        }
      }
      return false;
    }
    function mergePair(dest, src3) {
      for (const phase of ["enter", "exit"]) {
        if (!src3[phase]) continue;
        dest[phase] = [].concat(dest[phase] || [], src3[phase]);
      }
    }
    var _environmentVisitor = {
      FunctionParent(path9) {
        if (path9.isArrowFunctionExpression()) return;
        path9.skip();
        if (path9.isMethod()) {
          if (!path9.requeueComputedKeyAndDecorators) {
            _context.requeueComputedKeyAndDecorators.call(path9);
          } else {
            path9.requeueComputedKeyAndDecorators();
          }
        }
      },
      Property(path9) {
        if (path9.isObjectProperty()) return;
        path9.skip();
        if (!path9.requeueComputedKeyAndDecorators) {
          _context.requeueComputedKeyAndDecorators.call(path9);
        } else {
          path9.requeueComputedKeyAndDecorators();
        }
      }
    };
    function environmentVisitor(visitor) {
      return merge3([_environmentVisitor, visitor]);
    }
  }
});

// node_modules/@babel/traverse/lib/scope/lib/renamer.js
var require_renamer = __commonJS({
  "node_modules/@babel/traverse/lib/scope/lib/renamer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var t = require_lib3();
    var _t = t;
    var _traverseNode = require_traverse_node();
    var _visitors = require_visitors();
    var _context = require_context2();
    var {
      getAssignmentIdentifiers
    } = _t;
    var renameVisitor = {
      ReferencedIdentifier({
        node: node3
      }, state) {
        if (node3.name === state.oldName) {
          node3.name = state.newName;
        }
      },
      Scope(path9, state) {
        if (!path9.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {
          path9.skip();
          if (path9.isMethod()) {
            if (!path9.requeueComputedKeyAndDecorators) {
              _context.requeueComputedKeyAndDecorators.call(path9);
            } else {
              path9.requeueComputedKeyAndDecorators();
            }
          }
        }
      },
      ObjectProperty({
        node: node3,
        scope
      }, state) {
        const {
          name: name2
        } = node3.key;
        if (node3.shorthand && (name2 === state.oldName || name2 === state.newName) && scope.getBindingIdentifier(name2) === state.binding.identifier) {
          node3.shorthand = false;
          {
            var _node$extra;
            if ((_node$extra = node3.extra) != null && _node$extra.shorthand) node3.extra.shorthand = false;
          }
        }
      },
      "AssignmentExpression|Declaration|VariableDeclarator"(path9, state) {
        if (path9.isVariableDeclaration()) return;
        const ids = path9.isAssignmentExpression() ? getAssignmentIdentifiers(path9.node) : path9.getOuterBindingIdentifiers();
        for (const name2 in ids) {
          if (name2 === state.oldName) ids[name2].name = state.newName;
        }
      }
    };
    var Renamer = class {
      constructor(binding, oldName, newName) {
        this.newName = newName;
        this.oldName = oldName;
        this.binding = binding;
      }
      maybeConvertFromExportDeclaration(parentDeclar) {
        const maybeExportDeclar = parentDeclar.parentPath;
        if (!maybeExportDeclar.isExportDeclaration()) {
          return;
        }
        if (maybeExportDeclar.isExportDefaultDeclaration()) {
          const {
            declaration
          } = maybeExportDeclar.node;
          if (t.isDeclaration(declaration) && !declaration.id) {
            return;
          }
        }
        if (maybeExportDeclar.isExportAllDeclaration()) {
          return;
        }
        maybeExportDeclar.splitExportDeclaration();
      }
      maybeConvertFromClassFunctionDeclaration(path9) {
        return path9;
      }
      maybeConvertFromClassFunctionExpression(path9) {
        return path9;
      }
      rename() {
        const {
          binding,
          oldName,
          newName
        } = this;
        const {
          scope,
          path: path9
        } = binding;
        const parentDeclar = path9.find((path10) => path10.isDeclaration() || path10.isFunctionExpression() || path10.isClassExpression());
        if (parentDeclar) {
          const bindingIds = parentDeclar.getOuterBindingIdentifiers();
          if (bindingIds[oldName] === binding.identifier) {
            this.maybeConvertFromExportDeclaration(parentDeclar);
          }
        }
        const blockToTraverse = arguments[0] || scope.block;
        const skipKeys = {
          discriminant: true
        };
        if (t.isMethod(blockToTraverse)) {
          if (blockToTraverse.computed) {
            skipKeys.key = true;
          }
          if (!t.isObjectMethod(blockToTraverse)) {
            skipKeys.decorators = true;
          }
        }
        (0, _traverseNode.traverseNode)(blockToTraverse, (0, _visitors.explode)(renameVisitor), scope, this, scope.path, skipKeys);
        if (!arguments[0]) {
          scope.removeOwnBinding(oldName);
          scope.bindings[newName] = binding;
          this.binding.identifier.name = newName;
        }
        if (parentDeclar) {
          this.maybeConvertFromClassFunctionDeclaration(path9);
          this.maybeConvertFromClassFunctionExpression(path9);
        }
      }
    };
    exports2.default = Renamer;
  }
});

// node_modules/@babel/traverse/lib/scope/binding.js
var require_binding = __commonJS({
  "node_modules/@babel/traverse/lib/scope/binding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Binding = class {
      constructor({
        identifier,
        scope,
        path: path9,
        kind
      }) {
        this.identifier = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.kind = void 0;
        this.constantViolations = [];
        this.constant = true;
        this.referencePaths = [];
        this.referenced = false;
        this.references = 0;
        this.identifier = identifier;
        this.scope = scope;
        this.path = path9;
        this.kind = kind;
        if ((kind === "var" || kind === "hoisted") && isDeclaredInLoop(path9)) {
          this.reassign(path9);
        }
        this.clearValue();
      }
      deoptValue() {
        this.clearValue();
        this.hasDeoptedValue = true;
      }
      setValue(value2) {
        if (this.hasDeoptedValue) return;
        this.hasValue = true;
        this.value = value2;
      }
      clearValue() {
        this.hasDeoptedValue = false;
        this.hasValue = false;
        this.value = null;
      }
      reassign(path9) {
        this.constant = false;
        if (this.constantViolations.includes(path9)) {
          return;
        }
        this.constantViolations.push(path9);
      }
      reference(path9) {
        if (this.referencePaths.includes(path9)) {
          return;
        }
        this.referenced = true;
        this.references++;
        this.referencePaths.push(path9);
      }
      dereference() {
        this.references--;
        this.referenced = !!this.references;
      }
    };
    exports2.default = Binding;
    function isDeclaredInLoop(path9) {
      for (let {
        parentPath,
        key
      } = path9; parentPath; {
        parentPath,
        key
      } = parentPath) {
        if (parentPath.isFunctionParent()) return false;
        if (parentPath.isWhile() || parentPath.isForXStatement() || parentPath.isForStatement() && key === "body") {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/globals/globals.json
var require_globals = __commonJS({
  "node_modules/globals/globals.json"(exports2, module) {
    module.exports = {
      builtin: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        BigInt: false,
        BigInt64Array: false,
        BigUint64Array: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        globalThis: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es5: {
        Array: false,
        Boolean: false,
        constructor: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        propertyIsEnumerable: false,
        RangeError: false,
        ReferenceError: false,
        RegExp: false,
        String: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false
      },
      es2015: {
        Array: false,
        ArrayBuffer: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      es2017: {
        Array: false,
        ArrayBuffer: false,
        Atomics: false,
        Boolean: false,
        constructor: false,
        DataView: false,
        Date: false,
        decodeURI: false,
        decodeURIComponent: false,
        encodeURI: false,
        encodeURIComponent: false,
        Error: false,
        escape: false,
        eval: false,
        EvalError: false,
        Float32Array: false,
        Float64Array: false,
        Function: false,
        hasOwnProperty: false,
        Infinity: false,
        Int16Array: false,
        Int32Array: false,
        Int8Array: false,
        isFinite: false,
        isNaN: false,
        isPrototypeOf: false,
        JSON: false,
        Map: false,
        Math: false,
        NaN: false,
        Number: false,
        Object: false,
        parseFloat: false,
        parseInt: false,
        Promise: false,
        propertyIsEnumerable: false,
        Proxy: false,
        RangeError: false,
        ReferenceError: false,
        Reflect: false,
        RegExp: false,
        Set: false,
        SharedArrayBuffer: false,
        String: false,
        Symbol: false,
        SyntaxError: false,
        toLocaleString: false,
        toString: false,
        TypeError: false,
        Uint16Array: false,
        Uint32Array: false,
        Uint8Array: false,
        Uint8ClampedArray: false,
        undefined: false,
        unescape: false,
        URIError: false,
        valueOf: false,
        WeakMap: false,
        WeakSet: false
      },
      browser: {
        AbortController: false,
        AbortSignal: false,
        addEventListener: false,
        alert: false,
        AnalyserNode: false,
        Animation: false,
        AnimationEffectReadOnly: false,
        AnimationEffectTiming: false,
        AnimationEffectTimingReadOnly: false,
        AnimationEvent: false,
        AnimationPlaybackEvent: false,
        AnimationTimeline: false,
        applicationCache: false,
        ApplicationCache: false,
        ApplicationCacheErrorEvent: false,
        atob: false,
        Attr: false,
        Audio: false,
        AudioBuffer: false,
        AudioBufferSourceNode: false,
        AudioContext: false,
        AudioDestinationNode: false,
        AudioListener: false,
        AudioNode: false,
        AudioParam: false,
        AudioProcessingEvent: false,
        AudioScheduledSourceNode: false,
        "AudioWorkletGlobalScope ": false,
        AudioWorkletNode: false,
        AudioWorkletProcessor: false,
        BarProp: false,
        BaseAudioContext: false,
        BatteryManager: false,
        BeforeUnloadEvent: false,
        BiquadFilterNode: false,
        Blob: false,
        BlobEvent: false,
        blur: false,
        BroadcastChannel: false,
        btoa: false,
        BudgetService: false,
        ByteLengthQueuingStrategy: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        cancelAnimationFrame: false,
        cancelIdleCallback: false,
        CanvasCaptureMediaStreamTrack: false,
        CanvasGradient: false,
        CanvasPattern: false,
        CanvasRenderingContext2D: false,
        ChannelMergerNode: false,
        ChannelSplitterNode: false,
        CharacterData: false,
        clearInterval: false,
        clearTimeout: false,
        clientInformation: false,
        ClipboardEvent: false,
        close: false,
        closed: false,
        CloseEvent: false,
        Comment: false,
        CompositionEvent: false,
        confirm: false,
        console: false,
        ConstantSourceNode: false,
        ConvolverNode: false,
        CountQueuingStrategy: false,
        createImageBitmap: false,
        Credential: false,
        CredentialsContainer: false,
        crypto: false,
        Crypto: false,
        CryptoKey: false,
        CSS: false,
        CSSConditionRule: false,
        CSSFontFaceRule: false,
        CSSGroupingRule: false,
        CSSImportRule: false,
        CSSKeyframeRule: false,
        CSSKeyframesRule: false,
        CSSMediaRule: false,
        CSSNamespaceRule: false,
        CSSPageRule: false,
        CSSRule: false,
        CSSRuleList: false,
        CSSStyleDeclaration: false,
        CSSStyleRule: false,
        CSSStyleSheet: false,
        CSSSupportsRule: false,
        CustomElementRegistry: false,
        customElements: false,
        CustomEvent: false,
        DataTransfer: false,
        DataTransferItem: false,
        DataTransferItemList: false,
        defaultstatus: false,
        defaultStatus: false,
        DelayNode: false,
        DeviceMotionEvent: false,
        DeviceOrientationEvent: false,
        devicePixelRatio: false,
        dispatchEvent: false,
        document: false,
        Document: false,
        DocumentFragment: false,
        DocumentType: false,
        DOMError: false,
        DOMException: false,
        DOMImplementation: false,
        DOMMatrix: false,
        DOMMatrixReadOnly: false,
        DOMParser: false,
        DOMPoint: false,
        DOMPointReadOnly: false,
        DOMQuad: false,
        DOMRect: false,
        DOMRectReadOnly: false,
        DOMStringList: false,
        DOMStringMap: false,
        DOMTokenList: false,
        DragEvent: false,
        DynamicsCompressorNode: false,
        Element: false,
        ErrorEvent: false,
        event: false,
        Event: false,
        EventSource: false,
        EventTarget: false,
        external: false,
        fetch: false,
        File: false,
        FileList: false,
        FileReader: false,
        find: false,
        focus: false,
        FocusEvent: false,
        FontFace: false,
        FontFaceSetLoadEvent: false,
        FormData: false,
        frameElement: false,
        frames: false,
        GainNode: false,
        Gamepad: false,
        GamepadButton: false,
        GamepadEvent: false,
        getComputedStyle: false,
        getSelection: false,
        HashChangeEvent: false,
        Headers: false,
        history: false,
        History: false,
        HTMLAllCollection: false,
        HTMLAnchorElement: false,
        HTMLAreaElement: false,
        HTMLAudioElement: false,
        HTMLBaseElement: false,
        HTMLBodyElement: false,
        HTMLBRElement: false,
        HTMLButtonElement: false,
        HTMLCanvasElement: false,
        HTMLCollection: false,
        HTMLContentElement: false,
        HTMLDataElement: false,
        HTMLDataListElement: false,
        HTMLDetailsElement: false,
        HTMLDialogElement: false,
        HTMLDirectoryElement: false,
        HTMLDivElement: false,
        HTMLDListElement: false,
        HTMLDocument: false,
        HTMLElement: false,
        HTMLEmbedElement: false,
        HTMLFieldSetElement: false,
        HTMLFontElement: false,
        HTMLFormControlsCollection: false,
        HTMLFormElement: false,
        HTMLFrameElement: false,
        HTMLFrameSetElement: false,
        HTMLHeadElement: false,
        HTMLHeadingElement: false,
        HTMLHRElement: false,
        HTMLHtmlElement: false,
        HTMLIFrameElement: false,
        HTMLImageElement: false,
        HTMLInputElement: false,
        HTMLLabelElement: false,
        HTMLLegendElement: false,
        HTMLLIElement: false,
        HTMLLinkElement: false,
        HTMLMapElement: false,
        HTMLMarqueeElement: false,
        HTMLMediaElement: false,
        HTMLMenuElement: false,
        HTMLMetaElement: false,
        HTMLMeterElement: false,
        HTMLModElement: false,
        HTMLObjectElement: false,
        HTMLOListElement: false,
        HTMLOptGroupElement: false,
        HTMLOptionElement: false,
        HTMLOptionsCollection: false,
        HTMLOutputElement: false,
        HTMLParagraphElement: false,
        HTMLParamElement: false,
        HTMLPictureElement: false,
        HTMLPreElement: false,
        HTMLProgressElement: false,
        HTMLQuoteElement: false,
        HTMLScriptElement: false,
        HTMLSelectElement: false,
        HTMLShadowElement: false,
        HTMLSlotElement: false,
        HTMLSourceElement: false,
        HTMLSpanElement: false,
        HTMLStyleElement: false,
        HTMLTableCaptionElement: false,
        HTMLTableCellElement: false,
        HTMLTableColElement: false,
        HTMLTableElement: false,
        HTMLTableRowElement: false,
        HTMLTableSectionElement: false,
        HTMLTemplateElement: false,
        HTMLTextAreaElement: false,
        HTMLTimeElement: false,
        HTMLTitleElement: false,
        HTMLTrackElement: false,
        HTMLUListElement: false,
        HTMLUnknownElement: false,
        HTMLVideoElement: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        IdleDeadline: false,
        IIRFilterNode: false,
        Image: false,
        ImageBitmap: false,
        ImageBitmapRenderingContext: false,
        ImageCapture: false,
        ImageData: false,
        indexedDB: false,
        innerHeight: false,
        innerWidth: false,
        InputEvent: false,
        IntersectionObserver: false,
        IntersectionObserverEntry: false,
        Intl: false,
        isSecureContext: false,
        KeyboardEvent: false,
        KeyframeEffect: false,
        KeyframeEffectReadOnly: false,
        length: false,
        localStorage: false,
        location: true,
        Location: false,
        locationbar: false,
        matchMedia: false,
        MediaDeviceInfo: false,
        MediaDevices: false,
        MediaElementAudioSourceNode: false,
        MediaEncryptedEvent: false,
        MediaError: false,
        MediaKeyMessageEvent: false,
        MediaKeySession: false,
        MediaKeyStatusMap: false,
        MediaKeySystemAccess: false,
        MediaList: false,
        MediaQueryList: false,
        MediaQueryListEvent: false,
        MediaRecorder: false,
        MediaSettingsRange: false,
        MediaSource: false,
        MediaStream: false,
        MediaStreamAudioDestinationNode: false,
        MediaStreamAudioSourceNode: false,
        MediaStreamEvent: false,
        MediaStreamTrack: false,
        MediaStreamTrackEvent: false,
        menubar: false,
        MessageChannel: false,
        MessageEvent: false,
        MessagePort: false,
        MIDIAccess: false,
        MIDIConnectionEvent: false,
        MIDIInput: false,
        MIDIInputMap: false,
        MIDIMessageEvent: false,
        MIDIOutput: false,
        MIDIOutputMap: false,
        MIDIPort: false,
        MimeType: false,
        MimeTypeArray: false,
        MouseEvent: false,
        moveBy: false,
        moveTo: false,
        MutationEvent: false,
        MutationObserver: false,
        MutationRecord: false,
        name: false,
        NamedNodeMap: false,
        NavigationPreloadManager: false,
        navigator: false,
        Navigator: false,
        NetworkInformation: false,
        Node: false,
        NodeFilter: false,
        NodeIterator: false,
        NodeList: false,
        Notification: false,
        OfflineAudioCompletionEvent: false,
        OfflineAudioContext: false,
        offscreenBuffering: false,
        OffscreenCanvas: true,
        onabort: true,
        onafterprint: true,
        onanimationend: true,
        onanimationiteration: true,
        onanimationstart: true,
        onappinstalled: true,
        onauxclick: true,
        onbeforeinstallprompt: true,
        onbeforeprint: true,
        onbeforeunload: true,
        onblur: true,
        oncancel: true,
        oncanplay: true,
        oncanplaythrough: true,
        onchange: true,
        onclick: true,
        onclose: true,
        oncontextmenu: true,
        oncuechange: true,
        ondblclick: true,
        ondevicemotion: true,
        ondeviceorientation: true,
        ondeviceorientationabsolute: true,
        ondrag: true,
        ondragend: true,
        ondragenter: true,
        ondragleave: true,
        ondragover: true,
        ondragstart: true,
        ondrop: true,
        ondurationchange: true,
        onemptied: true,
        onended: true,
        onerror: true,
        onfocus: true,
        ongotpointercapture: true,
        onhashchange: true,
        oninput: true,
        oninvalid: true,
        onkeydown: true,
        onkeypress: true,
        onkeyup: true,
        onlanguagechange: true,
        onload: true,
        onloadeddata: true,
        onloadedmetadata: true,
        onloadstart: true,
        onlostpointercapture: true,
        onmessage: true,
        onmessageerror: true,
        onmousedown: true,
        onmouseenter: true,
        onmouseleave: true,
        onmousemove: true,
        onmouseout: true,
        onmouseover: true,
        onmouseup: true,
        onmousewheel: true,
        onoffline: true,
        ononline: true,
        onpagehide: true,
        onpageshow: true,
        onpause: true,
        onplay: true,
        onplaying: true,
        onpointercancel: true,
        onpointerdown: true,
        onpointerenter: true,
        onpointerleave: true,
        onpointermove: true,
        onpointerout: true,
        onpointerover: true,
        onpointerup: true,
        onpopstate: true,
        onprogress: true,
        onratechange: true,
        onrejectionhandled: true,
        onreset: true,
        onresize: true,
        onscroll: true,
        onsearch: true,
        onseeked: true,
        onseeking: true,
        onselect: true,
        onstalled: true,
        onstorage: true,
        onsubmit: true,
        onsuspend: true,
        ontimeupdate: true,
        ontoggle: true,
        ontransitionend: true,
        onunhandledrejection: true,
        onunload: true,
        onvolumechange: true,
        onwaiting: true,
        onwheel: true,
        open: false,
        openDatabase: false,
        opener: false,
        Option: false,
        origin: false,
        OscillatorNode: false,
        outerHeight: false,
        outerWidth: false,
        PageTransitionEvent: false,
        pageXOffset: false,
        pageYOffset: false,
        PannerNode: false,
        parent: false,
        Path2D: false,
        PaymentAddress: false,
        PaymentRequest: false,
        PaymentRequestUpdateEvent: false,
        PaymentResponse: false,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceLongTaskTiming: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceNavigationTiming: false,
        PerformanceObserver: false,
        PerformanceObserverEntryList: false,
        PerformancePaintTiming: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        PeriodicWave: false,
        Permissions: false,
        PermissionStatus: false,
        personalbar: false,
        PhotoCapabilities: false,
        Plugin: false,
        PluginArray: false,
        PointerEvent: false,
        PopStateEvent: false,
        postMessage: false,
        Presentation: false,
        PresentationAvailability: false,
        PresentationConnection: false,
        PresentationConnectionAvailableEvent: false,
        PresentationConnectionCloseEvent: false,
        PresentationConnectionList: false,
        PresentationReceiver: false,
        PresentationRequest: false,
        print: false,
        ProcessingInstruction: false,
        ProgressEvent: false,
        PromiseRejectionEvent: false,
        prompt: false,
        PushManager: false,
        PushSubscription: false,
        PushSubscriptionOptions: false,
        queueMicrotask: false,
        RadioNodeList: false,
        Range: false,
        ReadableStream: false,
        registerProcessor: false,
        RemotePlayback: false,
        removeEventListener: false,
        Request: false,
        requestAnimationFrame: false,
        requestIdleCallback: false,
        resizeBy: false,
        ResizeObserver: false,
        ResizeObserverEntry: false,
        resizeTo: false,
        Response: false,
        RTCCertificate: false,
        RTCDataChannel: false,
        RTCDataChannelEvent: false,
        RTCDtlsTransport: false,
        RTCIceCandidate: false,
        RTCIceGatherer: false,
        RTCIceTransport: false,
        RTCPeerConnection: false,
        RTCPeerConnectionIceEvent: false,
        RTCRtpContributingSource: false,
        RTCRtpReceiver: false,
        RTCRtpSender: false,
        RTCSctpTransport: false,
        RTCSessionDescription: false,
        RTCStatsReport: false,
        RTCTrackEvent: false,
        screen: false,
        Screen: false,
        screenLeft: false,
        ScreenOrientation: false,
        screenTop: false,
        screenX: false,
        screenY: false,
        ScriptProcessorNode: false,
        scroll: false,
        scrollbars: false,
        scrollBy: false,
        scrollTo: false,
        scrollX: false,
        scrollY: false,
        SecurityPolicyViolationEvent: false,
        Selection: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerRegistration: false,
        sessionStorage: false,
        setInterval: false,
        setTimeout: false,
        ShadowRoot: false,
        SharedWorker: false,
        SourceBuffer: false,
        SourceBufferList: false,
        speechSynthesis: false,
        SpeechSynthesisEvent: false,
        SpeechSynthesisUtterance: false,
        StaticRange: false,
        status: false,
        statusbar: false,
        StereoPannerNode: false,
        stop: false,
        Storage: false,
        StorageEvent: false,
        StorageManager: false,
        styleMedia: false,
        StyleSheet: false,
        StyleSheetList: false,
        SubtleCrypto: false,
        SVGAElement: false,
        SVGAngle: false,
        SVGAnimatedAngle: false,
        SVGAnimatedBoolean: false,
        SVGAnimatedEnumeration: false,
        SVGAnimatedInteger: false,
        SVGAnimatedLength: false,
        SVGAnimatedLengthList: false,
        SVGAnimatedNumber: false,
        SVGAnimatedNumberList: false,
        SVGAnimatedPreserveAspectRatio: false,
        SVGAnimatedRect: false,
        SVGAnimatedString: false,
        SVGAnimatedTransformList: false,
        SVGAnimateElement: false,
        SVGAnimateMotionElement: false,
        SVGAnimateTransformElement: false,
        SVGAnimationElement: false,
        SVGCircleElement: false,
        SVGClipPathElement: false,
        SVGComponentTransferFunctionElement: false,
        SVGDefsElement: false,
        SVGDescElement: false,
        SVGDiscardElement: false,
        SVGElement: false,
        SVGEllipseElement: false,
        SVGFEBlendElement: false,
        SVGFEColorMatrixElement: false,
        SVGFEComponentTransferElement: false,
        SVGFECompositeElement: false,
        SVGFEConvolveMatrixElement: false,
        SVGFEDiffuseLightingElement: false,
        SVGFEDisplacementMapElement: false,
        SVGFEDistantLightElement: false,
        SVGFEDropShadowElement: false,
        SVGFEFloodElement: false,
        SVGFEFuncAElement: false,
        SVGFEFuncBElement: false,
        SVGFEFuncGElement: false,
        SVGFEFuncRElement: false,
        SVGFEGaussianBlurElement: false,
        SVGFEImageElement: false,
        SVGFEMergeElement: false,
        SVGFEMergeNodeElement: false,
        SVGFEMorphologyElement: false,
        SVGFEOffsetElement: false,
        SVGFEPointLightElement: false,
        SVGFESpecularLightingElement: false,
        SVGFESpotLightElement: false,
        SVGFETileElement: false,
        SVGFETurbulenceElement: false,
        SVGFilterElement: false,
        SVGForeignObjectElement: false,
        SVGGElement: false,
        SVGGeometryElement: false,
        SVGGradientElement: false,
        SVGGraphicsElement: false,
        SVGImageElement: false,
        SVGLength: false,
        SVGLengthList: false,
        SVGLinearGradientElement: false,
        SVGLineElement: false,
        SVGMarkerElement: false,
        SVGMaskElement: false,
        SVGMatrix: false,
        SVGMetadataElement: false,
        SVGMPathElement: false,
        SVGNumber: false,
        SVGNumberList: false,
        SVGPathElement: false,
        SVGPatternElement: false,
        SVGPoint: false,
        SVGPointList: false,
        SVGPolygonElement: false,
        SVGPolylineElement: false,
        SVGPreserveAspectRatio: false,
        SVGRadialGradientElement: false,
        SVGRect: false,
        SVGRectElement: false,
        SVGScriptElement: false,
        SVGSetElement: false,
        SVGStopElement: false,
        SVGStringList: false,
        SVGStyleElement: false,
        SVGSVGElement: false,
        SVGSwitchElement: false,
        SVGSymbolElement: false,
        SVGTextContentElement: false,
        SVGTextElement: false,
        SVGTextPathElement: false,
        SVGTextPositioningElement: false,
        SVGTitleElement: false,
        SVGTransform: false,
        SVGTransformList: false,
        SVGTSpanElement: false,
        SVGUnitTypes: false,
        SVGUseElement: false,
        SVGViewElement: false,
        TaskAttributionTiming: false,
        Text: false,
        TextDecoder: false,
        TextEncoder: false,
        TextEvent: false,
        TextMetrics: false,
        TextTrack: false,
        TextTrackCue: false,
        TextTrackCueList: false,
        TextTrackList: false,
        TimeRanges: false,
        toolbar: false,
        top: false,
        Touch: false,
        TouchEvent: false,
        TouchList: false,
        TrackEvent: false,
        TransitionEvent: false,
        TreeWalker: false,
        UIEvent: false,
        URL: false,
        URLSearchParams: false,
        ValidityState: false,
        visualViewport: false,
        VisualViewport: false,
        VTTCue: false,
        WaveShaperNode: false,
        WebAssembly: false,
        WebGL2RenderingContext: false,
        WebGLActiveInfo: false,
        WebGLBuffer: false,
        WebGLContextEvent: false,
        WebGLFramebuffer: false,
        WebGLProgram: false,
        WebGLQuery: false,
        WebGLRenderbuffer: false,
        WebGLRenderingContext: false,
        WebGLSampler: false,
        WebGLShader: false,
        WebGLShaderPrecisionFormat: false,
        WebGLSync: false,
        WebGLTexture: false,
        WebGLTransformFeedback: false,
        WebGLUniformLocation: false,
        WebGLVertexArrayObject: false,
        WebSocket: false,
        WheelEvent: false,
        window: false,
        Window: false,
        Worker: false,
        WritableStream: false,
        XMLDocument: false,
        XMLHttpRequest: false,
        XMLHttpRequestEventTarget: false,
        XMLHttpRequestUpload: false,
        XMLSerializer: false,
        XPathEvaluator: false,
        XPathExpression: false,
        XPathResult: false,
        XSLTProcessor: false
      },
      worker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        clearInterval: false,
        clearTimeout: false,
        close: true,
        console: false,
        fetch: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: true,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onlanguagechange: true,
        onmessage: true,
        onoffline: true,
        ononline: true,
        onrejectionhandled: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: true,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      node: {
        __dirname: false,
        __filename: false,
        Buffer: false,
        clearImmediate: false,
        clearInterval: false,
        clearTimeout: false,
        console: false,
        exports: true,
        global: false,
        Intl: false,
        module: false,
        process: false,
        queueMicrotask: false,
        require: false,
        setImmediate: false,
        setInterval: false,
        setTimeout: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false
      },
      commonjs: {
        exports: true,
        global: false,
        module: false,
        require: false
      },
      amd: {
        define: false,
        require: false
      },
      mocha: {
        after: false,
        afterEach: false,
        before: false,
        beforeEach: false,
        context: false,
        describe: false,
        it: false,
        mocha: false,
        run: false,
        setup: false,
        specify: false,
        suite: false,
        suiteSetup: false,
        suiteTeardown: false,
        teardown: false,
        test: false,
        xcontext: false,
        xdescribe: false,
        xit: false,
        xspecify: false
      },
      jasmine: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fail: false,
        fdescribe: false,
        fit: false,
        it: false,
        jasmine: false,
        pending: false,
        runs: false,
        spyOn: false,
        spyOnProperty: false,
        waits: false,
        waitsFor: false,
        xdescribe: false,
        xit: false
      },
      jest: {
        afterAll: false,
        afterEach: false,
        beforeAll: false,
        beforeEach: false,
        describe: false,
        expect: false,
        fdescribe: false,
        fit: false,
        it: false,
        jest: false,
        pit: false,
        require: false,
        test: false,
        xdescribe: false,
        xit: false,
        xtest: false
      },
      qunit: {
        asyncTest: false,
        deepEqual: false,
        equal: false,
        expect: false,
        module: false,
        notDeepEqual: false,
        notEqual: false,
        notOk: false,
        notPropEqual: false,
        notStrictEqual: false,
        ok: false,
        propEqual: false,
        QUnit: false,
        raises: false,
        start: false,
        stop: false,
        strictEqual: false,
        test: false,
        throws: false
      },
      phantomjs: {
        console: true,
        exports: true,
        phantom: true,
        require: true,
        WebPage: true
      },
      couch: {
        emit: false,
        exports: false,
        getRow: false,
        log: false,
        module: false,
        provides: false,
        require: false,
        respond: false,
        send: false,
        start: false,
        sum: false
      },
      rhino: {
        defineClass: false,
        deserialize: false,
        gc: false,
        help: false,
        importClass: false,
        importPackage: false,
        java: false,
        load: false,
        loadClass: false,
        Packages: false,
        print: false,
        quit: false,
        readFile: false,
        readUrl: false,
        runCommand: false,
        seal: false,
        serialize: false,
        spawn: false,
        sync: false,
        toint32: false,
        version: false
      },
      nashorn: {
        __DIR__: false,
        __FILE__: false,
        __LINE__: false,
        com: false,
        edu: false,
        exit: false,
        java: false,
        Java: false,
        javafx: false,
        JavaImporter: false,
        javax: false,
        JSAdapter: false,
        load: false,
        loadWithNewGlobal: false,
        org: false,
        Packages: false,
        print: false,
        quit: false
      },
      wsh: {
        ActiveXObject: true,
        Enumerator: true,
        GetObject: true,
        ScriptEngine: true,
        ScriptEngineBuildVersion: true,
        ScriptEngineMajorVersion: true,
        ScriptEngineMinorVersion: true,
        VBArray: true,
        WScript: true,
        WSH: true,
        XDomainRequest: true
      },
      jquery: {
        $: false,
        jQuery: false
      },
      yui: {
        YAHOO: false,
        YAHOO_config: false,
        YUI: false,
        YUI_config: false
      },
      shelljs: {
        cat: false,
        cd: false,
        chmod: false,
        config: false,
        cp: false,
        dirs: false,
        echo: false,
        env: false,
        error: false,
        exec: false,
        exit: false,
        find: false,
        grep: false,
        ln: false,
        ls: false,
        mkdir: false,
        mv: false,
        popd: false,
        pushd: false,
        pwd: false,
        rm: false,
        sed: false,
        set: false,
        target: false,
        tempdir: false,
        test: false,
        touch: false,
        which: false
      },
      prototypejs: {
        $: false,
        $$: false,
        $A: false,
        $break: false,
        $continue: false,
        $F: false,
        $H: false,
        $R: false,
        $w: false,
        Abstract: false,
        Ajax: false,
        Autocompleter: false,
        Builder: false,
        Class: false,
        Control: false,
        Draggable: false,
        Draggables: false,
        Droppables: false,
        Effect: false,
        Element: false,
        Enumerable: false,
        Event: false,
        Field: false,
        Form: false,
        Hash: false,
        Insertion: false,
        ObjectRange: false,
        PeriodicalExecuter: false,
        Position: false,
        Prototype: false,
        Scriptaculous: false,
        Selector: false,
        Sortable: false,
        SortableObserver: false,
        Sound: false,
        Template: false,
        Toggle: false,
        Try: false
      },
      meteor: {
        _: false,
        $: false,
        Accounts: false,
        AccountsClient: false,
        AccountsCommon: false,
        AccountsServer: false,
        App: false,
        Assets: false,
        Blaze: false,
        check: false,
        Cordova: false,
        DDP: false,
        DDPRateLimiter: false,
        DDPServer: false,
        Deps: false,
        EJSON: false,
        Email: false,
        HTTP: false,
        Log: false,
        Match: false,
        Meteor: false,
        Mongo: false,
        MongoInternals: false,
        Npm: false,
        Package: false,
        Plugin: false,
        process: false,
        Random: false,
        ReactiveDict: false,
        ReactiveVar: false,
        Router: false,
        ServiceConfiguration: false,
        Session: false,
        share: false,
        Spacebars: false,
        Template: false,
        Tinytest: false,
        Tracker: false,
        UI: false,
        Utils: false,
        WebApp: false,
        WebAppInternals: false
      },
      mongo: {
        _isWindows: false,
        _rand: false,
        BulkWriteResult: false,
        cat: false,
        cd: false,
        connect: false,
        db: false,
        getHostName: false,
        getMemInfo: false,
        hostname: false,
        ISODate: false,
        listFiles: false,
        load: false,
        ls: false,
        md5sumFile: false,
        mkdir: false,
        Mongo: false,
        NumberInt: false,
        NumberLong: false,
        ObjectId: false,
        PlanCache: false,
        print: false,
        printjson: false,
        pwd: false,
        quit: false,
        removeFile: false,
        rs: false,
        sh: false,
        UUID: false,
        version: false,
        WriteResult: false
      },
      applescript: {
        $: false,
        Application: false,
        Automation: false,
        console: false,
        delay: false,
        Library: false,
        ObjC: false,
        ObjectSpecifier: false,
        Path: false,
        Progress: false,
        Ref: false
      },
      serviceworker: {
        addEventListener: false,
        applicationCache: false,
        atob: false,
        Blob: false,
        BroadcastChannel: false,
        btoa: false,
        Cache: false,
        caches: false,
        CacheStorage: false,
        clearInterval: false,
        clearTimeout: false,
        Client: false,
        clients: false,
        Clients: false,
        close: true,
        console: false,
        ExtendableEvent: false,
        ExtendableMessageEvent: false,
        fetch: false,
        FetchEvent: false,
        FileReaderSync: false,
        FormData: false,
        Headers: false,
        IDBCursor: false,
        IDBCursorWithValue: false,
        IDBDatabase: false,
        IDBFactory: false,
        IDBIndex: false,
        IDBKeyRange: false,
        IDBObjectStore: false,
        IDBOpenDBRequest: false,
        IDBRequest: false,
        IDBTransaction: false,
        IDBVersionChangeEvent: false,
        ImageData: false,
        importScripts: false,
        indexedDB: false,
        location: false,
        MessageChannel: false,
        MessagePort: false,
        name: false,
        navigator: false,
        Notification: false,
        onclose: true,
        onconnect: true,
        onerror: true,
        onfetch: true,
        oninstall: true,
        onlanguagechange: true,
        onmessage: true,
        onmessageerror: true,
        onnotificationclick: true,
        onnotificationclose: true,
        onoffline: true,
        ononline: true,
        onpush: true,
        onpushsubscriptionchange: true,
        onrejectionhandled: true,
        onsync: true,
        onunhandledrejection: true,
        performance: false,
        Performance: false,
        PerformanceEntry: false,
        PerformanceMark: false,
        PerformanceMeasure: false,
        PerformanceNavigation: false,
        PerformanceResourceTiming: false,
        PerformanceTiming: false,
        postMessage: true,
        Promise: false,
        queueMicrotask: false,
        registration: false,
        removeEventListener: false,
        Request: false,
        Response: false,
        self: false,
        ServiceWorker: false,
        ServiceWorkerContainer: false,
        ServiceWorkerGlobalScope: false,
        ServiceWorkerMessageEvent: false,
        ServiceWorkerRegistration: false,
        setInterval: false,
        setTimeout: false,
        skipWaiting: false,
        TextDecoder: false,
        TextEncoder: false,
        URL: false,
        URLSearchParams: false,
        WebSocket: false,
        WindowClient: false,
        Worker: false,
        WorkerGlobalScope: false,
        XMLHttpRequest: false
      },
      atomtest: {
        advanceClock: false,
        fakeClearInterval: false,
        fakeClearTimeout: false,
        fakeSetInterval: false,
        fakeSetTimeout: false,
        resetTimeouts: false,
        waitsForPromise: false
      },
      embertest: {
        andThen: false,
        click: false,
        currentPath: false,
        currentRouteName: false,
        currentURL: false,
        fillIn: false,
        find: false,
        findAll: false,
        findWithAssert: false,
        keyEvent: false,
        pauseTest: false,
        resumeTest: false,
        triggerEvent: false,
        visit: false,
        wait: false
      },
      protractor: {
        $: false,
        $$: false,
        browser: false,
        by: false,
        By: false,
        DartObject: false,
        element: false,
        protractor: false
      },
      "shared-node-browser": {
        clearInterval: false,
        clearTimeout: false,
        console: false,
        setInterval: false,
        setTimeout: false,
        URL: false,
        URLSearchParams: false
      },
      webextensions: {
        browser: false,
        chrome: false,
        opr: false
      },
      greasemonkey: {
        cloneInto: false,
        createObjectIn: false,
        exportFunction: false,
        GM: false,
        GM_addStyle: false,
        GM_deleteValue: false,
        GM_getResourceText: false,
        GM_getResourceURL: false,
        GM_getValue: false,
        GM_info: false,
        GM_listValues: false,
        GM_log: false,
        GM_openInTab: false,
        GM_registerMenuCommand: false,
        GM_setClipboard: false,
        GM_setValue: false,
        GM_xmlhttpRequest: false,
        unsafeWindow: false
      },
      devtools: {
        $: false,
        $_: false,
        $$: false,
        $0: false,
        $1: false,
        $2: false,
        $3: false,
        $4: false,
        $x: false,
        chrome: false,
        clear: false,
        copy: false,
        debug: false,
        dir: false,
        dirxml: false,
        getEventListeners: false,
        inspect: false,
        keys: false,
        monitor: false,
        monitorEvents: false,
        profile: false,
        profileEnd: false,
        queryObjects: false,
        table: false,
        undebug: false,
        unmonitor: false,
        unmonitorEvents: false,
        values: false
      }
    };
  }
});

// node_modules/globals/index.js
var require_globals2 = __commonJS({
  "node_modules/globals/index.js"(exports2, module) {
    "use strict";
    module.exports = require_globals();
  }
});

// node_modules/@babel/traverse/lib/cache.js
var require_cache = __commonJS({
  "node_modules/@babel/traverse/lib/cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.clear = clear;
    exports2.clearPath = clearPath;
    exports2.clearScope = clearScope;
    exports2.getCachedPaths = getCachedPaths;
    exports2.getOrCreateCachedPaths = getOrCreateCachedPaths;
    exports2.scope = exports2.path = void 0;
    var pathsCache = exports2.path = /* @__PURE__ */ new WeakMap();
    var scope = exports2.scope = /* @__PURE__ */ new WeakMap();
    function clear() {
      clearPath();
      clearScope();
    }
    function clearPath() {
      exports2.path = pathsCache = /* @__PURE__ */ new WeakMap();
    }
    function clearScope() {
      exports2.scope = scope = /* @__PURE__ */ new WeakMap();
    }
    var nullHub = Object.freeze({});
    function getCachedPaths(hub, parent) {
      var _pathsCache$get, _hub;
      {
        hub = null;
      }
      return (_pathsCache$get = pathsCache.get((_hub = hub) != null ? _hub : nullHub)) == null ? void 0 : _pathsCache$get.get(parent);
    }
    function getOrCreateCachedPaths(hub, parent) {
      var _hub2, _hub3;
      {
        hub = null;
      }
      let parents = pathsCache.get((_hub2 = hub) != null ? _hub2 : nullHub);
      if (!parents) pathsCache.set((_hub3 = hub) != null ? _hub3 : nullHub, parents = /* @__PURE__ */ new WeakMap());
      let paths = parents.get(parent);
      if (!paths) parents.set(parent, paths = /* @__PURE__ */ new Map());
      return paths;
    }
  }
});

// node_modules/@babel/traverse/lib/scope/index.js
var require_scope = __commonJS({
  "node_modules/@babel/traverse/lib/scope/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _renamer = require_renamer();
    var _index = require_lib9();
    var _binding = require_binding();
    var _globals = require_globals2();
    var _t = require_lib3();
    var t = _t;
    var _cache = require_cache();
    var _visitors = require_visitors();
    var {
      NOT_LOCAL_BINDING,
      assignmentExpression,
      callExpression,
      cloneNode,
      getBindingIdentifiers,
      identifier,
      isArrayExpression,
      isBinary,
      isCallExpression,
      isClass,
      isClassBody,
      isClassDeclaration,
      isExportAllDeclaration,
      isExportDefaultDeclaration,
      isExportNamedDeclaration,
      isFunctionDeclaration,
      isIdentifier: isIdentifier2,
      isImportDeclaration,
      isLiteral,
      isMemberExpression,
      isMethod,
      isModuleSpecifier,
      isNullLiteral,
      isObjectExpression,
      isProperty,
      isPureish,
      isRegExpLiteral,
      isSuper,
      isTaggedTemplateExpression,
      isTemplateLiteral,
      isThisExpression,
      isUnaryExpression,
      isVariableDeclaration,
      expressionStatement,
      matchesPattern,
      memberExpression,
      numericLiteral,
      toIdentifier,
      variableDeclaration,
      variableDeclarator,
      isRecordExpression,
      isTupleExpression,
      isObjectProperty,
      isTopicReference,
      isMetaProperty,
      isPrivateName,
      isExportDeclaration,
      buildUndefinedNode,
      sequenceExpression
    } = _t;
    function gatherNodeParts(node3, parts) {
      switch (node3 == null ? void 0 : node3.type) {
        default:
          if (isImportDeclaration(node3) || isExportDeclaration(node3)) {
            var _node$specifiers;
            if ((isExportAllDeclaration(node3) || isExportNamedDeclaration(node3) || isImportDeclaration(node3)) && node3.source) {
              gatherNodeParts(node3.source, parts);
            } else if ((isExportNamedDeclaration(node3) || isImportDeclaration(node3)) && (_node$specifiers = node3.specifiers) != null && _node$specifiers.length) {
              for (const e of node3.specifiers) gatherNodeParts(e, parts);
            } else if ((isExportDefaultDeclaration(node3) || isExportNamedDeclaration(node3)) && node3.declaration) {
              gatherNodeParts(node3.declaration, parts);
            }
          } else if (isModuleSpecifier(node3)) {
            gatherNodeParts(node3.local, parts);
          } else if (isLiteral(node3) && !isNullLiteral(node3) && !isRegExpLiteral(node3) && !isTemplateLiteral(node3)) {
            parts.push(node3.value);
          }
          break;
        case "MemberExpression":
        case "OptionalMemberExpression":
        case "JSXMemberExpression":
          gatherNodeParts(node3.object, parts);
          gatherNodeParts(node3.property, parts);
          break;
        case "Identifier":
        case "JSXIdentifier":
          parts.push(node3.name);
          break;
        case "CallExpression":
        case "OptionalCallExpression":
        case "NewExpression":
          gatherNodeParts(node3.callee, parts);
          break;
        case "ObjectExpression":
        case "ObjectPattern":
          for (const e of node3.properties) {
            gatherNodeParts(e, parts);
          }
          break;
        case "SpreadElement":
        case "RestElement":
          gatherNodeParts(node3.argument, parts);
          break;
        case "ObjectProperty":
        case "ObjectMethod":
        case "ClassProperty":
        case "ClassMethod":
        case "ClassPrivateProperty":
        case "ClassPrivateMethod":
          gatherNodeParts(node3.key, parts);
          break;
        case "ThisExpression":
          parts.push("this");
          break;
        case "Super":
          parts.push("super");
          break;
        case "Import":
          parts.push("import");
          break;
        case "DoExpression":
          parts.push("do");
          break;
        case "YieldExpression":
          parts.push("yield");
          gatherNodeParts(node3.argument, parts);
          break;
        case "AwaitExpression":
          parts.push("await");
          gatherNodeParts(node3.argument, parts);
          break;
        case "AssignmentExpression":
          gatherNodeParts(node3.left, parts);
          break;
        case "VariableDeclarator":
          gatherNodeParts(node3.id, parts);
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ClassExpression":
        case "ClassDeclaration":
          gatherNodeParts(node3.id, parts);
          break;
        case "PrivateName":
          gatherNodeParts(node3.id, parts);
          break;
        case "ParenthesizedExpression":
          gatherNodeParts(node3.expression, parts);
          break;
        case "UnaryExpression":
        case "UpdateExpression":
          gatherNodeParts(node3.argument, parts);
          break;
        case "MetaProperty":
          gatherNodeParts(node3.meta, parts);
          gatherNodeParts(node3.property, parts);
          break;
        case "JSXElement":
          gatherNodeParts(node3.openingElement, parts);
          break;
        case "JSXOpeningElement":
          gatherNodeParts(node3.name, parts);
          break;
        case "JSXFragment":
          gatherNodeParts(node3.openingFragment, parts);
          break;
        case "JSXOpeningFragment":
          parts.push("Fragment");
          break;
        case "JSXNamespacedName":
          gatherNodeParts(node3.namespace, parts);
          gatherNodeParts(node3.name, parts);
          break;
      }
    }
    var collectorVisitor = {
      ForStatement(path9) {
        const declar = path9.get("init");
        if (declar.isVar()) {
          const {
            scope
          } = path9;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", declar);
        }
      },
      Declaration(path9) {
        if (path9.isBlockScoped()) return;
        if (path9.isImportDeclaration()) return;
        if (path9.isExportDeclaration()) return;
        const parent = path9.scope.getFunctionParent() || path9.scope.getProgramParent();
        parent.registerDeclaration(path9);
      },
      ImportDeclaration(path9) {
        const parent = path9.scope.getBlockParent();
        parent.registerDeclaration(path9);
      },
      TSImportEqualsDeclaration(path9) {
        const parent = path9.scope.getBlockParent();
        parent.registerDeclaration(path9);
      },
      ReferencedIdentifier(path9, state) {
        if (t.isTSQualifiedName(path9.parent) && path9.parent.right === path9.node) {
          return;
        }
        if (path9.parentPath.isTSImportEqualsDeclaration()) return;
        state.references.push(path9);
      },
      ForXStatement(path9, state) {
        const left = path9.get("left");
        if (left.isPattern() || left.isIdentifier()) {
          state.constantViolations.push(path9);
        } else if (left.isVar()) {
          const {
            scope
          } = path9;
          const parentScope = scope.getFunctionParent() || scope.getProgramParent();
          parentScope.registerBinding("var", left);
        }
      },
      ExportDeclaration: {
        exit(path9) {
          const {
            node: node3,
            scope
          } = path9;
          if (isExportAllDeclaration(node3)) return;
          const declar = node3.declaration;
          if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {
            const id3 = declar.id;
            if (!id3) return;
            const binding = scope.getBinding(id3.name);
            binding == null || binding.reference(path9);
          } else if (isVariableDeclaration(declar)) {
            for (const decl2 of declar.declarations) {
              for (const name2 of Object.keys(getBindingIdentifiers(decl2))) {
                const binding = scope.getBinding(name2);
                binding == null || binding.reference(path9);
              }
            }
          }
        }
      },
      LabeledStatement(path9) {
        path9.scope.getBlockParent().registerDeclaration(path9);
      },
      AssignmentExpression(path9, state) {
        state.assignments.push(path9);
      },
      UpdateExpression(path9, state) {
        state.constantViolations.push(path9);
      },
      UnaryExpression(path9, state) {
        if (path9.node.operator === "delete") {
          state.constantViolations.push(path9);
        }
      },
      BlockScoped(path9) {
        let scope = path9.scope;
        if (scope.path === path9) scope = scope.parent;
        const parent = scope.getBlockParent();
        parent.registerDeclaration(path9);
        if (path9.isClassDeclaration() && path9.node.id) {
          const id3 = path9.node.id;
          const name2 = id3.name;
          path9.scope.bindings[name2] = path9.scope.parent.getBinding(name2);
        }
      },
      CatchClause(path9) {
        path9.scope.registerBinding("let", path9);
      },
      Function(path9) {
        const params = path9.get("params");
        for (const param of params) {
          path9.scope.registerBinding("param", param);
        }
        if (path9.isFunctionExpression() && path9.node.id && !path9.node.id[NOT_LOCAL_BINDING]) {
          path9.scope.registerBinding("local", path9.get("id"), path9);
        }
      },
      ClassExpression(path9) {
        if (path9.node.id && !path9.node.id[NOT_LOCAL_BINDING]) {
          path9.scope.registerBinding("local", path9.get("id"), path9);
        }
      },
      TSTypeAnnotation(path9) {
        path9.skip();
      }
    };
    var uid = 0;
    var Scope = class _Scope {
      constructor(path9) {
        this.uid = void 0;
        this.path = void 0;
        this.block = void 0;
        this.inited = void 0;
        this.labels = void 0;
        this.bindings = void 0;
        this.references = void 0;
        this.globals = void 0;
        this.uids = void 0;
        this.data = void 0;
        this.crawling = void 0;
        const {
          node: node3
        } = path9;
        const cached = _cache.scope.get(node3);
        if ((cached == null ? void 0 : cached.path) === path9) {
          return cached;
        }
        _cache.scope.set(node3, this);
        this.uid = uid++;
        this.block = node3;
        this.path = path9;
        this.labels = /* @__PURE__ */ new Map();
        this.inited = false;
      }
      get parent() {
        var _parent;
        let parent, path9 = this.path;
        do {
          var _path2;
          const shouldSkip = path9.key === "key" || path9.listKey === "decorators";
          path9 = path9.parentPath;
          if (shouldSkip && path9.isMethod()) path9 = path9.parentPath;
          if ((_path2 = path9) != null && _path2.isScope()) parent = path9;
        } while (path9 && !parent);
        return (_parent = parent) == null ? void 0 : _parent.scope;
      }
      generateDeclaredUidIdentifier(name2) {
        const id3 = this.generateUidIdentifier(name2);
        this.push({
          id: id3
        });
        return cloneNode(id3);
      }
      generateUidIdentifier(name2) {
        return identifier(this.generateUid(name2));
      }
      generateUid(name2 = "temp") {
        name2 = toIdentifier(name2).replace(/^_+/, "").replace(/\d+$/g, "");
        let uid2;
        let i = 1;
        do {
          uid2 = `_${name2}`;
          if (i > 1) uid2 += i;
          i++;
        } while (this.hasLabel(uid2) || this.hasBinding(uid2) || this.hasGlobal(uid2) || this.hasReference(uid2));
        const program = this.getProgramParent();
        program.references[uid2] = true;
        program.uids[uid2] = true;
        return uid2;
      }
      generateUidBasedOnNode(node3, defaultName) {
        const parts = [];
        gatherNodeParts(node3, parts);
        let id3 = parts.join("$");
        id3 = id3.replace(/^_/, "") || defaultName || "ref";
        return this.generateUid(id3.slice(0, 20));
      }
      generateUidIdentifierBasedOnNode(node3, defaultName) {
        return identifier(this.generateUidBasedOnNode(node3, defaultName));
      }
      isStatic(node3) {
        if (isThisExpression(node3) || isSuper(node3) || isTopicReference(node3)) {
          return true;
        }
        if (isIdentifier2(node3)) {
          const binding = this.getBinding(node3.name);
          if (binding) {
            return binding.constant;
          } else {
            return this.hasBinding(node3.name);
          }
        }
        return false;
      }
      maybeGenerateMemoised(node3, dontPush) {
        if (this.isStatic(node3)) {
          return null;
        } else {
          const id3 = this.generateUidIdentifierBasedOnNode(node3);
          if (!dontPush) {
            this.push({
              id: id3
            });
            return cloneNode(id3);
          }
          return id3;
        }
      }
      checkBlockScopedCollisions(local, kind, name2, id3) {
        if (kind === "param") return;
        if (local.kind === "local") return;
        const duplicate = kind === "let" || local.kind === "let" || local.kind === "const" || local.kind === "module" || local.kind === "param" && kind === "const";
        if (duplicate) {
          throw this.path.hub.buildError(id3, `Duplicate declaration "${name2}"`, TypeError);
        }
      }
      rename(oldName, newName) {
        const binding = this.getBinding(oldName);
        if (binding) {
          newName || (newName = this.generateUidIdentifier(oldName).name);
          const renamer = new _renamer.default(binding, oldName, newName);
          {
            renamer.rename(arguments[2]);
          }
        }
      }
      dump() {
        const sep2 = "-".repeat(60);
        console.log(sep2);
        let scope = this;
        do {
          console.log("#", scope.block.type);
          for (const name2 of Object.keys(scope.bindings)) {
            const binding = scope.bindings[name2];
            console.log(" -", name2, {
              constant: binding.constant,
              references: binding.references,
              violations: binding.constantViolations.length,
              kind: binding.kind
            });
          }
        } while (scope = scope.parent);
        console.log(sep2);
      }
      hasLabel(name2) {
        return !!this.getLabel(name2);
      }
      getLabel(name2) {
        return this.labels.get(name2);
      }
      registerLabel(path9) {
        this.labels.set(path9.node.label.name, path9);
      }
      registerDeclaration(path9) {
        if (path9.isLabeledStatement()) {
          this.registerLabel(path9);
        } else if (path9.isFunctionDeclaration()) {
          this.registerBinding("hoisted", path9.get("id"), path9);
        } else if (path9.isVariableDeclaration()) {
          const declarations = path9.get("declarations");
          const {
            kind
          } = path9.node;
          for (const declar of declarations) {
            this.registerBinding(kind === "using" || kind === "await using" ? "const" : kind, declar);
          }
        } else if (path9.isClassDeclaration()) {
          if (path9.node.declare) return;
          this.registerBinding("let", path9);
        } else if (path9.isImportDeclaration()) {
          const isTypeDeclaration = path9.node.importKind === "type" || path9.node.importKind === "typeof";
          const specifiers = path9.get("specifiers");
          for (const specifier of specifiers) {
            const isTypeSpecifier = isTypeDeclaration || specifier.isImportSpecifier() && (specifier.node.importKind === "type" || specifier.node.importKind === "typeof");
            this.registerBinding(isTypeSpecifier ? "unknown" : "module", specifier);
          }
        } else if (path9.isExportDeclaration()) {
          const declar = path9.get("declaration");
          if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {
            this.registerDeclaration(declar);
          }
        } else {
          this.registerBinding("unknown", path9);
        }
      }
      buildUndefinedNode() {
        return buildUndefinedNode();
      }
      registerConstantViolation(path9) {
        const ids = path9.getAssignmentIdentifiers();
        for (const name2 of Object.keys(ids)) {
          var _this$getBinding;
          (_this$getBinding = this.getBinding(name2)) == null || _this$getBinding.reassign(path9);
        }
      }
      registerBinding(kind, path9, bindingPath = path9) {
        if (!kind) throw new ReferenceError("no `kind`");
        if (path9.isVariableDeclaration()) {
          const declarators = path9.get("declarations");
          for (const declar of declarators) {
            this.registerBinding(kind, declar);
          }
          return;
        }
        const parent = this.getProgramParent();
        const ids = path9.getOuterBindingIdentifiers(true);
        for (const name2 of Object.keys(ids)) {
          parent.references[name2] = true;
          for (const id3 of ids[name2]) {
            const local = this.getOwnBinding(name2);
            if (local) {
              if (local.identifier === id3) continue;
              this.checkBlockScopedCollisions(local, kind, name2, id3);
            }
            if (local) {
              local.reassign(bindingPath);
            } else {
              this.bindings[name2] = new _binding.default({
                identifier: id3,
                scope: this,
                path: bindingPath,
                kind
              });
            }
          }
        }
      }
      addGlobal(node3) {
        this.globals[node3.name] = node3;
      }
      hasUid(name2) {
        let scope = this;
        do {
          if (scope.uids[name2]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasGlobal(name2) {
        let scope = this;
        do {
          if (scope.globals[name2]) return true;
        } while (scope = scope.parent);
        return false;
      }
      hasReference(name2) {
        return !!this.getProgramParent().references[name2];
      }
      isPure(node3, constantsOnly) {
        if (isIdentifier2(node3)) {
          const binding = this.getBinding(node3.name);
          if (!binding) return false;
          if (constantsOnly) return binding.constant;
          return true;
        } else if (isThisExpression(node3) || isMetaProperty(node3) || isTopicReference(node3) || isPrivateName(node3)) {
          return true;
        } else if (isClass(node3)) {
          var _node$decorators;
          if (node3.superClass && !this.isPure(node3.superClass, constantsOnly)) {
            return false;
          }
          if (((_node$decorators = node3.decorators) == null ? void 0 : _node$decorators.length) > 0) {
            return false;
          }
          return this.isPure(node3.body, constantsOnly);
        } else if (isClassBody(node3)) {
          for (const method of node3.body) {
            if (!this.isPure(method, constantsOnly)) return false;
          }
          return true;
        } else if (isBinary(node3)) {
          return this.isPure(node3.left, constantsOnly) && this.isPure(node3.right, constantsOnly);
        } else if (isArrayExpression(node3) || isTupleExpression(node3)) {
          for (const elem of node3.elements) {
            if (elem !== null && !this.isPure(elem, constantsOnly)) return false;
          }
          return true;
        } else if (isObjectExpression(node3) || isRecordExpression(node3)) {
          for (const prop of node3.properties) {
            if (!this.isPure(prop, constantsOnly)) return false;
          }
          return true;
        } else if (isMethod(node3)) {
          var _node$decorators2;
          if (node3.computed && !this.isPure(node3.key, constantsOnly)) return false;
          if (((_node$decorators2 = node3.decorators) == null ? void 0 : _node$decorators2.length) > 0) {
            return false;
          }
          return true;
        } else if (isProperty(node3)) {
          var _node$decorators3;
          if (node3.computed && !this.isPure(node3.key, constantsOnly)) return false;
          if (((_node$decorators3 = node3.decorators) == null ? void 0 : _node$decorators3.length) > 0) {
            return false;
          }
          if (isObjectProperty(node3) || node3.static) {
            if (node3.value !== null && !this.isPure(node3.value, constantsOnly)) {
              return false;
            }
          }
          return true;
        } else if (isUnaryExpression(node3)) {
          return this.isPure(node3.argument, constantsOnly);
        } else if (isTemplateLiteral(node3)) {
          for (const expression of node3.expressions) {
            if (!this.isPure(expression, constantsOnly)) return false;
          }
          return true;
        } else if (isTaggedTemplateExpression(node3)) {
          return matchesPattern(node3.tag, "String.raw") && !this.hasBinding("String", {
            noGlobals: true
          }) && this.isPure(node3.quasi, constantsOnly);
        } else if (isMemberExpression(node3)) {
          return !node3.computed && isIdentifier2(node3.object) && node3.object.name === "Symbol" && isIdentifier2(node3.property) && node3.property.name !== "for" && !this.hasBinding("Symbol", {
            noGlobals: true
          });
        } else if (isCallExpression(node3)) {
          return matchesPattern(node3.callee, "Symbol.for") && !this.hasBinding("Symbol", {
            noGlobals: true
          }) && node3.arguments.length === 1 && t.isStringLiteral(node3.arguments[0]);
        } else {
          return isPureish(node3);
        }
      }
      setData(key, val) {
        return this.data[key] = val;
      }
      getData(key) {
        let scope = this;
        do {
          const data = scope.data[key];
          if (data != null) return data;
        } while (scope = scope.parent);
      }
      removeData(key) {
        let scope = this;
        do {
          const data = scope.data[key];
          if (data != null) scope.data[key] = null;
        } while (scope = scope.parent);
      }
      init() {
        if (!this.inited) {
          this.inited = true;
          this.crawl();
        }
      }
      crawl() {
        const path9 = this.path;
        this.references = /* @__PURE__ */ Object.create(null);
        this.bindings = /* @__PURE__ */ Object.create(null);
        this.globals = /* @__PURE__ */ Object.create(null);
        this.uids = /* @__PURE__ */ Object.create(null);
        this.data = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          if (scope.crawling) return;
          if (scope.path.isProgram()) {
            break;
          }
        } while (scope = scope.parent);
        const programParent = scope;
        const state = {
          references: [],
          constantViolations: [],
          assignments: []
        };
        this.crawling = true;
        if (path9.type !== "Program" && (0, _visitors.isExplodedVisitor)(collectorVisitor)) {
          for (const visit2 of collectorVisitor.enter) {
            visit2.call(state, path9, state);
          }
          const typeVisitors = collectorVisitor[path9.type];
          if (typeVisitors) {
            for (const visit2 of typeVisitors.enter) {
              visit2.call(state, path9, state);
            }
          }
        }
        path9.traverse(collectorVisitor, state);
        this.crawling = false;
        for (const path10 of state.assignments) {
          const ids = path10.getAssignmentIdentifiers();
          for (const name2 of Object.keys(ids)) {
            if (path10.scope.getBinding(name2)) continue;
            programParent.addGlobal(ids[name2]);
          }
          path10.scope.registerConstantViolation(path10);
        }
        for (const ref of state.references) {
          const binding = ref.scope.getBinding(ref.node.name);
          if (binding) {
            binding.reference(ref);
          } else {
            programParent.addGlobal(ref.node);
          }
        }
        for (const path10 of state.constantViolations) {
          path10.scope.registerConstantViolation(path10);
        }
      }
      push(opts) {
        let path9 = this.path;
        if (path9.isPattern()) {
          path9 = this.getPatternParent().path;
        } else if (!path9.isBlockStatement() && !path9.isProgram()) {
          path9 = this.getBlockParent().path;
        }
        if (path9.isSwitchStatement()) {
          path9 = (this.getFunctionParent() || this.getProgramParent()).path;
        }
        const {
          init: init2,
          unique,
          kind = "var",
          id: id3
        } = opts;
        if (!init2 && !unique && (kind === "var" || kind === "let") && path9.isFunction() && !path9.node.name && isCallExpression(path9.parent, {
          callee: path9.node
        }) && path9.parent.arguments.length <= path9.node.params.length && isIdentifier2(id3)) {
          path9.pushContainer("params", id3);
          path9.scope.registerBinding("param", path9.get("params")[path9.node.params.length - 1]);
          return;
        }
        if (path9.isLoop() || path9.isCatchClause() || path9.isFunction()) {
          path9.ensureBlock();
          path9 = path9.get("body");
        }
        const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;
        const dataKey = `declaration:${kind}:${blockHoist}`;
        let declarPath = !unique && path9.getData(dataKey);
        if (!declarPath) {
          const declar = variableDeclaration(kind, []);
          declar._blockHoist = blockHoist;
          [declarPath] = path9.unshiftContainer("body", [declar]);
          if (!unique) path9.setData(dataKey, declarPath);
        }
        const declarator = variableDeclarator(id3, init2);
        const len = declarPath.node.declarations.push(declarator);
        path9.scope.registerBinding(kind, declarPath.get("declarations")[len - 1]);
      }
      getProgramParent() {
        let scope = this;
        do {
          if (scope.path.isProgram()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("Couldn't find a Program");
      }
      getFunctionParent() {
        let scope = this;
        do {
          if (scope.path.isFunctionParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        return null;
      }
      getBlockParent() {
        let scope = this;
        do {
          if (scope.path.isBlockParent()) {
            return scope;
          }
        } while (scope = scope.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getPatternParent() {
        let scope = this;
        do {
          if (!scope.path.isPattern()) {
            return scope.getBlockParent();
          }
        } while (scope = scope.parent.parent);
        throw new Error("We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...");
      }
      getAllBindings() {
        const ids = /* @__PURE__ */ Object.create(null);
        let scope = this;
        do {
          for (const key of Object.keys(scope.bindings)) {
            if (key in ids === false) {
              ids[key] = scope.bindings[key];
            }
          }
          scope = scope.parent;
        } while (scope);
        return ids;
      }
      bindingIdentifierEquals(name2, node3) {
        return this.getBindingIdentifier(name2) === node3;
      }
      getBinding(name2) {
        let scope = this;
        let previousPath;
        do {
          const binding = scope.getOwnBinding(name2);
          if (binding) {
            var _previousPath;
            if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== "param" && binding.kind !== "local") {
            } else {
              return binding;
            }
          } else if (!binding && name2 === "arguments" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
            break;
          }
          previousPath = scope.path;
        } while (scope = scope.parent);
      }
      getOwnBinding(name2) {
        return this.bindings[name2];
      }
      getBindingIdentifier(name2) {
        var _this$getBinding2;
        return (_this$getBinding2 = this.getBinding(name2)) == null ? void 0 : _this$getBinding2.identifier;
      }
      getOwnBindingIdentifier(name2) {
        const binding = this.bindings[name2];
        return binding == null ? void 0 : binding.identifier;
      }
      hasOwnBinding(name2) {
        return !!this.getOwnBinding(name2);
      }
      hasBinding(name2, opts) {
        if (!name2) return false;
        let scope = this;
        do {
          if (scope.hasOwnBinding(name2)) {
            return true;
          }
        } while (scope = scope.parent);
        let noGlobals;
        let noUids;
        if (typeof opts === "object") {
          noGlobals = opts.noGlobals;
          noUids = opts.noUids;
        } else if (typeof opts === "boolean") {
          noGlobals = opts;
        }
        if (!noUids && this.hasUid(name2)) return true;
        if (!noGlobals && _Scope.globals.includes(name2)) return true;
        if (!noGlobals && _Scope.contextVariables.includes(name2)) return true;
        return false;
      }
      parentHasBinding(name2, opts) {
        var _this$parent;
        return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name2, opts);
      }
      moveBindingTo(name2, scope) {
        const info = this.getBinding(name2);
        if (info) {
          info.scope.removeOwnBinding(name2);
          info.scope = scope;
          scope.bindings[name2] = info;
        }
      }
      removeOwnBinding(name2) {
        delete this.bindings[name2];
      }
      removeBinding(name2) {
        var _this$getBinding3;
        (_this$getBinding3 = this.getBinding(name2)) == null || _this$getBinding3.scope.removeOwnBinding(name2);
        let scope = this;
        do {
          if (scope.uids[name2]) {
            scope.uids[name2] = false;
          }
        } while (scope = scope.parent);
      }
      hoistVariables(emit = (id3) => this.push({
        id: id3
      })) {
        this.crawl();
        const seen2 = /* @__PURE__ */ new Set();
        for (const name2 of Object.keys(this.bindings)) {
          const binding = this.bindings[name2];
          if (!binding) continue;
          const {
            path: path9
          } = binding;
          if (!path9.isVariableDeclarator()) continue;
          const {
            parent,
            parentPath
          } = path9;
          if (parent.kind !== "var" || seen2.has(parent)) continue;
          seen2.add(path9.parent);
          let firstId;
          const init2 = [];
          for (const decl2 of parent.declarations) {
            var _firstId;
            (_firstId = firstId) != null ? _firstId : firstId = decl2.id;
            if (decl2.init) {
              init2.push(assignmentExpression("=", decl2.id, decl2.init));
            }
            const ids = Object.keys(getBindingIdentifiers(decl2, false, true, true));
            for (const name3 of ids) {
              emit(identifier(name3), decl2.init != null);
            }
          }
          if (parentPath.parentPath.isFor({
            left: parent
          })) {
            parentPath.replaceWith(firstId);
          } else if (init2.length === 0) {
            parentPath.remove();
          } else {
            const expr = init2.length === 1 ? init2[0] : sequenceExpression(init2);
            if (parentPath.parentPath.isForStatement({
              init: parent
            })) {
              parentPath.replaceWith(expr);
            } else {
              parentPath.replaceWith(expressionStatement(expr));
            }
          }
        }
      }
    };
    exports2.default = Scope;
    Scope.globals = Object.keys(_globals.builtin);
    Scope.contextVariables = ["arguments", "undefined", "Infinity", "NaN"];
    {
      Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value2) {
        if (map[oldName]) {
          map[newName] = value2;
          map[oldName] = null;
        }
      };
      Scope.prototype.traverse = function(node3, opts, state) {
        (0, _index.default)(node3, opts, this, state, this.path);
      };
      Scope.prototype._generateUid = function _generateUid(name2, i) {
        let id3 = name2;
        if (i > 1) id3 += i;
        return `_${id3}`;
      };
      Scope.prototype.toArray = function toArray(node3, i, arrayLikeIsIterable) {
        if (isIdentifier2(node3)) {
          const binding = this.getBinding(node3.name);
          if (binding != null && binding.constant && binding.path.isGenericType("Array")) {
            return node3;
          }
        }
        if (isArrayExpression(node3)) {
          return node3;
        }
        if (isIdentifier2(node3, {
          name: "arguments"
        })) {
          return callExpression(memberExpression(memberExpression(memberExpression(identifier("Array"), identifier("prototype")), identifier("slice")), identifier("call")), [node3]);
        }
        let helperName;
        const args = [node3];
        if (i === true) {
          helperName = "toConsumableArray";
        } else if (typeof i === "number") {
          args.push(numericLiteral(i));
          helperName = "slicedToArray";
        } else {
          helperName = "toArray";
        }
        if (arrayLikeIsIterable) {
          args.unshift(this.path.hub.addHelper(helperName));
          helperName = "maybeArrayLike";
        }
        return callExpression(this.path.hub.addHelper(helperName), args);
      };
      Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind(...kinds) {
        const ids = /* @__PURE__ */ Object.create(null);
        for (const kind of kinds) {
          let scope = this;
          do {
            for (const name2 of Object.keys(scope.bindings)) {
              const binding = scope.bindings[name2];
              if (binding.kind === kind) ids[name2] = binding;
            }
            scope = scope.parent;
          } while (scope);
        }
        return ids;
      };
      Object.defineProperties(Scope.prototype, {
        parentBlock: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.parent;
          }
        },
        hub: {
          configurable: true,
          enumerable: true,
          get() {
            return this.path.hub;
          }
        }
      });
    }
  }
});

// node_modules/@jridgewell/set-array/dist/set-array.umd.js
var require_set_array_umd = __commonJS({
  "node_modules/@jridgewell/set-array/dist/set-array.umd.js"(exports2, module) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.setArray = {}));
    })(exports2, function(exports3) {
      "use strict";
      class SetArray {
        constructor() {
          this._indexes = { __proto__: null };
          this.array = [];
        }
      }
      function cast2(set2) {
        return set2;
      }
      function get(setarr, key) {
        return cast2(setarr)._indexes[key];
      }
      function put(setarr, key) {
        const index4 = get(setarr, key);
        if (index4 !== void 0)
          return index4;
        const { array: array2, _indexes: indexes } = cast2(setarr);
        const length = array2.push(key);
        return indexes[key] = length - 1;
      }
      function pop(setarr) {
        const { array: array2, _indexes: indexes } = cast2(setarr);
        if (array2.length === 0)
          return;
        const last = array2.pop();
        indexes[last] = void 0;
      }
      function remove(setarr, key) {
        const index4 = get(setarr, key);
        if (index4 === void 0)
          return;
        const { array: array2, _indexes: indexes } = cast2(setarr);
        for (let i = index4 + 1; i < array2.length; i++) {
          const k = array2[i];
          array2[i - 1] = k;
          indexes[k]--;
        }
        indexes[key] = void 0;
        array2.pop();
      }
      exports3.SetArray = SetArray;
      exports3.get = get;
      exports3.pop = pop;
      exports3.put = put;
      exports3.remove = remove;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js
var require_sourcemap_codec_umd = __commonJS({
  "node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.umd.js"(exports2, module) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.sourcemapCodec = {}));
    })(exports2, function(exports3) {
      "use strict";
      const comma5 = ",".charCodeAt(0);
      const semicolon4 = ";".charCodeAt(0);
      const chars4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      const intToChar4 = new Uint8Array(64);
      const charToInt4 = new Uint8Array(128);
      for (let i = 0; i < chars4.length; i++) {
        const c = chars4.charCodeAt(i);
        intToChar4[i] = c;
        charToInt4[c] = i;
      }
      function decodeInteger2(reader2, relative2) {
        let value2 = 0;
        let shift = 0;
        let integer = 0;
        do {
          const c = reader2.next();
          integer = charToInt4[c];
          value2 |= (integer & 31) << shift;
          shift += 5;
        } while (integer & 32);
        const shouldNegate = value2 & 1;
        value2 >>>= 1;
        if (shouldNegate) {
          value2 = -2147483648 | -value2;
        }
        return relative2 + value2;
      }
      function encodeInteger(builder, num, relative2) {
        let delta = num - relative2;
        delta = delta < 0 ? -delta << 1 | 1 : delta << 1;
        do {
          let clamped = delta & 31;
          delta >>>= 5;
          if (delta > 0)
            clamped |= 32;
          builder.write(intToChar4[clamped]);
        } while (delta > 0);
        return num;
      }
      function hasMoreVlq2(reader2, max) {
        if (reader2.pos >= max)
          return false;
        return reader2.peek() !== comma5;
      }
      const bufLength3 = 1024 * 16;
      const td = typeof TextDecoder !== "undefined" ? /* @__PURE__ */ new TextDecoder() : typeof Buffer !== "undefined" ? {
        decode(buf) {
          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
          return out.toString();
        }
      } : {
        decode(buf) {
          let out = "";
          for (let i = 0; i < buf.length; i++) {
            out += String.fromCharCode(buf[i]);
          }
          return out;
        }
      };
      class StringWriter {
        constructor() {
          this.pos = 0;
          this.out = "";
          this.buffer = new Uint8Array(bufLength3);
        }
        write(v) {
          const { buffer } = this;
          buffer[this.pos++] = v;
          if (this.pos === bufLength3) {
            this.out += td.decode(buffer);
            this.pos = 0;
          }
        }
        flush() {
          const { buffer, out, pos } = this;
          return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;
        }
      }
      class StringReader2 {
        constructor(buffer) {
          this.pos = 0;
          this.buffer = buffer;
        }
        next() {
          return this.buffer.charCodeAt(this.pos++);
        }
        peek() {
          return this.buffer.charCodeAt(this.pos);
        }
        indexOf(char) {
          const { buffer, pos } = this;
          const idx = buffer.indexOf(char, pos);
          return idx === -1 ? buffer.length : idx;
        }
      }
      const EMPTY = [];
      function decodeOriginalScopes(input) {
        const { length } = input;
        const reader2 = new StringReader2(input);
        const scopes = [];
        const stack = [];
        let line = 0;
        for (; reader2.pos < length; reader2.pos++) {
          line = decodeInteger2(reader2, line);
          const column = decodeInteger2(reader2, 0);
          if (!hasMoreVlq2(reader2, length)) {
            const last = stack.pop();
            last[2] = line;
            last[3] = column;
            continue;
          }
          const kind = decodeInteger2(reader2, 0);
          const fields = decodeInteger2(reader2, 0);
          const hasName = fields & 1;
          const scope = hasName ? [line, column, 0, 0, kind, decodeInteger2(reader2, 0)] : [line, column, 0, 0, kind];
          let vars = EMPTY;
          if (hasMoreVlq2(reader2, length)) {
            vars = [];
            do {
              const varsIndex = decodeInteger2(reader2, 0);
              vars.push(varsIndex);
            } while (hasMoreVlq2(reader2, length));
          }
          scope.vars = vars;
          scopes.push(scope);
          stack.push(scope);
        }
        return scopes;
      }
      function encodeOriginalScopes(scopes) {
        const writer = new StringWriter();
        for (let i = 0; i < scopes.length; ) {
          i = _encodeOriginalScopes(scopes, i, writer, [0]);
        }
        return writer.flush();
      }
      function _encodeOriginalScopes(scopes, index4, writer, state) {
        const scope = scopes[index4];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;
        if (index4 > 0)
          writer.write(comma5);
        state[0] = encodeInteger(writer, startLine, state[0]);
        encodeInteger(writer, startColumn, 0);
        encodeInteger(writer, kind, 0);
        const fields = scope.length === 6 ? 1 : 0;
        encodeInteger(writer, fields, 0);
        if (scope.length === 6)
          encodeInteger(writer, scope[5], 0);
        for (const v of vars) {
          encodeInteger(writer, v, 0);
        }
        for (index4++; index4 < scopes.length; ) {
          const next = scopes[index4];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index4 = _encodeOriginalScopes(scopes, index4, writer, state);
        }
        writer.write(comma5);
        state[0] = encodeInteger(writer, endLine, state[0]);
        encodeInteger(writer, endColumn, 0);
        return index4;
      }
      function decodeGeneratedRanges(input) {
        const { length } = input;
        const reader2 = new StringReader2(input);
        const ranges = [];
        const stack = [];
        let genLine = 0;
        let definitionSourcesIndex = 0;
        let definitionScopeIndex = 0;
        let callsiteSourcesIndex = 0;
        let callsiteLine = 0;
        let callsiteColumn = 0;
        let bindingLine = 0;
        let bindingColumn = 0;
        do {
          const semi = reader2.indexOf(";");
          let genColumn = 0;
          for (; reader2.pos < semi; reader2.pos++) {
            genColumn = decodeInteger2(reader2, genColumn);
            if (!hasMoreVlq2(reader2, semi)) {
              const last = stack.pop();
              last[2] = genLine;
              last[3] = genColumn;
              continue;
            }
            const fields = decodeInteger2(reader2, 0);
            const hasDefinition = fields & 1;
            const hasCallsite = fields & 2;
            const hasScope = fields & 4;
            let callsite = null;
            let bindings = EMPTY;
            let range2;
            if (hasDefinition) {
              const defSourcesIndex = decodeInteger2(reader2, definitionSourcesIndex);
              definitionScopeIndex = decodeInteger2(reader2, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);
              definitionSourcesIndex = defSourcesIndex;
              range2 = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];
            } else {
              range2 = [genLine, genColumn, 0, 0];
            }
            range2.isScope = !!hasScope;
            if (hasCallsite) {
              const prevCsi = callsiteSourcesIndex;
              const prevLine = callsiteLine;
              callsiteSourcesIndex = decodeInteger2(reader2, callsiteSourcesIndex);
              const sameSource = prevCsi === callsiteSourcesIndex;
              callsiteLine = decodeInteger2(reader2, sameSource ? callsiteLine : 0);
              callsiteColumn = decodeInteger2(reader2, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);
              callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];
            }
            range2.callsite = callsite;
            if (hasMoreVlq2(reader2, semi)) {
              bindings = [];
              do {
                bindingLine = genLine;
                bindingColumn = genColumn;
                const expressionsCount = decodeInteger2(reader2, 0);
                let expressionRanges;
                if (expressionsCount < -1) {
                  expressionRanges = [[decodeInteger2(reader2, 0)]];
                  for (let i = -1; i > expressionsCount; i--) {
                    const prevBl = bindingLine;
                    bindingLine = decodeInteger2(reader2, bindingLine);
                    bindingColumn = decodeInteger2(reader2, bindingLine === prevBl ? bindingColumn : 0);
                    const expression = decodeInteger2(reader2, 0);
                    expressionRanges.push([expression, bindingLine, bindingColumn]);
                  }
                } else {
                  expressionRanges = [[expressionsCount]];
                }
                bindings.push(expressionRanges);
              } while (hasMoreVlq2(reader2, semi));
            }
            range2.bindings = bindings;
            ranges.push(range2);
            stack.push(range2);
          }
          genLine++;
          reader2.pos = semi + 1;
        } while (reader2.pos < length);
        return ranges;
      }
      function encodeGeneratedRanges(ranges) {
        if (ranges.length === 0)
          return "";
        const writer = new StringWriter();
        for (let i = 0; i < ranges.length; ) {
          i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);
        }
        return writer.flush();
      }
      function _encodeGeneratedRanges(ranges, index4, writer, state) {
        const range2 = ranges[index4];
        const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings } = range2;
        if (state[0] < startLine) {
          catchupLine(writer, state[0], startLine);
          state[0] = startLine;
          state[1] = 0;
        } else if (index4 > 0) {
          writer.write(comma5);
        }
        state[1] = encodeInteger(writer, range2[1], state[1]);
        const fields = (range2.length === 6 ? 1 : 0) | (callsite ? 2 : 0) | (isScope ? 4 : 0);
        encodeInteger(writer, fields, 0);
        if (range2.length === 6) {
          const { 4: sourcesIndex, 5: scopesIndex } = range2;
          if (sourcesIndex !== state[2]) {
            state[3] = 0;
          }
          state[2] = encodeInteger(writer, sourcesIndex, state[2]);
          state[3] = encodeInteger(writer, scopesIndex, state[3]);
        }
        if (callsite) {
          const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range2.callsite;
          if (sourcesIndex !== state[4]) {
            state[5] = 0;
            state[6] = 0;
          } else if (callLine !== state[5]) {
            state[6] = 0;
          }
          state[4] = encodeInteger(writer, sourcesIndex, state[4]);
          state[5] = encodeInteger(writer, callLine, state[5]);
          state[6] = encodeInteger(writer, callColumn, state[6]);
        }
        if (bindings) {
          for (const binding of bindings) {
            if (binding.length > 1)
              encodeInteger(writer, -binding.length, 0);
            const expression = binding[0][0];
            encodeInteger(writer, expression, 0);
            let bindingStartLine = startLine;
            let bindingStartColumn = startColumn;
            for (let i = 1; i < binding.length; i++) {
              const expRange = binding[i];
              bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);
              bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);
              encodeInteger(writer, expRange[0], 0);
            }
          }
        }
        for (index4++; index4 < ranges.length; ) {
          const next = ranges[index4];
          const { 0: l, 1: c } = next;
          if (l > endLine || l === endLine && c >= endColumn) {
            break;
          }
          index4 = _encodeGeneratedRanges(ranges, index4, writer, state);
        }
        if (state[0] < endLine) {
          catchupLine(writer, state[0], endLine);
          state[0] = endLine;
          state[1] = 0;
        } else {
          writer.write(comma5);
        }
        state[1] = encodeInteger(writer, endColumn, state[1]);
        return index4;
      }
      function catchupLine(writer, lastLine, line) {
        do {
          writer.write(semicolon4);
        } while (++lastLine < line);
      }
      function decode2(mappings) {
        const { length } = mappings;
        const reader2 = new StringReader2(mappings);
        const decoded = [];
        let genColumn = 0;
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        do {
          const semi = reader2.indexOf(";");
          const line = [];
          let sorted = true;
          let lastCol = 0;
          genColumn = 0;
          while (reader2.pos < semi) {
            let seg;
            genColumn = decodeInteger2(reader2, genColumn);
            if (genColumn < lastCol)
              sorted = false;
            lastCol = genColumn;
            if (hasMoreVlq2(reader2, semi)) {
              sourcesIndex = decodeInteger2(reader2, sourcesIndex);
              sourceLine = decodeInteger2(reader2, sourceLine);
              sourceColumn = decodeInteger2(reader2, sourceColumn);
              if (hasMoreVlq2(reader2, semi)) {
                namesIndex = decodeInteger2(reader2, namesIndex);
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
              } else {
                seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
              }
            } else {
              seg = [genColumn];
            }
            line.push(seg);
            reader2.pos++;
          }
          if (!sorted)
            sort2(line);
          decoded.push(line);
          reader2.pos = semi + 1;
        } while (reader2.pos <= length);
        return decoded;
      }
      function sort2(line) {
        line.sort(sortComparator3);
      }
      function sortComparator3(a, b) {
        return a[0] - b[0];
      }
      function encode2(decoded) {
        const writer = new StringWriter();
        let sourcesIndex = 0;
        let sourceLine = 0;
        let sourceColumn = 0;
        let namesIndex = 0;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          if (i > 0)
            writer.write(semicolon4);
          if (line.length === 0)
            continue;
          let genColumn = 0;
          for (let j = 0; j < line.length; j++) {
            const segment = line[j];
            if (j > 0)
              writer.write(comma5);
            genColumn = encodeInteger(writer, segment[0], genColumn);
            if (segment.length === 1)
              continue;
            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);
            sourceLine = encodeInteger(writer, segment[2], sourceLine);
            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);
            if (segment.length === 4)
              continue;
            namesIndex = encodeInteger(writer, segment[4], namesIndex);
          }
        }
        return writer.flush();
      }
      exports3.decode = decode2;
      exports3.decodeGeneratedRanges = decodeGeneratedRanges;
      exports3.decodeOriginalScopes = decodeOriginalScopes;
      exports3.encode = encode2;
      exports3.encodeGeneratedRanges = encodeGeneratedRanges;
      exports3.encodeOriginalScopes = encodeOriginalScopes;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js
var require_resolve_uri_umd = __commonJS({
  "node_modules/@jridgewell/resolve-uri/dist/resolve-uri.umd.js"(exports2, module) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.resolveURI = factory());
    })(exports2, function() {
      "use strict";
      const schemeRegex2 = /^[\w+.-]+:\/\//;
      const urlRegex2 = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
      const fileRegex2 = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
      function isAbsoluteUrl2(input) {
        return schemeRegex2.test(input);
      }
      function isSchemeRelativeUrl2(input) {
        return input.startsWith("//");
      }
      function isAbsolutePath2(input) {
        return input.startsWith("/");
      }
      function isFileUrl2(input) {
        return input.startsWith("file:");
      }
      function isRelative2(input) {
        return /^[.?#]/.test(input);
      }
      function parseAbsoluteUrl2(input) {
        const match2 = urlRegex2.exec(input);
        return makeUrl2(match2[1], match2[2] || "", match2[3], match2[4] || "", match2[5] || "/", match2[6] || "", match2[7] || "");
      }
      function parseFileUrl2(input) {
        const match2 = fileRegex2.exec(input);
        const path9 = match2[2];
        return makeUrl2("file:", "", match2[1] || "", "", isAbsolutePath2(path9) ? path9 : "/" + path9, match2[3] || "", match2[4] || "");
      }
      function makeUrl2(scheme, user, host, port, path9, query, hash3) {
        return {
          scheme,
          user,
          host,
          port,
          path: path9,
          query,
          hash: hash3,
          type: 7
        };
      }
      function parseUrl3(input) {
        if (isSchemeRelativeUrl2(input)) {
          const url3 = parseAbsoluteUrl2("http:" + input);
          url3.scheme = "";
          url3.type = 6;
          return url3;
        }
        if (isAbsolutePath2(input)) {
          const url3 = parseAbsoluteUrl2("http://foo.com" + input);
          url3.scheme = "";
          url3.host = "";
          url3.type = 5;
          return url3;
        }
        if (isFileUrl2(input))
          return parseFileUrl2(input);
        if (isAbsoluteUrl2(input))
          return parseAbsoluteUrl2(input);
        const url2 = parseAbsoluteUrl2("http://foo.com/" + input);
        url2.scheme = "";
        url2.host = "";
        url2.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
        return url2;
      }
      function stripPathFilename2(path9) {
        if (path9.endsWith("/.."))
          return path9;
        const index4 = path9.lastIndexOf("/");
        return path9.slice(0, index4 + 1);
      }
      function mergePaths2(url2, base) {
        normalizePath4(base, base.type);
        if (url2.path === "/") {
          url2.path = base.path;
        } else {
          url2.path = stripPathFilename2(base.path) + url2.path;
        }
      }
      function normalizePath4(url2, type) {
        const rel = type <= 4;
        const pieces = url2.path.split("/");
        let pointer = 1;
        let positive = 0;
        let addTrailingSlash = false;
        for (let i = 1; i < pieces.length; i++) {
          const piece = pieces[i];
          if (!piece) {
            addTrailingSlash = true;
            continue;
          }
          addTrailingSlash = false;
          if (piece === ".")
            continue;
          if (piece === "..") {
            if (positive) {
              addTrailingSlash = true;
              positive--;
              pointer--;
            } else if (rel) {
              pieces[pointer++] = piece;
            }
            continue;
          }
          pieces[pointer++] = piece;
          positive++;
        }
        let path9 = "";
        for (let i = 1; i < pointer; i++) {
          path9 += "/" + pieces[i];
        }
        if (!path9 || addTrailingSlash && !path9.endsWith("/..")) {
          path9 += "/";
        }
        url2.path = path9;
      }
      function resolve8(input, base) {
        if (!input && !base)
          return "";
        const url2 = parseUrl3(input);
        let inputType = url2.type;
        if (base && inputType !== 7) {
          const baseUrl = parseUrl3(base);
          const baseType = baseUrl.type;
          switch (inputType) {
            case 1:
              url2.hash = baseUrl.hash;
            // fall through
            case 2:
              url2.query = baseUrl.query;
            // fall through
            case 3:
            case 4:
              mergePaths2(url2, baseUrl);
            // fall through
            case 5:
              url2.user = baseUrl.user;
              url2.host = baseUrl.host;
              url2.port = baseUrl.port;
            // fall through
            case 6:
              url2.scheme = baseUrl.scheme;
          }
          if (baseType > inputType)
            inputType = baseType;
        }
        normalizePath4(url2, inputType);
        const queryHash = url2.query + url2.hash;
        switch (inputType) {
          // This is impossible, because of the empty checks at the start of the function.
          // case UrlType.Empty:
          case 2:
          case 3:
            return queryHash;
          case 4: {
            const path9 = url2.path.slice(1);
            if (!path9)
              return queryHash || ".";
            if (isRelative2(base || input) && !isRelative2(path9)) {
              return "./" + path9 + queryHash;
            }
            return path9 + queryHash;
          }
          case 5:
            return url2.path + queryHash;
          default:
            return url2.scheme + "//" + url2.user + url2.host + url2.port + url2.path + queryHash;
        }
      }
      return resolve8;
    });
  }
});

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js
var require_trace_mapping_umd = __commonJS({
  "node_modules/@jridgewell/trace-mapping/dist/trace-mapping.umd.js"(exports2, module) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module !== "undefined" ? factory(exports2, require_sourcemap_codec_umd(), require_resolve_uri_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/sourcemap-codec", "@jridgewell/resolve-uri"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.traceMapping = {}, global2.sourcemapCodec, global2.resolveURI));
    })(exports2, function(exports3, sourcemapCodec, resolveUri) {
      "use strict";
      function resolve8(input, base) {
        if (base && !base.endsWith("/"))
          base += "/";
        return resolveUri(input, base);
      }
      function stripFilename2(path9) {
        if (!path9)
          return "";
        const index4 = path9.lastIndexOf("/");
        return path9.slice(0, index4 + 1);
      }
      const COLUMN2 = 0;
      const SOURCES_INDEX2 = 1;
      const SOURCE_LINE2 = 2;
      const SOURCE_COLUMN2 = 3;
      const NAMES_INDEX2 = 4;
      const REV_GENERATED_LINE = 1;
      const REV_GENERATED_COLUMN = 2;
      function maybeSort2(mappings, owned) {
        const unsortedIndex = nextUnsortedSegmentLine2(mappings, 0);
        if (unsortedIndex === mappings.length)
          return mappings;
        if (!owned)
          mappings = mappings.slice();
        for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine2(mappings, i + 1)) {
          mappings[i] = sortSegments2(mappings[i], owned);
        }
        return mappings;
      }
      function nextUnsortedSegmentLine2(mappings, start) {
        for (let i = start; i < mappings.length; i++) {
          if (!isSorted2(mappings[i]))
            return i;
        }
        return mappings.length;
      }
      function isSorted2(line) {
        for (let j = 1; j < line.length; j++) {
          if (line[j][COLUMN2] < line[j - 1][COLUMN2]) {
            return false;
          }
        }
        return true;
      }
      function sortSegments2(line, owned) {
        if (!owned)
          line = line.slice();
        return line.sort(sortComparator3);
      }
      function sortComparator3(a, b) {
        return a[COLUMN2] - b[COLUMN2];
      }
      let found2 = false;
      function binarySearch2(haystack, needle, low, high) {
        while (low <= high) {
          const mid = low + (high - low >> 1);
          const cmp = haystack[mid][COLUMN2] - needle;
          if (cmp === 0) {
            found2 = true;
            return mid;
          }
          if (cmp < 0) {
            low = mid + 1;
          } else {
            high = mid - 1;
          }
        }
        found2 = false;
        return low - 1;
      }
      function upperBound2(haystack, needle, index4) {
        for (let i = index4 + 1; i < haystack.length; index4 = i++) {
          if (haystack[i][COLUMN2] !== needle)
            break;
        }
        return index4;
      }
      function lowerBound2(haystack, needle, index4) {
        for (let i = index4 - 1; i >= 0; index4 = i--) {
          if (haystack[i][COLUMN2] !== needle)
            break;
        }
        return index4;
      }
      function memoizedState2() {
        return {
          lastKey: -1,
          lastNeedle: -1,
          lastIndex: -1
        };
      }
      function memoizedBinarySearch2(haystack, needle, state, key) {
        const { lastKey, lastNeedle, lastIndex } = state;
        let low = 0;
        let high = haystack.length - 1;
        if (key === lastKey) {
          if (needle === lastNeedle) {
            found2 = lastIndex !== -1 && haystack[lastIndex][COLUMN2] === needle;
            return lastIndex;
          }
          if (needle >= lastNeedle) {
            low = lastIndex === -1 ? 0 : lastIndex;
          } else {
            high = lastIndex;
          }
        }
        state.lastKey = key;
        state.lastNeedle = needle;
        return state.lastIndex = binarySearch2(haystack, needle, low, high);
      }
      function buildBySources(decoded, memos) {
        const sources = memos.map(buildNullArray);
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            if (seg.length === 1)
              continue;
            const sourceIndex2 = seg[SOURCES_INDEX2];
            const sourceLine = seg[SOURCE_LINE2];
            const sourceColumn = seg[SOURCE_COLUMN2];
            const originalSource = sources[sourceIndex2];
            const originalLine = originalSource[sourceLine] || (originalSource[sourceLine] = []);
            const memo = memos[sourceIndex2];
            let index4 = upperBound2(originalLine, sourceColumn, memoizedBinarySearch2(originalLine, sourceColumn, memo, sourceLine));
            memo.lastIndex = ++index4;
            insert(originalLine, index4, [sourceColumn, i, seg[COLUMN2]]);
          }
        }
        return sources;
      }
      function insert(array2, index4, value2) {
        for (let i = array2.length; i > index4; i--) {
          array2[i] = array2[i - 1];
        }
        array2[index4] = value2;
      }
      function buildNullArray() {
        return { __proto__: null };
      }
      const AnyMap = function(map, mapUrl) {
        const parsed = parse6(map);
        if (!("sections" in parsed)) {
          return new TraceMap2(parsed, mapUrl);
        }
        const mappings = [];
        const sources = [];
        const sourcesContent = [];
        const names = [];
        const ignoreList = [];
        recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);
        const joined = {
          version: 3,
          file: parsed.file,
          names,
          sources,
          sourcesContent,
          mappings,
          ignoreList
        };
        return presortedDecodedMap(joined);
      };
      function parse6(map) {
        return typeof map === "string" ? JSON.parse(map) : map;
      }
      function recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const { sections } = input;
        for (let i = 0; i < sections.length; i++) {
          const { map, offset } = sections[i];
          let sl = stopLine;
          let sc = stopColumn;
          if (i + 1 < sections.length) {
            const nextOffset = sections[i + 1].offset;
            sl = Math.min(stopLine, lineOffset + nextOffset.line);
            if (sl === stopLine) {
              sc = Math.min(stopColumn, columnOffset + nextOffset.column);
            } else if (sl < stopLine) {
              sc = columnOffset + nextOffset.column;
            }
          }
          addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);
        }
      }
      function addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {
        const parsed = parse6(input);
        if ("sections" in parsed)
          return recurse(...arguments);
        const map = new TraceMap2(parsed, mapUrl);
        const sourcesOffset = sources.length;
        const namesOffset = names.length;
        const decoded = decodedMappings2(map);
        const { resolvedSources, sourcesContent: contents2, ignoreList: ignores } = map;
        append2(sources, resolvedSources);
        append2(names, map.names);
        if (contents2)
          append2(sourcesContent, contents2);
        else
          for (let i = 0; i < resolvedSources.length; i++)
            sourcesContent.push(null);
        if (ignores)
          for (let i = 0; i < ignores.length; i++)
            ignoreList.push(ignores[i] + sourcesOffset);
        for (let i = 0; i < decoded.length; i++) {
          const lineI = lineOffset + i;
          if (lineI > stopLine)
            return;
          const out = getLine(mappings, lineI);
          const cOffset = i === 0 ? columnOffset : 0;
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const column = cOffset + seg[COLUMN2];
            if (lineI === stopLine && column >= stopColumn)
              return;
            if (seg.length === 1) {
              out.push([column]);
              continue;
            }
            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX2];
            const sourceLine = seg[SOURCE_LINE2];
            const sourceColumn = seg[SOURCE_COLUMN2];
            out.push(seg.length === 4 ? [column, sourcesIndex, sourceLine, sourceColumn] : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX2]]);
          }
        }
      }
      function append2(arr, other) {
        for (let i = 0; i < other.length; i++)
          arr.push(other[i]);
      }
      function getLine(arr, index4) {
        for (let i = arr.length; i <= index4; i++)
          arr[i] = [];
        return arr[index4];
      }
      const LINE_GTR_ZERO2 = "`line` must be greater than 0 (lines start at line 1)";
      const COL_GTR_EQ_ZERO2 = "`column` must be greater than or equal to 0 (columns start at column 0)";
      const LEAST_UPPER_BOUND2 = -1;
      const GREATEST_LOWER_BOUND2 = 1;
      class TraceMap2 {
        constructor(map, mapUrl) {
          const isString3 = typeof map === "string";
          if (!isString3 && map._decodedMemo)
            return map;
          const parsed = isString3 ? JSON.parse(map) : map;
          const { version: version4, file, names, sourceRoot, sources, sourcesContent } = parsed;
          this.version = version4;
          this.file = file;
          this.names = names || [];
          this.sourceRoot = sourceRoot;
          this.sources = sources;
          this.sourcesContent = sourcesContent;
          this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
          const from = resolve8(sourceRoot || "", stripFilename2(mapUrl));
          this.resolvedSources = sources.map((s) => resolve8(s || "", from));
          const { mappings } = parsed;
          if (typeof mappings === "string") {
            this._encoded = mappings;
            this._decoded = void 0;
          } else {
            this._encoded = void 0;
            this._decoded = maybeSort2(mappings, isString3);
          }
          this._decodedMemo = memoizedState2();
          this._bySources = void 0;
          this._bySourceMemos = void 0;
        }
      }
      function cast2(map) {
        return map;
      }
      function encodedMappings(map) {
        var _a;
        var _b;
        return (_a = (_b = cast2(map))._encoded) !== null && _a !== void 0 ? _a : _b._encoded = sourcemapCodec.encode(cast2(map)._decoded);
      }
      function decodedMappings2(map) {
        var _a;
        return (_a = cast2(map))._decoded || (_a._decoded = sourcemapCodec.decode(cast2(map)._encoded));
      }
      function traceSegment(map, line, column) {
        const decoded = decodedMappings2(map);
        if (line >= decoded.length)
          return null;
        const segments = decoded[line];
        const index4 = traceSegmentInternal2(segments, cast2(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND2);
        return index4 === -1 ? null : segments[index4];
      }
      function originalPositionFor2(map, needle) {
        let { line, column, bias } = needle;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO2);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO2);
        const decoded = decodedMappings2(map);
        if (line >= decoded.length)
          return OMapping2(null, null, null, null);
        const segments = decoded[line];
        const index4 = traceSegmentInternal2(segments, cast2(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND2);
        if (index4 === -1)
          return OMapping2(null, null, null, null);
        const segment = segments[index4];
        if (segment.length === 1)
          return OMapping2(null, null, null, null);
        const { names, resolvedSources } = map;
        return OMapping2(resolvedSources[segment[SOURCES_INDEX2]], segment[SOURCE_LINE2] + 1, segment[SOURCE_COLUMN2], segment.length === 5 ? names[segment[NAMES_INDEX2]] : null);
      }
      function generatedPositionFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND2, false);
      }
      function allGeneratedPositionsFor(map, needle) {
        const { source, line, column, bias } = needle;
        return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND2, true);
      }
      function eachMapping(map, cb) {
        const decoded = decodedMappings2(map);
        const { names, resolvedSources } = map;
        for (let i = 0; i < decoded.length; i++) {
          const line = decoded[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generatedLine = i + 1;
            const generatedColumn = seg[0];
            let source = null;
            let originalLine = null;
            let originalColumn = null;
            let name2 = null;
            if (seg.length !== 1) {
              source = resolvedSources[seg[1]];
              originalLine = seg[2] + 1;
              originalColumn = seg[3];
            }
            if (seg.length === 5)
              name2 = names[seg[4]];
            cb({
              generatedLine,
              generatedColumn,
              source,
              originalLine,
              originalColumn,
              name: name2
            });
          }
        }
      }
      function sourceIndex(map, source) {
        const { sources, resolvedSources } = map;
        let index4 = sources.indexOf(source);
        if (index4 === -1)
          index4 = resolvedSources.indexOf(source);
        return index4;
      }
      function sourceContentFor(map, source) {
        const { sourcesContent } = map;
        if (sourcesContent == null)
          return null;
        const index4 = sourceIndex(map, source);
        return index4 === -1 ? null : sourcesContent[index4];
      }
      function isIgnored(map, source) {
        const { ignoreList } = map;
        if (ignoreList == null)
          return false;
        const index4 = sourceIndex(map, source);
        return index4 === -1 ? false : ignoreList.includes(index4);
      }
      function presortedDecodedMap(map, mapUrl) {
        const tracer = new TraceMap2(clone(map, []), mapUrl);
        cast2(tracer)._decoded = map.mappings;
        return tracer;
      }
      function decodedMap(map) {
        return clone(map, decodedMappings2(map));
      }
      function encodedMap(map) {
        return clone(map, encodedMappings(map));
      }
      function clone(map, mappings) {
        return {
          version: map.version,
          file: map.file,
          names: map.names,
          sourceRoot: map.sourceRoot,
          sources: map.sources,
          sourcesContent: map.sourcesContent,
          mappings,
          ignoreList: map.ignoreList || map.x_google_ignoreList
        };
      }
      function OMapping2(source, line, column, name2) {
        return { source, line, column, name: name2 };
      }
      function GMapping(line, column) {
        return { line, column };
      }
      function traceSegmentInternal2(segments, memo, line, column, bias) {
        let index4 = memoizedBinarySearch2(segments, column, memo, line);
        if (found2) {
          index4 = (bias === LEAST_UPPER_BOUND2 ? upperBound2 : lowerBound2)(segments, column, index4);
        } else if (bias === LEAST_UPPER_BOUND2)
          index4++;
        if (index4 === -1 || index4 === segments.length)
          return -1;
        return index4;
      }
      function sliceGeneratedPositions(segments, memo, line, column, bias) {
        let min2 = traceSegmentInternal2(segments, memo, line, column, GREATEST_LOWER_BOUND2);
        if (!found2 && bias === LEAST_UPPER_BOUND2)
          min2++;
        if (min2 === -1 || min2 === segments.length)
          return [];
        const matchedColumn = found2 ? column : segments[min2][COLUMN2];
        if (!found2)
          min2 = lowerBound2(segments, matchedColumn, min2);
        const max = upperBound2(segments, matchedColumn, min2);
        const result = [];
        for (; min2 <= max; min2++) {
          const segment = segments[min2];
          result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));
        }
        return result;
      }
      function generatedPosition(map, source, line, column, bias, all) {
        var _a;
        line--;
        if (line < 0)
          throw new Error(LINE_GTR_ZERO2);
        if (column < 0)
          throw new Error(COL_GTR_EQ_ZERO2);
        const { sources, resolvedSources } = map;
        let sourceIndex2 = sources.indexOf(source);
        if (sourceIndex2 === -1)
          sourceIndex2 = resolvedSources.indexOf(source);
        if (sourceIndex2 === -1)
          return all ? [] : GMapping(null, null);
        const generated = (_a = cast2(map))._bySources || (_a._bySources = buildBySources(decodedMappings2(map), cast2(map)._bySourceMemos = sources.map(memoizedState2)));
        const segments = generated[sourceIndex2][line];
        if (segments == null)
          return all ? [] : GMapping(null, null);
        const memo = cast2(map)._bySourceMemos[sourceIndex2];
        if (all)
          return sliceGeneratedPositions(segments, memo, line, column, bias);
        const index4 = traceSegmentInternal2(segments, memo, line, column, bias);
        if (index4 === -1)
          return GMapping(null, null);
        const segment = segments[index4];
        return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);
      }
      exports3.AnyMap = AnyMap;
      exports3.GREATEST_LOWER_BOUND = GREATEST_LOWER_BOUND2;
      exports3.LEAST_UPPER_BOUND = LEAST_UPPER_BOUND2;
      exports3.TraceMap = TraceMap2;
      exports3.allGeneratedPositionsFor = allGeneratedPositionsFor;
      exports3.decodedMap = decodedMap;
      exports3.decodedMappings = decodedMappings2;
      exports3.eachMapping = eachMapping;
      exports3.encodedMap = encodedMap;
      exports3.encodedMappings = encodedMappings;
      exports3.generatedPositionFor = generatedPositionFor;
      exports3.isIgnored = isIgnored;
      exports3.originalPositionFor = originalPositionFor2;
      exports3.presortedDecodedMap = presortedDecodedMap;
      exports3.sourceContentFor = sourceContentFor;
      exports3.traceSegment = traceSegment;
    });
  }
});

// node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js
var require_gen_mapping_umd = __commonJS({
  "node_modules/@jridgewell/gen-mapping/dist/gen-mapping.umd.js"(exports2, module) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module !== "undefined" ? factory(exports2, require_set_array_umd(), require_sourcemap_codec_umd(), require_trace_mapping_umd()) : typeof define === "function" && define.amd ? define(["exports", "@jridgewell/set-array", "@jridgewell/sourcemap-codec", "@jridgewell/trace-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.genMapping = {}, global2.setArray, global2.sourcemapCodec, global2.traceMapping));
    })(exports2, function(exports3, setArray, sourcemapCodec, traceMapping) {
      "use strict";
      const COLUMN2 = 0;
      const SOURCES_INDEX2 = 1;
      const SOURCE_LINE2 = 2;
      const SOURCE_COLUMN2 = 3;
      const NAMES_INDEX2 = 4;
      const NO_NAME = -1;
      class GenMapping {
        constructor({ file, sourceRoot } = {}) {
          this._names = new setArray.SetArray();
          this._sources = new setArray.SetArray();
          this._sourcesContent = [];
          this._mappings = [];
          this.file = file;
          this.sourceRoot = sourceRoot;
          this._ignoreList = new setArray.SetArray();
        }
      }
      function cast2(map) {
        return map;
      }
      function addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content) {
        return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content);
      }
      function addMapping(map, mapping) {
        return addMappingInternal(false, map, mapping);
      }
      const maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content) => {
        return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content);
      };
      const maybeAddMapping = (map, mapping) => {
        return addMappingInternal(true, map, mapping);
      };
      function setSourceContent(map, source, content) {
        const { _sources: sources, _sourcesContent: sourcesContent } = cast2(map);
        const index4 = setArray.put(sources, source);
        sourcesContent[index4] = content;
      }
      function setIgnore(map, source, ignore = true) {
        const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast2(map);
        const index4 = setArray.put(sources, source);
        if (index4 === sourcesContent.length)
          sourcesContent[index4] = null;
        if (ignore)
          setArray.put(ignoreList, index4);
        else
          setArray.remove(ignoreList, index4);
      }
      function toDecodedMap(map) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList } = cast2(map);
        removeEmptyFinalLines(mappings);
        return {
          version: 3,
          file: map.file || void 0,
          names: names.array,
          sourceRoot: map.sourceRoot || void 0,
          sources: sources.array,
          sourcesContent,
          mappings,
          ignoreList: ignoreList.array
        };
      }
      function toEncodedMap(map) {
        const decoded = toDecodedMap(map);
        return Object.assign(Object.assign({}, decoded), { mappings: sourcemapCodec.encode(decoded.mappings) });
      }
      function fromMap(input) {
        const map = new traceMapping.TraceMap(input);
        const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });
        putAll(cast2(gen)._names, map.names);
        putAll(cast2(gen)._sources, map.sources);
        cast2(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);
        cast2(gen)._mappings = traceMapping.decodedMappings(map);
        if (map.ignoreList)
          putAll(cast2(gen)._ignoreList, map.ignoreList);
        return gen;
      }
      function allMappings(map) {
        const out = [];
        const { _mappings: mappings, _sources: sources, _names: names } = cast2(map);
        for (let i = 0; i < mappings.length; i++) {
          const line = mappings[i];
          for (let j = 0; j < line.length; j++) {
            const seg = line[j];
            const generated = { line: i + 1, column: seg[COLUMN2] };
            let source = void 0;
            let original = void 0;
            let name2 = void 0;
            if (seg.length !== 1) {
              source = sources.array[seg[SOURCES_INDEX2]];
              original = { line: seg[SOURCE_LINE2] + 1, column: seg[SOURCE_COLUMN2] };
              if (seg.length === 5)
                name2 = names.array[seg[NAMES_INDEX2]];
            }
            out.push({ generated, source, original, name: name2 });
          }
        }
        return out;
      }
      function addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name2, content) {
        const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names } = cast2(map);
        const line = getLine(mappings, genLine);
        const index4 = getColumnIndex(line, genColumn);
        if (!source) {
          if (skipable && skipSourceless(line, index4))
            return;
          return insert(line, index4, [genColumn]);
        }
        const sourcesIndex = setArray.put(sources, source);
        const namesIndex = name2 ? setArray.put(names, name2) : NO_NAME;
        if (sourcesIndex === sourcesContent.length)
          sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;
        if (skipable && skipSource(line, index4, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {
          return;
        }
        return insert(line, index4, name2 ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex] : [genColumn, sourcesIndex, sourceLine, sourceColumn]);
      }
      function getLine(mappings, index4) {
        for (let i = mappings.length; i <= index4; i++) {
          mappings[i] = [];
        }
        return mappings[index4];
      }
      function getColumnIndex(line, genColumn) {
        let index4 = line.length;
        for (let i = index4 - 1; i >= 0; index4 = i--) {
          const current = line[i];
          if (genColumn >= current[COLUMN2])
            break;
        }
        return index4;
      }
      function insert(array2, index4, value2) {
        for (let i = array2.length; i > index4; i--) {
          array2[i] = array2[i - 1];
        }
        array2[index4] = value2;
      }
      function removeEmptyFinalLines(mappings) {
        const { length } = mappings;
        let len = length;
        for (let i = len - 1; i >= 0; len = i, i--) {
          if (mappings[i].length > 0)
            break;
        }
        if (len < length)
          mappings.length = len;
      }
      function putAll(setarr, array2) {
        for (let i = 0; i < array2.length; i++)
          setArray.put(setarr, array2[i]);
      }
      function skipSourceless(line, index4) {
        if (index4 === 0)
          return true;
        const prev = line[index4 - 1];
        return prev.length === 1;
      }
      function skipSource(line, index4, sourcesIndex, sourceLine, sourceColumn, namesIndex) {
        if (index4 === 0)
          return false;
        const prev = line[index4 - 1];
        if (prev.length === 1)
          return false;
        return sourcesIndex === prev[SOURCES_INDEX2] && sourceLine === prev[SOURCE_LINE2] && sourceColumn === prev[SOURCE_COLUMN2] && namesIndex === (prev.length === 5 ? prev[NAMES_INDEX2] : NO_NAME);
      }
      function addMappingInternal(skipable, map, mapping) {
        const { generated, source, original, name: name2, content } = mapping;
        if (!source) {
          return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);
        }
        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name2, content);
      }
      exports3.GenMapping = GenMapping;
      exports3.addMapping = addMapping;
      exports3.addSegment = addSegment;
      exports3.allMappings = allMappings;
      exports3.fromMap = fromMap;
      exports3.maybeAddMapping = maybeAddMapping;
      exports3.maybeAddSegment = maybeAddSegment;
      exports3.setIgnore = setIgnore;
      exports3.setSourceContent = setSourceContent;
      exports3.toDecodedMap = toDecodedMap;
      exports3.toEncodedMap = toEncodedMap;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@babel/generator/lib/source-map.js
var require_source_map2 = __commonJS({
  "node_modules/@babel/generator/lib/source-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _genMapping = require_gen_mapping_umd();
    var _traceMapping = require_trace_mapping_umd();
    var SourceMap = class {
      constructor(opts, code) {
        var _opts$sourceFileName;
        this._map = void 0;
        this._rawMappings = void 0;
        this._sourceFileName = void 0;
        this._lastGenLine = 0;
        this._lastSourceLine = 0;
        this._lastSourceColumn = 0;
        this._inputMap = void 0;
        const map = this._map = new _genMapping.GenMapping({
          sourceRoot: opts.sourceRoot
        });
        this._sourceFileName = (_opts$sourceFileName = opts.sourceFileName) == null ? void 0 : _opts$sourceFileName.replace(/\\/g, "/");
        this._rawMappings = void 0;
        if (opts.inputSourceMap) {
          this._inputMap = new _traceMapping.TraceMap(opts.inputSourceMap);
          const resolvedSources = this._inputMap.resolvedSources;
          if (resolvedSources.length) {
            for (let i = 0; i < resolvedSources.length; i++) {
              var _this$_inputMap$sourc;
              (0, _genMapping.setSourceContent)(map, resolvedSources[i], (_this$_inputMap$sourc = this._inputMap.sourcesContent) == null ? void 0 : _this$_inputMap$sourc[i]);
            }
          }
        }
        if (typeof code === "string" && !opts.inputSourceMap) {
          (0, _genMapping.setSourceContent)(map, this._sourceFileName, code);
        } else if (typeof code === "object") {
          for (const sourceFileName of Object.keys(code)) {
            (0, _genMapping.setSourceContent)(map, sourceFileName.replace(/\\/g, "/"), code[sourceFileName]);
          }
        }
      }
      get() {
        return (0, _genMapping.toEncodedMap)(this._map);
      }
      getDecoded() {
        return (0, _genMapping.toDecodedMap)(this._map);
      }
      getRawMappings() {
        return this._rawMappings || (this._rawMappings = (0, _genMapping.allMappings)(this._map));
      }
      mark(generated, line, column, identifierName, identifierNamePos, filename) {
        var _originalMapping;
        this._rawMappings = void 0;
        let originalMapping;
        if (line != null) {
          if (this._inputMap) {
            originalMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, {
              line,
              column
            });
            if (!originalMapping.name && identifierNamePos) {
              const originalIdentifierMapping = (0, _traceMapping.originalPositionFor)(this._inputMap, identifierNamePos);
              if (originalIdentifierMapping.name) {
                identifierName = originalIdentifierMapping.name;
              }
            }
          } else {
            originalMapping = {
              source: (filename == null ? void 0 : filename.replace(/\\/g, "/")) || this._sourceFileName,
              line,
              column
            };
          }
        }
        (0, _genMapping.maybeAddMapping)(this._map, {
          name: identifierName,
          generated,
          source: (_originalMapping = originalMapping) == null ? void 0 : _originalMapping.source,
          original: originalMapping
        });
      }
    };
    exports2.default = SourceMap;
  }
});

// node_modules/@babel/generator/lib/buffer.js
var require_buffer = __commonJS({
  "node_modules/@babel/generator/lib/buffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Buffer2 = class {
      constructor(map, indentChar) {
        this._map = null;
        this._buf = "";
        this._str = "";
        this._appendCount = 0;
        this._last = 0;
        this._queue = [];
        this._queueCursor = 0;
        this._canMarkIdName = true;
        this._indentChar = "";
        this._fastIndentations = [];
        this._position = {
          line: 1,
          column: 0
        };
        this._sourcePosition = {
          identifierName: void 0,
          identifierNamePos: void 0,
          line: void 0,
          column: void 0,
          filename: void 0
        };
        this._map = map;
        this._indentChar = indentChar;
        for (let i = 0; i < 64; i++) {
          this._fastIndentations.push(indentChar.repeat(i));
        }
        this._allocQueue();
      }
      _allocQueue() {
        const queue2 = this._queue;
        for (let i = 0; i < 16; i++) {
          queue2.push({
            char: 0,
            repeat: 1,
            line: void 0,
            column: void 0,
            identifierName: void 0,
            identifierNamePos: void 0,
            filename: ""
          });
        }
      }
      _pushQueue(char, repeat, line, column, filename) {
        const cursor = this._queueCursor;
        if (cursor === this._queue.length) {
          this._allocQueue();
        }
        const item = this._queue[cursor];
        item.char = char;
        item.repeat = repeat;
        item.line = line;
        item.column = column;
        item.filename = filename;
        this._queueCursor++;
      }
      _popQueue() {
        if (this._queueCursor === 0) {
          throw new Error("Cannot pop from empty queue");
        }
        return this._queue[--this._queueCursor];
      }
      get() {
        this._flush();
        const map = this._map;
        const result = {
          code: (this._buf + this._str).trimRight(),
          decodedMap: map == null ? void 0 : map.getDecoded(),
          get __mergedMap() {
            return this.map;
          },
          get map() {
            const resultMap = map ? map.get() : null;
            result.map = resultMap;
            return resultMap;
          },
          set map(value2) {
            Object.defineProperty(result, "map", {
              value: value2,
              writable: true
            });
          },
          get rawMappings() {
            const mappings = map == null ? void 0 : map.getRawMappings();
            result.rawMappings = mappings;
            return mappings;
          },
          set rawMappings(value2) {
            Object.defineProperty(result, "rawMappings", {
              value: value2,
              writable: true
            });
          }
        };
        return result;
      }
      append(str2, maybeNewline) {
        this._flush();
        this._append(str2, this._sourcePosition, maybeNewline);
      }
      appendChar(char) {
        this._flush();
        this._appendChar(char, 1, this._sourcePosition);
      }
      queue(char) {
        if (char === 10) {
          while (this._queueCursor !== 0) {
            const char2 = this._queue[this._queueCursor - 1].char;
            if (char2 !== 32 && char2 !== 9) {
              break;
            }
            this._queueCursor--;
          }
        }
        const sourcePosition = this._sourcePosition;
        this._pushQueue(char, 1, sourcePosition.line, sourcePosition.column, sourcePosition.filename);
      }
      queueIndentation(repeat) {
        if (repeat === 0) return;
        this._pushQueue(-1, repeat, void 0, void 0, void 0);
      }
      _flush() {
        const queueCursor = this._queueCursor;
        const queue2 = this._queue;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue2[i];
          this._appendChar(item.char, item.repeat, item);
        }
        this._queueCursor = 0;
      }
      _appendChar(char, repeat, sourcePos) {
        this._last = char;
        if (char === -1) {
          const fastIndentation = this._fastIndentations[repeat];
          if (fastIndentation !== void 0) {
            this._str += fastIndentation;
          } else {
            this._str += repeat > 1 ? this._indentChar.repeat(repeat) : this._indentChar;
          }
        } else {
          this._str += repeat > 1 ? String.fromCharCode(char).repeat(repeat) : String.fromCharCode(char);
        }
        if (char !== 10) {
          this._mark(sourcePos.line, sourcePos.column, sourcePos.identifierName, sourcePos.identifierNamePos, sourcePos.filename);
          this._position.column += repeat;
        } else {
          this._position.line++;
          this._position.column = 0;
        }
        if (this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
      }
      _append(str2, sourcePos, maybeNewline) {
        const len = str2.length;
        const position = this._position;
        this._last = str2.charCodeAt(len - 1);
        if (++this._appendCount > 4096) {
          +this._str;
          this._buf += this._str;
          this._str = str2;
          this._appendCount = 0;
        } else {
          this._str += str2;
        }
        if (!maybeNewline && !this._map) {
          position.column += len;
          return;
        }
        const {
          column,
          identifierName,
          identifierNamePos,
          filename
        } = sourcePos;
        let line = sourcePos.line;
        if ((identifierName != null || identifierNamePos != null) && this._canMarkIdName) {
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        let i = str2.indexOf("\n");
        let last = 0;
        if (i !== 0) {
          this._mark(line, column, identifierName, identifierNamePos, filename);
        }
        while (i !== -1) {
          position.line++;
          position.column = 0;
          last = i + 1;
          if (last < len && line !== void 0) {
            this._mark(++line, 0, null, null, filename);
          }
          i = str2.indexOf("\n", last);
        }
        position.column += len - last;
      }
      _mark(line, column, identifierName, identifierNamePos, filename) {
        var _this$_map;
        (_this$_map = this._map) == null || _this$_map.mark(this._position, line, column, identifierName, identifierNamePos, filename);
      }
      removeTrailingNewline() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 10) {
          this._queueCursor--;
        }
      }
      removeLastSemicolon() {
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0 && this._queue[queueCursor - 1].char === 59) {
          this._queueCursor--;
        }
      }
      getLastChar() {
        const queueCursor = this._queueCursor;
        return queueCursor !== 0 ? this._queue[queueCursor - 1].char : this._last;
      }
      getNewlineCount() {
        const queueCursor = this._queueCursor;
        let count = 0;
        if (queueCursor === 0) return this._last === 10 ? 1 : 0;
        for (let i = queueCursor - 1; i >= 0; i--) {
          if (this._queue[i].char !== 10) {
            break;
          }
          count++;
        }
        return count === queueCursor && this._last === 10 ? count + 1 : count;
      }
      endsWithCharAndNewline() {
        const queue2 = this._queue;
        const queueCursor = this._queueCursor;
        if (queueCursor !== 0) {
          const lastCp = queue2[queueCursor - 1].char;
          if (lastCp !== 10) return;
          if (queueCursor > 1) {
            return queue2[queueCursor - 2].char;
          } else {
            return this._last;
          }
        }
      }
      hasContent() {
        return this._queueCursor !== 0 || !!this._last;
      }
      exactSource(loc, cb) {
        if (!this._map) {
          cb();
          return;
        }
        this.source("start", loc);
        const identifierName = loc.identifierName;
        const sourcePos = this._sourcePosition;
        if (identifierName) {
          this._canMarkIdName = false;
          sourcePos.identifierName = identifierName;
        }
        cb();
        if (identifierName) {
          this._canMarkIdName = true;
          sourcePos.identifierName = void 0;
          sourcePos.identifierNamePos = void 0;
        }
        this.source("end", loc);
      }
      source(prop, loc) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, 0);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!this._map) return;
        this._normalizePosition(prop, loc, columnOffset);
      }
      _normalizePosition(prop, loc, columnOffset) {
        const pos = loc[prop];
        const target = this._sourcePosition;
        if (pos) {
          target.line = pos.line;
          target.column = Math.max(pos.column + columnOffset, 0);
          target.filename = loc.filename;
        }
      }
      getCurrentColumn() {
        const queue2 = this._queue;
        const queueCursor = this._queueCursor;
        let lastIndex = -1;
        let len = 0;
        for (let i = 0; i < queueCursor; i++) {
          const item = queue2[i];
          if (item.char === 10) {
            lastIndex = len;
          }
          len += item.repeat;
        }
        return lastIndex === -1 ? this._position.column + len : len - 1 - lastIndex;
      }
      getCurrentLine() {
        let count = 0;
        const queue2 = this._queue;
        for (let i = 0; i < this._queueCursor; i++) {
          if (queue2[i].char === 10) {
            count++;
          }
        }
        return this._position.line + count;
      }
    };
    exports2.default = Buffer2;
  }
});

// node_modules/@babel/generator/lib/node/whitespace.js
var require_whitespace = __commonJS({
  "node_modules/@babel/generator/lib/node/whitespace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.nodes = void 0;
    var _t = require_lib3();
    var {
      FLIPPED_ALIAS_KEYS,
      isArrayExpression,
      isAssignmentExpression,
      isBinary,
      isBlockStatement,
      isCallExpression,
      isFunction: isFunction2,
      isIdentifier: isIdentifier2,
      isLiteral,
      isMemberExpression,
      isObjectExpression,
      isOptionalCallExpression,
      isOptionalMemberExpression,
      isStringLiteral
    } = _t;
    function crawlInternal(node3, state) {
      if (!node3) return state;
      if (isMemberExpression(node3) || isOptionalMemberExpression(node3)) {
        crawlInternal(node3.object, state);
        if (node3.computed) crawlInternal(node3.property, state);
      } else if (isBinary(node3) || isAssignmentExpression(node3)) {
        crawlInternal(node3.left, state);
        crawlInternal(node3.right, state);
      } else if (isCallExpression(node3) || isOptionalCallExpression(node3)) {
        state.hasCall = true;
        crawlInternal(node3.callee, state);
      } else if (isFunction2(node3)) {
        state.hasFunction = true;
      } else if (isIdentifier2(node3)) {
        state.hasHelper = state.hasHelper || node3.callee && isHelper(node3.callee);
      }
      return state;
    }
    function crawl(node3) {
      return crawlInternal(node3, {
        hasCall: false,
        hasFunction: false,
        hasHelper: false
      });
    }
    function isHelper(node3) {
      if (!node3) return false;
      if (isMemberExpression(node3)) {
        return isHelper(node3.object) || isHelper(node3.property);
      } else if (isIdentifier2(node3)) {
        return node3.name === "require" || node3.name.charCodeAt(0) === 95;
      } else if (isCallExpression(node3)) {
        return isHelper(node3.callee);
      } else if (isBinary(node3) || isAssignmentExpression(node3)) {
        return isIdentifier2(node3.left) && isHelper(node3.left) || isHelper(node3.right);
      } else {
        return false;
      }
    }
    function isType(node3) {
      return isLiteral(node3) || isObjectExpression(node3) || isArrayExpression(node3) || isIdentifier2(node3) || isMemberExpression(node3);
    }
    var nodes = exports2.nodes = {
      AssignmentExpression(node3) {
        const state = crawl(node3.right);
        if (state.hasCall && state.hasHelper || state.hasFunction) {
          return state.hasFunction ? 1 | 2 : 2;
        }
      },
      SwitchCase(node3, parent) {
        return (!!node3.consequent.length || parent.cases[0] === node3 ? 1 : 0) | (!node3.consequent.length && parent.cases[parent.cases.length - 1] === node3 ? 2 : 0);
      },
      LogicalExpression(node3) {
        if (isFunction2(node3.left) || isFunction2(node3.right)) {
          return 2;
        }
      },
      Literal(node3) {
        if (isStringLiteral(node3) && node3.value === "use strict") {
          return 2;
        }
      },
      CallExpression(node3) {
        if (isFunction2(node3.callee) || isHelper(node3)) {
          return 1 | 2;
        }
      },
      OptionalCallExpression(node3) {
        if (isFunction2(node3.callee)) {
          return 1 | 2;
        }
      },
      VariableDeclaration(node3) {
        for (let i = 0; i < node3.declarations.length; i++) {
          const declar = node3.declarations[i];
          let enabled = isHelper(declar.id) && !isType(declar.init);
          if (!enabled && declar.init) {
            const state = crawl(declar.init);
            enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;
          }
          if (enabled) {
            return 1 | 2;
          }
        }
      },
      IfStatement(node3) {
        if (isBlockStatement(node3.consequent)) {
          return 1 | 2;
        }
      }
    };
    nodes.ObjectProperty = nodes.ObjectTypeProperty = nodes.ObjectMethod = function(node3, parent) {
      if (parent.properties[0] === node3) {
        return 1;
      }
    };
    nodes.ObjectTypeCallProperty = function(node3, parent) {
      var _parent$properties;
      if (parent.callProperties[0] === node3 && !((_parent$properties = parent.properties) != null && _parent$properties.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeIndexer = function(node3, parent) {
      var _parent$properties2, _parent$callPropertie;
      if (parent.indexers[0] === node3 && !((_parent$properties2 = parent.properties) != null && _parent$properties2.length) && !((_parent$callPropertie = parent.callProperties) != null && _parent$callPropertie.length)) {
        return 1;
      }
    };
    nodes.ObjectTypeInternalSlot = function(node3, parent) {
      var _parent$properties3, _parent$callPropertie2, _parent$indexers;
      if (parent.internalSlots[0] === node3 && !((_parent$properties3 = parent.properties) != null && _parent$properties3.length) && !((_parent$callPropertie2 = parent.callProperties) != null && _parent$callPropertie2.length) && !((_parent$indexers = parent.indexers) != null && _parent$indexers.length)) {
        return 1;
      }
    };
    [["Function", true], ["Class", true], ["Loop", true], ["LabeledStatement", true], ["SwitchStatement", true], ["TryStatement", true]].forEach(function([type, amounts]) {
      [type].concat(FLIPPED_ALIAS_KEYS[type] || []).forEach(function(type2) {
        const ret = amounts ? 1 | 2 : 0;
        nodes[type2] = () => ret;
      });
    });
  }
});

// node_modules/@babel/generator/lib/node/parentheses.js
var require_parentheses = __commonJS({
  "node_modules/@babel/generator/lib/node/parentheses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.Binary = Binary;
    exports2.BinaryExpression = BinaryExpression;
    exports2.ClassExpression = ClassExpression;
    exports2.ArrowFunctionExpression = exports2.ConditionalExpression = ConditionalExpression;
    exports2.DoExpression = DoExpression;
    exports2.FunctionExpression = FunctionExpression;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.Identifier = Identifier2;
    exports2.LogicalExpression = LogicalExpression;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    exports2.ObjectExpression = ObjectExpression;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.OptionalCallExpression = exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.SequenceExpression = SequenceExpression;
    exports2.TSSatisfiesExpression = exports2.TSAsExpression = TSAsExpression;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSConstructorType = exports2.TSFunctionType = TSFunctionType;
    exports2.TSInferType = TSInferType;
    exports2.TSInstantiationExpression = TSInstantiationExpression;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.UnaryLike = exports2.TSTypeAssertion = UnaryLike;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSUnionType = TSUnionType;
    exports2.IntersectionTypeAnnotation = exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.UpdateExpression = UpdateExpression;
    exports2.AwaitExpression = exports2.YieldExpression = YieldExpression;
    var _t = require_lib3();
    var _index = require_node4();
    var {
      isArrayTypeAnnotation,
      isBinaryExpression,
      isCallExpression,
      isForOfStatement,
      isIndexedAccessType,
      isMemberExpression,
      isObjectPattern,
      isOptionalMemberExpression,
      isYieldExpression,
      isStatement
    } = _t;
    var PRECEDENCE = /* @__PURE__ */ new Map([["||", 0], ["??", 0], ["|>", 0], ["&&", 1], ["|", 2], ["^", 3], ["&", 4], ["==", 5], ["===", 5], ["!=", 5], ["!==", 5], ["<", 6], [">", 6], ["<=", 6], [">=", 6], ["in", 6], ["instanceof", 6], [">>", 7], ["<<", 7], [">>>", 7], ["+", 8], ["-", 8], ["*", 9], ["/", 9], ["%", 9], ["**", 10]]);
    function getBinaryPrecedence(node3, nodeType) {
      if (nodeType === "BinaryExpression" || nodeType === "LogicalExpression") {
        return PRECEDENCE.get(node3.operator);
      }
      if (nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression") {
        return PRECEDENCE.get("in");
      }
    }
    function isTSTypeExpression(nodeType) {
      return nodeType === "TSAsExpression" || nodeType === "TSSatisfiesExpression" || nodeType === "TSTypeAssertion";
    }
    var isClassExtendsClause = (node3, parent) => {
      const parentType = parent.type;
      return (parentType === "ClassDeclaration" || parentType === "ClassExpression") && parent.superClass === node3;
    };
    var hasPostfixPart = (node3, parent) => {
      const parentType = parent.type;
      return (parentType === "MemberExpression" || parentType === "OptionalMemberExpression") && parent.object === node3 || (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression") && parent.callee === node3 || parentType === "TaggedTemplateExpression" && parent.tag === node3 || parentType === "TSNonNullExpression";
    };
    function NullableTypeAnnotation(node3, parent) {
      return isArrayTypeAnnotation(parent);
    }
    function FunctionTypeAnnotation(node3, parent, tokenContext) {
      const parentType = parent.type;
      return parentType === "UnionTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "ArrayTypeAnnotation" || Boolean(tokenContext & _index.TokenContext.arrowFlowReturnType);
    }
    function UpdateExpression(node3, parent) {
      return hasPostfixPart(node3, parent) || isClassExtendsClause(node3, parent);
    }
    function needsParenBeforeExpressionBrace(tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.arrowBody));
    }
    function ObjectExpression(node3, parent, tokenContext) {
      return needsParenBeforeExpressionBrace(tokenContext);
    }
    function DoExpression(node3, parent, tokenContext) {
      return !node3.async && Boolean(tokenContext & _index.TokenContext.expressionStatement);
    }
    function Binary(node3, parent) {
      const parentType = parent.type;
      if (node3.type === "BinaryExpression" && node3.operator === "**" && parentType === "BinaryExpression" && parent.operator === "**") {
        return parent.left === node3;
      }
      if (isClassExtendsClause(node3, parent)) {
        return true;
      }
      if (hasPostfixPart(node3, parent) || parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "AwaitExpression") {
        return true;
      }
      const parentPos = getBinaryPrecedence(parent, parentType);
      if (parentPos != null) {
        const nodePos = getBinaryPrecedence(node3, node3.type);
        if (parentPos === nodePos && parentType === "BinaryExpression" && parent.right === node3 || parentPos > nodePos) {
          return true;
        }
      }
      return void 0;
    }
    function UnionTypeAnnotation(node3, parent) {
      const parentType = parent.type;
      return parentType === "ArrayTypeAnnotation" || parentType === "NullableTypeAnnotation" || parentType === "IntersectionTypeAnnotation" || parentType === "UnionTypeAnnotation";
    }
    function OptionalIndexedAccessType(node3, parent) {
      return isIndexedAccessType(parent) && parent.objectType === node3;
    }
    function TSAsExpression(node3, parent) {
      if ((parent.type === "AssignmentExpression" || parent.type === "AssignmentPattern") && parent.left === node3) {
        return true;
      }
      if (parent.type === "BinaryExpression" && (parent.operator === "|" || parent.operator === "&") && node3 === parent.left) {
        return true;
      }
      return Binary(node3, parent);
    }
    function TSConditionalType(node3, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node3 || parentType === "TSOptionalType" || parentType === "TSTypeOperator" || parentType === "TSTypeParameter") {
        return true;
      }
      if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node3) {
        return true;
      }
      if (parentType === "TSConditionalType" && (parent.checkType === node3 || parent.extendsType === node3)) {
        return true;
      }
      return false;
    }
    function TSUnionType(node3, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node3 || parentType === "TSOptionalType";
    }
    function TSIntersectionType(node3, parent) {
      const parentType = parent.type;
      return parentType === "TSTypeOperator" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node3 || parentType === "TSOptionalType";
    }
    function TSInferType(node3, parent) {
      const parentType = parent.type;
      if (parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node3 || parentType === "TSOptionalType") {
        return true;
      }
      if (node3.typeParameter.constraint) {
        if ((parentType === "TSIntersectionType" || parentType === "TSUnionType") && parent.types[0] === node3) {
          return true;
        }
      }
      return false;
    }
    function TSTypeOperator(node3, parent) {
      const parentType = parent.type;
      return parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node3 || parentType === "TSOptionalType";
    }
    function TSInstantiationExpression(node3, parent) {
      const parentType = parent.type;
      return (parentType === "CallExpression" || parentType === "OptionalCallExpression" || parentType === "NewExpression" || parentType === "TSInstantiationExpression") && !!parent.typeParameters;
    }
    function TSFunctionType(node3, parent) {
      const parentType = parent.type;
      return parentType === "TSIntersectionType" || parentType === "TSUnionType" || parentType === "TSTypeOperator" || parentType === "TSOptionalType" || parentType === "TSArrayType" || parentType === "TSIndexedAccessType" && parent.objectType === node3 || parentType === "TSConditionalType" && (parent.checkType === node3 || parent.extendsType === node3);
    }
    function BinaryExpression(node3, parent, tokenContext, inForStatementInit) {
      return node3.operator === "in" && inForStatementInit;
    }
    function SequenceExpression(node3, parent) {
      const parentType = parent.type;
      if (parentType === "SequenceExpression" || parentType === "ParenthesizedExpression" || parentType === "MemberExpression" && parent.property === node3 || parentType === "OptionalMemberExpression" && parent.property === node3 || parentType === "TemplateLiteral") {
        return false;
      }
      if (parentType === "ClassDeclaration") {
        return true;
      }
      if (parentType === "ForOfStatement") {
        return parent.right === node3;
      }
      if (parentType === "ExportDefaultDeclaration") {
        return true;
      }
      return !isStatement(parent);
    }
    function YieldExpression(node3, parent) {
      const parentType = parent.type;
      return parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "UnaryExpression" || parentType === "SpreadElement" || hasPostfixPart(node3, parent) || parentType === "AwaitExpression" && isYieldExpression(node3) || parentType === "ConditionalExpression" && node3 === parent.test || isClassExtendsClause(node3, parent) || isTSTypeExpression(parentType);
    }
    function ClassExpression(node3, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function UnaryLike(node3, parent) {
      return hasPostfixPart(node3, parent) || isBinaryExpression(parent) && parent.operator === "**" && parent.left === node3 || isClassExtendsClause(node3, parent);
    }
    function FunctionExpression(node3, parent, tokenContext) {
      return Boolean(tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.exportDefault));
    }
    function ConditionalExpression(node3, parent) {
      const parentType = parent.type;
      if (parentType === "UnaryExpression" || parentType === "SpreadElement" || parentType === "BinaryExpression" || parentType === "LogicalExpression" || parentType === "ConditionalExpression" && parent.test === node3 || parentType === "AwaitExpression" || isTSTypeExpression(parentType)) {
        return true;
      }
      return UnaryLike(node3, parent);
    }
    function OptionalMemberExpression(node3, parent) {
      return isCallExpression(parent) && parent.callee === node3 || isMemberExpression(parent) && parent.object === node3;
    }
    function AssignmentExpression(node3, parent, tokenContext) {
      if (needsParenBeforeExpressionBrace(tokenContext) && isObjectPattern(node3.left)) {
        return true;
      } else {
        return ConditionalExpression(node3, parent);
      }
    }
    function LogicalExpression(node3, parent) {
      const parentType = parent.type;
      if (isTSTypeExpression(parentType)) return true;
      if (parentType !== "LogicalExpression") return false;
      switch (node3.operator) {
        case "||":
          return parent.operator === "??" || parent.operator === "&&";
        case "&&":
          return parent.operator === "??";
        case "??":
          return parent.operator !== "??";
      }
    }
    function Identifier2(node3, parent, tokenContext, _inForInit, getRawIdentifier) {
      var _node$extra;
      const parentType = parent.type;
      if ((_node$extra = node3.extra) != null && _node$extra.parenthesized && parentType === "AssignmentExpression" && parent.left === node3) {
        const rightType = parent.right.type;
        if ((rightType === "FunctionExpression" || rightType === "ClassExpression") && parent.right.id == null) {
          return true;
        }
      }
      if (getRawIdentifier && getRawIdentifier(node3) !== node3.name) {
        return false;
      }
      if (node3.name === "let") {
        const isFollowedByBracket = isMemberExpression(parent, {
          object: node3,
          computed: true
        }) || isOptionalMemberExpression(parent, {
          object: node3,
          computed: true,
          optional: false
        });
        if (isFollowedByBracket && tokenContext & (_index.TokenContext.expressionStatement | _index.TokenContext.forHead | _index.TokenContext.forInHead)) {
          return true;
        }
        return Boolean(tokenContext & _index.TokenContext.forOfHead);
      }
      return node3.name === "async" && isForOfStatement(parent, {
        left: node3,
        await: false
      });
    }
  }
});

// node_modules/@babel/generator/lib/node/index.js
var require_node4 = __commonJS({
  "node_modules/@babel/generator/lib/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenContext = void 0;
    exports2.isLastChild = isLastChild;
    exports2.needsParens = needsParens;
    exports2.needsWhitespace = needsWhitespace;
    exports2.needsWhitespaceAfter = needsWhitespaceAfter;
    exports2.needsWhitespaceBefore = needsWhitespaceBefore;
    var whitespace2 = require_whitespace();
    var parens = require_parentheses();
    var _t = require_lib3();
    var {
      FLIPPED_ALIAS_KEYS,
      VISITOR_KEYS,
      isCallExpression,
      isDecorator,
      isExpressionStatement,
      isMemberExpression,
      isNewExpression,
      isParenthesizedExpression
    } = _t;
    var TokenContext = exports2.TokenContext = {
      expressionStatement: 1,
      arrowBody: 2,
      exportDefault: 4,
      forHead: 8,
      forInHead: 16,
      forOfHead: 32,
      arrowFlowReturnType: 64
    };
    function expandAliases(obj) {
      const map = /* @__PURE__ */ new Map();
      function add(type, func) {
        const fn = map.get(type);
        map.set(type, fn ? function(node3, parent, stack, inForInit, getRawIdentifier) {
          var _fn;
          return (_fn = fn(node3, parent, stack, inForInit, getRawIdentifier)) != null ? _fn : func(node3, parent, stack, inForInit, getRawIdentifier);
        } : func);
      }
      for (const type of Object.keys(obj)) {
        const aliases = FLIPPED_ALIAS_KEYS[type];
        if (aliases) {
          for (const alias of aliases) {
            add(alias, obj[type]);
          }
        } else {
          add(type, obj[type]);
        }
      }
      return map;
    }
    var expandedParens = expandAliases(parens);
    var expandedWhitespaceNodes = expandAliases(whitespace2.nodes);
    function isOrHasCallExpression(node3) {
      if (isCallExpression(node3)) {
        return true;
      }
      return isMemberExpression(node3) && isOrHasCallExpression(node3.object);
    }
    function needsWhitespace(node3, parent, type) {
      var _expandedWhitespaceNo;
      if (!node3) return false;
      if (isExpressionStatement(node3)) {
        node3 = node3.expression;
      }
      const flag = (_expandedWhitespaceNo = expandedWhitespaceNodes.get(node3.type)) == null ? void 0 : _expandedWhitespaceNo(node3, parent);
      if (typeof flag === "number") {
        return (flag & type) !== 0;
      }
      return false;
    }
    function needsWhitespaceBefore(node3, parent) {
      return needsWhitespace(node3, parent, 1);
    }
    function needsWhitespaceAfter(node3, parent) {
      return needsWhitespace(node3, parent, 2);
    }
    function needsParens(node3, parent, tokenContext, inForInit, getRawIdentifier) {
      var _expandedParens$get;
      if (!parent) return false;
      if (isNewExpression(parent) && parent.callee === node3) {
        if (isOrHasCallExpression(node3)) return true;
      }
      if (isDecorator(parent)) {
        return !isDecoratorMemberExpression(node3) && !(isCallExpression(node3) && isDecoratorMemberExpression(node3.callee)) && !isParenthesizedExpression(node3);
      }
      return (_expandedParens$get = expandedParens.get(node3.type)) == null ? void 0 : _expandedParens$get(node3, parent, tokenContext, inForInit, getRawIdentifier);
    }
    function isDecoratorMemberExpression(node3) {
      switch (node3.type) {
        case "Identifier":
          return true;
        case "MemberExpression":
          return !node3.computed && node3.property.type === "Identifier" && isDecoratorMemberExpression(node3.object);
        default:
          return false;
      }
    }
    function isLastChild(parent, child) {
      const visitorKeys = VISITOR_KEYS[parent.type];
      for (let i = visitorKeys.length - 1; i >= 0; i--) {
        const val = parent[visitorKeys[i]];
        if (val === child) {
          return true;
        } else if (Array.isArray(val)) {
          let j = val.length - 1;
          while (j >= 0 && val[j] === null) j--;
          return j >= 0 && val[j] === child;
        } else if (val) {
          return false;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/generator/lib/token-map.js
var require_token_map = __commonJS({
  "node_modules/@babel/generator/lib/token-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenMap = void 0;
    var _t = require_lib3();
    var {
      traverseFast,
      VISITOR_KEYS
    } = _t;
    var TokenMap = class {
      constructor(ast, tokens, source) {
        this._tokens = void 0;
        this._source = void 0;
        this._nodesToTokenIndexes = /* @__PURE__ */ new Map();
        this._nodesOccurrencesCountCache = /* @__PURE__ */ new Map();
        this._tokensCache = /* @__PURE__ */ new Map();
        this._tokens = tokens;
        this._source = source;
        traverseFast(ast, (node3) => {
          const indexes = this._getTokensIndexesOfNode(node3);
          if (indexes.length > 0) this._nodesToTokenIndexes.set(node3, indexes);
        });
        this._tokensCache = null;
      }
      has(node3) {
        return this._nodesToTokenIndexes.has(node3);
      }
      getIndexes(node3) {
        return this._nodesToTokenIndexes.get(node3);
      }
      find(node3, condition) {
        const indexes = this._nodesToTokenIndexes.get(node3);
        if (indexes) {
          for (let k = 0; k < indexes.length; k++) {
            const index4 = indexes[k];
            const tok = this._tokens[index4];
            if (condition(tok, index4)) return tok;
          }
        }
        return null;
      }
      findLastIndex(node3, condition) {
        const indexes = this._nodesToTokenIndexes.get(node3);
        if (indexes) {
          for (let k = indexes.length - 1; k >= 0; k--) {
            const index4 = indexes[k];
            const tok = this._tokens[index4];
            if (condition(tok, index4)) return index4;
          }
        }
        return -1;
      }
      findMatching(node3, test, occurrenceCount = 0) {
        const indexes = this._nodesToTokenIndexes.get(node3);
        if (indexes) {
          let i = 0;
          const count = occurrenceCount;
          if (count > 1) {
            const cache2 = this._nodesOccurrencesCountCache.get(node3);
            if (cache2 && cache2.test === test && cache2.count < count) {
              i = cache2.i + 1;
              occurrenceCount -= cache2.count + 1;
            }
          }
          for (; i < indexes.length; i++) {
            const tok = this._tokens[indexes[i]];
            if (this.matchesOriginal(tok, test)) {
              if (occurrenceCount === 0) {
                if (count > 0) {
                  this._nodesOccurrencesCountCache.set(node3, {
                    test,
                    count,
                    i
                  });
                }
                return tok;
              }
              occurrenceCount--;
            }
          }
        }
        return null;
      }
      matchesOriginal(token, test) {
        if (token.end - token.start !== test.length) return false;
        if (token.value != null) return token.value === test;
        return this._source.startsWith(test, token.start);
      }
      startMatches(node3, test) {
        const indexes = this._nodesToTokenIndexes.get(node3);
        if (!indexes) return false;
        const tok = this._tokens[indexes[0]];
        if (tok.start !== node3.start) return false;
        return this.matchesOriginal(tok, test);
      }
      endMatches(node3, test) {
        const indexes = this._nodesToTokenIndexes.get(node3);
        if (!indexes) return false;
        const tok = this._tokens[indexes[indexes.length - 1]];
        if (tok.end !== node3.end) return false;
        return this.matchesOriginal(tok, test);
      }
      _getTokensIndexesOfNode(node3) {
        if (node3.start == null || node3.end == null) return [];
        const {
          first: first2,
          last
        } = this._findTokensOfNode(node3, 0, this._tokens.length - 1);
        let low = first2;
        const children = childrenIterator(node3);
        if ((node3.type === "ExportNamedDeclaration" || node3.type === "ExportDefaultDeclaration") && node3.declaration && node3.declaration.type === "ClassDeclaration") {
          children.next();
        }
        const indexes = [];
        for (const child of children) {
          if (child == null) continue;
          if (child.start == null || child.end == null) continue;
          const childTok = this._findTokensOfNode(child, low, last);
          const high = childTok.first;
          for (let k = low; k < high; k++) indexes.push(k);
          low = childTok.last + 1;
        }
        for (let k = low; k <= last; k++) indexes.push(k);
        return indexes;
      }
      _findTokensOfNode(node3, low, high) {
        const cached = this._tokensCache.get(node3);
        if (cached) return cached;
        const first2 = this._findFirstTokenOfNode(node3.start, low, high);
        const last = this._findLastTokenOfNode(node3.end, first2, high);
        this._tokensCache.set(node3, {
          first: first2,
          last
        });
        return {
          first: first2,
          last
        };
      }
      _findFirstTokenOfNode(start, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (start < this._tokens[mid].start) {
            high = mid - 1;
          } else if (start > this._tokens[mid].start) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return low;
      }
      _findLastTokenOfNode(end, low, high) {
        while (low <= high) {
          const mid = high + low >> 1;
          if (end < this._tokens[mid].end) {
            high = mid - 1;
          } else if (end > this._tokens[mid].end) {
            low = mid + 1;
          } else {
            return mid;
          }
        }
        return high;
      }
    };
    exports2.TokenMap = TokenMap;
    function* childrenIterator(node3) {
      if (node3.type === "TemplateLiteral") {
        yield node3.quasis[0];
        for (let i = 1; i < node3.quasis.length; i++) {
          yield node3.expressions[i - 1];
          yield node3.quasis[i];
        }
        return;
      }
      const keys = VISITOR_KEYS[node3.type];
      for (const key of keys) {
        const child = node3[key];
        if (!child) continue;
        if (Array.isArray(child)) {
          yield* child;
        } else {
          yield child;
        }
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/template-literals.js
var require_template_literals = __commonJS({
  "node_modules/@babel/generator/lib/generators/template-literals.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateElement = TemplateElement;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2._printTemplate = _printTemplate;
    function TaggedTemplateExpression(node3) {
      this.print(node3.tag);
      {
        this.print(node3.typeParameters);
      }
      this.print(node3.quasi);
    }
    function TemplateElement() {
      throw new Error("TemplateElement printing is handled in TemplateLiteral");
    }
    function _printTemplate(node3, substitutions) {
      const quasis = node3.quasis;
      let partRaw = "`";
      for (let i = 0; i < quasis.length - 1; i++) {
        partRaw += quasis[i].value.raw;
        this.token(partRaw + "${", true);
        this.print(substitutions[i]);
        partRaw = "}";
        if (this.tokenMap) {
          const token = this.tokenMap.findMatching(node3, "}", i);
          if (token) this._catchUpTo(token.loc.start);
        }
      }
      partRaw += quasis[quasis.length - 1].value.raw;
      this.token(partRaw + "`", true);
    }
    function TemplateLiteral(node3) {
      this._printTemplate(node3, node3.expressions);
    }
  }
});

// node_modules/@babel/generator/lib/generators/expressions.js
var require_expressions = __commonJS({
  "node_modules/@babel/generator/lib/generators/expressions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LogicalExpression = exports2.BinaryExpression = exports2.AssignmentExpression = AssignmentExpression;
    exports2.AssignmentPattern = AssignmentPattern;
    exports2.AwaitExpression = AwaitExpression;
    exports2.BindExpression = BindExpression;
    exports2.CallExpression = CallExpression;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.Decorator = Decorator;
    exports2.DoExpression = DoExpression;
    exports2.EmptyStatement = EmptyStatement;
    exports2.ExpressionStatement = ExpressionStatement;
    exports2.Import = Import;
    exports2.MemberExpression = MemberExpression;
    exports2.MetaProperty = MetaProperty;
    exports2.ModuleExpression = ModuleExpression;
    exports2.NewExpression = NewExpression;
    exports2.OptionalCallExpression = OptionalCallExpression;
    exports2.OptionalMemberExpression = OptionalMemberExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.PrivateName = PrivateName;
    exports2.SequenceExpression = SequenceExpression;
    exports2.Super = Super;
    exports2.ThisExpression = ThisExpression;
    exports2.UnaryExpression = UnaryExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.V8IntrinsicIdentifier = V8IntrinsicIdentifier;
    exports2.YieldExpression = YieldExpression;
    exports2._shouldPrintDecoratorsBeforeExport = _shouldPrintDecoratorsBeforeExport;
    var _t = require_lib3();
    var _index = require_node4();
    var {
      isCallExpression,
      isLiteral,
      isMemberExpression,
      isNewExpression,
      isPattern
    } = _t;
    function UnaryExpression(node3) {
      const {
        operator
      } = node3;
      if (operator === "void" || operator === "delete" || operator === "typeof" || operator === "throw") {
        this.word(operator);
        this.space();
      } else {
        this.token(operator);
      }
      this.print(node3.argument);
    }
    function DoExpression(node3) {
      if (node3.async) {
        this.word("async", true);
        this.space();
      }
      this.word("do");
      this.space();
      this.print(node3.body);
    }
    function ParenthesizedExpression(node3) {
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.print(node3.expression);
      exit();
      this.rightParens(node3);
    }
    function UpdateExpression(node3) {
      if (node3.prefix) {
        this.token(node3.operator);
        this.print(node3.argument);
      } else {
        this.print(node3.argument, true);
        this.token(node3.operator);
      }
    }
    function ConditionalExpression(node3) {
      this.print(node3.test);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node3.consequent);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node3.alternate);
    }
    function NewExpression(node3, parent) {
      this.word("new");
      this.space();
      this.print(node3.callee);
      if (this.format.minified && node3.arguments.length === 0 && !node3.optional && !isCallExpression(parent, {
        callee: node3
      }) && !isMemberExpression(parent) && !isNewExpression(parent)) {
        return;
      }
      this.print(node3.typeArguments);
      {
        this.print(node3.typeParameters);
      }
      if (node3.optional) {
        this.token("?.");
      }
      if (node3.arguments.length === 0 && this.tokenMap && !this.tokenMap.endMatches(node3, ")")) {
        return;
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node3.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node3);
    }
    function SequenceExpression(node3) {
      this.printList(node3.expressions);
    }
    function ThisExpression() {
      this.word("this");
    }
    function Super() {
      this.word("super");
    }
    function _shouldPrintDecoratorsBeforeExport(node3) {
      if (typeof this.format.decoratorsBeforeExport === "boolean") {
        return this.format.decoratorsBeforeExport;
      }
      return typeof node3.start === "number" && node3.start === node3.declaration.start;
    }
    function Decorator(node3) {
      this.tokenChar(64);
      this.print(node3.expression);
      this.newline();
    }
    function OptionalMemberExpression(node3) {
      let {
        computed
      } = node3;
      const {
        optional,
        property
      } = node3;
      this.print(node3.object);
      if (!computed && isMemberExpression(property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      if (isLiteral(property) && typeof property.value === "number") {
        computed = true;
      }
      if (optional) {
        this.token("?.");
      }
      if (computed) {
        this.tokenChar(91);
        this.print(property);
        this.tokenChar(93);
      } else {
        if (!optional) {
          this.tokenChar(46);
        }
        this.print(property);
      }
    }
    function OptionalCallExpression(node3) {
      this.print(node3.callee);
      {
        this.print(node3.typeParameters);
      }
      if (node3.optional) {
        this.token("?.");
      }
      this.print(node3.typeArguments);
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node3.arguments);
      exit();
      this.rightParens(node3);
    }
    function CallExpression(node3) {
      this.print(node3.callee);
      this.print(node3.typeArguments);
      {
        this.print(node3.typeParameters);
      }
      this.tokenChar(40);
      const exit = this.enterDelimited();
      this.printList(node3.arguments, this.shouldPrintTrailingComma(")"));
      exit();
      this.rightParens(node3);
    }
    function Import() {
      this.word("import");
    }
    function AwaitExpression(node3) {
      this.word("await");
      if (node3.argument) {
        this.space();
        this.printTerminatorless(node3.argument);
      }
    }
    function YieldExpression(node3) {
      this.word("yield", true);
      if (node3.delegate) {
        this.tokenChar(42);
        if (node3.argument) {
          this.space();
          this.print(node3.argument);
        }
      } else {
        if (node3.argument) {
          this.space();
          this.printTerminatorless(node3.argument);
        }
      }
    }
    function EmptyStatement() {
      this.semicolon(true);
    }
    function ExpressionStatement(node3) {
      this.tokenContext |= _index.TokenContext.expressionStatement;
      this.print(node3.expression);
      this.semicolon();
    }
    function AssignmentPattern(node3) {
      this.print(node3.left);
      if (node3.left.type === "Identifier" || isPattern(node3.left)) {
        if (node3.left.optional) this.tokenChar(63);
        this.print(node3.left.typeAnnotation);
      }
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node3.right);
    }
    function AssignmentExpression(node3) {
      this.print(node3.left);
      this.space();
      if (node3.operator === "in" || node3.operator === "instanceof") {
        this.word(node3.operator);
      } else {
        this.token(node3.operator);
        this._endsWithDiv = node3.operator === "/";
      }
      this.space();
      this.print(node3.right);
    }
    function BindExpression(node3) {
      this.print(node3.object);
      this.token("::");
      this.print(node3.callee);
    }
    function MemberExpression(node3) {
      this.print(node3.object);
      if (!node3.computed && isMemberExpression(node3.property)) {
        throw new TypeError("Got a MemberExpression for MemberExpression property");
      }
      let computed = node3.computed;
      if (isLiteral(node3.property) && typeof node3.property.value === "number") {
        computed = true;
      }
      if (computed) {
        const exit = this.enterDelimited();
        this.tokenChar(91);
        this.print(node3.property);
        this.tokenChar(93);
        exit();
      } else {
        this.tokenChar(46);
        this.print(node3.property);
      }
    }
    function MetaProperty(node3) {
      this.print(node3.meta);
      this.tokenChar(46);
      this.print(node3.property);
    }
    function PrivateName(node3) {
      this.tokenChar(35);
      this.print(node3.id);
    }
    function V8IntrinsicIdentifier(node3) {
      this.tokenChar(37);
      this.word(node3.name);
    }
    function ModuleExpression(node3) {
      this.word("module", true);
      this.space();
      this.tokenChar(123);
      this.indent();
      const {
        body
      } = node3;
      if (body.body.length || body.directives.length) {
        this.newline();
      }
      this.print(body);
      this.dedent();
      this.rightBrace(node3);
    }
  }
});

// node_modules/@babel/generator/lib/generators/statements.js
var require_statements = __commonJS({
  "node_modules/@babel/generator/lib/generators/statements.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BreakStatement = BreakStatement;
    exports2.CatchClause = CatchClause;
    exports2.ContinueStatement = ContinueStatement;
    exports2.DebuggerStatement = DebuggerStatement;
    exports2.DoWhileStatement = DoWhileStatement;
    exports2.ForOfStatement = exports2.ForInStatement = void 0;
    exports2.ForStatement = ForStatement;
    exports2.IfStatement = IfStatement;
    exports2.LabeledStatement = LabeledStatement;
    exports2.ReturnStatement = ReturnStatement;
    exports2.SwitchCase = SwitchCase;
    exports2.SwitchStatement = SwitchStatement;
    exports2.ThrowStatement = ThrowStatement;
    exports2.TryStatement = TryStatement;
    exports2.VariableDeclaration = VariableDeclaration;
    exports2.VariableDeclarator = VariableDeclarator;
    exports2.WhileStatement = WhileStatement;
    exports2.WithStatement = WithStatement;
    var _t = require_lib3();
    var _index = require_node4();
    var {
      isFor,
      isForStatement,
      isIfStatement,
      isStatement
    } = _t;
    function WithStatement(node3) {
      this.word("with");
      this.space();
      this.tokenChar(40);
      this.print(node3.object);
      this.tokenChar(41);
      this.printBlock(node3);
    }
    function IfStatement(node3) {
      this.word("if");
      this.space();
      this.tokenChar(40);
      this.print(node3.test);
      this.tokenChar(41);
      this.space();
      const needsBlock = node3.alternate && isIfStatement(getLastStatement(node3.consequent));
      if (needsBlock) {
        this.tokenChar(123);
        this.newline();
        this.indent();
      }
      this.printAndIndentOnComments(node3.consequent);
      if (needsBlock) {
        this.dedent();
        this.newline();
        this.tokenChar(125);
      }
      if (node3.alternate) {
        if (this.endsWith(125)) this.space();
        this.word("else");
        this.space();
        this.printAndIndentOnComments(node3.alternate);
      }
    }
    function getLastStatement(statement) {
      const {
        body
      } = statement;
      if (isStatement(body) === false) {
        return statement;
      }
      return getLastStatement(body);
    }
    function ForStatement(node3) {
      this.word("for");
      this.space();
      this.tokenChar(40);
      {
        const exit = this.enterForStatementInit();
        this.tokenContext |= _index.TokenContext.forHead;
        this.print(node3.init);
        exit();
      }
      this.tokenChar(59);
      if (node3.test) {
        this.space();
        this.print(node3.test);
      }
      this.token(";", false, 1);
      if (node3.update) {
        this.space();
        this.print(node3.update);
      }
      this.tokenChar(41);
      this.printBlock(node3);
    }
    function WhileStatement(node3) {
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node3.test);
      this.tokenChar(41);
      this.printBlock(node3);
    }
    function ForXStatement(node3) {
      this.word("for");
      this.space();
      const isForOf = node3.type === "ForOfStatement";
      if (isForOf && node3.await) {
        this.word("await");
        this.space();
      }
      this.noIndentInnerCommentsHere();
      this.tokenChar(40);
      {
        const exit = isForOf ? null : this.enterForStatementInit();
        this.tokenContext |= isForOf ? _index.TokenContext.forOfHead : _index.TokenContext.forInHead;
        this.print(node3.left);
        exit == null || exit();
      }
      this.space();
      this.word(isForOf ? "of" : "in");
      this.space();
      this.print(node3.right);
      this.tokenChar(41);
      this.printBlock(node3);
    }
    var ForInStatement = exports2.ForInStatement = ForXStatement;
    var ForOfStatement = exports2.ForOfStatement = ForXStatement;
    function DoWhileStatement(node3) {
      this.word("do");
      this.space();
      this.print(node3.body);
      this.space();
      this.word("while");
      this.space();
      this.tokenChar(40);
      this.print(node3.test);
      this.tokenChar(41);
      this.semicolon();
    }
    function printStatementAfterKeyword(printer, node3) {
      if (node3) {
        printer.space();
        printer.printTerminatorless(node3);
      }
      printer.semicolon();
    }
    function BreakStatement(node3) {
      this.word("break");
      printStatementAfterKeyword(this, node3.label);
    }
    function ContinueStatement(node3) {
      this.word("continue");
      printStatementAfterKeyword(this, node3.label);
    }
    function ReturnStatement(node3) {
      this.word("return");
      printStatementAfterKeyword(this, node3.argument);
    }
    function ThrowStatement(node3) {
      this.word("throw");
      printStatementAfterKeyword(this, node3.argument);
    }
    function LabeledStatement(node3) {
      this.print(node3.label);
      this.tokenChar(58);
      this.space();
      this.print(node3.body);
    }
    function TryStatement(node3) {
      this.word("try");
      this.space();
      this.print(node3.block);
      this.space();
      if (node3.handlers) {
        this.print(node3.handlers[0]);
      } else {
        this.print(node3.handler);
      }
      if (node3.finalizer) {
        this.space();
        this.word("finally");
        this.space();
        this.print(node3.finalizer);
      }
    }
    function CatchClause(node3) {
      this.word("catch");
      this.space();
      if (node3.param) {
        this.tokenChar(40);
        this.print(node3.param);
        this.print(node3.param.typeAnnotation);
        this.tokenChar(41);
        this.space();
      }
      this.print(node3.body);
    }
    function SwitchStatement(node3) {
      this.word("switch");
      this.space();
      this.tokenChar(40);
      this.print(node3.discriminant);
      this.tokenChar(41);
      this.space();
      this.tokenChar(123);
      this.printSequence(node3.cases, true, void 0, function addNewlines(leading, cas) {
        if (!leading && node3.cases[node3.cases.length - 1] === cas) return -1;
      });
      this.rightBrace(node3);
    }
    function SwitchCase(node3) {
      if (node3.test) {
        this.word("case");
        this.space();
        this.print(node3.test);
        this.tokenChar(58);
      } else {
        this.word("default");
        this.tokenChar(58);
      }
      if (node3.consequent.length) {
        this.newline();
        this.printSequence(node3.consequent, true);
      }
    }
    function DebuggerStatement() {
      this.word("debugger");
      this.semicolon();
    }
    function VariableDeclaration(node3, parent) {
      if (node3.declare) {
        this.word("declare");
        this.space();
      }
      const {
        kind
      } = node3;
      if (kind === "await using") {
        this.word("await");
        this.space();
        this.word("using", true);
      } else {
        this.word(kind, kind === "using");
      }
      this.space();
      let hasInits = false;
      if (!isFor(parent)) {
        for (const declar of node3.declarations) {
          if (declar.init) {
            hasInits = true;
          }
        }
      }
      this.printList(node3.declarations, void 0, void 0, node3.declarations.length > 1, hasInits ? function(occurrenceCount) {
        this.token(",", false, occurrenceCount);
        this.newline();
      } : void 0);
      if (isFor(parent)) {
        if (isForStatement(parent)) {
          if (parent.init === node3) return;
        } else {
          if (parent.left === node3) return;
        }
      }
      this.semicolon();
    }
    function VariableDeclarator(node3) {
      this.print(node3.id);
      if (node3.definite) this.tokenChar(33);
      this.print(node3.id.typeAnnotation);
      if (node3.init) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node3.init);
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/classes.js
var require_classes = __commonJS({
  "node_modules/@babel/generator/lib/generators/classes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ClassAccessorProperty = ClassAccessorProperty;
    exports2.ClassBody = ClassBody;
    exports2.ClassExpression = exports2.ClassDeclaration = ClassDeclaration;
    exports2.ClassMethod = ClassMethod;
    exports2.ClassPrivateMethod = ClassPrivateMethod;
    exports2.ClassPrivateProperty = ClassPrivateProperty;
    exports2.ClassProperty = ClassProperty;
    exports2.StaticBlock = StaticBlock;
    exports2._classMethodHead = _classMethodHead;
    var _t = require_lib3();
    var {
      isExportDefaultDeclaration,
      isExportNamedDeclaration
    } = _t;
    function ClassDeclaration(node3, parent) {
      const inExport = isExportDefaultDeclaration(parent) || isExportNamedDeclaration(parent);
      if (!inExport || !this._shouldPrintDecoratorsBeforeExport(parent)) {
        this.printJoin(node3.decorators);
      }
      if (node3.declare) {
        this.word("declare");
        this.space();
      }
      if (node3.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("class");
      if (node3.id) {
        this.space();
        this.print(node3.id);
      }
      this.print(node3.typeParameters);
      if (node3.superClass) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node3.superClass);
        this.print(node3.superTypeParameters);
      }
      if (node3.implements) {
        this.space();
        this.word("implements");
        this.space();
        this.printList(node3.implements);
      }
      this.space();
      this.print(node3.body);
    }
    function ClassBody(node3) {
      this.tokenChar(123);
      if (node3.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        const separator = classBodyEmptySemicolonsPrinter(this, node3);
        separator == null || separator(-1);
        const exit = this.enterDelimited();
        this.printJoin(node3.body, true, true, separator, true);
        exit();
        if (!this.endsWith(10)) this.newline();
        this.rightBrace(node3);
      }
    }
    function classBodyEmptySemicolonsPrinter(printer, node3) {
      if (!printer.tokenMap || node3.start == null || node3.end == null) {
        return null;
      }
      const indexes = printer.tokenMap.getIndexes(node3);
      if (!indexes) return null;
      let k = 1;
      let occurrenceCount = 0;
      let nextLocIndex = 0;
      const advanceNextLocIndex = () => {
        while (nextLocIndex < node3.body.length && node3.body[nextLocIndex].start == null) {
          nextLocIndex++;
        }
      };
      advanceNextLocIndex();
      return (i) => {
        if (nextLocIndex <= i) {
          nextLocIndex = i + 1;
          advanceNextLocIndex();
        }
        const end = nextLocIndex === node3.body.length ? node3.end : node3.body[nextLocIndex].start;
        let tok;
        while (k < indexes.length && printer.tokenMap.matchesOriginal(tok = printer._tokens[indexes[k]], ";") && tok.start < end) {
          printer.token(";", void 0, occurrenceCount++);
          k++;
        }
      };
    }
    function ClassProperty(node3) {
      this.printJoin(node3.decorators);
      if (!node3.static && !this.format.preserveFormat) {
        var _node$key$loc;
        const endLine = (_node$key$loc = node3.key.loc) == null || (_node$key$loc = _node$key$loc.end) == null ? void 0 : _node$key$loc.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node3);
      if (node3.computed) {
        this.tokenChar(91);
        this.print(node3.key);
        this.tokenChar(93);
      } else {
        this._variance(node3);
        this.print(node3.key);
      }
      if (node3.optional) {
        this.tokenChar(63);
      }
      if (node3.definite) {
        this.tokenChar(33);
      }
      this.print(node3.typeAnnotation);
      if (node3.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node3.value);
      }
      this.semicolon();
    }
    function ClassAccessorProperty(node3) {
      var _node$key$loc2;
      this.printJoin(node3.decorators);
      const endLine = (_node$key$loc2 = node3.key.loc) == null || (_node$key$loc2 = _node$key$loc2.end) == null ? void 0 : _node$key$loc2.line;
      if (endLine) this.catchUp(endLine);
      this.tsPrintClassMemberModifiers(node3);
      this.word("accessor", true);
      this.space();
      if (node3.computed) {
        this.tokenChar(91);
        this.print(node3.key);
        this.tokenChar(93);
      } else {
        this._variance(node3);
        this.print(node3.key);
      }
      if (node3.optional) {
        this.tokenChar(63);
      }
      if (node3.definite) {
        this.tokenChar(33);
      }
      this.print(node3.typeAnnotation);
      if (node3.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node3.value);
      }
      this.semicolon();
    }
    function ClassPrivateProperty(node3) {
      this.printJoin(node3.decorators);
      this.tsPrintClassMemberModifiers(node3);
      this.print(node3.key);
      if (node3.optional) {
        this.tokenChar(63);
      }
      if (node3.definite) {
        this.tokenChar(33);
      }
      this.print(node3.typeAnnotation);
      if (node3.value) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node3.value);
      }
      this.semicolon();
    }
    function ClassMethod(node3) {
      this._classMethodHead(node3);
      this.space();
      this.print(node3.body);
    }
    function ClassPrivateMethod(node3) {
      this._classMethodHead(node3);
      this.space();
      this.print(node3.body);
    }
    function _classMethodHead(node3) {
      this.printJoin(node3.decorators);
      if (!this.format.preserveFormat) {
        var _node$key$loc3;
        const endLine = (_node$key$loc3 = node3.key.loc) == null || (_node$key$loc3 = _node$key$loc3.end) == null ? void 0 : _node$key$loc3.line;
        if (endLine) this.catchUp(endLine);
      }
      this.tsPrintClassMemberModifiers(node3);
      this._methodHead(node3);
    }
    function StaticBlock(node3) {
      this.word("static");
      this.space();
      this.tokenChar(123);
      if (node3.body.length === 0) {
        this.tokenChar(125);
      } else {
        this.newline();
        this.printSequence(node3.body, true);
        this.rightBrace(node3);
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/methods.js
var require_methods = __commonJS({
  "node_modules/@babel/generator/lib/generators/methods.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArrowFunctionExpression = ArrowFunctionExpression;
    exports2.FunctionDeclaration = exports2.FunctionExpression = FunctionExpression;
    exports2._functionHead = _functionHead;
    exports2._methodHead = _methodHead;
    exports2._param = _param;
    exports2._parameters = _parameters;
    exports2._params = _params;
    exports2._predicate = _predicate;
    exports2._shouldPrintArrowParamsParens = _shouldPrintArrowParamsParens;
    var _t = require_lib3();
    var _index = require_node4();
    var {
      isIdentifier: isIdentifier2
    } = _t;
    function _params(node3, idNode, parentNode) {
      this.print(node3.typeParameters);
      const nameInfo = _getFuncIdName.call(this, idNode, parentNode);
      if (nameInfo) {
        this.sourceIdentifierName(nameInfo.name, nameInfo.pos);
      }
      this.tokenChar(40);
      this._parameters(node3.params, ")");
      const noLineTerminator = node3.type === "ArrowFunctionExpression";
      this.print(node3.returnType, noLineTerminator);
      this._noLineTerminator = noLineTerminator;
    }
    function _parameters(parameters, endToken) {
      const exit = this.enterDelimited();
      const trailingComma = this.shouldPrintTrailingComma(endToken);
      const paramLength = parameters.length;
      for (let i = 0; i < paramLength; i++) {
        this._param(parameters[i]);
        if (trailingComma || i < paramLength - 1) {
          this.token(",", null, i);
          this.space();
        }
      }
      this.token(endToken);
      exit();
    }
    function _param(parameter) {
      this.printJoin(parameter.decorators);
      this.print(parameter);
      if (parameter.optional) {
        this.tokenChar(63);
      }
      this.print(parameter.typeAnnotation);
    }
    function _methodHead(node3) {
      const kind = node3.kind;
      const key = node3.key;
      if (kind === "get" || kind === "set") {
        this.word(kind);
        this.space();
      }
      if (node3.async) {
        this.word("async", true);
        this.space();
      }
      if (kind === "method" || kind === "init") {
        if (node3.generator) {
          this.tokenChar(42);
        }
      }
      if (node3.computed) {
        this.tokenChar(91);
        this.print(key);
        this.tokenChar(93);
      } else {
        this.print(key);
      }
      if (node3.optional) {
        this.tokenChar(63);
      }
      this._params(node3, node3.computed && node3.key.type !== "StringLiteral" ? void 0 : node3.key, void 0);
    }
    function _predicate(node3, noLineTerminatorAfter) {
      if (node3.predicate) {
        if (!node3.returnType) {
          this.tokenChar(58);
        }
        this.space();
        this.print(node3.predicate, noLineTerminatorAfter);
      }
    }
    function _functionHead(node3, parent) {
      if (node3.async) {
        this.word("async");
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.space();
      }
      this.word("function");
      if (node3.generator) {
        if (!this.format.preserveFormat) {
          this._endsWithInnerRaw = false;
        }
        this.tokenChar(42);
      }
      this.space();
      if (node3.id) {
        this.print(node3.id);
      }
      this._params(node3, node3.id, parent);
      if (node3.type !== "TSDeclareFunction") {
        this._predicate(node3);
      }
    }
    function FunctionExpression(node3, parent) {
      this._functionHead(node3, parent);
      this.space();
      this.print(node3.body);
    }
    function ArrowFunctionExpression(node3, parent) {
      if (node3.async) {
        this.word("async", true);
        this.space();
      }
      if (this._shouldPrintArrowParamsParens(node3)) {
        this._params(node3, void 0, parent);
      } else {
        this.print(node3.params[0], true);
      }
      this._predicate(node3, true);
      this.space();
      this.printInnerComments();
      this.token("=>");
      this.space();
      this.tokenContext |= _index.TokenContext.arrowBody;
      this.print(node3.body);
    }
    function _shouldPrintArrowParamsParens(node3) {
      var _firstParam$leadingCo, _firstParam$trailingC;
      if (node3.params.length !== 1) return true;
      if (node3.typeParameters || node3.returnType || node3.predicate) {
        return true;
      }
      const firstParam = node3.params[0];
      if (!isIdentifier2(firstParam) || firstParam.typeAnnotation || firstParam.optional || (_firstParam$leadingCo = firstParam.leadingComments) != null && _firstParam$leadingCo.length || (_firstParam$trailingC = firstParam.trailingComments) != null && _firstParam$trailingC.length) {
        return true;
      }
      if (this.tokenMap) {
        if (node3.loc == null) return true;
        if (this.tokenMap.findMatching(node3, "(") !== null) return true;
        const arrowToken = this.tokenMap.findMatching(node3, "=>");
        if ((arrowToken == null ? void 0 : arrowToken.loc) == null) return true;
        return arrowToken.loc.start.line !== node3.loc.start.line;
      }
      if (this.format.retainLines) return true;
      return false;
    }
    function _getFuncIdName(idNode, parent) {
      let id3 = idNode;
      if (!id3 && parent) {
        const parentType = parent.type;
        if (parentType === "VariableDeclarator") {
          id3 = parent.id;
        } else if (parentType === "AssignmentExpression" || parentType === "AssignmentPattern") {
          id3 = parent.left;
        } else if (parentType === "ObjectProperty" || parentType === "ClassProperty") {
          if (!parent.computed || parent.key.type === "StringLiteral") {
            id3 = parent.key;
          }
        } else if (parentType === "ClassPrivateProperty" || parentType === "ClassAccessorProperty") {
          id3 = parent.key;
        }
      }
      if (!id3) return;
      let nameInfo;
      if (id3.type === "Identifier") {
        var _id$loc, _id$loc2;
        nameInfo = {
          pos: (_id$loc = id3.loc) == null ? void 0 : _id$loc.start,
          name: ((_id$loc2 = id3.loc) == null ? void 0 : _id$loc2.identifierName) || id3.name
        };
      } else if (id3.type === "PrivateName") {
        var _id$loc3;
        nameInfo = {
          pos: (_id$loc3 = id3.loc) == null ? void 0 : _id$loc3.start,
          name: "#" + id3.id.name
        };
      } else if (id3.type === "StringLiteral") {
        var _id$loc4;
        nameInfo = {
          pos: (_id$loc4 = id3.loc) == null ? void 0 : _id$loc4.start,
          name: id3.value
        };
      }
      return nameInfo;
    }
  }
});

// node_modules/@babel/generator/lib/generators/modules.js
var require_modules = __commonJS({
  "node_modules/@babel/generator/lib/generators/modules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ExportAllDeclaration = ExportAllDeclaration;
    exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
    exports2.ExportDefaultSpecifier = ExportDefaultSpecifier;
    exports2.ExportNamedDeclaration = ExportNamedDeclaration;
    exports2.ExportNamespaceSpecifier = ExportNamespaceSpecifier;
    exports2.ExportSpecifier = ExportSpecifier;
    exports2.ImportAttribute = ImportAttribute;
    exports2.ImportDeclaration = ImportDeclaration;
    exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
    exports2.ImportExpression = ImportExpression;
    exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
    exports2.ImportSpecifier = ImportSpecifier;
    exports2._printAttributes = _printAttributes;
    var _t = require_lib3();
    var _index = require_node4();
    var {
      isClassDeclaration,
      isExportDefaultSpecifier,
      isExportNamespaceSpecifier,
      isImportDefaultSpecifier,
      isImportNamespaceSpecifier,
      isStatement
    } = _t;
    function ImportSpecifier(node3) {
      if (node3.importKind === "type" || node3.importKind === "typeof") {
        this.word(node3.importKind);
        this.space();
      }
      this.print(node3.imported);
      if (node3.local && node3.local.name !== node3.imported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node3.local);
      }
    }
    function ImportDefaultSpecifier(node3) {
      this.print(node3.local);
    }
    function ExportDefaultSpecifier(node3) {
      this.print(node3.exported);
    }
    function ExportSpecifier(node3) {
      if (node3.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.print(node3.local);
      if (node3.exported && node3.local.name !== node3.exported.name) {
        this.space();
        this.word("as");
        this.space();
        this.print(node3.exported);
      }
    }
    function ExportNamespaceSpecifier(node3) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node3.exported);
    }
    var warningShown = false;
    function _printAttributes(node3, hasPreviousBrace) {
      const {
        importAttributesKeyword
      } = this.format;
      const {
        attributes,
        assertions
      } = node3;
      if (attributes && !importAttributesKeyword && !warningShown) {
        warningShown = true;
        console.warn(`You are using import attributes, without specifying the desired output syntax.
Please specify the "importAttributesKeyword" generator option, whose value can be one of:
 - "with"        : \`import { a } from "b" with { type: "json" };\`
 - "assert"      : \`import { a } from "b" assert { type: "json" };\`
 - "with-legacy" : \`import { a } from "b" with type: "json";\`
`);
      }
      const useAssertKeyword = importAttributesKeyword === "assert" || !importAttributesKeyword && assertions;
      this.word(useAssertKeyword ? "assert" : "with");
      this.space();
      if (!useAssertKeyword && importAttributesKeyword !== "with") {
        this.printList(attributes || assertions);
        return;
      }
      const occurrenceCount = hasPreviousBrace ? 1 : 0;
      this.token("{", null, occurrenceCount);
      this.space();
      this.printList(attributes || assertions, this.shouldPrintTrailingComma("}"));
      this.space();
      this.token("}", null, occurrenceCount);
    }
    function ExportAllDeclaration(node3) {
      var _node$attributes, _node$assertions;
      this.word("export");
      this.space();
      if (node3.exportKind === "type") {
        this.word("type");
        this.space();
      }
      this.tokenChar(42);
      this.space();
      this.word("from");
      this.space();
      if ((_node$attributes = node3.attributes) != null && _node$attributes.length || (_node$assertions = node3.assertions) != null && _node$assertions.length) {
        this.print(node3.source, true);
        this.space();
        this._printAttributes(node3, false);
      } else {
        this.print(node3.source);
      }
      this.semicolon();
    }
    function maybePrintDecoratorsBeforeExport(printer, node3) {
      if (isClassDeclaration(node3.declaration) && printer._shouldPrintDecoratorsBeforeExport(node3)) {
        printer.printJoin(node3.declaration.decorators);
      }
    }
    function ExportNamedDeclaration(node3) {
      maybePrintDecoratorsBeforeExport(this, node3);
      this.word("export");
      this.space();
      if (node3.declaration) {
        const declar = node3.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        if (node3.exportKind === "type") {
          this.word("type");
          this.space();
        }
        const specifiers = node3.specifiers.slice(0);
        let hasSpecial = false;
        for (; ; ) {
          const first2 = specifiers[0];
          if (isExportDefaultSpecifier(first2) || isExportNamespaceSpecifier(first2)) {
            hasSpecial = true;
            this.print(specifiers.shift());
            if (specifiers.length) {
              this.tokenChar(44);
              this.space();
            }
          } else {
            break;
          }
        }
        let hasBrace = false;
        if (specifiers.length || !specifiers.length && !hasSpecial) {
          hasBrace = true;
          this.tokenChar(123);
          if (specifiers.length) {
            this.space();
            this.printList(specifiers, this.shouldPrintTrailingComma("}"));
            this.space();
          }
          this.tokenChar(125);
        }
        if (node3.source) {
          var _node$attributes2, _node$assertions2;
          this.space();
          this.word("from");
          this.space();
          if ((_node$attributes2 = node3.attributes) != null && _node$attributes2.length || (_node$assertions2 = node3.assertions) != null && _node$assertions2.length) {
            this.print(node3.source, true);
            this.space();
            this._printAttributes(node3, hasBrace);
          } else {
            this.print(node3.source);
          }
        }
        this.semicolon();
      }
    }
    function ExportDefaultDeclaration(node3) {
      maybePrintDecoratorsBeforeExport(this, node3);
      this.word("export");
      this.noIndentInnerCommentsHere();
      this.space();
      this.word("default");
      this.space();
      this.tokenContext |= _index.TokenContext.exportDefault;
      const declar = node3.declaration;
      this.print(declar);
      if (!isStatement(declar)) this.semicolon();
    }
    function ImportDeclaration(node3) {
      var _node$attributes3, _node$assertions3;
      this.word("import");
      this.space();
      const isTypeKind = node3.importKind === "type" || node3.importKind === "typeof";
      if (isTypeKind) {
        this.noIndentInnerCommentsHere();
        this.word(node3.importKind);
        this.space();
      } else if (node3.module) {
        this.noIndentInnerCommentsHere();
        this.word("module");
        this.space();
      } else if (node3.phase) {
        this.noIndentInnerCommentsHere();
        this.word(node3.phase);
        this.space();
      }
      const specifiers = node3.specifiers.slice(0);
      const hasSpecifiers = !!specifiers.length;
      while (hasSpecifiers) {
        const first2 = specifiers[0];
        if (isImportDefaultSpecifier(first2) || isImportNamespaceSpecifier(first2)) {
          this.print(specifiers.shift());
          if (specifiers.length) {
            this.tokenChar(44);
            this.space();
          }
        } else {
          break;
        }
      }
      let hasBrace = false;
      if (specifiers.length) {
        hasBrace = true;
        this.tokenChar(123);
        this.space();
        this.printList(specifiers, this.shouldPrintTrailingComma("}"));
        this.space();
        this.tokenChar(125);
      } else if (isTypeKind && !hasSpecifiers) {
        hasBrace = true;
        this.tokenChar(123);
        this.tokenChar(125);
      }
      if (hasSpecifiers || isTypeKind) {
        this.space();
        this.word("from");
        this.space();
      }
      if ((_node$attributes3 = node3.attributes) != null && _node$attributes3.length || (_node$assertions3 = node3.assertions) != null && _node$assertions3.length) {
        this.print(node3.source, true);
        this.space();
        this._printAttributes(node3, hasBrace);
      } else {
        this.print(node3.source);
      }
      this.semicolon();
    }
    function ImportAttribute(node3) {
      this.print(node3.key);
      this.tokenChar(58);
      this.space();
      this.print(node3.value);
    }
    function ImportNamespaceSpecifier(node3) {
      this.tokenChar(42);
      this.space();
      this.word("as");
      this.space();
      this.print(node3.local);
    }
    function ImportExpression(node3) {
      this.word("import");
      if (node3.phase) {
        this.tokenChar(46);
        this.word(node3.phase);
      }
      this.tokenChar(40);
      this.print(node3.source);
      if (node3.options != null) {
        this.tokenChar(44);
        this.space();
        this.print(node3.options);
      }
      this.tokenChar(41);
    }
  }
});

// node_modules/jsesc/jsesc.js
var require_jsesc = __commonJS({
  "node_modules/jsesc/jsesc.js"(exports2, module) {
    "use strict";
    var object2 = {};
    var hasOwnProperty4 = object2.hasOwnProperty;
    var forOwn = (object3, callback) => {
      for (const key in object3) {
        if (hasOwnProperty4.call(object3, key)) {
          callback(key, object3[key]);
        }
      }
    };
    var extend = (destination, source) => {
      if (!source) {
        return destination;
      }
      forOwn(source, (key, value2) => {
        destination[key] = value2;
      });
      return destination;
    };
    var forEach = (array2, callback) => {
      const length = array2.length;
      let index4 = -1;
      while (++index4 < length) {
        callback(array2[index4]);
      }
    };
    var fourHexEscape = (hex) => {
      return "\\u" + ("0000" + hex).slice(-4);
    };
    var hexadecimal = (code, lowercase) => {
      let hexadecimal2 = code.toString(16);
      if (lowercase) return hexadecimal2;
      return hexadecimal2.toUpperCase();
    };
    var toString2 = object2.toString;
    var isArray2 = Array.isArray;
    var isBuffer2 = (value2) => {
      return typeof Buffer === "function" && Buffer.isBuffer(value2);
    };
    var isObject2 = (value2) => {
      return toString2.call(value2) == "[object Object]";
    };
    var isString3 = (value2) => {
      return typeof value2 == "string" || toString2.call(value2) == "[object String]";
    };
    var isNumber2 = (value2) => {
      return typeof value2 == "number" || toString2.call(value2) == "[object Number]";
    };
    var isFunction2 = (value2) => {
      return typeof value2 == "function";
    };
    var isMap2 = (value2) => {
      return toString2.call(value2) == "[object Map]";
    };
    var isSet = (value2) => {
      return toString2.call(value2) == "[object Set]";
    };
    var singleEscapes = {
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t"
      // `\v` is omitted intentionally, because in IE < 9, '\v' == 'v'.
      // '\v': '\\x0B'
    };
    var regexSingleEscape2 = /[\\\b\f\n\r\t]/;
    var regexDigit = /[0-9]/;
    var regexWhitespace = /[\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
    var escapeEverythingRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^]/g;
    var escapeNonAsciiRegex = /([\uD800-\uDBFF][\uDC00-\uDFFF])|([\uD800-\uDFFF])|(['"`])|[^ !#-&\(-\[\]-_a-~]/g;
    var jsesc = (argument, options2) => {
      const increaseIndentation = () => {
        oldIndent = indent;
        ++options2.indentLevel;
        indent = options2.indent.repeat(options2.indentLevel);
      };
      const defaults2 = {
        "escapeEverything": false,
        "minimal": false,
        "isScriptContext": false,
        "quotes": "single",
        "wrap": false,
        "es6": false,
        "json": false,
        "compact": true,
        "lowercaseHex": false,
        "numbers": "decimal",
        "indent": "	",
        "indentLevel": 0,
        "__inline1__": false,
        "__inline2__": false
      };
      const json = options2 && options2.json;
      if (json) {
        defaults2.quotes = "double";
        defaults2.wrap = true;
      }
      options2 = extend(defaults2, options2);
      if (options2.quotes != "single" && options2.quotes != "double" && options2.quotes != "backtick") {
        options2.quotes = "single";
      }
      const quote3 = options2.quotes == "double" ? '"' : options2.quotes == "backtick" ? "`" : "'";
      const compact = options2.compact;
      const lowercaseHex = options2.lowercaseHex;
      let indent = options2.indent.repeat(options2.indentLevel);
      let oldIndent = "";
      const inline1 = options2.__inline1__;
      const inline2 = options2.__inline2__;
      const newLine = compact ? "" : "\n";
      let result;
      let isEmpty2 = true;
      const useBinNumbers = options2.numbers == "binary";
      const useOctNumbers = options2.numbers == "octal";
      const useDecNumbers = options2.numbers == "decimal";
      const useHexNumbers = options2.numbers == "hexadecimal";
      if (json && argument && isFunction2(argument.toJSON)) {
        argument = argument.toJSON();
      }
      if (!isString3(argument)) {
        if (isMap2(argument)) {
          if (argument.size == 0) {
            return "new Map()";
          }
          if (!compact) {
            options2.__inline1__ = true;
            options2.__inline2__ = false;
          }
          return "new Map(" + jsesc(Array.from(argument), options2) + ")";
        }
        if (isSet(argument)) {
          if (argument.size == 0) {
            return "new Set()";
          }
          return "new Set(" + jsesc(Array.from(argument), options2) + ")";
        }
        if (isBuffer2(argument)) {
          if (argument.length == 0) {
            return "Buffer.from([])";
          }
          return "Buffer.from(" + jsesc(Array.from(argument), options2) + ")";
        }
        if (isArray2(argument)) {
          result = [];
          options2.wrap = true;
          if (inline1) {
            options2.__inline1__ = false;
            options2.__inline2__ = true;
          }
          if (!inline2) {
            increaseIndentation();
          }
          forEach(argument, (value2) => {
            isEmpty2 = false;
            if (inline2) {
              options2.__inline2__ = false;
            }
            result.push(
              (compact || inline2 ? "" : indent) + jsesc(value2, options2)
            );
          });
          if (isEmpty2) {
            return "[]";
          }
          if (inline2) {
            return "[" + result.join(", ") + "]";
          }
          return "[" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "]";
        } else if (isNumber2(argument)) {
          if (json) {
            return JSON.stringify(argument);
          }
          if (useDecNumbers) {
            return String(argument);
          }
          if (useHexNumbers) {
            let hexadecimal2 = argument.toString(16);
            if (!lowercaseHex) {
              hexadecimal2 = hexadecimal2.toUpperCase();
            }
            return "0x" + hexadecimal2;
          }
          if (useBinNumbers) {
            return "0b" + argument.toString(2);
          }
          if (useOctNumbers) {
            return "0o" + argument.toString(8);
          }
        } else if (!isObject2(argument)) {
          if (json) {
            return JSON.stringify(argument) || "null";
          }
          return String(argument);
        } else {
          result = [];
          options2.wrap = true;
          increaseIndentation();
          forOwn(argument, (key, value2) => {
            isEmpty2 = false;
            result.push(
              (compact ? "" : indent) + jsesc(key, options2) + ":" + (compact ? "" : " ") + jsesc(value2, options2)
            );
          });
          if (isEmpty2) {
            return "{}";
          }
          return "{" + newLine + result.join("," + newLine) + newLine + (compact ? "" : oldIndent) + "}";
        }
      }
      const regex2 = options2.escapeEverything ? escapeEverythingRegex : escapeNonAsciiRegex;
      result = argument.replace(regex2, (char, pair, lone, quoteChar, index4, string4) => {
        if (pair) {
          if (options2.minimal) return pair;
          const first2 = pair.charCodeAt(0);
          const second = pair.charCodeAt(1);
          if (options2.es6) {
            const codePoint = (first2 - 55296) * 1024 + second - 56320 + 65536;
            const hex2 = hexadecimal(codePoint, lowercaseHex);
            return "\\u{" + hex2 + "}";
          }
          return fourHexEscape(hexadecimal(first2, lowercaseHex)) + fourHexEscape(hexadecimal(second, lowercaseHex));
        }
        if (lone) {
          return fourHexEscape(hexadecimal(lone.charCodeAt(0), lowercaseHex));
        }
        if (char == "\0" && !json && !regexDigit.test(string4.charAt(index4 + 1))) {
          return "\\0";
        }
        if (quoteChar) {
          if (quoteChar == quote3 || options2.escapeEverything) {
            return "\\" + quoteChar;
          }
          return quoteChar;
        }
        if (regexSingleEscape2.test(char)) {
          return singleEscapes[char];
        }
        if (options2.minimal && !regexWhitespace.test(char)) {
          return char;
        }
        const hex = hexadecimal(char.charCodeAt(0), lowercaseHex);
        if (json || hex.length > 2) {
          return fourHexEscape(hex);
        }
        return "\\x" + ("00" + hex).slice(-2);
      });
      if (quote3 == "`") {
        result = result.replace(/\$\{/g, "\\${");
      }
      if (options2.isScriptContext) {
        result = result.replace(/<\/(script|style)/gi, "<\\/$1").replace(/<!--/g, json ? "\\u003C!--" : "\\x3C!--");
      }
      if (options2.wrap) {
        result = quote3 + result + quote3;
      }
      return result;
    };
    jsesc.version = "3.0.2";
    module.exports = jsesc;
  }
});

// node_modules/@babel/generator/lib/generators/types.js
var require_types = __commonJS({
  "node_modules/@babel/generator/lib/generators/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArgumentPlaceholder = ArgumentPlaceholder;
    exports2.ArrayPattern = exports2.ArrayExpression = ArrayExpression;
    exports2.BigIntLiteral = BigIntLiteral;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.Identifier = Identifier2;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral2;
    exports2.ObjectPattern = exports2.ObjectExpression = ObjectExpression;
    exports2.ObjectMethod = ObjectMethod;
    exports2.ObjectProperty = ObjectProperty;
    exports2.PipelineBareFunction = PipelineBareFunction;
    exports2.PipelinePrimaryTopicReference = PipelinePrimaryTopicReference;
    exports2.PipelineTopicExpression = PipelineTopicExpression;
    exports2.RecordExpression = RecordExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.SpreadElement = exports2.RestElement = RestElement;
    exports2.StringLiteral = StringLiteral2;
    exports2.TopicReference = TopicReference;
    exports2.TupleExpression = TupleExpression;
    exports2._getRawIdentifier = _getRawIdentifier;
    var _t = require_lib3();
    var _jsesc = require_jsesc();
    var {
      isAssignmentPattern,
      isIdentifier: isIdentifier2
    } = _t;
    var lastRawIdentNode = null;
    var lastRawIdentResult = "";
    function _getRawIdentifier(node3) {
      if (node3 === lastRawIdentNode) return lastRawIdentResult;
      lastRawIdentNode = node3;
      const {
        name: name2
      } = node3;
      const token = this.tokenMap.find(node3, (tok) => tok.value === name2);
      if (token) {
        lastRawIdentResult = this._originalCode.slice(token.start, token.end);
        return lastRawIdentResult;
      }
      return lastRawIdentResult = node3.name;
    }
    function Identifier2(node3) {
      var _node$loc;
      this.sourceIdentifierName(((_node$loc = node3.loc) == null ? void 0 : _node$loc.identifierName) || node3.name);
      this.word(this.tokenMap ? this._getRawIdentifier(node3) : node3.name);
    }
    function ArgumentPlaceholder() {
      this.tokenChar(63);
    }
    function RestElement(node3) {
      this.token("...");
      this.print(node3.argument);
    }
    function ObjectExpression(node3) {
      const props = node3.properties;
      this.tokenChar(123);
      if (props.length) {
        const exit = this.enterDelimited();
        this.space();
        this.printList(props, this.shouldPrintTrailingComma("}"), true, true);
        this.space();
        exit();
      }
      this.sourceWithOffset("end", node3.loc, -1);
      this.tokenChar(125);
    }
    function ObjectMethod(node3) {
      this.printJoin(node3.decorators);
      this._methodHead(node3);
      this.space();
      this.print(node3.body);
    }
    function ObjectProperty(node3) {
      this.printJoin(node3.decorators);
      if (node3.computed) {
        this.tokenChar(91);
        this.print(node3.key);
        this.tokenChar(93);
      } else {
        if (isAssignmentPattern(node3.value) && isIdentifier2(node3.key) && node3.key.name === node3.value.left.name) {
          this.print(node3.value);
          return;
        }
        this.print(node3.key);
        if (node3.shorthand && isIdentifier2(node3.key) && isIdentifier2(node3.value) && node3.key.name === node3.value.name) {
          return;
        }
      }
      this.tokenChar(58);
      this.space();
      this.print(node3.value);
    }
    function ArrayExpression(node3) {
      const elems = node3.elements;
      const len = elems.length;
      this.tokenChar(91);
      const exit = this.enterDelimited();
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma("]")) {
            this.token(",", false, i);
          }
        } else {
          this.token(",", false, i);
        }
      }
      exit();
      this.tokenChar(93);
    }
    function RecordExpression(node3) {
      const props = node3.properties;
      let startToken;
      let endToken;
      {
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "{|";
          endToken = "|}";
        } else if (this.format.recordAndTupleSyntaxType !== "hash" && this.format.recordAndTupleSyntaxType != null) {
          throw new Error(`The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" (${JSON.stringify(this.format.recordAndTupleSyntaxType)} received).`);
        } else {
          startToken = "#{";
          endToken = "}";
        }
      }
      this.token(startToken);
      if (props.length) {
        this.space();
        this.printList(props, this.shouldPrintTrailingComma(endToken), true, true);
        this.space();
      }
      this.token(endToken);
    }
    function TupleExpression(node3) {
      const elems = node3.elements;
      const len = elems.length;
      let startToken;
      let endToken;
      {
        if (this.format.recordAndTupleSyntaxType === "bar") {
          startToken = "[|";
          endToken = "|]";
        } else if (this.format.recordAndTupleSyntaxType === "hash") {
          startToken = "#[";
          endToken = "]";
        } else {
          throw new Error(`${this.format.recordAndTupleSyntaxType} is not a valid recordAndTuple syntax type`);
        }
      }
      this.token(startToken);
      for (let i = 0; i < elems.length; i++) {
        const elem = elems[i];
        if (elem) {
          if (i > 0) this.space();
          this.print(elem);
          if (i < len - 1 || this.shouldPrintTrailingComma(endToken)) {
            this.token(",", false, i);
          }
        }
      }
      this.token(endToken);
    }
    function RegExpLiteral(node3) {
      this.word(`/${node3.pattern}/${node3.flags}`);
    }
    function BooleanLiteral(node3) {
      this.word(node3.value ? "true" : "false");
    }
    function NullLiteral() {
      this.word("null");
    }
    function NumericLiteral2(node3) {
      const raw = this.getPossibleRaw(node3);
      const opts = this.format.jsescOption;
      const value2 = node3.value;
      const str2 = value2 + "";
      if (opts.numbers) {
        this.number(_jsesc(value2, opts), value2);
      } else if (raw == null) {
        this.number(str2, value2);
      } else if (this.format.minified) {
        this.number(raw.length < str2.length ? raw : str2, value2);
      } else {
        this.number(raw, value2);
      }
    }
    function StringLiteral2(node3) {
      const raw = this.getPossibleRaw(node3);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const val = _jsesc(node3.value, this.format.jsescOption);
      this.token(val);
    }
    function BigIntLiteral(node3) {
      const raw = this.getPossibleRaw(node3);
      if (!this.format.minified && raw !== void 0) {
        this.word(raw);
        return;
      }
      this.word(node3.value + "n");
    }
    var validTopicTokenSet = /* @__PURE__ */ new Set(["^^", "@@", "^", "%", "#"]);
    function TopicReference() {
      const {
        topicToken
      } = this.format;
      if (validTopicTokenSet.has(topicToken)) {
        this.token(topicToken);
      } else {
        const givenTopicTokenJSON = JSON.stringify(topicToken);
        const validTopics = Array.from(validTopicTokenSet, (v) => JSON.stringify(v));
        throw new Error(`The "topicToken" generator option must be one of ${validTopics.join(", ")} (${givenTopicTokenJSON} received instead).`);
      }
    }
    function PipelineTopicExpression(node3) {
      this.print(node3.expression);
    }
    function PipelineBareFunction(node3) {
      this.print(node3.callee);
    }
    function PipelinePrimaryTopicReference() {
      this.tokenChar(35);
    }
  }
});

// node_modules/@babel/generator/lib/generators/flow.js
var require_flow2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/flow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AnyTypeAnnotation = AnyTypeAnnotation;
    exports2.ArrayTypeAnnotation = ArrayTypeAnnotation;
    exports2.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;
    exports2.BooleanTypeAnnotation = BooleanTypeAnnotation;
    exports2.DeclareClass = DeclareClass;
    exports2.DeclareExportAllDeclaration = DeclareExportAllDeclaration;
    exports2.DeclareExportDeclaration = DeclareExportDeclaration;
    exports2.DeclareFunction = DeclareFunction;
    exports2.DeclareInterface = DeclareInterface;
    exports2.DeclareModule = DeclareModule;
    exports2.DeclareModuleExports = DeclareModuleExports;
    exports2.DeclareOpaqueType = DeclareOpaqueType;
    exports2.DeclareTypeAlias = DeclareTypeAlias;
    exports2.DeclareVariable = DeclareVariable;
    exports2.DeclaredPredicate = DeclaredPredicate;
    exports2.EmptyTypeAnnotation = EmptyTypeAnnotation;
    exports2.EnumBooleanBody = EnumBooleanBody;
    exports2.EnumBooleanMember = EnumBooleanMember;
    exports2.EnumDeclaration = EnumDeclaration;
    exports2.EnumDefaultedMember = EnumDefaultedMember;
    exports2.EnumNumberBody = EnumNumberBody;
    exports2.EnumNumberMember = EnumNumberMember;
    exports2.EnumStringBody = EnumStringBody;
    exports2.EnumStringMember = EnumStringMember;
    exports2.EnumSymbolBody = EnumSymbolBody;
    exports2.ExistsTypeAnnotation = ExistsTypeAnnotation;
    exports2.FunctionTypeAnnotation = FunctionTypeAnnotation;
    exports2.FunctionTypeParam = FunctionTypeParam;
    exports2.IndexedAccessType = IndexedAccessType;
    exports2.InferredPredicate = InferredPredicate;
    exports2.InterfaceDeclaration = InterfaceDeclaration;
    exports2.GenericTypeAnnotation = exports2.ClassImplements = exports2.InterfaceExtends = InterfaceExtends;
    exports2.InterfaceTypeAnnotation = InterfaceTypeAnnotation;
    exports2.IntersectionTypeAnnotation = IntersectionTypeAnnotation;
    exports2.MixedTypeAnnotation = MixedTypeAnnotation;
    exports2.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;
    exports2.NullableTypeAnnotation = NullableTypeAnnotation;
    Object.defineProperty(exports2, "NumberLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.NumericLiteral;
      }
    });
    exports2.NumberTypeAnnotation = NumberTypeAnnotation;
    exports2.ObjectTypeAnnotation = ObjectTypeAnnotation;
    exports2.ObjectTypeCallProperty = ObjectTypeCallProperty;
    exports2.ObjectTypeIndexer = ObjectTypeIndexer;
    exports2.ObjectTypeInternalSlot = ObjectTypeInternalSlot;
    exports2.ObjectTypeProperty = ObjectTypeProperty;
    exports2.ObjectTypeSpreadProperty = ObjectTypeSpreadProperty;
    exports2.OpaqueType = OpaqueType;
    exports2.OptionalIndexedAccessType = OptionalIndexedAccessType;
    exports2.QualifiedTypeIdentifier = QualifiedTypeIdentifier;
    Object.defineProperty(exports2, "StringLiteralTypeAnnotation", {
      enumerable: true,
      get: function() {
        return _types2.StringLiteral;
      }
    });
    exports2.StringTypeAnnotation = StringTypeAnnotation;
    exports2.SymbolTypeAnnotation = SymbolTypeAnnotation;
    exports2.ThisTypeAnnotation = ThisTypeAnnotation;
    exports2.TupleTypeAnnotation = TupleTypeAnnotation;
    exports2.TypeAlias = TypeAlias;
    exports2.TypeAnnotation = TypeAnnotation;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.TypeParameter = TypeParameter;
    exports2.TypeParameterDeclaration = exports2.TypeParameterInstantiation = TypeParameterInstantiation;
    exports2.TypeofTypeAnnotation = TypeofTypeAnnotation;
    exports2.UnionTypeAnnotation = UnionTypeAnnotation;
    exports2.Variance = Variance;
    exports2.VoidTypeAnnotation = VoidTypeAnnotation;
    exports2._interfaceish = _interfaceish;
    exports2._variance = _variance;
    var _t = require_lib3();
    var _modules = require_modules();
    var _index = require_node4();
    var _types2 = require_types();
    var {
      isDeclareExportDeclaration,
      isStatement
    } = _t;
    function AnyTypeAnnotation() {
      this.word("any");
    }
    function ArrayTypeAnnotation(node3) {
      this.print(node3.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function BooleanTypeAnnotation() {
      this.word("boolean");
    }
    function BooleanLiteralTypeAnnotation(node3) {
      this.word(node3.value ? "true" : "false");
    }
    function NullLiteralTypeAnnotation() {
      this.word("null");
    }
    function DeclareClass(node3, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("class");
      this.space();
      this._interfaceish(node3);
    }
    function DeclareFunction(node3, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("function");
      this.space();
      this.print(node3.id);
      this.print(node3.id.typeAnnotation.typeAnnotation);
      if (node3.predicate) {
        this.space();
        this.print(node3.predicate);
      }
      this.semicolon();
    }
    function InferredPredicate() {
      this.tokenChar(37);
      this.word("checks");
    }
    function DeclaredPredicate(node3) {
      this.tokenChar(37);
      this.word("checks");
      this.tokenChar(40);
      this.print(node3.value);
      this.tokenChar(41);
    }
    function DeclareInterface(node3) {
      this.word("declare");
      this.space();
      this.InterfaceDeclaration(node3);
    }
    function DeclareModule(node3) {
      this.word("declare");
      this.space();
      this.word("module");
      this.space();
      this.print(node3.id);
      this.space();
      this.print(node3.body);
    }
    function DeclareModuleExports(node3) {
      this.word("declare");
      this.space();
      this.word("module");
      this.tokenChar(46);
      this.word("exports");
      this.print(node3.typeAnnotation);
    }
    function DeclareTypeAlias(node3) {
      this.word("declare");
      this.space();
      this.TypeAlias(node3);
    }
    function DeclareOpaqueType(node3, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.OpaqueType(node3);
    }
    function DeclareVariable(node3, parent) {
      if (!isDeclareExportDeclaration(parent)) {
        this.word("declare");
        this.space();
      }
      this.word("var");
      this.space();
      this.print(node3.id);
      this.print(node3.id.typeAnnotation);
      this.semicolon();
    }
    function DeclareExportDeclaration(node3) {
      this.word("declare");
      this.space();
      this.word("export");
      this.space();
      if (node3.default) {
        this.word("default");
        this.space();
      }
      FlowExportDeclaration.call(this, node3);
    }
    function DeclareExportAllDeclaration(node3) {
      this.word("declare");
      this.space();
      _modules.ExportAllDeclaration.call(this, node3);
    }
    function EnumDeclaration(node3) {
      const {
        id: id3,
        body
      } = node3;
      this.word("enum");
      this.space();
      this.print(id3);
      this.print(body);
    }
    function enumExplicitType(context, name2, hasExplicitType) {
      if (hasExplicitType) {
        context.space();
        context.word("of");
        context.space();
        context.word(name2);
      }
      context.space();
    }
    function enumBody(context, node3) {
      const {
        members
      } = node3;
      context.token("{");
      context.indent();
      context.newline();
      for (const member of members) {
        context.print(member);
        context.newline();
      }
      if (node3.hasUnknownMembers) {
        context.token("...");
        context.newline();
      }
      context.dedent();
      context.token("}");
    }
    function EnumBooleanBody(node3) {
      const {
        explicitType
      } = node3;
      enumExplicitType(this, "boolean", explicitType);
      enumBody(this, node3);
    }
    function EnumNumberBody(node3) {
      const {
        explicitType
      } = node3;
      enumExplicitType(this, "number", explicitType);
      enumBody(this, node3);
    }
    function EnumStringBody(node3) {
      const {
        explicitType
      } = node3;
      enumExplicitType(this, "string", explicitType);
      enumBody(this, node3);
    }
    function EnumSymbolBody(node3) {
      enumExplicitType(this, "symbol", true);
      enumBody(this, node3);
    }
    function EnumDefaultedMember(node3) {
      const {
        id: id3
      } = node3;
      this.print(id3);
      this.tokenChar(44);
    }
    function enumInitializedMember(context, node3) {
      context.print(node3.id);
      context.space();
      context.token("=");
      context.space();
      context.print(node3.init);
      context.token(",");
    }
    function EnumBooleanMember(node3) {
      enumInitializedMember(this, node3);
    }
    function EnumNumberMember(node3) {
      enumInitializedMember(this, node3);
    }
    function EnumStringMember(node3) {
      enumInitializedMember(this, node3);
    }
    function FlowExportDeclaration(node3) {
      if (node3.declaration) {
        const declar = node3.declaration;
        this.print(declar);
        if (!isStatement(declar)) this.semicolon();
      } else {
        this.tokenChar(123);
        if (node3.specifiers.length) {
          this.space();
          this.printList(node3.specifiers);
          this.space();
        }
        this.tokenChar(125);
        if (node3.source) {
          this.space();
          this.word("from");
          this.space();
          this.print(node3.source);
        }
        this.semicolon();
      }
    }
    function ExistsTypeAnnotation() {
      this.tokenChar(42);
    }
    function FunctionTypeAnnotation(node3, parent) {
      this.print(node3.typeParameters);
      this.tokenChar(40);
      if (node3.this) {
        this.word("this");
        this.tokenChar(58);
        this.space();
        this.print(node3.this.typeAnnotation);
        if (node3.params.length || node3.rest) {
          this.tokenChar(44);
          this.space();
        }
      }
      this.printList(node3.params);
      if (node3.rest) {
        if (node3.params.length) {
          this.tokenChar(44);
          this.space();
        }
        this.token("...");
        this.print(node3.rest);
      }
      this.tokenChar(41);
      const type = parent == null ? void 0 : parent.type;
      if (type != null && (type === "ObjectTypeCallProperty" || type === "ObjectTypeInternalSlot" || type === "DeclareFunction" || type === "ObjectTypeProperty" && parent.method)) {
        this.tokenChar(58);
      } else {
        this.space();
        this.token("=>");
      }
      this.space();
      this.print(node3.returnType);
    }
    function FunctionTypeParam(node3) {
      this.print(node3.name);
      if (node3.optional) this.tokenChar(63);
      if (node3.name) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node3.typeAnnotation);
    }
    function InterfaceExtends(node3) {
      this.print(node3.id);
      this.print(node3.typeParameters, true);
    }
    function _interfaceish(node3) {
      var _node$extends;
      this.print(node3.id);
      this.print(node3.typeParameters);
      if ((_node$extends = node3.extends) != null && _node$extends.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node3.extends);
      }
      if (node3.type === "DeclareClass") {
        var _node$mixins, _node$implements;
        if ((_node$mixins = node3.mixins) != null && _node$mixins.length) {
          this.space();
          this.word("mixins");
          this.space();
          this.printList(node3.mixins);
        }
        if ((_node$implements = node3.implements) != null && _node$implements.length) {
          this.space();
          this.word("implements");
          this.space();
          this.printList(node3.implements);
        }
      }
      this.space();
      this.print(node3.body);
    }
    function _variance(node3) {
      var _node$variance;
      const kind = (_node$variance = node3.variance) == null ? void 0 : _node$variance.kind;
      if (kind != null) {
        if (kind === "plus") {
          this.tokenChar(43);
        } else if (kind === "minus") {
          this.tokenChar(45);
        }
      }
    }
    function InterfaceDeclaration(node3) {
      this.word("interface");
      this.space();
      this._interfaceish(node3);
    }
    function andSeparator(occurrenceCount) {
      this.space();
      this.token("&", false, occurrenceCount);
      this.space();
    }
    function InterfaceTypeAnnotation(node3) {
      var _node$extends2;
      this.word("interface");
      if ((_node$extends2 = node3.extends) != null && _node$extends2.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(node3.extends);
      }
      this.space();
      this.print(node3.body);
    }
    function IntersectionTypeAnnotation(node3) {
      this.printJoin(node3.types, void 0, void 0, andSeparator);
    }
    function MixedTypeAnnotation() {
      this.word("mixed");
    }
    function EmptyTypeAnnotation() {
      this.word("empty");
    }
    function NullableTypeAnnotation(node3) {
      this.tokenChar(63);
      this.print(node3.typeAnnotation);
    }
    function NumberTypeAnnotation() {
      this.word("number");
    }
    function StringTypeAnnotation() {
      this.word("string");
    }
    function ThisTypeAnnotation() {
      this.word("this");
    }
    function TupleTypeAnnotation(node3) {
      this.tokenChar(91);
      this.printList(node3.types);
      this.tokenChar(93);
    }
    function TypeofTypeAnnotation(node3) {
      this.word("typeof");
      this.space();
      this.print(node3.argument);
    }
    function TypeAlias(node3) {
      this.word("type");
      this.space();
      this.print(node3.id);
      this.print(node3.typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node3.right);
      this.semicolon();
    }
    function TypeAnnotation(node3, parent) {
      this.tokenChar(58);
      this.space();
      if (parent.type === "ArrowFunctionExpression") {
        this.tokenContext |= _index.TokenContext.arrowFlowReturnType;
      } else if (node3.optional) {
        this.tokenChar(63);
      }
      this.print(node3.typeAnnotation);
    }
    function TypeParameterInstantiation(node3) {
      this.tokenChar(60);
      this.printList(node3.params);
      this.tokenChar(62);
    }
    function TypeParameter(node3) {
      this._variance(node3);
      this.word(node3.name);
      if (node3.bound) {
        this.print(node3.bound);
      }
      if (node3.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node3.default);
      }
    }
    function OpaqueType(node3) {
      this.word("opaque");
      this.space();
      this.word("type");
      this.space();
      this.print(node3.id);
      this.print(node3.typeParameters);
      if (node3.supertype) {
        this.tokenChar(58);
        this.space();
        this.print(node3.supertype);
      }
      if (node3.impltype) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node3.impltype);
      }
      this.semicolon();
    }
    function ObjectTypeAnnotation(node3) {
      if (node3.exact) {
        this.token("{|");
      } else {
        this.tokenChar(123);
      }
      const props = [...node3.properties, ...node3.callProperties || [], ...node3.indexers || [], ...node3.internalSlots || []];
      if (props.length) {
        this.newline();
        this.space();
        this.printJoin(props, true, true, void 0, void 0, function addNewlines(leading) {
          if (leading && !props[0]) return 1;
        }, () => {
          if (props.length !== 1 || node3.inexact) {
            this.tokenChar(44);
            this.space();
          }
        });
        this.space();
      }
      if (node3.inexact) {
        this.indent();
        this.token("...");
        if (props.length) {
          this.newline();
        }
        this.dedent();
      }
      if (node3.exact) {
        this.token("|}");
      } else {
        this.tokenChar(125);
      }
    }
    function ObjectTypeInternalSlot(node3) {
      if (node3.static) {
        this.word("static");
        this.space();
      }
      this.tokenChar(91);
      this.tokenChar(91);
      this.print(node3.id);
      this.tokenChar(93);
      this.tokenChar(93);
      if (node3.optional) this.tokenChar(63);
      if (!node3.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node3.value);
    }
    function ObjectTypeCallProperty(node3) {
      if (node3.static) {
        this.word("static");
        this.space();
      }
      this.print(node3.value);
    }
    function ObjectTypeIndexer(node3) {
      if (node3.static) {
        this.word("static");
        this.space();
      }
      this._variance(node3);
      this.tokenChar(91);
      if (node3.id) {
        this.print(node3.id);
        this.tokenChar(58);
        this.space();
      }
      this.print(node3.key);
      this.tokenChar(93);
      this.tokenChar(58);
      this.space();
      this.print(node3.value);
    }
    function ObjectTypeProperty(node3) {
      if (node3.proto) {
        this.word("proto");
        this.space();
      }
      if (node3.static) {
        this.word("static");
        this.space();
      }
      if (node3.kind === "get" || node3.kind === "set") {
        this.word(node3.kind);
        this.space();
      }
      this._variance(node3);
      this.print(node3.key);
      if (node3.optional) this.tokenChar(63);
      if (!node3.method) {
        this.tokenChar(58);
        this.space();
      }
      this.print(node3.value);
    }
    function ObjectTypeSpreadProperty(node3) {
      this.token("...");
      this.print(node3.argument);
    }
    function QualifiedTypeIdentifier(node3) {
      this.print(node3.qualification);
      this.tokenChar(46);
      this.print(node3.id);
    }
    function SymbolTypeAnnotation() {
      this.word("symbol");
    }
    function orSeparator(occurrenceCount) {
      this.space();
      this.token("|", false, occurrenceCount);
      this.space();
    }
    function UnionTypeAnnotation(node3) {
      this.printJoin(node3.types, void 0, void 0, orSeparator);
    }
    function TypeCastExpression(node3) {
      this.tokenChar(40);
      this.print(node3.expression);
      this.print(node3.typeAnnotation);
      this.tokenChar(41);
    }
    function Variance(node3) {
      if (node3.kind === "plus") {
        this.tokenChar(43);
      } else {
        this.tokenChar(45);
      }
    }
    function VoidTypeAnnotation() {
      this.word("void");
    }
    function IndexedAccessType(node3) {
      this.print(node3.objectType, true);
      this.tokenChar(91);
      this.print(node3.indexType);
      this.tokenChar(93);
    }
    function OptionalIndexedAccessType(node3) {
      this.print(node3.objectType);
      if (node3.optional) {
        this.token("?.");
      }
      this.tokenChar(91);
      this.print(node3.indexType);
      this.tokenChar(93);
    }
  }
});

// node_modules/@babel/generator/lib/generators/base.js
var require_base = __commonJS({
  "node_modules/@babel/generator/lib/generators/base.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BlockStatement = BlockStatement;
    exports2.Directive = Directive;
    exports2.DirectiveLiteral = DirectiveLiteral;
    exports2.File = File;
    exports2.InterpreterDirective = InterpreterDirective;
    exports2.Placeholder = Placeholder;
    exports2.Program = Program;
    function File(node3) {
      if (node3.program) {
        this.print(node3.program.interpreter);
      }
      this.print(node3.program);
    }
    function Program(node3) {
      var _node$directives;
      this.noIndentInnerCommentsHere();
      this.printInnerComments();
      const directivesLen = (_node$directives = node3.directives) == null ? void 0 : _node$directives.length;
      if (directivesLen) {
        var _node$directives$trai;
        const newline2 = node3.body.length ? 2 : 1;
        this.printSequence(node3.directives, void 0, newline2);
        if (!((_node$directives$trai = node3.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai.length)) {
          this.newline(newline2);
        }
      }
      this.printSequence(node3.body);
    }
    function BlockStatement(node3) {
      var _node$directives2;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      const directivesLen = (_node$directives2 = node3.directives) == null ? void 0 : _node$directives2.length;
      if (directivesLen) {
        var _node$directives$trai2;
        const newline2 = node3.body.length ? 2 : 1;
        this.printSequence(node3.directives, true, newline2);
        if (!((_node$directives$trai2 = node3.directives[directivesLen - 1].trailingComments) != null && _node$directives$trai2.length)) {
          this.newline(newline2);
        }
      }
      this.printSequence(node3.body, true);
      exit();
      this.rightBrace(node3);
    }
    function Directive(node3) {
      this.print(node3.value);
      this.semicolon();
    }
    var unescapedSingleQuoteRE = /(?:^|[^\\])(?:\\\\)*'/;
    var unescapedDoubleQuoteRE = /(?:^|[^\\])(?:\\\\)*"/;
    function DirectiveLiteral(node3) {
      const raw = this.getPossibleRaw(node3);
      if (!this.format.minified && raw !== void 0) {
        this.token(raw);
        return;
      }
      const {
        value: value2
      } = node3;
      if (!unescapedDoubleQuoteRE.test(value2)) {
        this.token(`"${value2}"`);
      } else if (!unescapedSingleQuoteRE.test(value2)) {
        this.token(`'${value2}'`);
      } else {
        throw new Error("Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes.");
      }
    }
    function InterpreterDirective(node3) {
      this.token(`#!${node3.value}`);
      this.newline(1, true);
    }
    function Placeholder(node3) {
      this.token("%%");
      this.print(node3.name);
      this.token("%%");
      if (node3.expectedNode === "Statement") {
        this.semicolon();
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/jsx.js
var require_jsx2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/jsx.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSXAttribute = JSXAttribute;
    exports2.JSXClosingElement = JSXClosingElement;
    exports2.JSXClosingFragment = JSXClosingFragment;
    exports2.JSXElement = JSXElement;
    exports2.JSXEmptyExpression = JSXEmptyExpression;
    exports2.JSXExpressionContainer = JSXExpressionContainer;
    exports2.JSXFragment = JSXFragment;
    exports2.JSXIdentifier = JSXIdentifier2;
    exports2.JSXMemberExpression = JSXMemberExpression;
    exports2.JSXNamespacedName = JSXNamespacedName;
    exports2.JSXOpeningElement = JSXOpeningElement;
    exports2.JSXOpeningFragment = JSXOpeningFragment;
    exports2.JSXSpreadAttribute = JSXSpreadAttribute;
    exports2.JSXSpreadChild = JSXSpreadChild;
    exports2.JSXText = JSXText2;
    function JSXAttribute(node3) {
      this.print(node3.name);
      if (node3.value) {
        this.tokenChar(61);
        this.print(node3.value);
      }
    }
    function JSXIdentifier2(node3) {
      this.word(node3.name);
    }
    function JSXNamespacedName(node3) {
      this.print(node3.namespace);
      this.tokenChar(58);
      this.print(node3.name);
    }
    function JSXMemberExpression(node3) {
      this.print(node3.object);
      this.tokenChar(46);
      this.print(node3.property);
    }
    function JSXSpreadAttribute(node3) {
      this.tokenChar(123);
      this.token("...");
      this.print(node3.argument);
      this.rightBrace(node3);
    }
    function JSXExpressionContainer(node3) {
      this.tokenChar(123);
      this.print(node3.expression);
      this.rightBrace(node3);
    }
    function JSXSpreadChild(node3) {
      this.tokenChar(123);
      this.token("...");
      this.print(node3.expression);
      this.rightBrace(node3);
    }
    function JSXText2(node3) {
      const raw = this.getPossibleRaw(node3);
      if (raw !== void 0) {
        this.token(raw, true);
      } else {
        this.token(node3.value, true);
      }
    }
    function JSXElement(node3) {
      const open2 = node3.openingElement;
      this.print(open2);
      if (open2.selfClosing) return;
      this.indent();
      for (const child of node3.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node3.closingElement);
    }
    function spaceSeparator() {
      this.space();
    }
    function JSXOpeningElement(node3) {
      this.tokenChar(60);
      this.print(node3.name);
      {
        if (node3.typeArguments) {
          this.print(node3.typeArguments);
        }
        this.print(node3.typeParameters);
      }
      if (node3.attributes.length > 0) {
        this.space();
        this.printJoin(node3.attributes, void 0, void 0, spaceSeparator);
      }
      if (node3.selfClosing) {
        this.space();
        this.tokenChar(47);
      }
      this.tokenChar(62);
    }
    function JSXClosingElement(node3) {
      this.tokenChar(60);
      this.tokenChar(47);
      this.print(node3.name);
      this.tokenChar(62);
    }
    function JSXEmptyExpression() {
      this.printInnerComments();
    }
    function JSXFragment(node3) {
      this.print(node3.openingFragment);
      this.indent();
      for (const child of node3.children) {
        this.print(child);
      }
      this.dedent();
      this.print(node3.closingFragment);
    }
    function JSXOpeningFragment() {
      this.tokenChar(60);
      this.tokenChar(62);
    }
    function JSXClosingFragment() {
      this.token("</");
      this.tokenChar(62);
    }
  }
});

// node_modules/@babel/generator/lib/generators/typescript.js
var require_typescript2 = __commonJS({
  "node_modules/@babel/generator/lib/generators/typescript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TSAnyKeyword = TSAnyKeyword;
    exports2.TSArrayType = TSArrayType;
    exports2.TSSatisfiesExpression = exports2.TSAsExpression = TSTypeExpression;
    exports2.TSBigIntKeyword = TSBigIntKeyword;
    exports2.TSBooleanKeyword = TSBooleanKeyword;
    exports2.TSCallSignatureDeclaration = TSCallSignatureDeclaration;
    exports2.TSInterfaceHeritage = exports2.TSClassImplements = TSClassImplements;
    exports2.TSConditionalType = TSConditionalType;
    exports2.TSConstructSignatureDeclaration = TSConstructSignatureDeclaration;
    exports2.TSConstructorType = TSConstructorType;
    exports2.TSDeclareFunction = TSDeclareFunction;
    exports2.TSDeclareMethod = TSDeclareMethod;
    exports2.TSEnumBody = TSEnumBody;
    exports2.TSEnumDeclaration = TSEnumDeclaration;
    exports2.TSEnumMember = TSEnumMember;
    exports2.TSExportAssignment = TSExportAssignment;
    exports2.TSExternalModuleReference = TSExternalModuleReference;
    exports2.TSFunctionType = TSFunctionType;
    exports2.TSImportEqualsDeclaration = TSImportEqualsDeclaration;
    exports2.TSImportType = TSImportType;
    exports2.TSIndexSignature = TSIndexSignature;
    exports2.TSIndexedAccessType = TSIndexedAccessType;
    exports2.TSInferType = TSInferType;
    exports2.TSInstantiationExpression = TSInstantiationExpression;
    exports2.TSInterfaceBody = TSInterfaceBody;
    exports2.TSInterfaceDeclaration = TSInterfaceDeclaration;
    exports2.TSIntersectionType = TSIntersectionType;
    exports2.TSIntrinsicKeyword = TSIntrinsicKeyword;
    exports2.TSLiteralType = TSLiteralType;
    exports2.TSMappedType = TSMappedType;
    exports2.TSMethodSignature = TSMethodSignature;
    exports2.TSModuleBlock = TSModuleBlock;
    exports2.TSModuleDeclaration = TSModuleDeclaration;
    exports2.TSNamedTupleMember = TSNamedTupleMember;
    exports2.TSNamespaceExportDeclaration = TSNamespaceExportDeclaration;
    exports2.TSNeverKeyword = TSNeverKeyword;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TSNullKeyword = TSNullKeyword;
    exports2.TSNumberKeyword = TSNumberKeyword;
    exports2.TSObjectKeyword = TSObjectKeyword;
    exports2.TSOptionalType = TSOptionalType;
    exports2.TSParameterProperty = TSParameterProperty;
    exports2.TSParenthesizedType = TSParenthesizedType;
    exports2.TSPropertySignature = TSPropertySignature;
    exports2.TSQualifiedName = TSQualifiedName;
    exports2.TSRestType = TSRestType;
    exports2.TSStringKeyword = TSStringKeyword;
    exports2.TSSymbolKeyword = TSSymbolKeyword;
    exports2.TSTemplateLiteralType = TSTemplateLiteralType;
    exports2.TSThisType = TSThisType;
    exports2.TSTupleType = TSTupleType;
    exports2.TSTypeAliasDeclaration = TSTypeAliasDeclaration;
    exports2.TSTypeAnnotation = TSTypeAnnotation;
    exports2.TSTypeAssertion = TSTypeAssertion;
    exports2.TSTypeLiteral = TSTypeLiteral;
    exports2.TSTypeOperator = TSTypeOperator;
    exports2.TSTypeParameter = TSTypeParameter;
    exports2.TSTypeParameterDeclaration = exports2.TSTypeParameterInstantiation = TSTypeParameterInstantiation;
    exports2.TSTypePredicate = TSTypePredicate;
    exports2.TSTypeQuery = TSTypeQuery;
    exports2.TSTypeReference = TSTypeReference;
    exports2.TSUndefinedKeyword = TSUndefinedKeyword;
    exports2.TSUnionType = TSUnionType;
    exports2.TSUnknownKeyword = TSUnknownKeyword;
    exports2.TSVoidKeyword = TSVoidKeyword;
    exports2.tsPrintClassMemberModifiers = tsPrintClassMemberModifiers;
    exports2.tsPrintFunctionOrConstructorType = tsPrintFunctionOrConstructorType;
    exports2.tsPrintPropertyOrMethodName = tsPrintPropertyOrMethodName;
    exports2.tsPrintSignatureDeclarationBase = tsPrintSignatureDeclarationBase;
    function TSTypeAnnotation(node3, parent) {
      this.token((parent.type === "TSFunctionType" || parent.type === "TSConstructorType") && parent.typeAnnotation === node3 ? "=>" : ":");
      this.space();
      if (node3.optional) this.tokenChar(63);
      this.print(node3.typeAnnotation);
    }
    function TSTypeParameterInstantiation(node3, parent) {
      this.tokenChar(60);
      let printTrailingSeparator = parent.type === "ArrowFunctionExpression" && node3.params.length === 1;
      if (this.tokenMap && node3.start != null && node3.end != null) {
        printTrailingSeparator && (printTrailingSeparator = !!this.tokenMap.find(node3, (t) => this.tokenMap.matchesOriginal(t, ",")));
        printTrailingSeparator || (printTrailingSeparator = this.shouldPrintTrailingComma(">"));
      }
      this.printList(node3.params, printTrailingSeparator);
      this.tokenChar(62);
    }
    function TSTypeParameter(node3) {
      if (node3.in) {
        this.word("in");
        this.space();
      }
      if (node3.out) {
        this.word("out");
        this.space();
      }
      this.word(node3.name);
      if (node3.constraint) {
        this.space();
        this.word("extends");
        this.space();
        this.print(node3.constraint);
      }
      if (node3.default) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(node3.default);
      }
    }
    function TSParameterProperty(node3) {
      if (node3.accessibility) {
        this.word(node3.accessibility);
        this.space();
      }
      if (node3.readonly) {
        this.word("readonly");
        this.space();
      }
      this._param(node3.parameter);
    }
    function TSDeclareFunction(node3, parent) {
      if (node3.declare) {
        this.word("declare");
        this.space();
      }
      this._functionHead(node3, parent);
      this.semicolon();
    }
    function TSDeclareMethod(node3) {
      this._classMethodHead(node3);
      this.semicolon();
    }
    function TSQualifiedName(node3) {
      this.print(node3.left);
      this.tokenChar(46);
      this.print(node3.right);
    }
    function TSCallSignatureDeclaration(node3) {
      this.tsPrintSignatureDeclarationBase(node3);
      maybePrintTrailingCommaOrSemicolon(this, node3);
    }
    function maybePrintTrailingCommaOrSemicolon(printer, node3) {
      if (!printer.tokenMap || !node3.start || !node3.end) {
        printer.semicolon();
        return;
      }
      if (printer.tokenMap.endMatches(node3, ",")) {
        printer.token(",");
      } else if (printer.tokenMap.endMatches(node3, ";")) {
        printer.semicolon();
      }
    }
    function TSConstructSignatureDeclaration(node3) {
      this.word("new");
      this.space();
      this.tsPrintSignatureDeclarationBase(node3);
      maybePrintTrailingCommaOrSemicolon(this, node3);
    }
    function TSPropertySignature(node3) {
      const {
        readonly
      } = node3;
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node3);
      this.print(node3.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node3);
    }
    function tsPrintPropertyOrMethodName(node3) {
      if (node3.computed) {
        this.tokenChar(91);
      }
      this.print(node3.key);
      if (node3.computed) {
        this.tokenChar(93);
      }
      if (node3.optional) {
        this.tokenChar(63);
      }
    }
    function TSMethodSignature(node3) {
      const {
        kind
      } = node3;
      if (kind === "set" || kind === "get") {
        this.word(kind);
        this.space();
      }
      this.tsPrintPropertyOrMethodName(node3);
      this.tsPrintSignatureDeclarationBase(node3);
      maybePrintTrailingCommaOrSemicolon(this, node3);
    }
    function TSIndexSignature(node3) {
      const {
        readonly,
        static: isStatic
      } = node3;
      if (isStatic) {
        this.word("static");
        this.space();
      }
      if (readonly) {
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      this._parameters(node3.parameters, "]");
      this.print(node3.typeAnnotation);
      maybePrintTrailingCommaOrSemicolon(this, node3);
    }
    function TSAnyKeyword() {
      this.word("any");
    }
    function TSBigIntKeyword() {
      this.word("bigint");
    }
    function TSUnknownKeyword() {
      this.word("unknown");
    }
    function TSNumberKeyword() {
      this.word("number");
    }
    function TSObjectKeyword() {
      this.word("object");
    }
    function TSBooleanKeyword() {
      this.word("boolean");
    }
    function TSStringKeyword() {
      this.word("string");
    }
    function TSSymbolKeyword() {
      this.word("symbol");
    }
    function TSVoidKeyword() {
      this.word("void");
    }
    function TSUndefinedKeyword() {
      this.word("undefined");
    }
    function TSNullKeyword() {
      this.word("null");
    }
    function TSNeverKeyword() {
      this.word("never");
    }
    function TSIntrinsicKeyword() {
      this.word("intrinsic");
    }
    function TSThisType() {
      this.word("this");
    }
    function TSFunctionType(node3) {
      this.tsPrintFunctionOrConstructorType(node3);
    }
    function TSConstructorType(node3) {
      if (node3.abstract) {
        this.word("abstract");
        this.space();
      }
      this.word("new");
      this.space();
      this.tsPrintFunctionOrConstructorType(node3);
    }
    function tsPrintFunctionOrConstructorType(node3) {
      const {
        typeParameters
      } = node3;
      const parameters = node3.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      this.space();
      const returnType = node3.typeAnnotation;
      this.print(returnType);
    }
    function TSTypeReference(node3) {
      const typeArguments = node3.typeParameters;
      this.print(node3.typeName, !!typeArguments);
      this.print(typeArguments);
    }
    function TSTypePredicate(node3) {
      if (node3.asserts) {
        this.word("asserts");
        this.space();
      }
      this.print(node3.parameterName);
      if (node3.typeAnnotation) {
        this.space();
        this.word("is");
        this.space();
        this.print(node3.typeAnnotation.typeAnnotation);
      }
    }
    function TSTypeQuery(node3) {
      this.word("typeof");
      this.space();
      this.print(node3.exprName);
      const typeArguments = node3.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSTypeLiteral(node3) {
      printBraced(this, node3, () => this.printJoin(node3.members, true, true));
    }
    function TSArrayType(node3) {
      this.print(node3.elementType, true);
      this.tokenChar(91);
      this.tokenChar(93);
    }
    function TSTupleType(node3) {
      this.tokenChar(91);
      this.printList(node3.elementTypes, this.shouldPrintTrailingComma("]"));
      this.tokenChar(93);
    }
    function TSOptionalType(node3) {
      this.print(node3.typeAnnotation);
      this.tokenChar(63);
    }
    function TSRestType(node3) {
      this.token("...");
      this.print(node3.typeAnnotation);
    }
    function TSNamedTupleMember(node3) {
      this.print(node3.label);
      if (node3.optional) this.tokenChar(63);
      this.tokenChar(58);
      this.space();
      this.print(node3.elementType);
    }
    function TSUnionType(node3) {
      tsPrintUnionOrIntersectionType(this, node3, "|");
    }
    function TSIntersectionType(node3) {
      tsPrintUnionOrIntersectionType(this, node3, "&");
    }
    function tsPrintUnionOrIntersectionType(printer, node3, sep2) {
      var _printer$tokenMap;
      let hasLeadingToken = 0;
      if ((_printer$tokenMap = printer.tokenMap) != null && _printer$tokenMap.startMatches(node3, sep2)) {
        hasLeadingToken = 1;
        printer.token(sep2);
      }
      printer.printJoin(node3.types, void 0, void 0, function(i) {
        this.space();
        this.token(sep2, null, i + hasLeadingToken);
        this.space();
      });
    }
    function TSConditionalType(node3) {
      this.print(node3.checkType);
      this.space();
      this.word("extends");
      this.space();
      this.print(node3.extendsType);
      this.space();
      this.tokenChar(63);
      this.space();
      this.print(node3.trueType);
      this.space();
      this.tokenChar(58);
      this.space();
      this.print(node3.falseType);
    }
    function TSInferType(node3) {
      this.word("infer");
      this.print(node3.typeParameter);
    }
    function TSParenthesizedType(node3) {
      this.tokenChar(40);
      this.print(node3.typeAnnotation);
      this.tokenChar(41);
    }
    function TSTypeOperator(node3) {
      this.word(node3.operator);
      this.space();
      this.print(node3.typeAnnotation);
    }
    function TSIndexedAccessType(node3) {
      this.print(node3.objectType, true);
      this.tokenChar(91);
      this.print(node3.indexType);
      this.tokenChar(93);
    }
    function TSMappedType(node3) {
      const {
        nameType,
        optional,
        readonly,
        typeAnnotation
      } = node3;
      this.tokenChar(123);
      const exit = this.enterDelimited();
      this.space();
      if (readonly) {
        tokenIfPlusMinus(this, readonly);
        this.word("readonly");
        this.space();
      }
      this.tokenChar(91);
      {
        this.word(node3.typeParameter.name);
      }
      this.space();
      this.word("in");
      this.space();
      {
        this.print(node3.typeParameter.constraint);
      }
      if (nameType) {
        this.space();
        this.word("as");
        this.space();
        this.print(nameType);
      }
      this.tokenChar(93);
      if (optional) {
        tokenIfPlusMinus(this, optional);
        this.tokenChar(63);
      }
      if (typeAnnotation) {
        this.tokenChar(58);
        this.space();
        this.print(typeAnnotation);
      }
      this.space();
      exit();
      this.tokenChar(125);
    }
    function tokenIfPlusMinus(self2, tok) {
      if (tok !== true) {
        self2.token(tok);
      }
    }
    function TSTemplateLiteralType(node3) {
      this._printTemplate(node3, node3.types);
    }
    function TSLiteralType(node3) {
      this.print(node3.literal);
    }
    function TSClassImplements(node3) {
      this.print(node3.expression);
      this.print(node3.typeArguments);
    }
    function TSInterfaceDeclaration(node3) {
      const {
        declare,
        id: id3,
        typeParameters,
        extends: extendz,
        body
      } = node3;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("interface");
      this.space();
      this.print(id3);
      this.print(typeParameters);
      if (extendz != null && extendz.length) {
        this.space();
        this.word("extends");
        this.space();
        this.printList(extendz);
      }
      this.space();
      this.print(body);
    }
    function TSInterfaceBody(node3) {
      printBraced(this, node3, () => this.printJoin(node3.body, true, true));
    }
    function TSTypeAliasDeclaration(node3) {
      const {
        declare,
        id: id3,
        typeParameters,
        typeAnnotation
      } = node3;
      if (declare) {
        this.word("declare");
        this.space();
      }
      this.word("type");
      this.space();
      this.print(id3);
      this.print(typeParameters);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(typeAnnotation);
      this.semicolon();
    }
    function TSTypeExpression(node3) {
      const {
        type,
        expression,
        typeAnnotation
      } = node3;
      this.print(expression, true);
      this.space();
      this.word(type === "TSAsExpression" ? "as" : "satisfies");
      this.space();
      this.print(typeAnnotation);
    }
    function TSTypeAssertion(node3) {
      const {
        typeAnnotation,
        expression
      } = node3;
      this.tokenChar(60);
      this.print(typeAnnotation);
      this.tokenChar(62);
      this.space();
      this.print(expression);
    }
    function TSInstantiationExpression(node3) {
      this.print(node3.expression);
      {
        this.print(node3.typeParameters);
      }
    }
    function TSEnumDeclaration(node3) {
      const {
        declare,
        const: isConst,
        id: id3
      } = node3;
      if (declare) {
        this.word("declare");
        this.space();
      }
      if (isConst) {
        this.word("const");
        this.space();
      }
      this.word("enum");
      this.space();
      this.print(id3);
      this.space();
      {
        TSEnumBody.call(this, node3);
      }
    }
    function TSEnumBody(node3) {
      printBraced(this, node3, () => {
        var _this$shouldPrintTrai;
        return this.printList(node3.members, (_this$shouldPrintTrai = this.shouldPrintTrailingComma("}")) != null ? _this$shouldPrintTrai : true, true, true);
      });
    }
    function TSEnumMember(node3) {
      const {
        id: id3,
        initializer
      } = node3;
      this.print(id3);
      if (initializer) {
        this.space();
        this.tokenChar(61);
        this.space();
        this.print(initializer);
      }
    }
    function TSModuleDeclaration(node3) {
      const {
        declare,
        id: id3,
        kind
      } = node3;
      if (declare) {
        this.word("declare");
        this.space();
      }
      {
        if (!node3.global) {
          this.word(kind != null ? kind : id3.type === "Identifier" ? "namespace" : "module");
          this.space();
        }
        this.print(id3);
        if (!node3.body) {
          this.semicolon();
          return;
        }
        let body = node3.body;
        while (body.type === "TSModuleDeclaration") {
          this.tokenChar(46);
          this.print(body.id);
          body = body.body;
        }
        this.space();
        this.print(body);
      }
    }
    function TSModuleBlock(node3) {
      printBraced(this, node3, () => this.printSequence(node3.body, true));
    }
    function TSImportType(node3) {
      const {
        argument,
        qualifier,
        options: options2
      } = node3;
      this.word("import");
      this.tokenChar(40);
      this.print(argument);
      if (options2) {
        this.tokenChar(44);
        this.print(options2);
      }
      this.tokenChar(41);
      if (qualifier) {
        this.tokenChar(46);
        this.print(qualifier);
      }
      const typeArguments = node3.typeParameters;
      if (typeArguments) {
        this.print(typeArguments);
      }
    }
    function TSImportEqualsDeclaration(node3) {
      const {
        id: id3,
        moduleReference
      } = node3;
      if (node3.isExport) {
        this.word("export");
        this.space();
      }
      this.word("import");
      this.space();
      this.print(id3);
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(moduleReference);
      this.semicolon();
    }
    function TSExternalModuleReference(node3) {
      this.token("require(");
      this.print(node3.expression);
      this.tokenChar(41);
    }
    function TSNonNullExpression(node3) {
      this.print(node3.expression);
      this.tokenChar(33);
    }
    function TSExportAssignment(node3) {
      this.word("export");
      this.space();
      this.tokenChar(61);
      this.space();
      this.print(node3.expression);
      this.semicolon();
    }
    function TSNamespaceExportDeclaration(node3) {
      this.word("export");
      this.space();
      this.word("as");
      this.space();
      this.word("namespace");
      this.space();
      this.print(node3.id);
      this.semicolon();
    }
    function tsPrintSignatureDeclarationBase(node3) {
      const {
        typeParameters
      } = node3;
      const parameters = node3.parameters;
      this.print(typeParameters);
      this.tokenChar(40);
      this._parameters(parameters, ")");
      const returnType = node3.typeAnnotation;
      this.print(returnType);
    }
    function tsPrintClassMemberModifiers(node3) {
      const isPrivateField = node3.type === "ClassPrivateProperty";
      const isPublicField = node3.type === "ClassAccessorProperty" || node3.type === "ClassProperty";
      printModifiersList(this, node3, [isPublicField && node3.declare && "declare", !isPrivateField && node3.accessibility]);
      if (node3.static) {
        this.word("static");
        this.space();
      }
      printModifiersList(this, node3, [!isPrivateField && node3.override && "override", !isPrivateField && node3.abstract && "abstract", (isPublicField || isPrivateField) && node3.readonly && "readonly"]);
    }
    function printBraced(printer, node3, cb) {
      printer.token("{");
      const exit = printer.enterDelimited();
      cb();
      exit();
      printer.rightBrace(node3);
    }
    function printModifiersList(printer, node3, modifiers) {
      var _printer$tokenMap2;
      const modifiersSet = /* @__PURE__ */ new Set();
      for (const modifier of modifiers) {
        if (modifier) modifiersSet.add(modifier);
      }
      (_printer$tokenMap2 = printer.tokenMap) == null || _printer$tokenMap2.find(node3, (tok) => {
        if (modifiersSet.has(tok.value)) {
          printer.token(tok.value);
          printer.space();
          modifiersSet.delete(tok.value);
          return modifiersSet.size === 0;
        }
      });
      for (const modifier of modifiersSet) {
        printer.word(modifier);
        printer.space();
      }
    }
  }
});

// node_modules/@babel/generator/lib/generators/index.js
var require_generators = __commonJS({
  "node_modules/@babel/generator/lib/generators/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _templateLiterals = require_template_literals();
    Object.keys(_templateLiterals).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _templateLiterals[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _templateLiterals[key];
        }
      });
    });
    var _expressions = require_expressions();
    Object.keys(_expressions).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _expressions[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _expressions[key];
        }
      });
    });
    var _statements = require_statements();
    Object.keys(_statements).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _statements[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _statements[key];
        }
      });
    });
    var _classes = require_classes();
    Object.keys(_classes).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _classes[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _classes[key];
        }
      });
    });
    var _methods = require_methods();
    Object.keys(_methods).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _methods[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _methods[key];
        }
      });
    });
    var _modules = require_modules();
    Object.keys(_modules).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _modules[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _modules[key];
        }
      });
    });
    var _types2 = require_types();
    Object.keys(_types2).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _types2[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _types2[key];
        }
      });
    });
    var _flow = require_flow2();
    Object.keys(_flow).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _flow[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _flow[key];
        }
      });
    });
    var _base = require_base();
    Object.keys(_base).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _base[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _base[key];
        }
      });
    });
    var _jsx = require_jsx2();
    Object.keys(_jsx).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _jsx[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _jsx[key];
        }
      });
    });
    var _typescript = require_typescript2();
    Object.keys(_typescript).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports2 && exports2[key] === _typescript[key]) return;
      Object.defineProperty(exports2, key, {
        enumerable: true,
        get: function() {
          return _typescript[key];
        }
      });
    });
  }
});

// node_modules/@babel/generator/lib/generators/deprecated.js
var require_deprecated = __commonJS({
  "node_modules/@babel/generator/lib/generators/deprecated.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addDeprecatedGenerators = addDeprecatedGenerators;
    function addDeprecatedGenerators(PrinterClass) {
      {
        const deprecatedBabel7Generators = {
          Noop() {
          },
          TSExpressionWithTypeArguments(node3) {
            this.print(node3.expression);
            this.print(node3.typeParameters);
          },
          DecimalLiteral(node3) {
            const raw = this.getPossibleRaw(node3);
            if (!this.format.minified && raw !== void 0) {
              this.word(raw);
              return;
            }
            this.word(node3.value + "m");
          }
        };
        Object.assign(PrinterClass.prototype, deprecatedBabel7Generators);
      }
    }
  }
});

// node_modules/@babel/generator/lib/printer.js
var require_printer = __commonJS({
  "node_modules/@babel/generator/lib/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _buffer = require_buffer();
    var n = require_node4();
    var _t = require_lib3();
    var _tokenMap = require_token_map();
    var generatorFunctions = require_generators();
    var _deprecated = require_deprecated();
    var {
      isExpression,
      isFunction: isFunction2,
      isStatement,
      isClassBody,
      isTSInterfaceBody,
      isTSEnumMember
    } = _t;
    var SCIENTIFIC_NOTATION = /e/i;
    var ZERO_DECIMAL_INTEGER = /\.0+$/;
    var HAS_NEWLINE = /[\n\r\u2028\u2029]/;
    var HAS_NEWLINE_OR_BlOCK_COMMENT_END = /[\n\r\u2028\u2029]|\*\//;
    function commentIsNewline(c) {
      return c.type === "CommentLine" || HAS_NEWLINE.test(c.value);
    }
    var {
      needsParens
    } = n;
    var Printer = class {
      constructor(format2, map, tokens, originalCode) {
        this.inForStatementInit = false;
        this.tokenContext = 0;
        this._tokens = null;
        this._originalCode = null;
        this._currentNode = null;
        this._indent = 0;
        this._indentRepeat = 0;
        this._insideAux = false;
        this._noLineTerminator = false;
        this._noLineTerminatorAfterNode = null;
        this._printAuxAfterOnNextUserNode = false;
        this._printedComments = /* @__PURE__ */ new Set();
        this._endsWithInteger = false;
        this._endsWithWord = false;
        this._endsWithDiv = false;
        this._lastCommentLine = 0;
        this._endsWithInnerRaw = false;
        this._indentInnerComments = true;
        this.tokenMap = null;
        this._boundGetRawIdentifier = this._getRawIdentifier.bind(this);
        this._printSemicolonBeforeNextNode = -1;
        this._printSemicolonBeforeNextToken = -1;
        this.format = format2;
        this._tokens = tokens;
        this._originalCode = originalCode;
        this._indentRepeat = format2.indent.style.length;
        this._inputMap = map == null ? void 0 : map._inputMap;
        this._buf = new _buffer.default(map, format2.indent.style[0]);
      }
      enterForStatementInit() {
        if (this.inForStatementInit) return () => {
        };
        this.inForStatementInit = true;
        return () => {
          this.inForStatementInit = false;
        };
      }
      enterDelimited() {
        const oldInForStatementInit = this.inForStatementInit;
        const oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
        if (oldInForStatementInit === false && oldNoLineTerminatorAfterNode === null) {
          return () => {
          };
        }
        this.inForStatementInit = false;
        this._noLineTerminatorAfterNode = null;
        return () => {
          this.inForStatementInit = oldInForStatementInit;
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        };
      }
      generate(ast) {
        if (this.format.preserveFormat) {
          this.tokenMap = new _tokenMap.TokenMap(ast, this._tokens, this._originalCode);
        }
        this.print(ast);
        this._maybeAddAuxComment();
        return this._buf.get();
      }
      indent() {
        const {
          format: format2
        } = this;
        if (format2.preserveFormat || format2.compact || format2.concise) {
          return;
        }
        this._indent++;
      }
      dedent() {
        const {
          format: format2
        } = this;
        if (format2.preserveFormat || format2.compact || format2.concise) {
          return;
        }
        this._indent--;
      }
      semicolon(force = false) {
        this._maybeAddAuxComment();
        if (force) {
          this._appendChar(59);
          this._noLineTerminator = false;
          return;
        }
        if (this.tokenMap) {
          const node3 = this._currentNode;
          if (node3.start != null && node3.end != null) {
            if (!this.tokenMap.endMatches(node3, ";")) {
              this._printSemicolonBeforeNextNode = this._buf.getCurrentLine();
              return;
            }
            const indexes = this.tokenMap.getIndexes(this._currentNode);
            this._catchUpTo(this._tokens[indexes[indexes.length - 1]].loc.start);
          }
        }
        this._queue(59);
        this._noLineTerminator = false;
      }
      rightBrace(node3) {
        if (this.format.minified) {
          this._buf.removeLastSemicolon();
        }
        this.sourceWithOffset("end", node3.loc, -1);
        this.tokenChar(125);
      }
      rightParens(node3) {
        this.sourceWithOffset("end", node3.loc, -1);
        this.tokenChar(41);
      }
      space(force = false) {
        const {
          format: format2
        } = this;
        if (format2.compact || format2.preserveFormat) return;
        if (force) {
          this._space();
        } else if (this._buf.hasContent()) {
          const lastCp = this.getLastChar();
          if (lastCp !== 32 && lastCp !== 10) {
            this._space();
          }
        }
      }
      word(str2, noLineTerminatorAfter = false) {
        this.tokenContext = 0;
        this._maybePrintInnerComments(str2);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str2);
        if (this._endsWithWord || this._endsWithDiv && str2.charCodeAt(0) === 47) {
          this._space();
        }
        this._append(str2, false);
        this._endsWithWord = true;
        this._noLineTerminator = noLineTerminatorAfter;
      }
      number(str2, number) {
        function isNonDecimalLiteral(str3) {
          if (str3.length > 2 && str3.charCodeAt(0) === 48) {
            const secondChar = str3.charCodeAt(1);
            return secondChar === 98 || secondChar === 111 || secondChar === 120;
          }
          return false;
        }
        this.word(str2);
        this._endsWithInteger = Number.isInteger(number) && !isNonDecimalLiteral(str2) && !SCIENTIFIC_NOTATION.test(str2) && !ZERO_DECIMAL_INTEGER.test(str2) && str2.charCodeAt(str2.length - 1) !== 46;
      }
      token(str2, maybeNewline = false, occurrenceCount = 0) {
        this.tokenContext = 0;
        this._maybePrintInnerComments(str2, occurrenceCount);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str2, occurrenceCount);
        const lastChar = this.getLastChar();
        const strFirst = str2.charCodeAt(0);
        if (lastChar === 33 && (str2 === "--" || strFirst === 61) || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {
          this._space();
        }
        this._append(str2, maybeNewline);
        this._noLineTerminator = false;
      }
      tokenChar(char) {
        this.tokenContext = 0;
        const str2 = String.fromCharCode(char);
        this._maybePrintInnerComments(str2);
        this._maybeAddAuxComment();
        if (this.tokenMap) this._catchUpToCurrentToken(str2);
        const lastChar = this.getLastChar();
        if (char === 43 && lastChar === 43 || char === 45 && lastChar === 45 || char === 46 && this._endsWithInteger) {
          this._space();
        }
        this._appendChar(char);
        this._noLineTerminator = false;
      }
      newline(i = 1, force) {
        if (i <= 0) return;
        if (!force) {
          if (this.format.retainLines || this.format.compact) return;
          if (this.format.concise) {
            this.space();
            return;
          }
        }
        if (i > 2) i = 2;
        i -= this._buf.getNewlineCount();
        for (let j = 0; j < i; j++) {
          this._newline();
        }
        return;
      }
      endsWith(char) {
        return this.getLastChar() === char;
      }
      getLastChar() {
        return this._buf.getLastChar();
      }
      endsWithCharAndNewline() {
        return this._buf.endsWithCharAndNewline();
      }
      removeTrailingNewline() {
        this._buf.removeTrailingNewline();
      }
      exactSource(loc, cb) {
        if (!loc) {
          cb();
          return;
        }
        this._catchUp("start", loc);
        this._buf.exactSource(loc, cb);
      }
      source(prop, loc) {
        if (!loc) return;
        this._catchUp(prop, loc);
        this._buf.source(prop, loc);
      }
      sourceWithOffset(prop, loc, columnOffset) {
        if (!loc || this.format.preserveFormat) return;
        this._catchUp(prop, loc);
        this._buf.sourceWithOffset(prop, loc, columnOffset);
      }
      sourceIdentifierName(identifierName, pos) {
        if (!this._buf._canMarkIdName) return;
        const sourcePosition = this._buf._sourcePosition;
        sourcePosition.identifierNamePos = pos;
        sourcePosition.identifierName = identifierName;
      }
      _space() {
        this._queue(32);
      }
      _newline() {
        this._queue(10);
      }
      _catchUpToCurrentToken(str2, occurrenceCount = 0) {
        const token = this.tokenMap.findMatching(this._currentNode, str2, occurrenceCount);
        if (token) this._catchUpTo(token.loc.start);
        if (this._printSemicolonBeforeNextToken !== -1 && this._printSemicolonBeforeNextToken === this._buf.getCurrentLine()) {
          this._buf.appendChar(59);
          this._endsWithWord = false;
          this._endsWithInteger = false;
          this._endsWithDiv = false;
        }
        this._printSemicolonBeforeNextToken = -1;
        this._printSemicolonBeforeNextNode = -1;
      }
      _append(str2, maybeNewline) {
        this._maybeIndent(str2.charCodeAt(0));
        this._buf.append(str2, maybeNewline);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _appendChar(char) {
        this._maybeIndent(char);
        this._buf.appendChar(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
        this._endsWithDiv = false;
      }
      _queue(char) {
        this._maybeIndent(char);
        this._buf.queue(char);
        this._endsWithWord = false;
        this._endsWithInteger = false;
      }
      _maybeIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          this._buf.queueIndentation(this._getIndent());
        }
      }
      _shouldIndent(firstChar) {
        if (this._indent && firstChar !== 10 && this.endsWith(10)) {
          return true;
        }
      }
      catchUp(line) {
        if (!this.format.retainLines) return;
        const count = line - this._buf.getCurrentLine();
        for (let i = 0; i < count; i++) {
          this._newline();
        }
      }
      _catchUp(prop, loc) {
        const {
          format: format2
        } = this;
        if (!format2.preserveFormat) {
          if (format2.retainLines && loc != null && loc[prop]) {
            this.catchUp(loc[prop].line);
          }
          return;
        }
        const pos = loc == null ? void 0 : loc[prop];
        if (pos != null) this._catchUpTo(pos);
      }
      _catchUpTo({
        line,
        column,
        index: index4
      }) {
        const count = line - this._buf.getCurrentLine();
        if (count > 0 && this._noLineTerminator) {
          return;
        }
        for (let i = 0; i < count; i++) {
          this._newline();
        }
        const spacesCount = count > 0 ? column : column - this._buf.getCurrentColumn();
        if (spacesCount > 0) {
          const spaces = this._originalCode ? this._originalCode.slice(index4 - spacesCount, index4).replace(/[^\t\x0B\f \xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF]/gu, " ") : " ".repeat(spacesCount);
          this._append(spaces, false);
        }
      }
      _getIndent() {
        return this._indentRepeat * this._indent;
      }
      printTerminatorless(node3) {
        this._noLineTerminator = true;
        this.print(node3);
      }
      print(node3, noLineTerminatorAfter, trailingCommentsLineOffset) {
        var _node$extra, _node$leadingComments, _node$leadingComments2;
        if (!node3) return;
        this._endsWithInnerRaw = false;
        const nodeType = node3.type;
        const format2 = this.format;
        const oldConcise = format2.concise;
        if (node3._compact) {
          format2.concise = true;
        }
        const printMethod = this[nodeType];
        if (printMethod === void 0) {
          throw new ReferenceError(`unknown node of type ${JSON.stringify(nodeType)} with constructor ${JSON.stringify(node3.constructor.name)}`);
        }
        const parent = this._currentNode;
        this._currentNode = node3;
        if (this.tokenMap) {
          this._printSemicolonBeforeNextToken = this._printSemicolonBeforeNextNode;
        }
        const oldInAux = this._insideAux;
        this._insideAux = node3.loc == null;
        this._maybeAddAuxComment(this._insideAux && !oldInAux);
        const parenthesized = (_node$extra = node3.extra) == null ? void 0 : _node$extra.parenthesized;
        let shouldPrintParens = parenthesized && format2.preserveFormat || parenthesized && format2.retainFunctionParens && nodeType === "FunctionExpression" || needsParens(node3, parent, this.tokenContext, this.inForStatementInit, format2.preserveFormat ? this._boundGetRawIdentifier : void 0);
        if (!shouldPrintParens && parenthesized && (_node$leadingComments = node3.leadingComments) != null && _node$leadingComments.length && node3.leadingComments[0].type === "CommentBlock") {
          const parentType = parent == null ? void 0 : parent.type;
          switch (parentType) {
            case "ExpressionStatement":
            case "VariableDeclarator":
            case "AssignmentExpression":
            case "ReturnStatement":
              break;
            case "CallExpression":
            case "OptionalCallExpression":
            case "NewExpression":
              if (parent.callee !== node3) break;
            default:
              shouldPrintParens = true;
          }
        }
        let indentParenthesized = false;
        if (!shouldPrintParens && this._noLineTerminator && ((_node$leadingComments2 = node3.leadingComments) != null && _node$leadingComments2.some(commentIsNewline) || this.format.retainLines && node3.loc && node3.loc.start.line > this._buf.getCurrentLine())) {
          shouldPrintParens = true;
          indentParenthesized = true;
        }
        let oldNoLineTerminatorAfterNode;
        let oldInForStatementInitWasTrue;
        if (!shouldPrintParens) {
          noLineTerminatorAfter || (noLineTerminatorAfter = parent && this._noLineTerminatorAfterNode === parent && n.isLastChild(parent, node3));
          if (noLineTerminatorAfter) {
            var _node$trailingComment;
            if ((_node$trailingComment = node3.trailingComments) != null && _node$trailingComment.some(commentIsNewline)) {
              if (isExpression(node3)) shouldPrintParens = true;
            } else {
              oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
              this._noLineTerminatorAfterNode = node3;
            }
          }
        }
        if (shouldPrintParens) {
          this.tokenChar(40);
          if (indentParenthesized) this.indent();
          this._endsWithInnerRaw = false;
          if (this.inForStatementInit) {
            oldInForStatementInitWasTrue = true;
            this.inForStatementInit = false;
          }
          oldNoLineTerminatorAfterNode = this._noLineTerminatorAfterNode;
          this._noLineTerminatorAfterNode = null;
        }
        this._lastCommentLine = 0;
        this._printLeadingComments(node3, parent);
        const loc = nodeType === "Program" || nodeType === "File" ? null : node3.loc;
        this.exactSource(loc, printMethod.bind(this, node3, parent));
        if (shouldPrintParens) {
          this._printTrailingComments(node3, parent);
          if (indentParenthesized) {
            this.dedent();
            this.newline();
          }
          this.tokenChar(41);
          this._noLineTerminator = noLineTerminatorAfter;
          if (oldInForStatementInitWasTrue) this.inForStatementInit = true;
        } else if (noLineTerminatorAfter && !this._noLineTerminator) {
          this._noLineTerminator = true;
          this._printTrailingComments(node3, parent);
        } else {
          this._printTrailingComments(node3, parent, trailingCommentsLineOffset);
        }
        this._currentNode = parent;
        format2.concise = oldConcise;
        this._insideAux = oldInAux;
        if (oldNoLineTerminatorAfterNode !== void 0) {
          this._noLineTerminatorAfterNode = oldNoLineTerminatorAfterNode;
        }
        this._endsWithInnerRaw = false;
      }
      _maybeAddAuxComment(enteredPositionlessNode) {
        if (enteredPositionlessNode) this._printAuxBeforeComment();
        if (!this._insideAux) this._printAuxAfterComment();
      }
      _printAuxBeforeComment() {
        if (this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = true;
        const comment4 = this.format.auxiliaryCommentBefore;
        if (comment4) {
          this._printComment({
            type: "CommentBlock",
            value: comment4
          }, 0);
        }
      }
      _printAuxAfterComment() {
        if (!this._printAuxAfterOnNextUserNode) return;
        this._printAuxAfterOnNextUserNode = false;
        const comment4 = this.format.auxiliaryCommentAfter;
        if (comment4) {
          this._printComment({
            type: "CommentBlock",
            value: comment4
          }, 0);
        }
      }
      getPossibleRaw(node3) {
        const extra = node3.extra;
        if ((extra == null ? void 0 : extra.raw) != null && extra.rawValue != null && node3.value === extra.rawValue) {
          return extra.raw;
        }
      }
      printJoin(nodes, statement, indent, separator, printTrailingSeparator, addNewlines, iterator, trailingCommentsLineOffset) {
        if (!(nodes != null && nodes.length)) return;
        if (indent == null && this.format.retainLines) {
          var _nodes$0$loc;
          const startLine = (_nodes$0$loc = nodes[0].loc) == null ? void 0 : _nodes$0$loc.start.line;
          if (startLine != null && startLine !== this._buf.getCurrentLine()) {
            indent = true;
          }
        }
        if (indent) this.indent();
        const newlineOpts = {
          addNewlines,
          nextNodeStartLine: 0
        };
        const boundSeparator = separator == null ? void 0 : separator.bind(this);
        const len = nodes.length;
        for (let i = 0; i < len; i++) {
          const node3 = nodes[i];
          if (!node3) continue;
          if (statement) this._printNewline(i === 0, newlineOpts);
          this.print(node3, void 0, trailingCommentsLineOffset || 0);
          iterator == null || iterator(node3, i);
          if (boundSeparator != null) {
            if (i < len - 1) boundSeparator(i, false);
            else if (printTrailingSeparator) boundSeparator(i, true);
          }
          if (statement) {
            var _node$trailingComment2;
            if (!((_node$trailingComment2 = node3.trailingComments) != null && _node$trailingComment2.length)) {
              this._lastCommentLine = 0;
            }
            if (i + 1 === len) {
              this.newline(1);
            } else {
              var _nextNode$loc;
              const nextNode = nodes[i + 1];
              newlineOpts.nextNodeStartLine = ((_nextNode$loc = nextNode.loc) == null ? void 0 : _nextNode$loc.start.line) || 0;
              this._printNewline(true, newlineOpts);
            }
          }
        }
        if (indent) this.dedent();
      }
      printAndIndentOnComments(node3) {
        const indent = node3.leadingComments && node3.leadingComments.length > 0;
        if (indent) this.indent();
        this.print(node3);
        if (indent) this.dedent();
      }
      printBlock(parent) {
        const node3 = parent.body;
        if (node3.type !== "EmptyStatement") {
          this.space();
        }
        this.print(node3);
      }
      _printTrailingComments(node3, parent, lineOffset) {
        const {
          innerComments,
          trailingComments
        } = node3;
        if (innerComments != null && innerComments.length) {
          this._printComments(2, innerComments, node3, parent, lineOffset);
        }
        if (trailingComments != null && trailingComments.length) {
          this._printComments(2, trailingComments, node3, parent, lineOffset);
        }
      }
      _printLeadingComments(node3, parent) {
        const comments = node3.leadingComments;
        if (!(comments != null && comments.length)) return;
        this._printComments(0, comments, node3, parent);
      }
      _maybePrintInnerComments(nextTokenStr, nextTokenOccurrenceCount) {
        if (this._endsWithInnerRaw) {
          var _this$tokenMap;
          this.printInnerComments((_this$tokenMap = this.tokenMap) == null ? void 0 : _this$tokenMap.findMatching(this._currentNode, nextTokenStr, nextTokenOccurrenceCount));
        }
        this._endsWithInnerRaw = true;
        this._indentInnerComments = true;
      }
      printInnerComments(nextToken) {
        const node3 = this._currentNode;
        const comments = node3.innerComments;
        if (!(comments != null && comments.length)) return;
        const hasSpace = this.endsWith(32);
        const indent = this._indentInnerComments;
        const printedCommentsCount = this._printedComments.size;
        if (indent) this.indent();
        this._printComments(1, comments, node3, void 0, void 0, nextToken);
        if (hasSpace && printedCommentsCount !== this._printedComments.size) {
          this.space();
        }
        if (indent) this.dedent();
      }
      noIndentInnerCommentsHere() {
        this._indentInnerComments = false;
      }
      printSequence(nodes, indent, trailingCommentsLineOffset, addNewlines) {
        this.printJoin(nodes, true, indent != null ? indent : false, void 0, void 0, addNewlines, void 0, trailingCommentsLineOffset);
      }
      printList(items, printTrailingSeparator, statement, indent, separator, iterator) {
        this.printJoin(items, statement, indent, separator != null ? separator : commaSeparator, printTrailingSeparator, void 0, iterator);
      }
      shouldPrintTrailingComma(listEnd) {
        if (!this.tokenMap) return null;
        const listEndIndex = this.tokenMap.findLastIndex(this._currentNode, (token) => this.tokenMap.matchesOriginal(token, listEnd));
        if (listEndIndex <= 0) return null;
        return this.tokenMap.matchesOriginal(this._tokens[listEndIndex - 1], ",");
      }
      _printNewline(newLine, opts) {
        const format2 = this.format;
        if (format2.retainLines || format2.compact) return;
        if (format2.concise) {
          this.space();
          return;
        }
        if (!newLine) {
          return;
        }
        const startLine = opts.nextNodeStartLine;
        const lastCommentLine = this._lastCommentLine;
        if (startLine > 0 && lastCommentLine > 0) {
          const offset = startLine - lastCommentLine;
          if (offset >= 0) {
            this.newline(offset || 1);
            return;
          }
        }
        if (this._buf.hasContent()) {
          this.newline(1);
        }
      }
      _shouldPrintComment(comment4, nextToken) {
        if (comment4.ignore) return 0;
        if (this._printedComments.has(comment4)) return 0;
        if (this._noLineTerminator && HAS_NEWLINE_OR_BlOCK_COMMENT_END.test(comment4.value)) {
          return 2;
        }
        if (nextToken && this.tokenMap) {
          const commentTok = this.tokenMap.find(this._currentNode, (token) => token.value === comment4.value);
          if (commentTok && commentTok.start > nextToken.start) {
            return 2;
          }
        }
        this._printedComments.add(comment4);
        if (!this.format.shouldPrintComment(comment4.value)) {
          return 0;
        }
        return 1;
      }
      _printComment(comment4, skipNewLines) {
        const noLineTerminator = this._noLineTerminator;
        const isBlockComment = comment4.type === "CommentBlock";
        const printNewLines = isBlockComment && skipNewLines !== 1 && !this._noLineTerminator;
        if (printNewLines && this._buf.hasContent() && skipNewLines !== 2) {
          this.newline(1);
        }
        const lastCharCode = this.getLastChar();
        if (lastCharCode !== 91 && lastCharCode !== 123 && lastCharCode !== 40) {
          this.space();
        }
        let val;
        if (isBlockComment) {
          val = `/*${comment4.value}*/`;
          if (this.format.indent.adjustMultilineComment) {
            var _comment$loc;
            const offset = (_comment$loc = comment4.loc) == null ? void 0 : _comment$loc.start.column;
            if (offset) {
              const newlineRegex = new RegExp("\\n\\s{1," + offset + "}", "g");
              val = val.replace(newlineRegex, "\n");
            }
            if (this.format.concise) {
              val = val.replace(/\n(?!$)/g, `
`);
            } else {
              let indentSize = this.format.retainLines ? 0 : this._buf.getCurrentColumn();
              if (this._shouldIndent(47) || this.format.retainLines) {
                indentSize += this._getIndent();
              }
              val = val.replace(/\n(?!$)/g, `
${" ".repeat(indentSize)}`);
            }
          }
        } else if (!noLineTerminator) {
          val = `//${comment4.value}`;
        } else {
          val = `/*${comment4.value}*/`;
        }
        if (this._endsWithDiv) this._space();
        if (this.tokenMap) {
          const {
            _printSemicolonBeforeNextToken,
            _printSemicolonBeforeNextNode
          } = this;
          this._printSemicolonBeforeNextToken = -1;
          this._printSemicolonBeforeNextNode = -1;
          this.source("start", comment4.loc);
          this._append(val, isBlockComment);
          this._printSemicolonBeforeNextNode = _printSemicolonBeforeNextNode;
          this._printSemicolonBeforeNextToken = _printSemicolonBeforeNextToken;
        } else {
          this.source("start", comment4.loc);
          this._append(val, isBlockComment);
        }
        if (!isBlockComment && !noLineTerminator) {
          this.newline(1, true);
        }
        if (printNewLines && skipNewLines !== 3) {
          this.newline(1);
        }
      }
      _printComments(type, comments, node3, parent, lineOffset = 0, nextToken) {
        const nodeLoc = node3.loc;
        const len = comments.length;
        let hasLoc = !!nodeLoc;
        const nodeStartLine = hasLoc ? nodeLoc.start.line : 0;
        const nodeEndLine = hasLoc ? nodeLoc.end.line : 0;
        let lastLine = 0;
        let leadingCommentNewline = 0;
        const maybeNewline = this._noLineTerminator ? function() {
        } : this.newline.bind(this);
        for (let i = 0; i < len; i++) {
          const comment4 = comments[i];
          const shouldPrint = this._shouldPrintComment(comment4, nextToken);
          if (shouldPrint === 2) {
            hasLoc = false;
            break;
          }
          if (hasLoc && comment4.loc && shouldPrint === 1) {
            const commentStartLine = comment4.loc.start.line;
            const commentEndLine = comment4.loc.end.line;
            if (type === 0) {
              let offset = 0;
              if (i === 0) {
                if (this._buf.hasContent() && (comment4.type === "CommentLine" || commentStartLine !== commentEndLine)) {
                  offset = leadingCommentNewline = 1;
                }
              } else {
                offset = commentStartLine - lastLine;
              }
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment4, 1);
              if (i + 1 === len) {
                maybeNewline(Math.max(nodeStartLine - lastLine, leadingCommentNewline));
                lastLine = nodeStartLine;
              }
            } else if (type === 1) {
              const offset = commentStartLine - (i === 0 ? nodeStartLine : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment4, 1);
              if (i + 1 === len) {
                maybeNewline(Math.min(1, nodeEndLine - lastLine));
                lastLine = nodeEndLine;
              }
            } else {
              const offset = commentStartLine - (i === 0 ? nodeEndLine - lineOffset : lastLine);
              lastLine = commentEndLine;
              maybeNewline(offset);
              this._printComment(comment4, 1);
            }
          } else {
            hasLoc = false;
            if (shouldPrint !== 1) {
              continue;
            }
            if (len === 1) {
              const singleLine = comment4.loc ? comment4.loc.start.line === comment4.loc.end.line : !HAS_NEWLINE.test(comment4.value);
              const shouldSkipNewline = singleLine && !isStatement(node3) && !isClassBody(parent) && !isTSInterfaceBody(parent) && !isTSEnumMember(node3);
              if (type === 0) {
                this._printComment(comment4, shouldSkipNewline && node3.type !== "ObjectExpression" || singleLine && isFunction2(parent, {
                  body: node3
                }) ? 1 : 0);
              } else if (shouldSkipNewline && type === 2) {
                this._printComment(comment4, 1);
              } else {
                this._printComment(comment4, 0);
              }
            } else if (type === 1 && !(node3.type === "ObjectExpression" && node3.properties.length > 1) && node3.type !== "ClassBody" && node3.type !== "TSInterfaceBody") {
              this._printComment(comment4, i === 0 ? 2 : i === len - 1 ? 3 : 0);
            } else {
              this._printComment(comment4, 0);
            }
          }
        }
        if (type === 2 && hasLoc && lastLine) {
          this._lastCommentLine = lastLine;
        }
      }
    };
    Object.assign(Printer.prototype, generatorFunctions);
    {
      (0, _deprecated.addDeprecatedGenerators)(Printer);
    }
    var _default = exports2.default = Printer;
    function commaSeparator(occurrenceCount, last) {
      this.token(",", false, occurrenceCount);
      if (!last) this.space();
    }
  }
});

// node_modules/@babel/generator/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@babel/generator/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = generate2;
    var _sourceMap = require_source_map2();
    var _printer = require_printer();
    function normalizeOptions(code, opts, ast) {
      if (opts.experimental_preserveFormat) {
        if (typeof code !== "string") {
          throw new Error("`experimental_preserveFormat` requires the original `code` to be passed to @babel/generator as a string");
        }
        if (!opts.retainLines) {
          throw new Error("`experimental_preserveFormat` requires `retainLines` to be set to `true`");
        }
        if (opts.compact && opts.compact !== "auto") {
          throw new Error("`experimental_preserveFormat` is not compatible with the `compact` option");
        }
        if (opts.minified) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `minified` option");
        }
        if (opts.jsescOption) {
          throw new Error("`experimental_preserveFormat` is not compatible with the `jsescOption` option");
        }
        if (!Array.isArray(ast.tokens)) {
          throw new Error("`experimental_preserveFormat` requires the AST to have attatched the token of the input code. Make sure to enable the `tokens: true` parser option.");
        }
      }
      const format2 = {
        auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
        auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
        shouldPrintComment: opts.shouldPrintComment,
        preserveFormat: opts.experimental_preserveFormat,
        retainLines: opts.retainLines,
        retainFunctionParens: opts.retainFunctionParens,
        comments: opts.comments == null || opts.comments,
        compact: opts.compact,
        minified: opts.minified,
        concise: opts.concise,
        indent: {
          adjustMultilineComment: true,
          style: "  "
        },
        jsescOption: Object.assign({
          quotes: "double",
          wrap: true,
          minimal: false
        }, opts.jsescOption),
        topicToken: opts.topicToken,
        importAttributesKeyword: opts.importAttributesKeyword
      };
      {
        var _opts$recordAndTupleS;
        format2.decoratorsBeforeExport = opts.decoratorsBeforeExport;
        format2.jsescOption.json = opts.jsonCompatibleStrings;
        format2.recordAndTupleSyntaxType = (_opts$recordAndTupleS = opts.recordAndTupleSyntaxType) != null ? _opts$recordAndTupleS : "hash";
      }
      if (format2.minified) {
        format2.compact = true;
        format2.shouldPrintComment = format2.shouldPrintComment || (() => format2.comments);
      } else {
        format2.shouldPrintComment = format2.shouldPrintComment || ((value2) => format2.comments || value2.includes("@license") || value2.includes("@preserve"));
      }
      if (format2.compact === "auto") {
        format2.compact = typeof code === "string" && code.length > 5e5;
        if (format2.compact) {
          console.error(`[BABEL] Note: The code generator has deoptimised the styling of ${opts.filename} as it exceeds the max of ${"500KB"}.`);
        }
      }
      if (format2.compact || format2.preserveFormat) {
        format2.indent.adjustMultilineComment = false;
      }
      const {
        auxiliaryCommentBefore,
        auxiliaryCommentAfter,
        shouldPrintComment
      } = format2;
      if (auxiliaryCommentBefore && !shouldPrintComment(auxiliaryCommentBefore)) {
        format2.auxiliaryCommentBefore = void 0;
      }
      if (auxiliaryCommentAfter && !shouldPrintComment(auxiliaryCommentAfter)) {
        format2.auxiliaryCommentAfter = void 0;
      }
      return format2;
    }
    {
      exports2.CodeGenerator = class CodeGenerator {
        constructor(ast, opts = {}, code) {
          this._ast = void 0;
          this._format = void 0;
          this._map = void 0;
          this._ast = ast;
          this._format = normalizeOptions(code, opts, ast);
          this._map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
        }
        generate() {
          const printer = new _printer.default(this._format, this._map);
          return printer.generate(this._ast);
        }
      };
    }
    function generate2(ast, opts = {}, code) {
      const format2 = normalizeOptions(code, opts, ast);
      const map = opts.sourceMaps ? new _sourceMap.default(opts, code) : null;
      const printer = new _printer.default(format2, map, ast.tokens, typeof code === "string" ? code : null);
      return printer.generate(ast);
    }
  }
});

// node_modules/@babel/traverse/lib/path/ancestry.js
var require_ancestry = __commonJS({
  "node_modules/@babel/traverse/lib/path/ancestry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.find = find;
    exports2.findParent = findParent;
    exports2.getAncestry = getAncestry;
    exports2.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;
    exports2.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;
    exports2.getFunctionParent = getFunctionParent;
    exports2.getStatementParent = getStatementParent;
    exports2.inType = inType;
    exports2.isAncestor = isAncestor;
    exports2.isDescendant = isDescendant;
    var _t = require_lib3();
    var {
      VISITOR_KEYS
    } = _t;
    function findParent(callback) {
      let path9 = this;
      while (path9 = path9.parentPath) {
        if (callback(path9)) return path9;
      }
      return null;
    }
    function find(callback) {
      let path9 = this;
      do {
        if (callback(path9)) return path9;
      } while (path9 = path9.parentPath);
      return null;
    }
    function getFunctionParent() {
      return this.findParent((p) => p.isFunction());
    }
    function getStatementParent() {
      let path9 = this;
      do {
        if (!path9.parentPath || Array.isArray(path9.container) && path9.isStatement()) {
          break;
        } else {
          path9 = path9.parentPath;
        }
      } while (path9);
      if (path9 && (path9.isProgram() || path9.isFile())) {
        throw new Error("File/Program node, we can't possibly find a statement parent to this");
      }
      return path9;
    }
    function getEarliestCommonAncestorFrom(paths) {
      return this.getDeepestCommonAncestorFrom(paths, function(deepest, i, ancestries) {
        let earliest;
        const keys = VISITOR_KEYS[deepest.type];
        for (const ancestry of ancestries) {
          const path9 = ancestry[i + 1];
          if (!earliest) {
            earliest = path9;
            continue;
          }
          if (path9.listKey && earliest.listKey === path9.listKey) {
            if (path9.key < earliest.key) {
              earliest = path9;
              continue;
            }
          }
          const earliestKeyIndex = keys.indexOf(earliest.parentKey);
          const currentKeyIndex = keys.indexOf(path9.parentKey);
          if (earliestKeyIndex > currentKeyIndex) {
            earliest = path9;
          }
        }
        return earliest;
      });
    }
    function getDeepestCommonAncestorFrom(paths, filter2) {
      if (!paths.length) {
        return this;
      }
      if (paths.length === 1) {
        return paths[0];
      }
      let minDepth = Infinity;
      let lastCommonIndex, lastCommon;
      const ancestries = paths.map((path9) => {
        const ancestry = [];
        do {
          ancestry.unshift(path9);
        } while ((path9 = path9.parentPath) && path9 !== this);
        if (ancestry.length < minDepth) {
          minDepth = ancestry.length;
        }
        return ancestry;
      });
      const first2 = ancestries[0];
      depthLoop: for (let i = 0; i < minDepth; i++) {
        const shouldMatch = first2[i];
        for (const ancestry of ancestries) {
          if (ancestry[i] !== shouldMatch) {
            break depthLoop;
          }
        }
        lastCommonIndex = i;
        lastCommon = shouldMatch;
      }
      if (lastCommon) {
        if (filter2) {
          return filter2(lastCommon, lastCommonIndex, ancestries);
        } else {
          return lastCommon;
        }
      } else {
        throw new Error("Couldn't find intersection");
      }
    }
    function getAncestry() {
      let path9 = this;
      const paths = [];
      do {
        paths.push(path9);
      } while (path9 = path9.parentPath);
      return paths;
    }
    function isAncestor(maybeDescendant) {
      return maybeDescendant.isDescendant(this);
    }
    function isDescendant(maybeAncestor) {
      return !!this.findParent((parent) => parent === maybeAncestor);
    }
    function inType(...candidateTypes) {
      let path9 = this;
      while (path9) {
        for (const type of candidateTypes) {
          if (path9.node.type === type) return true;
        }
        path9 = path9.parentPath;
      }
      return false;
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/util.js
var require_util2 = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createUnionType = createUnionType;
    var _t = require_lib3();
    var {
      createFlowUnionType,
      createTSUnionType,
      createUnionTypeAnnotation,
      isFlowType,
      isTSType
    } = _t;
    function createUnionType(types3) {
      {
        if (types3.every((v) => isFlowType(v))) {
          if (createFlowUnionType) {
            return createFlowUnionType(types3);
          }
          return createUnionTypeAnnotation(types3);
        } else if (types3.every((v) => isTSType(v))) {
          if (createTSUnionType) {
            return createTSUnionType(types3);
          }
        }
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/inferer-reference.js
var require_inferer_reference = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    var _t = require_lib3();
    var _util = require_util2();
    var {
      BOOLEAN_NUMBER_BINARY_OPERATORS,
      createTypeAnnotationBasedOnTypeof,
      numberTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function _default(node3) {
      if (!this.isReferenced()) return;
      const binding = this.scope.getBinding(node3.name);
      if (binding) {
        if (binding.identifier.typeAnnotation) {
          return binding.identifier.typeAnnotation;
        } else {
          return getTypeAnnotationBindingConstantViolations(binding, this, node3.name);
        }
      }
      if (node3.name === "undefined") {
        return voidTypeAnnotation();
      } else if (node3.name === "NaN" || node3.name === "Infinity") {
        return numberTypeAnnotation();
      } else if (node3.name === "arguments") {
      }
    }
    function getTypeAnnotationBindingConstantViolations(binding, path9, name2) {
      const types3 = [];
      const functionConstantViolations = [];
      let constantViolations = getConstantViolationsBefore(binding, path9, functionConstantViolations);
      const testType = getConditionalAnnotation(binding, path9, name2);
      if (testType) {
        const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);
        constantViolations = constantViolations.filter((path10) => !testConstantViolations.includes(path10));
        types3.push(testType.typeAnnotation);
      }
      if (constantViolations.length) {
        constantViolations.push(...functionConstantViolations);
        for (const violation of constantViolations) {
          types3.push(violation.getTypeAnnotation());
        }
      }
      if (!types3.length) {
        return;
      }
      return (0, _util.createUnionType)(types3);
    }
    function getConstantViolationsBefore(binding, path9, functions) {
      const violations = binding.constantViolations.slice();
      violations.unshift(binding.path);
      return violations.filter((violation) => {
        violation = violation.resolve();
        const status2 = violation._guessExecutionStatusRelativeTo(path9);
        if (functions && status2 === "unknown") functions.push(violation);
        return status2 === "before";
      });
    }
    function inferAnnotationFromBinaryExpression(name2, path9) {
      const operator = path9.node.operator;
      const right = path9.get("right").resolve();
      const left = path9.get("left").resolve();
      let target;
      if (left.isIdentifier({
        name: name2
      })) {
        target = right;
      } else if (right.isIdentifier({
        name: name2
      })) {
        target = left;
      }
      if (target) {
        if (operator === "===") {
          return target.getTypeAnnotation();
        }
        if (BOOLEAN_NUMBER_BINARY_OPERATORS.includes(operator)) {
          return numberTypeAnnotation();
        }
        return;
      }
      if (operator !== "===" && operator !== "==") return;
      let typeofPath;
      let typePath;
      if (left.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = left;
        typePath = right;
      } else if (right.isUnaryExpression({
        operator: "typeof"
      })) {
        typeofPath = right;
        typePath = left;
      }
      if (!typeofPath) return;
      if (!typeofPath.get("argument").isIdentifier({
        name: name2
      })) return;
      typePath = typePath.resolve();
      if (!typePath.isLiteral()) return;
      const typeValue = typePath.node.value;
      if (typeof typeValue !== "string") return;
      return createTypeAnnotationBasedOnTypeof(typeValue);
    }
    function getParentConditionalPath(binding, path9, name2) {
      let parentPath;
      while (parentPath = path9.parentPath) {
        if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {
          if (path9.key === "test") {
            return;
          }
          return parentPath;
        }
        if (parentPath.isFunction()) {
          if (parentPath.parentPath.scope.getBinding(name2) !== binding) return;
        }
        path9 = parentPath;
      }
    }
    function getConditionalAnnotation(binding, path9, name2) {
      const ifStatement = getParentConditionalPath(binding, path9, name2);
      if (!ifStatement) return;
      const test = ifStatement.get("test");
      const paths = [test];
      const types3 = [];
      for (let i = 0; i < paths.length; i++) {
        const path10 = paths[i];
        if (path10.isLogicalExpression()) {
          if (path10.node.operator === "&&") {
            paths.push(path10.get("left"));
            paths.push(path10.get("right"));
          }
        } else if (path10.isBinaryExpression()) {
          const type = inferAnnotationFromBinaryExpression(name2, path10);
          if (type) types3.push(type);
        }
      }
      if (types3.length) {
        return {
          typeAnnotation: (0, _util.createUnionType)(types3),
          ifStatement
        };
      }
      return getConditionalAnnotation(binding, ifStatement, name2);
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/inferers.js
var require_inferers = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/inferers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArrayExpression = ArrayExpression;
    exports2.AssignmentExpression = AssignmentExpression;
    exports2.BinaryExpression = BinaryExpression;
    exports2.BooleanLiteral = BooleanLiteral;
    exports2.CallExpression = CallExpression;
    exports2.ConditionalExpression = ConditionalExpression;
    exports2.ClassDeclaration = exports2.ClassExpression = exports2.FunctionDeclaration = exports2.ArrowFunctionExpression = exports2.FunctionExpression = Func;
    Object.defineProperty(exports2, "Identifier", {
      enumerable: true,
      get: function() {
        return _infererReference.default;
      }
    });
    exports2.LogicalExpression = LogicalExpression;
    exports2.NewExpression = NewExpression;
    exports2.NullLiteral = NullLiteral;
    exports2.NumericLiteral = NumericLiteral2;
    exports2.ObjectExpression = ObjectExpression;
    exports2.ParenthesizedExpression = ParenthesizedExpression;
    exports2.RegExpLiteral = RegExpLiteral;
    exports2.RestElement = RestElement;
    exports2.SequenceExpression = SequenceExpression;
    exports2.StringLiteral = StringLiteral2;
    exports2.TSAsExpression = TSAsExpression;
    exports2.TSNonNullExpression = TSNonNullExpression;
    exports2.TaggedTemplateExpression = TaggedTemplateExpression;
    exports2.TemplateLiteral = TemplateLiteral;
    exports2.TypeCastExpression = TypeCastExpression;
    exports2.UnaryExpression = UnaryExpression;
    exports2.UpdateExpression = UpdateExpression;
    exports2.VariableDeclarator = VariableDeclarator;
    var _t = require_lib3();
    var _infererReference = require_inferer_reference();
    var _util = require_util2();
    var {
      BOOLEAN_BINARY_OPERATORS,
      BOOLEAN_UNARY_OPERATORS,
      NUMBER_BINARY_OPERATORS,
      NUMBER_UNARY_OPERATORS,
      STRING_UNARY_OPERATORS,
      anyTypeAnnotation,
      arrayTypeAnnotation,
      booleanTypeAnnotation,
      buildMatchMemberExpression,
      genericTypeAnnotation,
      identifier,
      nullLiteralTypeAnnotation,
      numberTypeAnnotation,
      stringTypeAnnotation,
      tupleTypeAnnotation,
      unionTypeAnnotation,
      voidTypeAnnotation,
      isIdentifier: isIdentifier2
    } = _t;
    function VariableDeclarator() {
      if (!this.get("id").isIdentifier()) return;
      return this.get("init").getTypeAnnotation();
    }
    function TypeCastExpression(node3) {
      return node3.typeAnnotation;
    }
    TypeCastExpression.validParent = true;
    function TSAsExpression(node3) {
      return node3.typeAnnotation;
    }
    TSAsExpression.validParent = true;
    function TSNonNullExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function NewExpression(node3) {
      if (node3.callee.type === "Identifier") {
        return genericTypeAnnotation(node3.callee);
      }
    }
    function TemplateLiteral() {
      return stringTypeAnnotation();
    }
    function UnaryExpression(node3) {
      const operator = node3.operator;
      if (operator === "void") {
        return voidTypeAnnotation();
      } else if (NUMBER_UNARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (STRING_UNARY_OPERATORS.includes(operator)) {
        return stringTypeAnnotation();
      } else if (BOOLEAN_UNARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      }
    }
    function BinaryExpression(node3) {
      const operator = node3.operator;
      if (NUMBER_BINARY_OPERATORS.includes(operator)) {
        return numberTypeAnnotation();
      } else if (BOOLEAN_BINARY_OPERATORS.includes(operator)) {
        return booleanTypeAnnotation();
      } else if (operator === "+") {
        const right = this.get("right");
        const left = this.get("left");
        if (left.isBaseType("number") && right.isBaseType("number")) {
          return numberTypeAnnotation();
        } else if (left.isBaseType("string") || right.isBaseType("string")) {
          return stringTypeAnnotation();
        }
        return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);
      }
    }
    function LogicalExpression() {
      const argumentTypes = [this.get("left").getTypeAnnotation(), this.get("right").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function ConditionalExpression() {
      const argumentTypes = [this.get("consequent").getTypeAnnotation(), this.get("alternate").getTypeAnnotation()];
      return (0, _util.createUnionType)(argumentTypes);
    }
    function SequenceExpression() {
      return this.get("expressions").pop().getTypeAnnotation();
    }
    function ParenthesizedExpression() {
      return this.get("expression").getTypeAnnotation();
    }
    function AssignmentExpression() {
      return this.get("right").getTypeAnnotation();
    }
    function UpdateExpression(node3) {
      const operator = node3.operator;
      if (operator === "++" || operator === "--") {
        return numberTypeAnnotation();
      }
    }
    function StringLiteral2() {
      return stringTypeAnnotation();
    }
    function NumericLiteral2() {
      return numberTypeAnnotation();
    }
    function BooleanLiteral() {
      return booleanTypeAnnotation();
    }
    function NullLiteral() {
      return nullLiteralTypeAnnotation();
    }
    function RegExpLiteral() {
      return genericTypeAnnotation(identifier("RegExp"));
    }
    function ObjectExpression() {
      return genericTypeAnnotation(identifier("Object"));
    }
    function ArrayExpression() {
      return genericTypeAnnotation(identifier("Array"));
    }
    function RestElement() {
      return ArrayExpression();
    }
    RestElement.validParent = true;
    function Func() {
      return genericTypeAnnotation(identifier("Function"));
    }
    var isArrayFrom = buildMatchMemberExpression("Array.from");
    var isObjectKeys = buildMatchMemberExpression("Object.keys");
    var isObjectValues = buildMatchMemberExpression("Object.values");
    var isObjectEntries = buildMatchMemberExpression("Object.entries");
    function CallExpression() {
      const {
        callee
      } = this.node;
      if (isObjectKeys(callee)) {
        return arrayTypeAnnotation(stringTypeAnnotation());
      } else if (isArrayFrom(callee) || isObjectValues(callee) || isIdentifier2(callee, {
        name: "Array"
      })) {
        return arrayTypeAnnotation(anyTypeAnnotation());
      } else if (isObjectEntries(callee)) {
        return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));
      }
      return resolveCall(this.get("callee"));
    }
    function TaggedTemplateExpression() {
      return resolveCall(this.get("tag"));
    }
    function resolveCall(callee) {
      callee = callee.resolve();
      if (callee.isFunction()) {
        const {
          node: node3
        } = callee;
        if (node3.async) {
          if (node3.generator) {
            return genericTypeAnnotation(identifier("AsyncIterator"));
          } else {
            return genericTypeAnnotation(identifier("Promise"));
          }
        } else {
          if (node3.generator) {
            return genericTypeAnnotation(identifier("Iterator"));
          } else if (callee.node.returnType) {
            return callee.node.returnType;
          } else {
          }
        }
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/inference/index.js
var require_inference = __commonJS({
  "node_modules/@babel/traverse/lib/path/inference/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._getTypeAnnotation = _getTypeAnnotation;
    exports2.baseTypeStrictlyMatches = baseTypeStrictlyMatches;
    exports2.couldBeBaseType = couldBeBaseType;
    exports2.getTypeAnnotation = getTypeAnnotation;
    exports2.isBaseType = isBaseType;
    exports2.isGenericType = isGenericType;
    var inferers = require_inferers();
    var _t = require_lib3();
    var {
      anyTypeAnnotation,
      isAnyTypeAnnotation,
      isArrayTypeAnnotation,
      isBooleanTypeAnnotation,
      isEmptyTypeAnnotation,
      isFlowBaseAnnotation,
      isGenericTypeAnnotation,
      isIdentifier: isIdentifier2,
      isMixedTypeAnnotation,
      isNumberTypeAnnotation,
      isStringTypeAnnotation,
      isTSArrayType,
      isTSTypeAnnotation,
      isTSTypeReference,
      isTupleTypeAnnotation,
      isTypeAnnotation,
      isUnionTypeAnnotation,
      isVoidTypeAnnotation,
      stringTypeAnnotation,
      voidTypeAnnotation
    } = _t;
    function getTypeAnnotation() {
      let type = this.getData("typeAnnotation");
      if (type != null) {
        return type;
      }
      type = _getTypeAnnotation.call(this) || anyTypeAnnotation();
      if (isTypeAnnotation(type) || isTSTypeAnnotation(type)) {
        type = type.typeAnnotation;
      }
      this.setData("typeAnnotation", type);
      return type;
    }
    var typeAnnotationInferringNodes = /* @__PURE__ */ new WeakSet();
    function _getTypeAnnotation() {
      const node3 = this.node;
      if (!node3) {
        if (this.key === "init" && this.parentPath.isVariableDeclarator()) {
          const declar = this.parentPath.parentPath;
          const declarParent = declar.parentPath;
          if (declar.key === "left" && declarParent.isForInStatement()) {
            return stringTypeAnnotation();
          }
          if (declar.key === "left" && declarParent.isForOfStatement()) {
            return anyTypeAnnotation();
          }
          return voidTypeAnnotation();
        } else {
          return;
        }
      }
      if (node3.typeAnnotation) {
        return node3.typeAnnotation;
      }
      if (typeAnnotationInferringNodes.has(node3)) {
        return;
      }
      typeAnnotationInferringNodes.add(node3);
      try {
        var _inferer;
        let inferer = inferers[node3.type];
        if (inferer) {
          return inferer.call(this, node3);
        }
        inferer = inferers[this.parentPath.type];
        if ((_inferer = inferer) != null && _inferer.validParent) {
          return this.parentPath.getTypeAnnotation();
        }
      } finally {
        typeAnnotationInferringNodes.delete(node3);
      }
    }
    function isBaseType(baseName, soft) {
      return _isBaseType(baseName, this.getTypeAnnotation(), soft);
    }
    function _isBaseType(baseName, type, soft) {
      if (baseName === "string") {
        return isStringTypeAnnotation(type);
      } else if (baseName === "number") {
        return isNumberTypeAnnotation(type);
      } else if (baseName === "boolean") {
        return isBooleanTypeAnnotation(type);
      } else if (baseName === "any") {
        return isAnyTypeAnnotation(type);
      } else if (baseName === "mixed") {
        return isMixedTypeAnnotation(type);
      } else if (baseName === "empty") {
        return isEmptyTypeAnnotation(type);
      } else if (baseName === "void") {
        return isVoidTypeAnnotation(type);
      } else {
        if (soft) {
          return false;
        } else {
          throw new Error(`Unknown base type ${baseName}`);
        }
      }
    }
    function couldBeBaseType(name2) {
      const type = this.getTypeAnnotation();
      if (isAnyTypeAnnotation(type)) return true;
      if (isUnionTypeAnnotation(type)) {
        for (const type2 of type.types) {
          if (isAnyTypeAnnotation(type2) || _isBaseType(name2, type2, true)) {
            return true;
          }
        }
        return false;
      } else {
        return _isBaseType(name2, type, true);
      }
    }
    function baseTypeStrictlyMatches(rightArg) {
      const left = this.getTypeAnnotation();
      const right = rightArg.getTypeAnnotation();
      if (!isAnyTypeAnnotation(left) && isFlowBaseAnnotation(left)) {
        return right.type === left.type;
      }
      return false;
    }
    function isGenericType(genericName) {
      const type = this.getTypeAnnotation();
      if (genericName === "Array") {
        if (isTSArrayType(type) || isArrayTypeAnnotation(type) || isTupleTypeAnnotation(type)) {
          return true;
        }
      }
      return isGenericTypeAnnotation(type) && isIdentifier2(type.id, {
        name: genericName
      }) || isTSTypeReference(type) && isIdentifier2(type.typeName, {
        name: genericName
      });
    }
  }
});

// node_modules/@babel/traverse/lib/path/lib/removal-hooks.js
var require_removal_hooks = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/removal-hooks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hooks = void 0;
    var hooks = exports2.hooks = [function(self2, parent) {
      const removeParent = self2.key === "test" && (parent.isWhile() || parent.isSwitchCase()) || self2.key === "declaration" && parent.isExportDeclaration() || self2.key === "body" && parent.isLabeledStatement() || self2.listKey === "declarations" && parent.isVariableDeclaration() && parent.node.declarations.length === 1 || self2.key === "expression" && parent.isExpressionStatement();
      if (removeParent) {
        parent.remove();
        return true;
      }
    }, function(self2, parent) {
      if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {
        parent.replaceWith(parent.node.expressions[0]);
        return true;
      }
    }, function(self2, parent) {
      if (parent.isBinary()) {
        if (self2.key === "left") {
          parent.replaceWith(parent.node.right);
        } else {
          parent.replaceWith(parent.node.left);
        }
        return true;
      }
    }, function(self2, parent) {
      if (parent.isIfStatement() && self2.key === "consequent" || self2.key === "body" && (parent.isLoop() || parent.isArrowFunctionExpression())) {
        self2.replaceWith({
          type: "BlockStatement",
          body: []
        });
        return true;
      }
    }];
  }
});

// node_modules/@babel/traverse/lib/path/removal.js
var require_removal = __commonJS({
  "node_modules/@babel/traverse/lib/path/removal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._assertUnremoved = _assertUnremoved;
    exports2._callRemovalHooks = _callRemovalHooks;
    exports2._markRemoved = _markRemoved;
    exports2._remove = _remove;
    exports2._removeFromScope = _removeFromScope;
    exports2.remove = remove;
    var _removalHooks = require_removal_hooks();
    var _cache = require_cache();
    var _replacement = require_replacement();
    var _index = require_path();
    var _t = require_lib3();
    var _modification = require_modification();
    var _context = require_context2();
    var {
      getBindingIdentifiers
    } = _t;
    function remove() {
      var _this$opts;
      _assertUnremoved.call(this);
      _context.resync.call(this);
      if (_callRemovalHooks.call(this)) {
        _markRemoved.call(this);
        return;
      }
      if (!((_this$opts = this.opts) != null && _this$opts.noScope)) {
        _removeFromScope.call(this);
      }
      this.shareCommentsWithSiblings();
      _remove.call(this);
      _markRemoved.call(this);
    }
    function _removeFromScope() {
      const bindings = getBindingIdentifiers(this.node, false, false, true);
      Object.keys(bindings).forEach((name2) => this.scope.removeBinding(name2));
    }
    function _callRemovalHooks() {
      if (this.parentPath) {
        for (const fn of _removalHooks.hooks) {
          if (fn(this, this.parentPath)) return true;
        }
      }
    }
    function _remove() {
      if (Array.isArray(this.container)) {
        this.container.splice(this.key, 1);
        _modification.updateSiblingKeys.call(this, this.key, -1);
      } else {
        _replacement._replaceWith.call(this, null);
      }
    }
    function _markRemoved() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.REMOVED;
      if (this.parent) {
        (0, _cache.getCachedPaths)(this.hub, this.parent).delete(this.node);
      }
      this.node = null;
    }
    function _assertUnremoved() {
      if (this.removed) {
        throw this.buildCodeFrameError("NodePath has been removed so is read-only.");
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/lib/hoister.js
var require_hoister = __commonJS({
  "node_modules/@babel/traverse/lib/path/lib/hoister.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _t = require_lib3();
    var _t2 = _t;
    var {
      react
    } = _t;
    var {
      cloneNode,
      jsxExpressionContainer,
      variableDeclaration,
      variableDeclarator
    } = _t2;
    var referenceVisitor = {
      ReferencedIdentifier(path9, state) {
        if (path9.isJSXIdentifier() && react.isCompatTag(path9.node.name) && !path9.parentPath.isJSXMemberExpression()) {
          return;
        }
        if (path9.node.name === "this") {
          let scope = path9.scope;
          do {
            if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {
              break;
            }
          } while (scope = scope.parent);
          if (scope) state.breakOnScopePaths.push(scope.path);
        }
        const binding = path9.scope.getBinding(path9.node.name);
        if (!binding) return;
        for (const violation of binding.constantViolations) {
          if (violation.scope !== binding.path.scope) {
            state.mutableBinding = true;
            path9.stop();
            return;
          }
        }
        if (binding !== state.scope.getBinding(path9.node.name)) return;
        state.bindings[path9.node.name] = binding;
      }
    };
    var PathHoister = class {
      constructor(path9, scope) {
        this.breakOnScopePaths = void 0;
        this.bindings = void 0;
        this.mutableBinding = void 0;
        this.scopes = void 0;
        this.scope = void 0;
        this.path = void 0;
        this.attachAfter = void 0;
        this.breakOnScopePaths = [];
        this.bindings = {};
        this.mutableBinding = false;
        this.scopes = [];
        this.scope = scope;
        this.path = path9;
        this.attachAfter = false;
      }
      isCompatibleScope(scope) {
        for (const key of Object.keys(this.bindings)) {
          const binding = this.bindings[key];
          if (!scope.bindingIdentifierEquals(key, binding.identifier)) {
            return false;
          }
        }
        return true;
      }
      getCompatibleScopes() {
        let scope = this.path.scope;
        do {
          if (this.isCompatibleScope(scope)) {
            this.scopes.push(scope);
          } else {
            break;
          }
          if (this.breakOnScopePaths.includes(scope.path)) {
            break;
          }
        } while (scope = scope.parent);
      }
      getAttachmentPath() {
        let path9 = this._getAttachmentPath();
        if (!path9) return;
        let targetScope = path9.scope;
        if (targetScope.path === path9) {
          targetScope = path9.scope.parent;
        }
        if (targetScope.path.isProgram() || targetScope.path.isFunction()) {
          for (const name2 of Object.keys(this.bindings)) {
            if (!targetScope.hasOwnBinding(name2)) continue;
            const binding = this.bindings[name2];
            if (binding.kind === "param" || binding.path.parentKey === "params") {
              continue;
            }
            const bindingParentPath = this.getAttachmentParentForPath(binding.path);
            if (bindingParentPath.key >= path9.key) {
              this.attachAfter = true;
              path9 = binding.path;
              for (const violationPath of binding.constantViolations) {
                if (this.getAttachmentParentForPath(violationPath).key > path9.key) {
                  path9 = violationPath;
                }
              }
            }
          }
        }
        return path9;
      }
      _getAttachmentPath() {
        const scopes = this.scopes;
        const scope = scopes.pop();
        if (!scope) return;
        if (scope.path.isFunction()) {
          if (this.hasOwnParamBindings(scope)) {
            if (this.scope === scope) return;
            const bodies = scope.path.get("body").get("body");
            for (let i = 0; i < bodies.length; i++) {
              if (bodies[i].node._blockHoist) continue;
              return bodies[i];
            }
          } else {
            return this.getNextScopeAttachmentParent();
          }
        } else if (scope.path.isProgram()) {
          return this.getNextScopeAttachmentParent();
        }
      }
      getNextScopeAttachmentParent() {
        const scope = this.scopes.pop();
        if (scope) return this.getAttachmentParentForPath(scope.path);
      }
      getAttachmentParentForPath(path9) {
        do {
          if (!path9.parentPath || Array.isArray(path9.container) && path9.isStatement()) {
            return path9;
          }
        } while (path9 = path9.parentPath);
      }
      hasOwnParamBindings(scope) {
        for (const name2 of Object.keys(this.bindings)) {
          if (!scope.hasOwnBinding(name2)) continue;
          const binding = this.bindings[name2];
          if (binding.kind === "param" && binding.constant) return true;
        }
        return false;
      }
      run() {
        this.path.traverse(referenceVisitor, this);
        if (this.mutableBinding) return;
        this.getCompatibleScopes();
        const attachTo = this.getAttachmentPath();
        if (!attachTo) return;
        if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;
        let uid = attachTo.scope.generateUidIdentifier("ref");
        const declarator = variableDeclarator(uid, this.path.node);
        const insertFn = this.attachAfter ? "insertAfter" : "insertBefore";
        const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration("var", [declarator])]);
        const parent = this.path.parentPath;
        if (parent.isJSXElement() && this.path.container === parent.node.children) {
          uid = jsxExpressionContainer(uid);
        }
        this.path.replaceWith(cloneNode(uid));
        return attachTo.isVariableDeclarator() ? attached.get("init") : attached.get("declarations.0.init");
      }
    };
    exports2.default = PathHoister;
  }
});

// node_modules/@babel/traverse/lib/path/modification.js
var require_modification = __commonJS({
  "node_modules/@babel/traverse/lib/path/modification.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._containerInsert = _containerInsert;
    exports2._containerInsertAfter = _containerInsertAfter;
    exports2._containerInsertBefore = _containerInsertBefore;
    exports2._verifyNodeList = _verifyNodeList;
    exports2.insertAfter = insertAfter;
    exports2.insertBefore = insertBefore;
    exports2.pushContainer = pushContainer;
    exports2.unshiftContainer = unshiftContainer;
    exports2.updateSiblingKeys = updateSiblingKeys;
    var _cache = require_cache();
    var _index = require_path();
    var _context = require_context2();
    var _removal = require_removal();
    var _t = require_lib3();
    var _hoister = require_hoister();
    var {
      arrowFunctionExpression,
      assertExpression,
      assignmentExpression,
      blockStatement,
      callExpression,
      cloneNode,
      expressionStatement,
      isAssignmentExpression,
      isCallExpression,
      isExportNamedDeclaration,
      isExpression,
      isIdentifier: isIdentifier2,
      isSequenceExpression,
      isSuper,
      thisExpression
    } = _t;
    function insertBefore(nodes_) {
      _removal._assertUnremoved.call(this);
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertBefore(nodes);
      } else if (this.isNodeType("Expression") && !this.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        if (this.node) nodes.push(this.node);
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertBefore.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node3 = this.node;
        const shouldInsertCurrentNode = node3 && (!this.isExpressionStatement() || node3.expression != null);
        this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node3] : []));
        return this.unshiftContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function _containerInsert(from, nodes) {
      updateSiblingKeys.call(this, from, nodes.length);
      const paths = [];
      this.container.splice(from, 0, ...nodes);
      for (let i = 0; i < nodes.length; i++) {
        var _this$context;
        const to = from + i;
        const path9 = this.getSibling(to);
        paths.push(path9);
        if ((_this$context = this.context) != null && _this$context.queue) {
          _context.pushContext.call(path9, this.context);
        }
      }
      const contexts = _context._getQueueContexts.call(this);
      for (const path9 of paths) {
        _context.setScope.call(path9);
        path9.debug("Inserted.");
        for (const context of contexts) {
          context.maybeQueue(path9, true);
        }
      }
      return paths;
    }
    function _containerInsertBefore(nodes) {
      return _containerInsert.call(this, this.key, nodes);
    }
    function _containerInsertAfter(nodes) {
      return _containerInsert.call(this, this.key + 1, nodes);
    }
    var last = (arr) => arr[arr.length - 1];
    function isHiddenInSequenceExpression(path9) {
      return isSequenceExpression(path9.parent) && (last(path9.parent.expressions) !== path9.node || isHiddenInSequenceExpression(path9.parentPath));
    }
    function isAlmostConstantAssignment(node3, scope) {
      if (!isAssignmentExpression(node3) || !isIdentifier2(node3.left)) {
        return false;
      }
      const blockScope = scope.getBlockParent();
      return blockScope.hasOwnBinding(node3.left.name) && blockScope.getOwnBinding(node3.left.name).constantViolations.length <= 1;
    }
    function insertAfter(nodes_) {
      _removal._assertUnremoved.call(this);
      if (this.isSequenceExpression()) {
        return last(this.get("expressions")).insertAfter(nodes_);
      }
      const nodes = _verifyNodeList.call(this, nodes_);
      const {
        parentPath,
        parent
      } = this;
      if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || isExportNamedDeclaration(parent) || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {
        return parentPath.insertAfter(nodes.map((node3) => {
          return isExpression(node3) ? expressionStatement(node3) : node3;
        }));
      } else if (this.isNodeType("Expression") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === "init") {
        const self2 = this;
        if (self2.node) {
          const node3 = self2.node;
          let {
            scope
          } = this;
          if (scope.path.isPattern()) {
            assertExpression(node3);
            self2.replaceWith(callExpression(arrowFunctionExpression([], node3), []));
            self2.get("callee.body").insertAfter(nodes);
            return [self2];
          }
          if (isHiddenInSequenceExpression(self2)) {
            nodes.unshift(node3);
          } else if (isCallExpression(node3) && isSuper(node3.callee)) {
            nodes.unshift(node3);
            nodes.push(thisExpression());
          } else if (isAlmostConstantAssignment(node3, scope)) {
            nodes.unshift(node3);
            nodes.push(cloneNode(node3.left));
          } else if (scope.isPure(node3, true)) {
            nodes.push(node3);
          } else {
            if (parentPath.isMethod({
              computed: true,
              key: node3
            })) {
              scope = scope.parent;
            }
            const temp = scope.generateDeclaredUidIdentifier();
            nodes.unshift(expressionStatement(assignmentExpression("=", cloneNode(temp), node3)));
            nodes.push(expressionStatement(cloneNode(temp)));
          }
        }
        return this.replaceExpressionWithStatements(nodes);
      } else if (Array.isArray(this.container)) {
        return _containerInsertAfter.call(this, nodes);
      } else if (this.isStatementOrBlock()) {
        const node3 = this.node;
        const shouldInsertCurrentNode = node3 && (!this.isExpressionStatement() || node3.expression != null);
        this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node3] : []));
        return this.pushContainer("body", nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    }
    function updateSiblingKeys(fromIndex, incrementBy) {
      if (!this.parent) return;
      const paths = (0, _cache.getCachedPaths)(this.hub, this.parent) || [];
      for (const [, path9] of paths) {
        if (typeof path9.key === "number" && path9.container === this.container && path9.key >= fromIndex) {
          path9.key += incrementBy;
        }
      }
    }
    function _verifyNodeList(nodes) {
      if (!nodes) {
        return [];
      }
      if (!Array.isArray(nodes)) {
        nodes = [nodes];
      }
      for (let i = 0; i < nodes.length; i++) {
        const node3 = nodes[i];
        let msg;
        if (!node3) {
          msg = "has falsy node";
        } else if (typeof node3 !== "object") {
          msg = "contains a non-object node";
        } else if (!node3.type) {
          msg = "without a type";
        } else if (node3 instanceof _index.default) {
          msg = "has a NodePath when it expected a raw object";
        }
        if (msg) {
          const type = Array.isArray(node3) ? "array" : typeof node3;
          throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);
        }
      }
      return nodes;
    }
    function unshiftContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      nodes = _verifyNodeList.call(this, nodes);
      const path9 = _index.default.get({
        parentPath: this,
        parent: this.node,
        container: this.node[listKey],
        listKey,
        key: 0
      }).setContext(this.context);
      return _containerInsertBefore.call(path9, nodes);
    }
    function pushContainer(listKey, nodes) {
      _removal._assertUnremoved.call(this);
      const verifiedNodes = _verifyNodeList.call(this, nodes);
      const container2 = this.node[listKey];
      const path9 = _index.default.get({
        parentPath: this,
        parent: this.node,
        container: container2,
        listKey,
        key: container2.length
      }).setContext(this.context);
      return path9.replaceWithMultiple(verifiedNodes);
    }
    {
      exports2.hoist = function hoist(scope = this.scope) {
        const hoister = new _hoister.default(this, scope);
        return hoister.run();
      };
    }
  }
});

// node_modules/@babel/traverse/lib/path/replacement.js
var require_replacement = __commonJS({
  "node_modules/@babel/traverse/lib/path/replacement.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._replaceWith = _replaceWith;
    exports2.replaceExpressionWithStatements = replaceExpressionWithStatements;
    exports2.replaceInline = replaceInline;
    exports2.replaceWith = replaceWith;
    exports2.replaceWithMultiple = replaceWithMultiple;
    exports2.replaceWithSourceString = replaceWithSourceString;
    var _codeFrame = require_lib5();
    var _index = require_lib9();
    var _index2 = require_path();
    var _cache = require_cache();
    var _modification = require_modification();
    var _parser = require_lib4();
    var _t = require_lib3();
    var _context = require_context2();
    var {
      FUNCTION_TYPES,
      arrowFunctionExpression,
      assignmentExpression,
      awaitExpression,
      blockStatement,
      buildUndefinedNode,
      callExpression,
      cloneNode,
      conditionalExpression,
      expressionStatement,
      getBindingIdentifiers,
      identifier,
      inheritLeadingComments,
      inheritTrailingComments,
      inheritsComments,
      isBlockStatement,
      isEmptyStatement,
      isExpression,
      isExpressionStatement,
      isIfStatement,
      isProgram,
      isStatement,
      isVariableDeclaration,
      removeComments,
      returnStatement,
      sequenceExpression,
      validate,
      yieldExpression
    } = _t;
    function replaceWithMultiple(nodes) {
      var _getCachedPaths;
      _context.resync.call(this);
      nodes = _modification._verifyNodeList.call(this, nodes);
      inheritLeadingComments(nodes[0], this.node);
      inheritTrailingComments(nodes[nodes.length - 1], this.node);
      (_getCachedPaths = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths.delete(this.node);
      this.node = this.container[this.key] = null;
      const paths = this.insertAfter(nodes);
      if (this.node) {
        this.requeue();
      } else {
        this.remove();
      }
      return paths;
    }
    function replaceWithSourceString(replacement) {
      _context.resync.call(this);
      let ast;
      try {
        replacement = `(${replacement})`;
        ast = (0, _parser.parse)(replacement);
      } catch (err) {
        const loc = err.loc;
        if (loc) {
          err.message += " - make sure this is an expression.\n" + (0, _codeFrame.codeFrameColumns)(replacement, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          });
          err.code = "BABEL_REPLACE_SOURCE_ERROR";
        }
        throw err;
      }
      const expressionAST = ast.program.body[0].expression;
      _index.default.removeProperties(expressionAST);
      return this.replaceWith(expressionAST);
    }
    function replaceWith(replacementPath) {
      _context.resync.call(this);
      if (this.removed) {
        throw new Error("You can't replace this node, we've already removed it");
      }
      let replacement = replacementPath instanceof _index2.default ? replacementPath.node : replacementPath;
      if (!replacement) {
        throw new Error("You passed `path.replaceWith()` a falsy node, use `path.remove()` instead");
      }
      if (this.node === replacement) {
        return [this];
      }
      if (this.isProgram() && !isProgram(replacement)) {
        throw new Error("You can only replace a Program root node with another Program node");
      }
      if (Array.isArray(replacement)) {
        throw new Error("Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`");
      }
      if (typeof replacement === "string") {
        throw new Error("Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`");
      }
      let nodePath = "";
      if (this.isNodeType("Statement") && isExpression(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement) && !this.parentPath.isExportDefaultDeclaration()) {
          replacement = expressionStatement(replacement);
          nodePath = "expression";
        }
      }
      if (this.isNodeType("Expression") && isStatement(replacement)) {
        if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {
          return this.replaceExpressionWithStatements([replacement]);
        }
      }
      const oldNode = this.node;
      if (oldNode) {
        inheritsComments(replacement, oldNode);
        removeComments(oldNode);
      }
      _replaceWith.call(this, replacement);
      this.type = replacement.type;
      _context.setScope.call(this);
      this.requeue();
      return [nodePath ? this.get(nodePath) : this];
    }
    function _replaceWith(node3) {
      var _getCachedPaths2;
      if (!this.container) {
        throw new ReferenceError("Container is falsy");
      }
      if (this.inList) {
        validate(this.parent, this.key, [node3]);
      } else {
        validate(this.parent, this.key, node3);
      }
      this.debug(`Replace with ${node3 == null ? void 0 : node3.type}`);
      (_getCachedPaths2 = (0, _cache.getCachedPaths)(this.hub, this.parent)) == null || _getCachedPaths2.set(node3, this).delete(this.node);
      this.node = this.container[this.key] = node3;
    }
    function replaceExpressionWithStatements(nodes) {
      _context.resync.call(this);
      const declars = [];
      const nodesAsSingleExpression = gatherSequenceExpressions(nodes, declars);
      if (nodesAsSingleExpression) {
        for (const id3 of declars) this.scope.push({
          id: id3
        });
        return this.replaceWith(nodesAsSingleExpression)[0].get("expressions");
      }
      const functionParent = this.getFunctionParent();
      const isParentAsync = functionParent == null ? void 0 : functionParent.node.async;
      const isParentGenerator = functionParent == null ? void 0 : functionParent.node.generator;
      const container2 = arrowFunctionExpression([], blockStatement(nodes));
      this.replaceWith(callExpression(container2, []));
      const callee = this.get("callee");
      callee.get("body").scope.hoistVariables((id3) => this.scope.push({
        id: id3
      }));
      const completionRecords = callee.getCompletionRecords();
      for (const path9 of completionRecords) {
        if (!path9.isExpressionStatement()) continue;
        const loop = path9.findParent((path10) => path10.isLoop());
        if (loop) {
          let uid = loop.getData("expressionReplacementReturnUid");
          if (!uid) {
            uid = callee.scope.generateDeclaredUidIdentifier("ret");
            callee.get("body").pushContainer("body", returnStatement(cloneNode(uid)));
            loop.setData("expressionReplacementReturnUid", uid);
          } else {
            uid = identifier(uid.name);
          }
          path9.get("expression").replaceWith(assignmentExpression("=", cloneNode(uid), path9.node.expression));
        } else {
          path9.replaceWith(returnStatement(path9.node.expression));
        }
      }
      callee.arrowFunctionToExpression();
      const newCallee = callee;
      const needToAwaitFunction = isParentAsync && _index.default.hasType(this.get("callee.body").node, "AwaitExpression", FUNCTION_TYPES);
      const needToYieldFunction = isParentGenerator && _index.default.hasType(this.get("callee.body").node, "YieldExpression", FUNCTION_TYPES);
      if (needToAwaitFunction) {
        newCallee.set("async", true);
        if (!needToYieldFunction) {
          this.replaceWith(awaitExpression(this.node));
        }
      }
      if (needToYieldFunction) {
        newCallee.set("generator", true);
        this.replaceWith(yieldExpression(this.node, true));
      }
      return newCallee.get("body.body");
    }
    function gatherSequenceExpressions(nodes, declars) {
      const exprs = [];
      let ensureLastUndefined = true;
      for (const node3 of nodes) {
        if (!isEmptyStatement(node3)) {
          ensureLastUndefined = false;
        }
        if (isExpression(node3)) {
          exprs.push(node3);
        } else if (isExpressionStatement(node3)) {
          exprs.push(node3.expression);
        } else if (isVariableDeclaration(node3)) {
          if (node3.kind !== "var") return;
          for (const declar of node3.declarations) {
            const bindings = getBindingIdentifiers(declar);
            for (const key of Object.keys(bindings)) {
              declars.push(cloneNode(bindings[key]));
            }
            if (declar.init) {
              exprs.push(assignmentExpression("=", declar.id, declar.init));
            }
          }
          ensureLastUndefined = true;
        } else if (isIfStatement(node3)) {
          const consequent = node3.consequent ? gatherSequenceExpressions([node3.consequent], declars) : buildUndefinedNode();
          const alternate = node3.alternate ? gatherSequenceExpressions([node3.alternate], declars) : buildUndefinedNode();
          if (!consequent || !alternate) return;
          exprs.push(conditionalExpression(node3.test, consequent, alternate));
        } else if (isBlockStatement(node3)) {
          const body = gatherSequenceExpressions(node3.body, declars);
          if (!body) return;
          exprs.push(body);
        } else if (isEmptyStatement(node3)) {
          if (nodes.indexOf(node3) === 0) {
            ensureLastUndefined = true;
          }
        } else {
          return;
        }
      }
      if (ensureLastUndefined) exprs.push(buildUndefinedNode());
      if (exprs.length === 1) {
        return exprs[0];
      } else {
        return sequenceExpression(exprs);
      }
    }
    function replaceInline(nodes) {
      _context.resync.call(this);
      if (Array.isArray(nodes)) {
        if (Array.isArray(this.container)) {
          nodes = _modification._verifyNodeList.call(this, nodes);
          const paths = _modification._containerInsertAfter.call(this, nodes);
          this.remove();
          return paths;
        } else {
          return this.replaceWithMultiple(nodes);
        }
      } else {
        return this.replaceWith(nodes);
      }
    }
  }
});

// node_modules/@babel/traverse/lib/path/evaluation.js
var require_evaluation = __commonJS({
  "node_modules/@babel/traverse/lib/path/evaluation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.evaluate = evaluate;
    exports2.evaluateTruthy = evaluateTruthy;
    var VALID_OBJECT_CALLEES = ["Number", "String", "Math"];
    var VALID_IDENTIFIER_CALLEES = ["isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", null, null];
    var INVALID_METHODS = ["random"];
    function isValidObjectCallee(val) {
      return VALID_OBJECT_CALLEES.includes(val);
    }
    function isValidIdentifierCallee(val) {
      return VALID_IDENTIFIER_CALLEES.includes(val);
    }
    function isInvalidMethod(val) {
      return INVALID_METHODS.includes(val);
    }
    function evaluateTruthy() {
      const res = this.evaluate();
      if (res.confident) return !!res.value;
    }
    function deopt(path9, state) {
      if (!state.confident) return;
      state.deoptPath = path9;
      state.confident = false;
    }
    var Globals = /* @__PURE__ */ new Map([["undefined", void 0], ["Infinity", Infinity], ["NaN", NaN]]);
    function evaluateCached(path9, state) {
      const {
        node: node3
      } = path9;
      const {
        seen: seen2
      } = state;
      if (seen2.has(node3)) {
        const existing = seen2.get(node3);
        if (existing.resolved) {
          return existing.value;
        } else {
          deopt(path9, state);
          return;
        }
      } else {
        const item = {
          resolved: false
        };
        seen2.set(node3, item);
        const val = _evaluate(path9, state);
        if (state.confident) {
          item.resolved = true;
          item.value = val;
        }
        return val;
      }
    }
    function _evaluate(path9, state) {
      if (!state.confident) return;
      if (path9.isSequenceExpression()) {
        const exprs = path9.get("expressions");
        return evaluateCached(exprs[exprs.length - 1], state);
      }
      if (path9.isStringLiteral() || path9.isNumericLiteral() || path9.isBooleanLiteral()) {
        return path9.node.value;
      }
      if (path9.isNullLiteral()) {
        return null;
      }
      if (path9.isTemplateLiteral()) {
        return evaluateQuasis(path9, path9.node.quasis, state);
      }
      if (path9.isTaggedTemplateExpression() && path9.get("tag").isMemberExpression()) {
        const object2 = path9.get("tag.object");
        const {
          node: {
            name: name2
          }
        } = object2;
        const property = path9.get("tag.property");
        if (object2.isIdentifier() && name2 === "String" && !path9.scope.getBinding(name2) && property.isIdentifier() && property.node.name === "raw") {
          return evaluateQuasis(path9, path9.node.quasi.quasis, state, true);
        }
      }
      if (path9.isConditionalExpression()) {
        const testResult = evaluateCached(path9.get("test"), state);
        if (!state.confident) return;
        if (testResult) {
          return evaluateCached(path9.get("consequent"), state);
        } else {
          return evaluateCached(path9.get("alternate"), state);
        }
      }
      if (path9.isExpressionWrapper()) {
        return evaluateCached(path9.get("expression"), state);
      }
      if (path9.isMemberExpression() && !path9.parentPath.isCallExpression({
        callee: path9.node
      })) {
        const property = path9.get("property");
        const object2 = path9.get("object");
        if (object2.isLiteral()) {
          const value2 = object2.node.value;
          const type = typeof value2;
          let key = null;
          if (path9.node.computed) {
            key = evaluateCached(property, state);
            if (!state.confident) return;
          } else if (property.isIdentifier()) {
            key = property.node.name;
          }
          if ((type === "number" || type === "string") && key != null && (typeof key === "number" || typeof key === "string")) {
            return value2[key];
          }
        }
      }
      if (path9.isReferencedIdentifier()) {
        const binding = path9.scope.getBinding(path9.node.name);
        if (binding) {
          if (binding.constantViolations.length > 0 || path9.node.start < binding.path.node.end) {
            deopt(binding.path, state);
            return;
          }
          if (binding.hasValue) {
            return binding.value;
          }
        }
        const name2 = path9.node.name;
        if (Globals.has(name2)) {
          if (!binding) {
            return Globals.get(name2);
          }
          deopt(binding.path, state);
          return;
        }
        const resolved = path9.resolve();
        if (resolved === path9) {
          deopt(path9, state);
          return;
        } else {
          return evaluateCached(resolved, state);
        }
      }
      if (path9.isUnaryExpression({
        prefix: true
      })) {
        if (path9.node.operator === "void") {
          return void 0;
        }
        const argument = path9.get("argument");
        if (path9.node.operator === "typeof" && (argument.isFunction() || argument.isClass())) {
          return "function";
        }
        const arg = evaluateCached(argument, state);
        if (!state.confident) return;
        switch (path9.node.operator) {
          case "!":
            return !arg;
          case "+":
            return +arg;
          case "-":
            return -arg;
          case "~":
            return ~arg;
          case "typeof":
            return typeof arg;
        }
      }
      if (path9.isArrayExpression()) {
        const arr = [];
        const elems = path9.get("elements");
        for (const elem of elems) {
          const elemValue = elem.evaluate();
          if (elemValue.confident) {
            arr.push(elemValue.value);
          } else {
            deopt(elemValue.deopt, state);
            return;
          }
        }
        return arr;
      }
      if (path9.isObjectExpression()) {
        const obj = {};
        const props = path9.get("properties");
        for (const prop of props) {
          if (prop.isObjectMethod() || prop.isSpreadElement()) {
            deopt(prop, state);
            return;
          }
          const keyPath = prop.get("key");
          let key;
          if (prop.node.computed) {
            key = keyPath.evaluate();
            if (!key.confident) {
              deopt(key.deopt, state);
              return;
            }
            key = key.value;
          } else if (keyPath.isIdentifier()) {
            key = keyPath.node.name;
          } else {
            key = keyPath.node.value;
          }
          const valuePath = prop.get("value");
          let value2 = valuePath.evaluate();
          if (!value2.confident) {
            deopt(value2.deopt, state);
            return;
          }
          value2 = value2.value;
          obj[key] = value2;
        }
        return obj;
      }
      if (path9.isLogicalExpression()) {
        const wasConfident = state.confident;
        const left = evaluateCached(path9.get("left"), state);
        const leftConfident = state.confident;
        state.confident = wasConfident;
        const right = evaluateCached(path9.get("right"), state);
        const rightConfident = state.confident;
        switch (path9.node.operator) {
          case "||":
            state.confident = leftConfident && (!!left || rightConfident);
            if (!state.confident) return;
            return left || right;
          case "&&":
            state.confident = leftConfident && (!left || rightConfident);
            if (!state.confident) return;
            return left && right;
          case "??":
            state.confident = leftConfident && (left != null || rightConfident);
            if (!state.confident) return;
            return left != null ? left : right;
        }
      }
      if (path9.isBinaryExpression()) {
        const left = evaluateCached(path9.get("left"), state);
        if (!state.confident) return;
        const right = evaluateCached(path9.get("right"), state);
        if (!state.confident) return;
        switch (path9.node.operator) {
          case "-":
            return left - right;
          case "+":
            return left + right;
          case "/":
            return left / right;
          case "*":
            return left * right;
          case "%":
            return left % right;
          case "**":
            return Math.pow(left, right);
          case "<":
            return left < right;
          case ">":
            return left > right;
          case "<=":
            return left <= right;
          case ">=":
            return left >= right;
          case "==":
            return left == right;
          case "!=":
            return left != right;
          case "===":
            return left === right;
          case "!==":
            return left !== right;
          case "|":
            return left | right;
          case "&":
            return left & right;
          case "^":
            return left ^ right;
          case "<<":
            return left << right;
          case ">>":
            return left >> right;
          case ">>>":
            return left >>> right;
        }
      }
      if (path9.isCallExpression()) {
        const callee = path9.get("callee");
        let context;
        let func;
        if (callee.isIdentifier() && !path9.scope.getBinding(callee.node.name) && (isValidObjectCallee(callee.node.name) || isValidIdentifierCallee(callee.node.name))) {
          func = global[callee.node.name];
        }
        if (callee.isMemberExpression()) {
          const object2 = callee.get("object");
          const property = callee.get("property");
          if (object2.isIdentifier() && property.isIdentifier() && isValidObjectCallee(object2.node.name) && !isInvalidMethod(property.node.name)) {
            context = global[object2.node.name];
            const key = property.node.name;
            if (hasOwnProperty.call(context, key)) {
              func = context[key];
            }
          }
          if (object2.isLiteral() && property.isIdentifier()) {
            const type = typeof object2.node.value;
            if (type === "string" || type === "number") {
              context = object2.node.value;
              func = context[property.node.name];
            }
          }
        }
        if (func) {
          const args = path9.get("arguments").map((arg) => evaluateCached(arg, state));
          if (!state.confident) return;
          return func.apply(context, args);
        }
      }
      deopt(path9, state);
    }
    function evaluateQuasis(path9, quasis, state, raw = false) {
      let str2 = "";
      let i = 0;
      const exprs = path9.isTemplateLiteral() ? path9.get("expressions") : path9.get("quasi.expressions");
      for (const elem of quasis) {
        if (!state.confident) break;
        str2 += raw ? elem.value.raw : elem.value.cooked;
        const expr = exprs[i++];
        if (expr) str2 += String(evaluateCached(expr, state));
      }
      if (!state.confident) return;
      return str2;
    }
    function evaluate() {
      const state = {
        confident: true,
        deoptPath: null,
        seen: /* @__PURE__ */ new Map()
      };
      let value2 = evaluateCached(this, state);
      if (!state.confident) value2 = void 0;
      return {
        confident: state.confident,
        deopt: state.deoptPath,
        value: value2
      };
    }
  }
});

// node_modules/@babel/traverse/lib/path/conversion.js
var require_conversion = __commonJS({
  "node_modules/@babel/traverse/lib/path/conversion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.arrowFunctionToExpression = arrowFunctionToExpression;
    exports2.ensureBlock = ensureBlock;
    exports2.ensureFunctionName = ensureFunctionName;
    exports2.splitExportDeclaration = splitExportDeclaration;
    exports2.toComputedKey = toComputedKey;
    exports2.unwrapFunctionEnvironment = unwrapFunctionEnvironment;
    var _t = require_lib3();
    var _template = require_lib6();
    var _visitors = require_visitors();
    var _context = require_context2();
    var {
      arrowFunctionExpression,
      assignmentExpression,
      binaryExpression,
      blockStatement,
      callExpression,
      conditionalExpression,
      expressionStatement,
      identifier,
      isIdentifier: isIdentifier2,
      jsxIdentifier,
      logicalExpression,
      LOGICAL_OPERATORS,
      memberExpression,
      metaProperty,
      numericLiteral,
      objectExpression,
      restElement,
      returnStatement,
      sequenceExpression,
      spreadElement,
      stringLiteral,
      super: _super,
      thisExpression,
      toExpression,
      unaryExpression,
      toBindingIdentifierName,
      isFunction: isFunction2,
      isAssignmentPattern,
      isRestElement,
      getFunctionName,
      cloneNode,
      variableDeclaration,
      variableDeclarator,
      exportNamedDeclaration,
      exportSpecifier,
      inherits
    } = _t;
    function toComputedKey() {
      let key;
      if (this.isMemberExpression()) {
        key = this.node.property;
      } else if (this.isProperty() || this.isMethod()) {
        key = this.node.key;
      } else {
        throw new ReferenceError("todo");
      }
      if (!this.node.computed) {
        if (isIdentifier2(key)) key = stringLiteral(key.name);
      }
      return key;
    }
    function ensureBlock() {
      const body = this.get("body");
      const bodyNode = body.node;
      if (Array.isArray(body)) {
        throw new Error("Can't convert array path to a block statement");
      }
      if (!bodyNode) {
        throw new Error("Can't convert node without a body");
      }
      if (body.isBlockStatement()) {
        return bodyNode;
      }
      const statements = [];
      let stringPath = "body";
      let key;
      let listKey;
      if (body.isStatement()) {
        listKey = "body";
        key = 0;
        statements.push(body.node);
      } else {
        stringPath += ".body.0";
        if (this.isFunction()) {
          key = "argument";
          statements.push(returnStatement(body.node));
        } else {
          key = "expression";
          statements.push(expressionStatement(body.node));
        }
      }
      this.node.body = blockStatement(statements);
      const parentPath = this.get(stringPath);
      _context.setup.call(body, parentPath, listKey ? parentPath.node[listKey] : parentPath.node, listKey, key);
      return this.node;
    }
    {
      exports2.arrowFunctionToShadowed = function() {
        if (!this.isArrowFunctionExpression()) return;
        this.arrowFunctionToExpression();
      };
    }
    function unwrapFunctionEnvironment() {
      if (!this.isArrowFunctionExpression() && !this.isFunctionExpression() && !this.isFunctionDeclaration()) {
        throw this.buildCodeFrameError("Can only unwrap the environment of a function.");
      }
      hoistFunctionEnvironment(this);
    }
    function setType(path9, type) {
      path9.node.type = type;
    }
    function arrowFunctionToExpression({
      allowInsertArrow = true,
      allowInsertArrowWithRest = allowInsertArrow,
      noNewArrows = !((_arguments$) => (_arguments$ = arguments[0]) == null ? void 0 : _arguments$.specCompliant)()
    } = {}) {
      if (!this.isArrowFunctionExpression()) {
        throw this.buildCodeFrameError("Cannot convert non-arrow function to a function expression.");
      }
      let self2 = this;
      if (!noNewArrows) {
        var _self$ensureFunctionN;
        self2 = (_self$ensureFunctionN = self2.ensureFunctionName(false)) != null ? _self$ensureFunctionN : self2;
      }
      const {
        thisBinding,
        fnPath: fn
      } = hoistFunctionEnvironment(self2, noNewArrows, allowInsertArrow, allowInsertArrowWithRest);
      fn.ensureBlock();
      setType(fn, "FunctionExpression");
      if (!noNewArrows) {
        const checkBinding = thisBinding ? null : fn.scope.generateUidIdentifier("arrowCheckId");
        if (checkBinding) {
          fn.parentPath.scope.push({
            id: checkBinding,
            init: objectExpression([])
          });
        }
        fn.get("body").unshiftContainer("body", expressionStatement(callExpression(this.hub.addHelper("newArrowCheck"), [thisExpression(), checkBinding ? identifier(checkBinding.name) : identifier(thisBinding)])));
        fn.replaceWith(callExpression(memberExpression(fn.node, identifier("bind")), [checkBinding ? identifier(checkBinding.name) : thisExpression()]));
        return fn.get("callee.object");
      }
      return fn;
    }
    var getSuperCallsVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        allSuperCalls
      }) {
        if (!child.get("callee").isSuper()) return;
        allSuperCalls.push(child);
      }
    });
    function hoistFunctionEnvironment(fnPath, noNewArrows = true, allowInsertArrow = true, allowInsertArrowWithRest = true) {
      let arrowParent;
      let thisEnvFn = fnPath.findParent((p) => {
        if (p.isArrowFunctionExpression()) {
          var _arrowParent;
          (_arrowParent = arrowParent) != null ? _arrowParent : arrowParent = p;
          return false;
        }
        return p.isFunction() || p.isProgram() || p.isClassProperty({
          static: false
        }) || p.isClassPrivateProperty({
          static: false
        });
      });
      const inConstructor = thisEnvFn.isClassMethod({
        kind: "constructor"
      });
      if (thisEnvFn.isClassProperty() || thisEnvFn.isClassPrivateProperty()) {
        if (arrowParent) {
          thisEnvFn = arrowParent;
        } else if (allowInsertArrow) {
          fnPath.replaceWith(callExpression(arrowFunctionExpression([], toExpression(fnPath.node)), []));
          thisEnvFn = fnPath.get("callee");
          fnPath = thisEnvFn.get("body");
        } else {
          throw fnPath.buildCodeFrameError("Unable to transform arrow inside class property");
        }
      }
      const {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      } = getScopeInformation(fnPath);
      if (inConstructor && superCalls.length > 0) {
        if (!allowInsertArrow) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        if (!allowInsertArrowWithRest) {
          throw superCalls[0].buildCodeFrameError("When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const allSuperCalls = [];
        thisEnvFn.traverse(getSuperCallsVisitor, {
          allSuperCalls
        });
        const superBinding = getSuperBinding(thisEnvFn);
        allSuperCalls.forEach((superCall) => {
          const callee = identifier(superBinding);
          callee.loc = superCall.node.callee.loc;
          superCall.get("callee").replaceWith(callee);
        });
      }
      if (argumentsPaths.length > 0) {
        const argumentsBinding = getBinding(thisEnvFn, "arguments", () => {
          const args = () => identifier("arguments");
          if (thisEnvFn.scope.path.isProgram()) {
            return conditionalExpression(binaryExpression("===", unaryExpression("typeof", args()), stringLiteral("undefined")), thisEnvFn.scope.buildUndefinedNode(), args());
          } else {
            return args();
          }
        });
        argumentsPaths.forEach((argumentsChild) => {
          const argsRef = identifier(argumentsBinding);
          argsRef.loc = argumentsChild.node.loc;
          argumentsChild.replaceWith(argsRef);
        });
      }
      if (newTargetPaths.length > 0) {
        const newTargetBinding = getBinding(thisEnvFn, "newtarget", () => metaProperty(identifier("new"), identifier("target")));
        newTargetPaths.forEach((targetChild) => {
          const targetRef = identifier(newTargetBinding);
          targetRef.loc = targetChild.node.loc;
          targetChild.replaceWith(targetRef);
        });
      }
      if (superProps.length > 0) {
        if (!allowInsertArrow) {
          throw superProps[0].buildCodeFrameError("When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration.");
        }
        const flatSuperProps = superProps.reduce((acc, superProp) => acc.concat(standardizeSuperProperty(superProp)), []);
        flatSuperProps.forEach((superProp) => {
          const key = superProp.node.computed ? "" : superProp.get("property").node.name;
          const superParentPath = superProp.parentPath;
          const isAssignment = superParentPath.isAssignmentExpression({
            left: superProp.node
          });
          const isCall = superParentPath.isCallExpression({
            callee: superProp.node
          });
          const isTaggedTemplate = superParentPath.isTaggedTemplateExpression({
            tag: superProp.node
          });
          const superBinding = getSuperPropBinding(thisEnvFn, isAssignment, key);
          const args = [];
          if (superProp.node.computed) {
            args.push(superProp.get("property").node);
          }
          if (isAssignment) {
            const value2 = superParentPath.node.right;
            args.push(value2);
          }
          const call2 = callExpression(identifier(superBinding), args);
          if (isCall) {
            superParentPath.unshiftContainer("arguments", thisExpression());
            superProp.replaceWith(memberExpression(call2, identifier("call")));
            thisPaths.push(superParentPath.get("arguments.0"));
          } else if (isAssignment) {
            superParentPath.replaceWith(call2);
          } else if (isTaggedTemplate) {
            superProp.replaceWith(callExpression(memberExpression(call2, identifier("bind"), false), [thisExpression()]));
            thisPaths.push(superProp.get("arguments.0"));
          } else {
            superProp.replaceWith(call2);
          }
        });
      }
      let thisBinding;
      if (thisPaths.length > 0 || !noNewArrows) {
        thisBinding = getThisBinding(thisEnvFn, inConstructor);
        if (noNewArrows || inConstructor && hasSuperClass(thisEnvFn)) {
          thisPaths.forEach((thisChild) => {
            const thisRef = thisChild.isJSX() ? jsxIdentifier(thisBinding) : identifier(thisBinding);
            thisRef.loc = thisChild.node.loc;
            thisChild.replaceWith(thisRef);
          });
          if (!noNewArrows) thisBinding = null;
        }
      }
      return {
        thisBinding,
        fnPath
      };
    }
    function isLogicalOp(op) {
      return LOGICAL_OPERATORS.includes(op);
    }
    function standardizeSuperProperty(superProp) {
      if (superProp.parentPath.isAssignmentExpression() && superProp.parentPath.node.operator !== "=") {
        const assignmentPath = superProp.parentPath;
        const op = assignmentPath.node.operator.slice(0, -1);
        const value2 = assignmentPath.node.right;
        const isLogicalAssignment = isLogicalOp(op);
        if (superProp.node.computed) {
          const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
          const object2 = superProp.node.object;
          const property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression(object2, assignmentExpression("=", tmp, property), true));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object2, identifier(tmp.name), true), value2));
        } else {
          const object2 = superProp.node.object;
          const property = superProp.node.property;
          assignmentPath.get("left").replaceWith(memberExpression(object2, property));
          assignmentPath.get("right").replaceWith(rightExpression(isLogicalAssignment ? "=" : op, memberExpression(object2, identifier(property.name)), value2));
        }
        if (isLogicalAssignment) {
          assignmentPath.replaceWith(logicalExpression(op, assignmentPath.node.left, assignmentPath.node.right));
        } else {
          assignmentPath.node.operator = "=";
        }
        return [assignmentPath.get("left"), assignmentPath.get("right").get("left")];
      } else if (superProp.parentPath.isUpdateExpression()) {
        const updateExpr = superProp.parentPath;
        const tmp = superProp.scope.generateDeclaredUidIdentifier("tmp");
        const computedKey = superProp.node.computed ? superProp.scope.generateDeclaredUidIdentifier("prop") : null;
        const parts = [assignmentExpression("=", tmp, memberExpression(superProp.node.object, computedKey ? assignmentExpression("=", computedKey, superProp.node.property) : superProp.node.property, superProp.node.computed)), assignmentExpression("=", memberExpression(superProp.node.object, computedKey ? identifier(computedKey.name) : superProp.node.property, superProp.node.computed), binaryExpression(superProp.parentPath.node.operator[0], identifier(tmp.name), numericLiteral(1)))];
        if (!superProp.parentPath.node.prefix) {
          parts.push(identifier(tmp.name));
        }
        updateExpr.replaceWith(sequenceExpression(parts));
        const left = updateExpr.get("expressions.0.right");
        const right = updateExpr.get("expressions.1.left");
        return [left, right];
      }
      return [superProp];
      function rightExpression(op, left, right) {
        if (op === "=") {
          return assignmentExpression("=", left, right);
        } else {
          return binaryExpression(op, left, right);
        }
      }
    }
    function hasSuperClass(thisEnvFn) {
      return thisEnvFn.isClassMethod() && !!thisEnvFn.parentPath.parentPath.node.superClass;
    }
    var assignSuperThisVisitor = (0, _visitors.environmentVisitor)({
      CallExpression(child, {
        supers,
        thisBinding
      }) {
        if (!child.get("callee").isSuper()) return;
        if (supers.has(child.node)) return;
        supers.add(child.node);
        child.replaceWithMultiple([child.node, assignmentExpression("=", identifier(thisBinding), identifier("this"))]);
      }
    });
    function getThisBinding(thisEnvFn, inConstructor) {
      return getBinding(thisEnvFn, "this", (thisBinding) => {
        if (!inConstructor || !hasSuperClass(thisEnvFn)) return thisExpression();
        thisEnvFn.traverse(assignSuperThisVisitor, {
          supers: /* @__PURE__ */ new WeakSet(),
          thisBinding
        });
      });
    }
    function getSuperBinding(thisEnvFn) {
      return getBinding(thisEnvFn, "supercall", () => {
        const argsBinding = thisEnvFn.scope.generateUidIdentifier("args");
        return arrowFunctionExpression([restElement(argsBinding)], callExpression(_super(), [spreadElement(identifier(argsBinding.name))]));
      });
    }
    function getSuperPropBinding(thisEnvFn, isAssignment, propName) {
      const op = isAssignment ? "set" : "get";
      return getBinding(thisEnvFn, `superprop_${op}:${propName || ""}`, () => {
        const argsList = [];
        let fnBody;
        if (propName) {
          fnBody = memberExpression(_super(), identifier(propName));
        } else {
          const method = thisEnvFn.scope.generateUidIdentifier("prop");
          argsList.unshift(method);
          fnBody = memberExpression(_super(), identifier(method.name), true);
        }
        if (isAssignment) {
          const valueIdent = thisEnvFn.scope.generateUidIdentifier("value");
          argsList.push(valueIdent);
          fnBody = assignmentExpression("=", fnBody, identifier(valueIdent.name));
        }
        return arrowFunctionExpression(argsList, fnBody);
      });
    }
    function getBinding(thisEnvFn, key, init2) {
      const cacheKey = "binding:" + key;
      let data = thisEnvFn.getData(cacheKey);
      if (!data) {
        const id3 = thisEnvFn.scope.generateUidIdentifier(key);
        data = id3.name;
        thisEnvFn.setData(cacheKey, data);
        thisEnvFn.scope.push({
          id: id3,
          init: init2(data)
        });
      }
      return data;
    }
    var getScopeInformationVisitor = (0, _visitors.environmentVisitor)({
      ThisExpression(child, {
        thisPaths
      }) {
        thisPaths.push(child);
      },
      JSXIdentifier(child, {
        thisPaths
      }) {
        if (child.node.name !== "this") return;
        if (!child.parentPath.isJSXMemberExpression({
          object: child.node
        }) && !child.parentPath.isJSXOpeningElement({
          name: child.node
        })) {
          return;
        }
        thisPaths.push(child);
      },
      CallExpression(child, {
        superCalls
      }) {
        if (child.get("callee").isSuper()) superCalls.push(child);
      },
      MemberExpression(child, {
        superProps
      }) {
        if (child.get("object").isSuper()) superProps.push(child);
      },
      Identifier(child, {
        argumentsPaths
      }) {
        if (!child.isReferencedIdentifier({
          name: "arguments"
        })) return;
        let curr = child.scope;
        do {
          if (curr.hasOwnBinding("arguments")) {
            curr.rename("arguments");
            return;
          }
          if (curr.path.isFunction() && !curr.path.isArrowFunctionExpression()) {
            break;
          }
        } while (curr = curr.parent);
        argumentsPaths.push(child);
      },
      MetaProperty(child, {
        newTargetPaths
      }) {
        if (!child.get("meta").isIdentifier({
          name: "new"
        })) return;
        if (!child.get("property").isIdentifier({
          name: "target"
        })) return;
        newTargetPaths.push(child);
      }
    });
    function getScopeInformation(fnPath) {
      const thisPaths = [];
      const argumentsPaths = [];
      const newTargetPaths = [];
      const superProps = [];
      const superCalls = [];
      fnPath.traverse(getScopeInformationVisitor, {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      });
      return {
        thisPaths,
        argumentsPaths,
        newTargetPaths,
        superProps,
        superCalls
      };
    }
    function splitExportDeclaration() {
      if (!this.isExportDeclaration() || this.isExportAllDeclaration()) {
        throw new Error("Only default and named export declarations can be split.");
      }
      if (this.isExportNamedDeclaration() && this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const declaration = this.get("declaration");
      if (this.isExportDefaultDeclaration()) {
        const standaloneDeclaration = declaration.isFunctionDeclaration() || declaration.isClassDeclaration();
        const exportExpr = declaration.isFunctionExpression() || declaration.isClassExpression();
        const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;
        let id3 = declaration.node.id;
        let needBindingRegistration = false;
        if (!id3) {
          needBindingRegistration = true;
          id3 = scope.generateUidIdentifier("default");
          if (standaloneDeclaration || exportExpr) {
            declaration.node.id = cloneNode(id3);
          }
        } else if (exportExpr && scope.hasBinding(id3.name)) {
          needBindingRegistration = true;
          id3 = scope.generateUidIdentifier(id3.name);
        }
        const updatedDeclaration = standaloneDeclaration ? declaration.node : variableDeclaration("var", [variableDeclarator(cloneNode(id3), declaration.node)]);
        const updatedExportDeclaration = exportNamedDeclaration(null, [exportSpecifier(cloneNode(id3), identifier("default"))]);
        this.insertAfter(updatedExportDeclaration);
        this.replaceWith(updatedDeclaration);
        if (needBindingRegistration) {
          scope.registerDeclaration(this);
        }
        return this;
      } else if (this.get("specifiers").length > 0) {
        throw new Error("It doesn't make sense to split exported specifiers.");
      }
      const bindingIdentifiers = declaration.getOuterBindingIdentifiers();
      const specifiers = Object.keys(bindingIdentifiers).map((name2) => {
        return exportSpecifier(identifier(name2), identifier(name2));
      });
      const aliasDeclar = exportNamedDeclaration(null, specifiers);
      this.insertAfter(aliasDeclar);
      this.replaceWith(declaration.node);
      return this;
    }
    var refersOuterBindingVisitor = {
      "ReferencedIdentifier|BindingIdentifier"(path9, state) {
        if (path9.node.name !== state.name) return;
        state.needsRename = true;
        path9.stop();
      },
      Scope(path9, state) {
        if (path9.scope.hasOwnBinding(state.name)) {
          path9.skip();
        }
      }
    };
    function ensureFunctionName(supportUnicodeId) {
      if (this.node.id) return this;
      const res = getFunctionName(this.node, this.parent);
      if (res == null) return this;
      let {
        name: name2
      } = res;
      if (!supportUnicodeId && /[\uD800-\uDFFF]/.test(name2)) {
        return null;
      }
      if (name2.startsWith("get ") || name2.startsWith("set ")) {
        return null;
      }
      name2 = toBindingIdentifierName(name2.replace(/[/ ]/g, "_"));
      const id3 = identifier(name2);
      inherits(id3, res.originalNode);
      const state = {
        needsRename: false,
        name: name2
      };
      const {
        scope
      } = this;
      const binding = scope.getOwnBinding(name2);
      if (binding) {
        if (binding.kind === "param") {
          state.needsRename = true;
        } else {
        }
      } else if (scope.parent.hasBinding(name2) || scope.hasGlobal(name2)) {
        this.traverse(refersOuterBindingVisitor, state);
      }
      if (!state.needsRename) {
        this.node.id = id3;
        scope.getProgramParent().references[id3.name] = true;
        return this;
      }
      if (scope.hasBinding(id3.name) && !scope.hasGlobal(id3.name)) {
        scope.rename(id3.name);
        this.node.id = id3;
        scope.getProgramParent().references[id3.name] = true;
        return this;
      }
      if (!isFunction2(this.node)) return null;
      const key = scope.generateUidIdentifier(id3.name);
      const params = [];
      for (let i = 0, len = getFunctionArity(this.node); i < len; i++) {
        params.push(scope.generateUidIdentifier("x"));
      }
      const call2 = _template.default.expression.ast`
    (function (${key}) {
      function ${id3}(${params}) {
        return ${cloneNode(key)}.apply(this, arguments);
      }

      ${cloneNode(id3)}.toString = function () {
        return ${cloneNode(key)}.toString();
      }

      return ${cloneNode(id3)};
    })(${toExpression(this.node)})
  `;
      return this.replaceWith(call2)[0].get("arguments.0");
    }
    function getFunctionArity(node3) {
      const count = node3.params.findIndex((param) => isAssignmentPattern(param) || isRestElement(param));
      return count === -1 ? node3.params.length : count;
    }
  }
});

// node_modules/@babel/traverse/lib/path/introspection.js
var require_introspection = __commonJS({
  "node_modules/@babel/traverse/lib/path/introspection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;
    exports2._resolve = _resolve;
    exports2.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;
    exports2.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;
    exports2.getSource = getSource;
    exports2.isCompletionRecord = isCompletionRecord;
    exports2.isConstantExpression = isConstantExpression;
    exports2.isInStrictMode = isInStrictMode;
    exports2.isNodeType = isNodeType2;
    exports2.isStatementOrBlock = isStatementOrBlock;
    exports2.isStatic = isStatic;
    exports2.matchesPattern = matchesPattern;
    exports2.referencesImport = referencesImport;
    exports2.resolve = resolve8;
    exports2.willIMaybeExecuteBefore = willIMaybeExecuteBefore;
    var _t = require_lib3();
    var {
      STATEMENT_OR_BLOCK_KEYS,
      VISITOR_KEYS,
      isBlockStatement,
      isExpression,
      isIdentifier: isIdentifier2,
      isLiteral,
      isStringLiteral,
      isType,
      matchesPattern: _matchesPattern
    } = _t;
    function matchesPattern(pattern2, allowPartial) {
      return _matchesPattern(this.node, pattern2, allowPartial);
    }
    {
      exports2.has = function has(key) {
        var _this$node;
        const val = (_this$node = this.node) == null ? void 0 : _this$node[key];
        if (val && Array.isArray(val)) {
          return !!val.length;
        } else {
          return !!val;
        }
      };
    }
    function isStatic() {
      return this.scope.isStatic(this.node);
    }
    {
      exports2.is = exports2.has;
      exports2.isnt = function isnt(key) {
        return !this.has(key);
      };
      exports2.equals = function equals2(key, value2) {
        return this.node[key] === value2;
      };
    }
    function isNodeType2(type) {
      return isType(this.type, type);
    }
    function canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
    }
    function canSwapBetweenExpressionAndStatement(replacement) {
      if (this.key !== "body" || !this.parentPath.isArrowFunctionExpression()) {
        return false;
      }
      if (this.isExpression()) {
        return isBlockStatement(replacement);
      } else if (this.isBlockStatement()) {
        return isExpression(replacement);
      }
      return false;
    }
    function isCompletionRecord(allowInsideFunction) {
      let path9 = this;
      let first2 = true;
      do {
        const {
          type,
          container: container2
        } = path9;
        if (!first2 && (path9.isFunction() || type === "StaticBlock")) {
          return !!allowInsideFunction;
        }
        first2 = false;
        if (Array.isArray(container2) && path9.key !== container2.length - 1) {
          return false;
        }
      } while ((path9 = path9.parentPath) && !path9.isProgram() && !path9.isDoExpression());
      return true;
    }
    function isStatementOrBlock() {
      if (this.parentPath.isLabeledStatement() || isBlockStatement(this.container)) {
        return false;
      } else {
        return STATEMENT_OR_BLOCK_KEYS.includes(this.key);
      }
    }
    function referencesImport(moduleSource, importName) {
      if (!this.isReferencedIdentifier()) {
        if (this.isJSXMemberExpression() && this.node.property.name === importName || (this.isMemberExpression() || this.isOptionalMemberExpression()) && (this.node.computed ? isStringLiteral(this.node.property, {
          value: importName
        }) : this.node.property.name === importName)) {
          const object2 = this.get("object");
          return object2.isReferencedIdentifier() && object2.referencesImport(moduleSource, "*");
        }
        return false;
      }
      const binding = this.scope.getBinding(this.node.name);
      if (!binding || binding.kind !== "module") return false;
      const path9 = binding.path;
      const parent = path9.parentPath;
      if (!parent.isImportDeclaration()) return false;
      if (parent.node.source.value === moduleSource) {
        if (!importName) return true;
      } else {
        return false;
      }
      if (path9.isImportDefaultSpecifier() && importName === "default") {
        return true;
      }
      if (path9.isImportNamespaceSpecifier() && importName === "*") {
        return true;
      }
      if (path9.isImportSpecifier() && isIdentifier2(path9.node.imported, {
        name: importName
      })) {
        return true;
      }
      return false;
    }
    function getSource() {
      const node3 = this.node;
      if (node3.end) {
        const code = this.hub.getCode();
        if (code) return code.slice(node3.start, node3.end);
      }
      return "";
    }
    function willIMaybeExecuteBefore(target) {
      return this._guessExecutionStatusRelativeTo(target) !== "after";
    }
    function getOuterFunction(path9) {
      return path9.isProgram() ? path9 : (path9.parentPath.scope.getFunctionParent() || path9.parentPath.scope.getProgramParent()).path;
    }
    function isExecutionUncertain(type, key) {
      switch (type) {
        case "LogicalExpression":
          return key === "right";
        case "ConditionalExpression":
        case "IfStatement":
          return key === "consequent" || key === "alternate";
        case "WhileStatement":
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForOfStatement":
          return key === "body";
        case "ForStatement":
          return key === "body" || key === "update";
        case "SwitchStatement":
          return key === "cases";
        case "TryStatement":
          return key === "handler";
        case "AssignmentPattern":
          return key === "right";
        case "OptionalMemberExpression":
          return key === "property";
        case "OptionalCallExpression":
          return key === "arguments";
        default:
          return false;
      }
    }
    function isExecutionUncertainInList(paths, maxIndex) {
      for (let i = 0; i < maxIndex; i++) {
        const path9 = paths[i];
        if (isExecutionUncertain(path9.parent.type, path9.parentKey)) {
          return true;
        }
      }
      return false;
    }
    var SYMBOL_CHECKING = Symbol();
    function _guessExecutionStatusRelativeTo(target) {
      return _guessExecutionStatusRelativeToCached(this, target, /* @__PURE__ */ new Map());
    }
    function _guessExecutionStatusRelativeToCached(base, target, cache2) {
      const funcParent = {
        this: getOuterFunction(base),
        target: getOuterFunction(target)
      };
      if (funcParent.target.node !== funcParent.this.node) {
        return _guessExecutionStatusRelativeToDifferentFunctionsCached(base, funcParent.target, cache2);
      }
      const paths = {
        target: target.getAncestry(),
        this: base.getAncestry()
      };
      if (paths.target.includes(base)) return "after";
      if (paths.this.includes(target)) return "before";
      let commonPath;
      const commonIndex = {
        target: 0,
        this: 0
      };
      while (!commonPath && commonIndex.this < paths.this.length) {
        const path9 = paths.this[commonIndex.this];
        commonIndex.target = paths.target.indexOf(path9);
        if (commonIndex.target >= 0) {
          commonPath = path9;
        } else {
          commonIndex.this++;
        }
      }
      if (!commonPath) {
        throw new Error("Internal Babel error - The two compared nodes don't appear to belong to the same program.");
      }
      if (isExecutionUncertainInList(paths.this, commonIndex.this - 1) || isExecutionUncertainInList(paths.target, commonIndex.target - 1)) {
        return "unknown";
      }
      const divergence = {
        this: paths.this[commonIndex.this - 1],
        target: paths.target[commonIndex.target - 1]
      };
      if (divergence.target.listKey && divergence.this.listKey && divergence.target.container === divergence.this.container) {
        return divergence.target.key > divergence.this.key ? "before" : "after";
      }
      const keys = VISITOR_KEYS[commonPath.type];
      const keyPosition = {
        this: keys.indexOf(divergence.this.parentKey),
        target: keys.indexOf(divergence.target.parentKey)
      };
      return keyPosition.target > keyPosition.this ? "before" : "after";
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache2) {
      if (!target.isFunctionDeclaration()) {
        if (_guessExecutionStatusRelativeToCached(base, target, cache2) === "before") {
          return "before";
        }
        return "unknown";
      } else if (target.parentPath.isExportDeclaration()) {
        return "unknown";
      }
      const binding = target.scope.getBinding(target.node.id.name);
      if (!binding.references) return "before";
      const referencePaths = binding.referencePaths;
      let allStatus;
      for (const path9 of referencePaths) {
        const childOfFunction = !!path9.find((path10) => path10.node === target.node);
        if (childOfFunction) continue;
        if (path9.key !== "callee" || !path9.parentPath.isCallExpression()) {
          return "unknown";
        }
        const status2 = _guessExecutionStatusRelativeToCached(base, path9, cache2);
        if (allStatus && allStatus !== status2) {
          return "unknown";
        } else {
          allStatus = status2;
        }
      }
      return allStatus;
    }
    function _guessExecutionStatusRelativeToDifferentFunctionsCached(base, target, cache2) {
      let nodeMap = cache2.get(base.node);
      let cached;
      if (!nodeMap) {
        cache2.set(base.node, nodeMap = /* @__PURE__ */ new Map());
      } else if (cached = nodeMap.get(target.node)) {
        if (cached === SYMBOL_CHECKING) {
          return "unknown";
        }
        return cached;
      }
      nodeMap.set(target.node, SYMBOL_CHECKING);
      const result = _guessExecutionStatusRelativeToDifferentFunctionsInternal(base, target, cache2);
      nodeMap.set(target.node, result);
      return result;
    }
    function resolve8(dangerous, resolved) {
      return _resolve.call(this, dangerous, resolved) || this;
    }
    function _resolve(dangerous, resolved) {
      var _resolved;
      if ((_resolved = resolved) != null && _resolved.includes(this)) return;
      resolved = resolved || [];
      resolved.push(this);
      if (this.isVariableDeclarator()) {
        if (this.get("id").isIdentifier()) {
          return this.get("init").resolve(dangerous, resolved);
        } else {
        }
      } else if (this.isReferencedIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return;
        if (!binding.constant) return;
        if (binding.kind === "module") return;
        if (binding.path !== this) {
          const ret = binding.path.resolve(dangerous, resolved);
          if (this.find((parent) => parent.node === ret.node)) return;
          return ret;
        }
      } else if (this.isTypeCastExpression()) {
        return this.get("expression").resolve(dangerous, resolved);
      } else if (dangerous && this.isMemberExpression()) {
        const targetKey = this.toComputedKey();
        if (!isLiteral(targetKey)) return;
        const targetName = targetKey.value;
        const target = this.get("object").resolve(dangerous, resolved);
        if (target.isObjectExpression()) {
          const props = target.get("properties");
          for (const prop of props) {
            if (!prop.isProperty()) continue;
            const key = prop.get("key");
            let match2 = prop.isnt("computed") && key.isIdentifier({
              name: targetName
            });
            match2 = match2 || key.isLiteral({
              value: targetName
            });
            if (match2) return prop.get("value").resolve(dangerous, resolved);
          }
        } else if (target.isArrayExpression() && !isNaN(+targetName)) {
          const elems = target.get("elements");
          const elem = elems[targetName];
          if (elem) return elem.resolve(dangerous, resolved);
        }
      }
    }
    function isConstantExpression() {
      if (this.isIdentifier()) {
        const binding = this.scope.getBinding(this.node.name);
        if (!binding) return false;
        return binding.constant;
      }
      if (this.isLiteral()) {
        if (this.isRegExpLiteral()) {
          return false;
        }
        if (this.isTemplateLiteral()) {
          return this.get("expressions").every((expression) => expression.isConstantExpression());
        }
        return true;
      }
      if (this.isUnaryExpression()) {
        if (this.node.operator !== "void") {
          return false;
        }
        return this.get("argument").isConstantExpression();
      }
      if (this.isBinaryExpression()) {
        const {
          operator
        } = this.node;
        return operator !== "in" && operator !== "instanceof" && this.get("left").isConstantExpression() && this.get("right").isConstantExpression();
      }
      if (this.isMemberExpression()) {
        return !this.node.computed && this.get("object").isIdentifier({
          name: "Symbol"
        }) && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        });
      }
      if (this.isCallExpression()) {
        return this.node.arguments.length === 1 && this.get("callee").matchesPattern("Symbol.for") && !this.scope.hasBinding("Symbol", {
          noGlobals: true
        }) && this.get("arguments")[0].isStringLiteral();
      }
      return false;
    }
    function isInStrictMode() {
      const start = this.isProgram() ? this : this.parentPath;
      const strictParent = start.find((path9) => {
        if (path9.isProgram({
          sourceType: "module"
        })) return true;
        if (path9.isClass()) return true;
        if (path9.isArrowFunctionExpression() && !path9.get("body").isBlockStatement()) {
          return false;
        }
        let body;
        if (path9.isFunction()) {
          body = path9.node.body;
        } else if (path9.isProgram()) {
          body = path9.node;
        } else {
          return false;
        }
        for (const directive of body.directives) {
          if (directive.value.value === "use strict") {
            return true;
          }
        }
      });
      return !!strictParent;
    }
  }
});

// node_modules/@babel/traverse/lib/path/family.js
var require_family = __commonJS({
  "node_modules/@babel/traverse/lib/path/family.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._getKey = _getKey;
    exports2._getPattern = _getPattern;
    exports2.get = get;
    exports2.getAllNextSiblings = getAllNextSiblings;
    exports2.getAllPrevSiblings = getAllPrevSiblings;
    exports2.getAssignmentIdentifiers = getAssignmentIdentifiers;
    exports2.getBindingIdentifierPaths = getBindingIdentifierPaths;
    exports2.getBindingIdentifiers = getBindingIdentifiers;
    exports2.getCompletionRecords = getCompletionRecords;
    exports2.getNextSibling = getNextSibling;
    exports2.getOpposite = getOpposite;
    exports2.getOuterBindingIdentifierPaths = getOuterBindingIdentifierPaths;
    exports2.getOuterBindingIdentifiers = getOuterBindingIdentifiers;
    exports2.getPrevSibling = getPrevSibling;
    exports2.getSibling = getSibling;
    var _index = require_path();
    var _t = require_lib3();
    var {
      getAssignmentIdentifiers: _getAssignmentIdentifiers,
      getBindingIdentifiers: _getBindingIdentifiers,
      getOuterBindingIdentifiers: _getOuterBindingIdentifiers,
      numericLiteral,
      unaryExpression
    } = _t;
    var NORMAL_COMPLETION = 0;
    var BREAK_COMPLETION = 1;
    function NormalCompletion(path9) {
      return {
        type: NORMAL_COMPLETION,
        path: path9
      };
    }
    function BreakCompletion(path9) {
      return {
        type: BREAK_COMPLETION,
        path: path9
      };
    }
    function getOpposite() {
      if (this.key === "left") {
        return this.getSibling("right");
      } else if (this.key === "right") {
        return this.getSibling("left");
      }
      return null;
    }
    function addCompletionRecords(path9, records, context) {
      if (path9) {
        records.push(..._getCompletionRecords(path9, context));
      }
      return records;
    }
    function completionRecordForSwitch(cases, records, context) {
      let lastNormalCompletions = [];
      for (let i = 0; i < cases.length; i++) {
        const casePath = cases[i];
        const caseCompletions = _getCompletionRecords(casePath, context);
        const normalCompletions = [];
        const breakCompletions = [];
        for (const c of caseCompletions) {
          if (c.type === NORMAL_COMPLETION) {
            normalCompletions.push(c);
          }
          if (c.type === BREAK_COMPLETION) {
            breakCompletions.push(c);
          }
        }
        if (normalCompletions.length) {
          lastNormalCompletions = normalCompletions;
        }
        records.push(...breakCompletions);
      }
      records.push(...lastNormalCompletions);
      return records;
    }
    function normalCompletionToBreak(completions) {
      completions.forEach((c) => {
        c.type = BREAK_COMPLETION;
      });
    }
    function replaceBreakStatementInBreakCompletion(completions, reachable) {
      completions.forEach((c) => {
        if (c.path.isBreakStatement({
          label: null
        })) {
          if (reachable) {
            c.path.replaceWith(unaryExpression("void", numericLiteral(0)));
          } else {
            c.path.remove();
          }
        }
      });
    }
    function getStatementListCompletion(paths, context) {
      const completions = [];
      if (context.canHaveBreak) {
        let lastNormalCompletions = [];
        for (let i = 0; i < paths.length; i++) {
          const path9 = paths[i];
          const newContext = Object.assign({}, context, {
            inCaseClause: false
          });
          if (path9.isBlockStatement() && (context.inCaseClause || context.shouldPopulateBreak)) {
            newContext.shouldPopulateBreak = true;
          } else {
            newContext.shouldPopulateBreak = false;
          }
          const statementCompletions = _getCompletionRecords(path9, newContext);
          if (statementCompletions.length > 0 && statementCompletions.every((c) => c.type === BREAK_COMPLETION)) {
            if (lastNormalCompletions.length > 0 && statementCompletions.every((c) => c.path.isBreakStatement({
              label: null
            }))) {
              normalCompletionToBreak(lastNormalCompletions);
              completions.push(...lastNormalCompletions);
              if (lastNormalCompletions.some((c) => c.path.isDeclaration())) {
                completions.push(...statementCompletions);
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
              replaceBreakStatementInBreakCompletion(statementCompletions, false);
            } else {
              completions.push(...statementCompletions);
              if (!context.shouldPopulateBreak) {
                replaceBreakStatementInBreakCompletion(statementCompletions, true);
              }
            }
            break;
          }
          if (i === paths.length - 1) {
            completions.push(...statementCompletions);
          } else {
            lastNormalCompletions = [];
            for (let i2 = 0; i2 < statementCompletions.length; i2++) {
              const c = statementCompletions[i2];
              if (c.type === BREAK_COMPLETION) {
                completions.push(c);
              }
              if (c.type === NORMAL_COMPLETION) {
                lastNormalCompletions.push(c);
              }
            }
          }
        }
      } else if (paths.length) {
        for (let i = paths.length - 1; i >= 0; i--) {
          const pathCompletions = _getCompletionRecords(paths[i], context);
          if (pathCompletions.length > 1 || pathCompletions.length === 1 && !pathCompletions[0].path.isVariableDeclaration()) {
            completions.push(...pathCompletions);
            break;
          }
        }
      }
      return completions;
    }
    function _getCompletionRecords(path9, context) {
      let records = [];
      if (path9.isIfStatement()) {
        records = addCompletionRecords(path9.get("consequent"), records, context);
        records = addCompletionRecords(path9.get("alternate"), records, context);
      } else if (path9.isDoExpression() || path9.isFor() || path9.isWhile() || path9.isLabeledStatement()) {
        return addCompletionRecords(path9.get("body"), records, context);
      } else if (path9.isProgram() || path9.isBlockStatement()) {
        return getStatementListCompletion(path9.get("body"), context);
      } else if (path9.isFunction()) {
        return _getCompletionRecords(path9.get("body"), context);
      } else if (path9.isTryStatement()) {
        records = addCompletionRecords(path9.get("block"), records, context);
        records = addCompletionRecords(path9.get("handler"), records, context);
      } else if (path9.isCatchClause()) {
        return addCompletionRecords(path9.get("body"), records, context);
      } else if (path9.isSwitchStatement()) {
        return completionRecordForSwitch(path9.get("cases"), records, context);
      } else if (path9.isSwitchCase()) {
        return getStatementListCompletion(path9.get("consequent"), {
          canHaveBreak: true,
          shouldPopulateBreak: false,
          inCaseClause: true
        });
      } else if (path9.isBreakStatement()) {
        records.push(BreakCompletion(path9));
      } else {
        records.push(NormalCompletion(path9));
      }
      return records;
    }
    function getCompletionRecords() {
      const records = _getCompletionRecords(this, {
        canHaveBreak: false,
        shouldPopulateBreak: false,
        inCaseClause: false
      });
      return records.map((r) => r.path);
    }
    function getSibling(key) {
      return _index.default.get({
        parentPath: this.parentPath,
        parent: this.parent,
        container: this.container,
        listKey: this.listKey,
        key
      }).setContext(this.context);
    }
    function getPrevSibling() {
      return this.getSibling(this.key - 1);
    }
    function getNextSibling() {
      return this.getSibling(this.key + 1);
    }
    function getAllNextSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(++_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(++_key);
      }
      return siblings;
    }
    function getAllPrevSiblings() {
      let _key = this.key;
      let sibling = this.getSibling(--_key);
      const siblings = [];
      while (sibling.node) {
        siblings.push(sibling);
        sibling = this.getSibling(--_key);
      }
      return siblings;
    }
    function get(key, context = true) {
      if (context === true) context = this.context;
      const parts = key.split(".");
      if (parts.length === 1) {
        return _getKey.call(this, key, context);
      } else {
        return _getPattern.call(this, parts, context);
      }
    }
    function _getKey(key, context) {
      const node3 = this.node;
      const container2 = node3[key];
      if (Array.isArray(container2)) {
        return container2.map((_, i) => {
          return _index.default.get({
            listKey: key,
            parentPath: this,
            parent: node3,
            container: container2,
            key: i
          }).setContext(context);
        });
      } else {
        return _index.default.get({
          parentPath: this,
          parent: node3,
          container: node3,
          key
        }).setContext(context);
      }
    }
    function _getPattern(parts, context) {
      let path9 = this;
      for (const part of parts) {
        if (part === ".") {
          path9 = path9.parentPath;
        } else {
          if (Array.isArray(path9)) {
            path9 = path9[part];
          } else {
            path9 = path9.get(part, context);
          }
        }
      }
      return path9;
    }
    function getAssignmentIdentifiers() {
      return _getAssignmentIdentifiers(this.node);
    }
    function getBindingIdentifiers(duplicates) {
      return _getBindingIdentifiers(this.node, duplicates);
    }
    function getOuterBindingIdentifiers(duplicates) {
      return _getOuterBindingIdentifiers(this.node, duplicates);
    }
    function getBindingIdentifierPaths(duplicates = false, outerOnly = false) {
      const path9 = this;
      const search = [path9];
      const ids = /* @__PURE__ */ Object.create(null);
      while (search.length) {
        const id3 = search.shift();
        if (!id3) continue;
        if (!id3.node) continue;
        const keys = _getBindingIdentifiers.keys[id3.node.type];
        if (id3.isIdentifier()) {
          if (duplicates) {
            const _ids = ids[id3.node.name] = ids[id3.node.name] || [];
            _ids.push(id3);
          } else {
            ids[id3.node.name] = id3;
          }
          continue;
        }
        if (id3.isExportDeclaration()) {
          const declaration = id3.get("declaration");
          if (declaration.isDeclaration()) {
            search.push(declaration);
          }
          continue;
        }
        if (outerOnly) {
          if (id3.isFunctionDeclaration()) {
            search.push(id3.get("id"));
            continue;
          }
          if (id3.isFunctionExpression()) {
            continue;
          }
        }
        if (keys) {
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const child = id3.get(key);
            if (Array.isArray(child)) {
              search.push(...child);
            } else if (child.node) {
              search.push(child);
            }
          }
        }
      }
      return ids;
    }
    function getOuterBindingIdentifierPaths(duplicates = false) {
      return this.getBindingIdentifierPaths(duplicates, true);
    }
  }
});

// node_modules/@babel/traverse/lib/path/comments.js
var require_comments = __commonJS({
  "node_modules/@babel/traverse/lib/path/comments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addComment = addComment;
    exports2.addComments = addComments;
    exports2.shareCommentsWithSiblings = shareCommentsWithSiblings;
    var _t = require_lib3();
    var {
      addComment: _addComment,
      addComments: _addComments
    } = _t;
    function shareCommentsWithSiblings() {
      if (typeof this.key === "string") return;
      const node3 = this.node;
      if (!node3) return;
      const trailing = node3.trailingComments;
      const leading = node3.leadingComments;
      if (!trailing && !leading) return;
      const prev = this.getSibling(this.key - 1);
      const next = this.getSibling(this.key + 1);
      const hasPrev = Boolean(prev.node);
      const hasNext = Boolean(next.node);
      if (hasPrev) {
        if (leading) {
          prev.addComments("trailing", removeIfExisting(leading, prev.node.trailingComments));
        }
        if (trailing && !hasNext) prev.addComments("trailing", trailing);
      }
      if (hasNext) {
        if (trailing) {
          next.addComments("leading", removeIfExisting(trailing, next.node.leadingComments));
        }
        if (leading && !hasPrev) next.addComments("leading", leading);
      }
    }
    function removeIfExisting(list2, toRemove) {
      if (!(toRemove != null && toRemove.length)) return list2;
      const set2 = new Set(toRemove);
      return list2.filter((el) => {
        return !set2.has(el);
      });
    }
    function addComment(type, content, line) {
      _addComment(this.node, type, content, line);
    }
    function addComments(type, comments) {
      _addComments(this.node, type, comments);
    }
  }
});

// node_modules/@babel/traverse/lib/path/index.js
var require_path = __commonJS({
  "node_modules/@babel/traverse/lib/path/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = exports2.SHOULD_STOP = exports2.SHOULD_SKIP = exports2.REMOVED = void 0;
    var virtualTypes = require_virtual_types();
    var _debug2 = require_src();
    var _index = require_lib9();
    var _index2 = require_scope();
    var _t = require_lib3();
    var t = _t;
    var cache2 = require_cache();
    var _generator = require_lib8();
    var NodePath_ancestry = require_ancestry();
    var NodePath_inference = require_inference();
    var NodePath_replacement = require_replacement();
    var NodePath_evaluation = require_evaluation();
    var NodePath_conversion = require_conversion();
    var NodePath_introspection = require_introspection();
    var _context = require_context2();
    var NodePath_context = _context;
    var NodePath_removal = require_removal();
    var NodePath_modification = require_modification();
    var NodePath_family = require_family();
    var NodePath_comments = require_comments();
    var NodePath_virtual_types_validator = require_virtual_types_validator();
    var {
      validate
    } = _t;
    var debug2 = _debug2("babel");
    var REMOVED = exports2.REMOVED = 1 << 0;
    var SHOULD_STOP = exports2.SHOULD_STOP = 1 << 1;
    var SHOULD_SKIP = exports2.SHOULD_SKIP = 1 << 2;
    var NodePath_Final = exports2.default = class NodePath {
      constructor(hub, parent) {
        this.contexts = [];
        this.state = null;
        this.opts = null;
        this._traverseFlags = 0;
        this.skipKeys = null;
        this.parentPath = null;
        this.container = null;
        this.listKey = null;
        this.key = null;
        this.node = null;
        this.type = null;
        this.parent = parent;
        this.hub = hub;
        this.data = null;
        this.context = null;
        this.scope = null;
      }
      get removed() {
        return (this._traverseFlags & 1) > 0;
      }
      set removed(v) {
        if (v) this._traverseFlags |= 1;
        else this._traverseFlags &= -2;
      }
      get shouldStop() {
        return (this._traverseFlags & 2) > 0;
      }
      set shouldStop(v) {
        if (v) this._traverseFlags |= 2;
        else this._traverseFlags &= -3;
      }
      get shouldSkip() {
        return (this._traverseFlags & 4) > 0;
      }
      set shouldSkip(v) {
        if (v) this._traverseFlags |= 4;
        else this._traverseFlags &= -5;
      }
      static get({
        hub,
        parentPath,
        parent,
        container: container2,
        listKey,
        key
      }) {
        if (!hub && parentPath) {
          hub = parentPath.hub;
        }
        if (!parent) {
          throw new Error("To get a node path the parent needs to exist");
        }
        const targetNode = container2[key];
        const paths = cache2.getOrCreateCachedPaths(hub, parent);
        let path9 = paths.get(targetNode);
        if (!path9) {
          path9 = new NodePath(hub, parent);
          if (targetNode) paths.set(targetNode, path9);
        }
        _context.setup.call(path9, parentPath, container2, listKey, key);
        return path9;
      }
      getScope(scope) {
        return this.isScope() ? new _index2.default(this) : scope;
      }
      setData(key, val) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        return this.data[key] = val;
      }
      getData(key, def) {
        if (this.data == null) {
          this.data = /* @__PURE__ */ Object.create(null);
        }
        let val = this.data[key];
        if (val === void 0 && def !== void 0) val = this.data[key] = def;
        return val;
      }
      hasNode() {
        return this.node != null;
      }
      buildCodeFrameError(msg, Error2 = SyntaxError) {
        return this.hub.buildError(this.node, msg, Error2);
      }
      traverse(visitor, state) {
        (0, _index.default)(this.node, visitor, this.scope, state, this);
      }
      set(key, node3) {
        validate(this.node, key, node3);
        this.node[key] = node3;
      }
      getPathLocation() {
        const parts = [];
        let path9 = this;
        do {
          let key = path9.key;
          if (path9.inList) key = `${path9.listKey}[${key}]`;
          parts.unshift(key);
        } while (path9 = path9.parentPath);
        return parts.join(".");
      }
      debug(message) {
        if (!debug2.enabled) return;
        debug2(`${this.getPathLocation()} ${this.type}: ${message}`);
      }
      toString() {
        return (0, _generator.default)(this.node).code;
      }
      get inList() {
        return !!this.listKey;
      }
      set inList(inList) {
        if (!inList) {
          this.listKey = null;
        }
      }
      get parentKey() {
        return this.listKey || this.key;
      }
    };
    var methods = {
      findParent: NodePath_ancestry.findParent,
      find: NodePath_ancestry.find,
      getFunctionParent: NodePath_ancestry.getFunctionParent,
      getStatementParent: NodePath_ancestry.getStatementParent,
      getEarliestCommonAncestorFrom: NodePath_ancestry.getEarliestCommonAncestorFrom,
      getDeepestCommonAncestorFrom: NodePath_ancestry.getDeepestCommonAncestorFrom,
      getAncestry: NodePath_ancestry.getAncestry,
      isAncestor: NodePath_ancestry.isAncestor,
      isDescendant: NodePath_ancestry.isDescendant,
      inType: NodePath_ancestry.inType,
      getTypeAnnotation: NodePath_inference.getTypeAnnotation,
      isBaseType: NodePath_inference.isBaseType,
      couldBeBaseType: NodePath_inference.couldBeBaseType,
      baseTypeStrictlyMatches: NodePath_inference.baseTypeStrictlyMatches,
      isGenericType: NodePath_inference.isGenericType,
      replaceWithMultiple: NodePath_replacement.replaceWithMultiple,
      replaceWithSourceString: NodePath_replacement.replaceWithSourceString,
      replaceWith: NodePath_replacement.replaceWith,
      replaceExpressionWithStatements: NodePath_replacement.replaceExpressionWithStatements,
      replaceInline: NodePath_replacement.replaceInline,
      evaluateTruthy: NodePath_evaluation.evaluateTruthy,
      evaluate: NodePath_evaluation.evaluate,
      toComputedKey: NodePath_conversion.toComputedKey,
      ensureBlock: NodePath_conversion.ensureBlock,
      unwrapFunctionEnvironment: NodePath_conversion.unwrapFunctionEnvironment,
      arrowFunctionToExpression: NodePath_conversion.arrowFunctionToExpression,
      splitExportDeclaration: NodePath_conversion.splitExportDeclaration,
      ensureFunctionName: NodePath_conversion.ensureFunctionName,
      matchesPattern: NodePath_introspection.matchesPattern,
      isStatic: NodePath_introspection.isStatic,
      isNodeType: NodePath_introspection.isNodeType,
      canHaveVariableDeclarationOrExpression: NodePath_introspection.canHaveVariableDeclarationOrExpression,
      canSwapBetweenExpressionAndStatement: NodePath_introspection.canSwapBetweenExpressionAndStatement,
      isCompletionRecord: NodePath_introspection.isCompletionRecord,
      isStatementOrBlock: NodePath_introspection.isStatementOrBlock,
      referencesImport: NodePath_introspection.referencesImport,
      getSource: NodePath_introspection.getSource,
      willIMaybeExecuteBefore: NodePath_introspection.willIMaybeExecuteBefore,
      _guessExecutionStatusRelativeTo: NodePath_introspection._guessExecutionStatusRelativeTo,
      resolve: NodePath_introspection.resolve,
      isConstantExpression: NodePath_introspection.isConstantExpression,
      isInStrictMode: NodePath_introspection.isInStrictMode,
      isDenylisted: NodePath_context.isDenylisted,
      visit: NodePath_context.visit,
      skip: NodePath_context.skip,
      skipKey: NodePath_context.skipKey,
      stop: NodePath_context.stop,
      setContext: NodePath_context.setContext,
      requeue: NodePath_context.requeue,
      requeueComputedKeyAndDecorators: NodePath_context.requeueComputedKeyAndDecorators,
      remove: NodePath_removal.remove,
      insertBefore: NodePath_modification.insertBefore,
      insertAfter: NodePath_modification.insertAfter,
      unshiftContainer: NodePath_modification.unshiftContainer,
      pushContainer: NodePath_modification.pushContainer,
      getOpposite: NodePath_family.getOpposite,
      getCompletionRecords: NodePath_family.getCompletionRecords,
      getSibling: NodePath_family.getSibling,
      getPrevSibling: NodePath_family.getPrevSibling,
      getNextSibling: NodePath_family.getNextSibling,
      getAllNextSiblings: NodePath_family.getAllNextSiblings,
      getAllPrevSiblings: NodePath_family.getAllPrevSiblings,
      get: NodePath_family.get,
      getAssignmentIdentifiers: NodePath_family.getAssignmentIdentifiers,
      getBindingIdentifiers: NodePath_family.getBindingIdentifiers,
      getOuterBindingIdentifiers: NodePath_family.getOuterBindingIdentifiers,
      getBindingIdentifierPaths: NodePath_family.getBindingIdentifierPaths,
      getOuterBindingIdentifierPaths: NodePath_family.getOuterBindingIdentifierPaths,
      shareCommentsWithSiblings: NodePath_comments.shareCommentsWithSiblings,
      addComment: NodePath_comments.addComment,
      addComments: NodePath_comments.addComments
    };
    Object.assign(NodePath_Final.prototype, methods);
    {
      NodePath_Final.prototype.arrowFunctionToShadowed = NodePath_conversion[String("arrowFunctionToShadowed")];
      Object.assign(NodePath_Final.prototype, {
        has: NodePath_introspection[String("has")],
        is: NodePath_introspection[String("is")],
        isnt: NodePath_introspection[String("isnt")],
        equals: NodePath_introspection[String("equals")],
        hoist: NodePath_modification[String("hoist")],
        updateSiblingKeys: NodePath_modification.updateSiblingKeys,
        call: NodePath_context.call,
        isBlacklisted: NodePath_context[String("isBlacklisted")],
        setScope: NodePath_context.setScope,
        resync: NodePath_context.resync,
        popContext: NodePath_context.popContext,
        pushContext: NodePath_context.pushContext,
        setup: NodePath_context.setup,
        setKey: NodePath_context.setKey
      });
    }
    {
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      NodePath_Final.prototype._guessExecutionStatusRelativeToDifferentFunctions = NodePath_introspection._guessExecutionStatusRelativeTo;
      Object.assign(NodePath_Final.prototype, {
        _getTypeAnnotation: NodePath_inference._getTypeAnnotation,
        _replaceWith: NodePath_replacement._replaceWith,
        _resolve: NodePath_introspection._resolve,
        _call: NodePath_context._call,
        _resyncParent: NodePath_context._resyncParent,
        _resyncKey: NodePath_context._resyncKey,
        _resyncList: NodePath_context._resyncList,
        _resyncRemoved: NodePath_context._resyncRemoved,
        _getQueueContexts: NodePath_context._getQueueContexts,
        _removeFromScope: NodePath_removal._removeFromScope,
        _callRemovalHooks: NodePath_removal._callRemovalHooks,
        _remove: NodePath_removal._remove,
        _markRemoved: NodePath_removal._markRemoved,
        _assertUnremoved: NodePath_removal._assertUnremoved,
        _containerInsert: NodePath_modification._containerInsert,
        _containerInsertBefore: NodePath_modification._containerInsertBefore,
        _containerInsertAfter: NodePath_modification._containerInsertAfter,
        _verifyNodeList: NodePath_modification._verifyNodeList,
        _getKey: NodePath_family._getKey,
        _getPattern: NodePath_family._getPattern
      });
    }
    for (const type of t.TYPES) {
      const typeKey = `is${type}`;
      const fn = t[typeKey];
      NodePath_Final.prototype[typeKey] = function(opts) {
        return fn(this.node, opts);
      };
      NodePath_Final.prototype[`assert${type}`] = function(opts) {
        if (!fn(this.node, opts)) {
          throw new TypeError(`Expected node path of type ${type}`);
        }
      };
    }
    Object.assign(NodePath_Final.prototype, NodePath_virtual_types_validator);
    for (const type of Object.keys(virtualTypes)) {
      if (type[0] === "_") continue;
      if (!t.TYPES.includes(type)) t.TYPES.push(type);
    }
  }
});

// node_modules/@babel/traverse/lib/context.js
var require_context = __commonJS({
  "node_modules/@babel/traverse/lib/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _index = require_path();
    var _t = require_lib3();
    var _context = require_context2();
    var {
      VISITOR_KEYS
    } = _t;
    var TraversalContext = class {
      constructor(scope, opts, state, parentPath) {
        this.queue = null;
        this.priorityQueue = null;
        this.parentPath = parentPath;
        this.scope = scope;
        this.state = state;
        this.opts = opts;
      }
      shouldVisit(node3) {
        const opts = this.opts;
        if (opts.enter || opts.exit) return true;
        if (opts[node3.type]) return true;
        const keys = VISITOR_KEYS[node3.type];
        if (!(keys != null && keys.length)) return false;
        for (const key of keys) {
          if (node3[key]) {
            return true;
          }
        }
        return false;
      }
      create(node3, container2, key, listKey) {
        return _index.default.get({
          parentPath: this.parentPath,
          parent: node3,
          container: container2,
          key,
          listKey
        });
      }
      maybeQueue(path9, notPriority) {
        if (this.queue) {
          if (notPriority) {
            this.queue.push(path9);
          } else {
            this.priorityQueue.push(path9);
          }
        }
      }
      visitMultiple(container2, parent, listKey) {
        if (container2.length === 0) return false;
        const queue2 = [];
        for (let key = 0; key < container2.length; key++) {
          const node3 = container2[key];
          if (node3 && this.shouldVisit(node3)) {
            queue2.push(this.create(parent, container2, key, listKey));
          }
        }
        return this.visitQueue(queue2);
      }
      visitSingle(node3, key) {
        if (this.shouldVisit(node3[key])) {
          return this.visitQueue([this.create(node3, node3, key)]);
        } else {
          return false;
        }
      }
      visitQueue(queue2) {
        this.queue = queue2;
        this.priorityQueue = [];
        const visited = /* @__PURE__ */ new WeakSet();
        let stop = false;
        let visitIndex = 0;
        for (; visitIndex < queue2.length; ) {
          const path9 = queue2[visitIndex];
          visitIndex++;
          _context.resync.call(path9);
          if (path9.contexts.length === 0 || path9.contexts[path9.contexts.length - 1] !== this) {
            _context.pushContext.call(path9, this);
          }
          if (path9.key === null) continue;
          const {
            node: node3
          } = path9;
          if (visited.has(node3)) continue;
          if (node3) visited.add(node3);
          if (path9.visit()) {
            stop = true;
            break;
          }
          if (this.priorityQueue.length) {
            stop = this.visitQueue(this.priorityQueue);
            this.priorityQueue = [];
            this.queue = queue2;
            if (stop) break;
          }
        }
        for (let i = 0; i < visitIndex; i++) {
          _context.popContext.call(queue2[i]);
        }
        this.queue = null;
        return stop;
      }
      visit(node3, key) {
        const nodes = node3[key];
        if (!nodes) return false;
        if (Array.isArray(nodes)) {
          return this.visitMultiple(nodes, node3, key);
        } else {
          return this.visitSingle(node3, key);
        }
      }
    };
    exports2.default = TraversalContext;
  }
});

// node_modules/@babel/traverse/lib/traverse-node.js
var require_traverse_node = __commonJS({
  "node_modules/@babel/traverse/lib/traverse-node.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.traverseNode = traverseNode;
    var _context = require_context();
    var _t = require_lib3();
    var {
      VISITOR_KEYS
    } = _t;
    function traverseNode(node3, opts, scope, state, path9, skipKeys, visitSelf) {
      const keys = VISITOR_KEYS[node3.type];
      if (!keys) return false;
      const context = new _context.default(scope, opts, state, path9);
      if (visitSelf) {
        if (skipKeys != null && skipKeys[path9.parentKey]) return false;
        return context.visitQueue([path9]);
      }
      for (const key of keys) {
        if (skipKeys != null && skipKeys[key]) continue;
        if (context.visit(node3, key)) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/@babel/traverse/lib/path/context.js
var require_context2 = __commonJS({
  "node_modules/@babel/traverse/lib/path/context.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2._call = _call;
    exports2._getQueueContexts = _getQueueContexts;
    exports2._resyncKey = _resyncKey;
    exports2._resyncList = _resyncList;
    exports2._resyncParent = _resyncParent;
    exports2._resyncRemoved = _resyncRemoved;
    exports2.call = call2;
    exports2.isDenylisted = isDenylisted;
    exports2.popContext = popContext;
    exports2.pushContext = pushContext;
    exports2.requeue = requeue;
    exports2.requeueComputedKeyAndDecorators = requeueComputedKeyAndDecorators;
    exports2.resync = resync;
    exports2.setContext = setContext;
    exports2.setKey = setKey;
    exports2.setScope = setScope;
    exports2.setup = setup;
    exports2.skip = skip;
    exports2.skipKey = skipKey;
    exports2.stop = stop;
    exports2.visit = visit2;
    var _traverseNode = require_traverse_node();
    var _index = require_path();
    var _removal = require_removal();
    var t = require_lib3();
    function call2(key) {
      const opts = this.opts;
      this.debug(key);
      if (this.node) {
        if (_call.call(this, opts[key])) return true;
      }
      if (this.node) {
        var _opts$this$node$type;
        return _call.call(this, (_opts$this$node$type = opts[this.node.type]) == null ? void 0 : _opts$this$node$type[key]);
      }
      return false;
    }
    function _call(fns) {
      if (!fns) return false;
      for (const fn of fns) {
        if (!fn) continue;
        const node3 = this.node;
        if (!node3) return true;
        const ret = fn.call(this.state, this, this.state);
        if (ret && typeof ret === "object" && typeof ret.then === "function") {
          throw new Error(`You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
        if (ret) {
          throw new Error(`Unexpected return value from visitor method ${fn}`);
        }
        if (this.node !== node3) return true;
        if (this._traverseFlags > 0) return true;
      }
      return false;
    }
    function isDenylisted() {
      var _this$opts$denylist;
      const denylist = (_this$opts$denylist = this.opts.denylist) != null ? _this$opts$denylist : this.opts.blacklist;
      return denylist == null ? void 0 : denylist.includes(this.node.type);
    }
    {
      exports2.isBlacklisted = isDenylisted;
    }
    function restoreContext(path9, context) {
      if (path9.context !== context) {
        path9.context = context;
        path9.state = context.state;
        path9.opts = context.opts;
      }
    }
    function visit2() {
      var _this$opts$shouldSkip, _this$opts;
      if (!this.node) {
        return false;
      }
      if (this.isDenylisted()) {
        return false;
      }
      if ((_this$opts$shouldSkip = (_this$opts = this.opts).shouldSkip) != null && _this$opts$shouldSkip.call(_this$opts, this)) {
        return false;
      }
      const currentContext = this.context;
      if (this.shouldSkip || call2.call(this, "enter")) {
        this.debug("Skip...");
        return this.shouldStop;
      }
      restoreContext(this, currentContext);
      this.debug("Recursing into...");
      this.shouldStop = (0, _traverseNode.traverseNode)(this.node, this.opts, this.scope, this.state, this, this.skipKeys);
      restoreContext(this, currentContext);
      call2.call(this, "exit");
      return this.shouldStop;
    }
    function skip() {
      this.shouldSkip = true;
    }
    function skipKey(key) {
      if (this.skipKeys == null) {
        this.skipKeys = {};
      }
      this.skipKeys[key] = true;
    }
    function stop() {
      this._traverseFlags |= _index.SHOULD_SKIP | _index.SHOULD_STOP;
    }
    function setScope() {
      var _this$opts2, _this$scope;
      if ((_this$opts2 = this.opts) != null && _this$opts2.noScope) return;
      let path9 = this.parentPath;
      if ((this.key === "key" || this.listKey === "decorators") && path9.isMethod() || this.key === "discriminant" && path9.isSwitchStatement()) {
        path9 = path9.parentPath;
      }
      let target;
      while (path9 && !target) {
        var _path$opts;
        if ((_path$opts = path9.opts) != null && _path$opts.noScope) return;
        target = path9.scope;
        path9 = path9.parentPath;
      }
      this.scope = this.getScope(target);
      (_this$scope = this.scope) == null || _this$scope.init();
    }
    function setContext(context) {
      if (this.skipKeys != null) {
        this.skipKeys = {};
      }
      this._traverseFlags = 0;
      if (context) {
        this.context = context;
        this.state = context.state;
        this.opts = context.opts;
      }
      setScope.call(this);
      return this;
    }
    function resync() {
      if (this.removed) return;
      _resyncParent.call(this);
      _resyncList.call(this);
      _resyncKey.call(this);
    }
    function _resyncParent() {
      if (this.parentPath) {
        this.parent = this.parentPath.node;
      }
    }
    function _resyncKey() {
      if (!this.container) return;
      if (this.node === this.container[this.key]) {
        return;
      }
      if (Array.isArray(this.container)) {
        for (let i = 0; i < this.container.length; i++) {
          if (this.container[i] === this.node) {
            setKey.call(this, i);
            return;
          }
        }
      } else {
        for (const key of Object.keys(this.container)) {
          if (this.container[key] === this.node) {
            setKey.call(this, key);
            return;
          }
        }
      }
      this.key = null;
    }
    function _resyncList() {
      if (!this.parent || !this.inList) return;
      const newContainer = this.parent[this.listKey];
      if (this.container === newContainer) return;
      this.container = newContainer || null;
    }
    function _resyncRemoved() {
      if (this.key == null || !this.container || this.container[this.key] !== this.node) {
        _removal._markRemoved.call(this);
      }
    }
    function popContext() {
      this.contexts.pop();
      if (this.contexts.length > 0) {
        this.setContext(this.contexts[this.contexts.length - 1]);
      } else {
        this.setContext(void 0);
      }
    }
    function pushContext(context) {
      this.contexts.push(context);
      this.setContext(context);
    }
    function setup(parentPath, container2, listKey, key) {
      this.listKey = listKey;
      this.container = container2;
      this.parentPath = parentPath || this.parentPath;
      setKey.call(this, key);
    }
    function setKey(key) {
      var _this$node;
      this.key = key;
      this.node = this.container[this.key];
      this.type = (_this$node = this.node) == null ? void 0 : _this$node.type;
    }
    function requeue(pathToQueue = this) {
      if (pathToQueue.removed) return;
      ;
      const contexts = this.contexts;
      for (const context of contexts) {
        context.maybeQueue(pathToQueue);
      }
    }
    function requeueComputedKeyAndDecorators() {
      const {
        context,
        node: node3
      } = this;
      if (!t.isPrivate(node3) && node3.computed) {
        context.maybeQueue(this.get("key"));
      }
      if (node3.decorators) {
        for (const decorator of this.get("decorators")) {
          context.maybeQueue(decorator);
        }
      }
    }
    function _getQueueContexts() {
      let path9 = this;
      let contexts = this.contexts;
      while (!contexts.length) {
        path9 = path9.parentPath;
        if (!path9) break;
        contexts = path9.contexts;
      }
      return contexts;
    }
  }
});

// node_modules/@babel/traverse/lib/hub.js
var require_hub = __commonJS({
  "node_modules/@babel/traverse/lib/hub.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var Hub = class {
      getCode() {
      }
      getScope() {
      }
      addHelper() {
        throw new Error("Helpers are not supported by the default hub.");
      }
      buildError(node3, msg, Error2 = TypeError) {
        return new Error2(msg);
      }
    };
    exports2.default = Hub;
  }
});

// node_modules/@babel/traverse/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/@babel/traverse/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "Hub", {
      enumerable: true,
      get: function() {
        return _hub.default;
      }
    });
    Object.defineProperty(exports2, "NodePath", {
      enumerable: true,
      get: function() {
        return _index.default;
      }
    });
    Object.defineProperty(exports2, "Scope", {
      enumerable: true,
      get: function() {
        return _index2.default;
      }
    });
    exports2.visitors = exports2.default = void 0;
    require_context2();
    var visitors = require_visitors();
    exports2.visitors = visitors;
    var _t = require_lib3();
    var cache2 = require_cache();
    var _traverseNode = require_traverse_node();
    var _index = require_path();
    var _index2 = require_scope();
    var _hub = require_hub();
    var {
      VISITOR_KEYS,
      removeProperties,
      traverseFast
    } = _t;
    function traverse(parent, opts = {}, scope, state, parentPath, visitSelf) {
      if (!parent) return;
      if (!opts.noScope && !scope) {
        if (parent.type !== "Program" && parent.type !== "File") {
          throw new Error(`You must pass a scope and parentPath unless traversing a Program/File. Instead of that you tried to traverse a ${parent.type} node without passing scope and parentPath.`);
        }
      }
      if (!parentPath && visitSelf) {
        throw new Error("visitSelf can only be used when providing a NodePath.");
      }
      if (!VISITOR_KEYS[parent.type]) {
        return;
      }
      visitors.explode(opts);
      (0, _traverseNode.traverseNode)(parent, opts, scope, state, parentPath, null, visitSelf);
    }
    var _default = exports2.default = traverse;
    traverse.visitors = visitors;
    traverse.verify = visitors.verify;
    traverse.explode = visitors.explode;
    traverse.cheap = function(node3, enter) {
      traverseFast(node3, enter);
      return;
    };
    traverse.node = function(node3, opts, scope, state, path9, skipKeys) {
      (0, _traverseNode.traverseNode)(node3, opts, scope, state, path9, skipKeys);
    };
    traverse.clearNode = function(node3, opts) {
      removeProperties(node3, opts);
    };
    traverse.removeProperties = function(tree, opts) {
      traverseFast(tree, traverse.clearNode, opts);
      return tree;
    };
    function hasDenylistedType(path9, state) {
      if (path9.node.type === state.type) {
        state.has = true;
        path9.stop();
      }
    }
    traverse.hasType = function(tree, type, denylistTypes) {
      if (denylistTypes != null && denylistTypes.includes(tree.type)) return false;
      if (tree.type === type) return true;
      const state = {
        has: false,
        type
      };
      traverse(tree, {
        noScope: true,
        denylist: denylistTypes,
        enter: hasDenylistedType
      }, null, state);
      return state.has;
    };
    traverse.cache = cache2;
  }
});

// node_modules/semver/semver.js
var require_semver = __commonJS({
  "node_modules/semver/semver.js"(exports2, module) {
    exports2 = module.exports = SemVer;
    var debug2;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH2 = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH2 - 6;
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src3 = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH2],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value2) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max = safeRegexReplacements[i2][1];
        value2 = value2.split(token + "*").join(token + "{0," + max + "}").split(token + "+").join(token + "{1," + max + "}");
      }
      return value2;
    }
    tok("NUMERICIDENTIFIER");
    src3[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src3[t.NUMERICIDENTIFIERLOOSE] = "\\d+";
    tok("NONNUMERICIDENTIFIER");
    src3[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    tok("MAINVERSION");
    src3[t.MAINVERSION] = "(" + src3[t.NUMERICIDENTIFIER] + ")\\.(" + src3[t.NUMERICIDENTIFIER] + ")\\.(" + src3[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src3[t.MAINVERSIONLOOSE] = "(" + src3[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src3[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src3[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src3[t.PRERELEASEIDENTIFIER] = "(?:" + src3[t.NUMERICIDENTIFIER] + "|" + src3[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src3[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src3[t.NUMERICIDENTIFIERLOOSE] + "|" + src3[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src3[t.PRERELEASE] = "(?:-(" + src3[t.PRERELEASEIDENTIFIER] + "(?:\\." + src3[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src3[t.PRERELEASELOOSE] = "(?:-?(" + src3[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src3[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src3[t.BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    tok("BUILD");
    src3[t.BUILD] = "(?:\\+(" + src3[t.BUILDIDENTIFIER] + "(?:\\." + src3[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src3[t.FULLPLAIN] = "v?" + src3[t.MAINVERSION] + src3[t.PRERELEASE] + "?" + src3[t.BUILD] + "?";
    src3[t.FULL] = "^" + src3[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src3[t.LOOSEPLAIN] = "[v=\\s]*" + src3[t.MAINVERSIONLOOSE] + src3[t.PRERELEASELOOSE] + "?" + src3[t.BUILD] + "?";
    tok("LOOSE");
    src3[t.LOOSE] = "^" + src3[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src3[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src3[t.XRANGEIDENTIFIERLOOSE] = src3[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src3[t.XRANGEIDENTIFIER] = src3[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src3[t.XRANGEPLAIN] = "[v=\\s]*(" + src3[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src3[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src3[t.XRANGEIDENTIFIER] + ")(?:" + src3[t.PRERELEASE] + ")?" + src3[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src3[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src3[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src3[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src3[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src3[t.PRERELEASELOOSE] + ")?" + src3[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src3[t.XRANGE] = "^" + src3[t.GTLT] + "\\s*" + src3[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src3[t.XRANGELOOSE] = "^" + src3[t.GTLT] + "\\s*" + src3[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src3[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src3[t.COERCE], "g");
    safeRe[t.COERCERTL] = new RegExp(makeSafeRe(src3[t.COERCE]), "g");
    tok("LONETILDE");
    src3[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src3[t.TILDETRIM] = "(\\s*)" + src3[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src3[t.TILDETRIM], "g");
    safeRe[t.TILDETRIM] = new RegExp(makeSafeRe(src3[t.TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src3[t.TILDE] = "^" + src3[t.LONETILDE] + src3[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src3[t.TILDELOOSE] = "^" + src3[t.LONETILDE] + src3[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src3[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src3[t.CARETTRIM] = "(\\s*)" + src3[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src3[t.CARETTRIM], "g");
    safeRe[t.CARETTRIM] = new RegExp(makeSafeRe(src3[t.CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src3[t.CARET] = "^" + src3[t.LONECARET] + src3[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src3[t.CARETLOOSE] = "^" + src3[t.LONECARET] + src3[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src3[t.COMPARATORLOOSE] = "^" + src3[t.GTLT] + "\\s*(" + src3[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src3[t.COMPARATOR] = "^" + src3[t.GTLT] + "\\s*(" + src3[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src3[t.COMPARATORTRIM] = "(\\s*)" + src3[t.GTLT] + "\\s*(" + src3[t.LOOSEPLAIN] + "|" + src3[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src3[t.COMPARATORTRIM], "g");
    safeRe[t.COMPARATORTRIM] = new RegExp(makeSafeRe(src3[t.COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src3[t.HYPHENRANGE] = "^\\s*(" + src3[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src3[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src3[t.HYPHENRANGELOOSE] = "^\\s*(" + src3[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src3[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src3[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug2(i, src3[i]);
      if (!re[i]) {
        re[i] = new RegExp(src3[i]);
        safeRe[i] = new RegExp(makeSafeRe(src3[i]));
      }
    }
    var i;
    exports2.parse = parse6;
    function parse6(version4, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version4 instanceof SemVer) {
        return version4;
      }
      if (typeof version4 !== "string") {
        return null;
      }
      if (version4.length > MAX_LENGTH2) {
        return null;
      }
      var r = options2.loose ? safeRe[t.LOOSE] : safeRe[t.FULL];
      if (!r.test(version4)) {
        return null;
      }
      try {
        return new SemVer(version4, options2);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version4, options2) {
      var v = parse6(version4, options2);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version4, options2) {
      var s = parse6(version4.trim().replace(/^[=v]+/, ""), options2);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version4, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (version4 instanceof SemVer) {
        if (version4.loose === options2.loose) {
          return version4;
        } else {
          version4 = version4.version;
        }
      } else if (typeof version4 !== "string") {
        throw new TypeError("Invalid Version: " + version4);
      }
      if (version4.length > MAX_LENGTH2) {
        throw new TypeError("version is longer than " + MAX_LENGTH2 + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version4, options2);
      }
      debug2("SemVer", version4, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      var m = version4.trim().match(options2.loose ? safeRe[t.LOOSE] : safeRe[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version4);
      }
      this.raw = version4;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id3) {
          if (/^[0-9]+$/.test(id3)) {
            var num = +id3;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id3;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug2("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug2("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version4, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version4, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version22) {
      if (eq(version1, version22)) {
        return null;
      } else {
        var v1 = parse6(version1);
        var v2 = parse6(version22);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric2 = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric2.test(a);
      var bnum = numeric2.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare2;
    function compare2(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare2(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare2(b, a, loose);
    }
    exports2.sort = sort2;
    function sort2(list2, loose) {
      return list2.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list2, loose) {
      return list2.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare2(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare2(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare2(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare2(a, b, loose) !== 0;
    }
    exports2.gte = gte2;
    function gte2(a, b, loose) {
      return compare2(a, b, loose) >= 0;
    }
    exports2.lte = lte2;
    function lte2(a, b, loose) {
      return compare2(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte2(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte2(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options2.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options2);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug2("comparator", comp, options2);
      this.options = options2;
      this.loose = !!options2.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug2("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version4) {
      debug2("Comparator.test", version4, this.options.loose);
      if (this.semver === ANY || version4 === ANY) {
        return true;
      }
      if (typeof version4 === "string") {
        try {
          version4 = new SemVer(version4, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version4, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options2) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options2);
        return satisfies(this.value, rangeTmp, options2);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options2);
        return satisfies(comp.semver, rangeTmp, options2);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options2) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options2) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range2, options2) {
      if (!options2 || typeof options2 !== "object") {
        options2 = {
          loose: !!options2,
          includePrerelease: false
        };
      }
      if (range2 instanceof Range) {
        if (range2.loose === !!options2.loose && range2.includePrerelease === !!options2.includePrerelease) {
          return range2;
        } else {
          return new Range(range2.raw, options2);
        }
      }
      if (range2 instanceof Comparator) {
        return new Range(range2.value, options2);
      }
      if (!(this instanceof Range)) {
        return new Range(range2, options2);
      }
      this.options = options2;
      this.loose = !!options2.loose;
      this.includePrerelease = !!options2.includePrerelease;
      this.raw = range2.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range3) {
        return this.parseRange(range3.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range2) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[t.HYPHENRANGELOOSE] : safeRe[t.HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace);
      debug2("hyphen replace", range2);
      range2 = range2.replace(safeRe[t.COMPARATORTRIM], comparatorTrimReplace);
      debug2("comparator trim", range2, safeRe[t.COMPARATORTRIM]);
      range2 = range2.replace(safeRe[t.TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(safeRe[t.CARETTRIM], caretTrimReplace);
      range2 = range2.split(/\s+/).join(" ");
      var compRe = loose ? safeRe[t.COMPARATORLOOSE] : safeRe[t.COMPARATOR];
      var set2 = range2.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set2 = set2.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set2 = set2.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set2;
    };
    Range.prototype.intersects = function(range2, options2) {
      if (!(range2 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options2) && range2.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options2) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options2);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options2) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options2);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range2, options2) {
      return new Range(range2, options2).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options2) {
      debug2("comp", comp, options2);
      comp = replaceCarets(comp, options2);
      debug2("caret", comp);
      comp = replaceTildes(comp, options2);
      debug2("tildes", comp);
      comp = replaceXRanges(comp, options2);
      debug2("xrange", comp);
      comp = replaceStars(comp, options2);
      debug2("stars", comp);
      return comp;
    }
    function isX(id3) {
      return !id3 || id3.toLowerCase() === "x" || id3 === "*";
    }
    function replaceTildes(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options2);
      }).join(" ");
    }
    function replaceTilde(comp, options2) {
      var r = options2.loose ? safeRe[t.TILDELOOSE] : safeRe[t.TILDE];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("tilde", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug2("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug2("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options2) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options2);
      }).join(" ");
    }
    function replaceCaret(comp, options2) {
      debug2("caret", comp, options2);
      var r = options2.loose ? safeRe[t.CARETLOOSE] : safeRe[t.CARET];
      return comp.replace(r, function(_, M, m, p, pr) {
        debug2("caret", comp, _, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug2("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug2("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug2("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options2) {
      debug2("replaceXRanges", comp, options2);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options2);
      }).join(" ");
    }
    function replaceXRange(comp, options2) {
      comp = comp.trim();
      var r = options2.loose ? safeRe[t.XRANGELOOSE] : safeRe[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug2("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options2.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug2("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options2) {
      debug2("replaceStars", comp, options2);
      return comp.trim().replace(safeRe[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version4) {
      if (!version4) {
        return false;
      }
      if (typeof version4 === "string") {
        try {
          version4 = new SemVer(version4, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version4, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set2, version4, options2) {
      for (var i2 = 0; i2 < set2.length; i2++) {
        if (!set2[i2].test(version4)) {
          return false;
        }
      }
      if (version4.prerelease.length && !options2.includePrerelease) {
        for (i2 = 0; i2 < set2.length; i2++) {
          debug2(set2[i2].semver);
          if (set2[i2].semver === ANY) {
            continue;
          }
          if (set2[i2].semver.prerelease.length > 0) {
            var allowed = set2[i2].semver;
            if (allowed.major === version4.major && allowed.minor === version4.minor && allowed.patch === version4.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version4, range2, options2) {
      try {
        range2 = new Range(range2, options2);
      } catch (er) {
        return false;
      }
      return range2.test(version4);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range2, options2) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range2, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options2);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range2, options2) {
      var min2 = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range2, options2);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min2 || minSV.compare(v) === 1) {
            min2 = v;
            minSV = new SemVer(min2, options2);
          }
        }
      });
      return min2;
    }
    exports2.minVersion = minVersion;
    function minVersion(range2, loose) {
      range2 = new Range(range2, loose);
      var minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range2.set.length; ++i2) {
        var comparators = range2.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range2, options2) {
      try {
        return new Range(range2, options2).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version4, range2, options2) {
      return outside(version4, range2, "<", options2);
    }
    exports2.gtr = gtr;
    function gtr(version4, range2, options2) {
      return outside(version4, range2, ">", options2);
    }
    exports2.outside = outside;
    function outside(version4, range2, hilo, options2) {
      version4 = new SemVer(version4, options2);
      range2 = new Range(range2, options2);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte2;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte2;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version4, range2, options2)) {
        return false;
      }
      for (var i2 = 0; i2 < range2.set.length; ++i2) {
        var comparators = range2.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options2)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options2)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version4, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version4, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version4, options2) {
      var parsed = parse6(version4, options2);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options2) {
      r1 = new Range(r1, options2);
      r2 = new Range(r2, options2);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version4, options2) {
      if (version4 instanceof SemVer) {
        return version4;
      }
      if (typeof version4 === "number") {
        version4 = String(version4);
      }
      if (typeof version4 !== "string") {
        return null;
      }
      options2 = options2 || {};
      var match2 = null;
      if (!options2.rtl) {
        match2 = version4.match(safeRe[t.COERCE]);
      } else {
        var next;
        while ((next = safeRe[t.COERCERTL].exec(version4)) && (!match2 || match2.index + match2[0].length !== version4.length)) {
          if (!match2 || next.index + next[0].length !== match2.index + match2[0].length) {
            match2 = next;
          }
          safeRe[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        safeRe[t.COERCERTL].lastIndex = -1;
      }
      if (match2 === null) {
        return null;
      }
      return parse6(match2[2] + "." + (match2[3] || "0") + "." + (match2[4] || "0"), options2);
    }
  }
});

// node_modules/@babel/helper-module-imports/lib/import-builder.js
var require_import_builder = __commonJS({
  "node_modules/@babel/helper-module-imports/lib/import-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _assert = __require("assert");
    var _t = require_lib3();
    var {
      callExpression,
      cloneNode,
      expressionStatement,
      identifier,
      importDeclaration,
      importDefaultSpecifier,
      importNamespaceSpecifier,
      importSpecifier,
      memberExpression,
      stringLiteral,
      variableDeclaration,
      variableDeclarator
    } = _t;
    var ImportBuilder = class {
      constructor(importedSource, scope, hub) {
        this._statements = [];
        this._resultName = null;
        this._importedSource = void 0;
        this._scope = scope;
        this._hub = hub;
        this._importedSource = importedSource;
      }
      done() {
        return {
          statements: this._statements,
          resultName: this._resultName
        };
      }
      import() {
        this._statements.push(importDeclaration([], stringLiteral(this._importedSource)));
        return this;
      }
      require() {
        this._statements.push(expressionStatement(callExpression(identifier("require"), [stringLiteral(this._importedSource)])));
        return this;
      }
      namespace(name2 = "namespace") {
        const local = this._scope.generateUidIdentifier(name2);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [importNamespaceSpecifier(local)];
        this._resultName = cloneNode(local);
        return this;
      }
      default(name2) {
        const id3 = this._scope.generateUidIdentifier(name2);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [importDefaultSpecifier(id3)];
        this._resultName = cloneNode(id3);
        return this;
      }
      named(name2, importName) {
        if (importName === "default") return this.default(name2);
        const id3 = this._scope.generateUidIdentifier(name2);
        const statement = this._statements[this._statements.length - 1];
        _assert(statement.type === "ImportDeclaration");
        _assert(statement.specifiers.length === 0);
        statement.specifiers = [importSpecifier(id3, identifier(importName))];
        this._resultName = cloneNode(id3);
        return this;
      }
      var(name2) {
        const id3 = this._scope.generateUidIdentifier(name2);
        let statement = this._statements[this._statements.length - 1];
        if (statement.type !== "ExpressionStatement") {
          _assert(this._resultName);
          statement = expressionStatement(this._resultName);
          this._statements.push(statement);
        }
        this._statements[this._statements.length - 1] = variableDeclaration("var", [variableDeclarator(id3, statement.expression)]);
        this._resultName = cloneNode(id3);
        return this;
      }
      defaultInterop() {
        return this._interop(this._hub.addHelper("interopRequireDefault"));
      }
      wildcardInterop() {
        return this._interop(this._hub.addHelper("interopRequireWildcard"));
      }
      _interop(callee) {
        const statement = this._statements[this._statements.length - 1];
        if (statement.type === "ExpressionStatement") {
          statement.expression = callExpression(callee, [statement.expression]);
        } else if (statement.type === "VariableDeclaration") {
          _assert(statement.declarations.length === 1);
          statement.declarations[0].init = callExpression(callee, [statement.declarations[0].init]);
        } else {
          _assert.fail("Unexpected type.");
        }
        return this;
      }
      prop(name2) {
        const statement = this._statements[this._statements.length - 1];
        if (statement.type === "ExpressionStatement") {
          statement.expression = memberExpression(statement.expression, identifier(name2));
        } else if (statement.type === "VariableDeclaration") {
          _assert(statement.declarations.length === 1);
          statement.declarations[0].init = memberExpression(statement.declarations[0].init, identifier(name2));
        } else {
          _assert.fail("Unexpected type:" + statement.type);
        }
        return this;
      }
      read(name2) {
        this._resultName = memberExpression(this._resultName, identifier(name2));
      }
    };
    exports2.default = ImportBuilder;
  }
});

// node_modules/@babel/helper-module-imports/lib/is-module.js
var require_is_module = __commonJS({
  "node_modules/@babel/helper-module-imports/lib/is-module.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isModule;
    function isModule(path9) {
      return path9.node.sourceType === "module";
    }
  }
});

// node_modules/@babel/helper-module-imports/lib/import-injector.js
var require_import_injector = __commonJS({
  "node_modules/@babel/helper-module-imports/lib/import-injector.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _assert = __require("assert");
    var _t = require_lib3();
    var _importBuilder = require_import_builder();
    var _isModule = require_is_module();
    var {
      identifier,
      importSpecifier,
      numericLiteral,
      sequenceExpression,
      isImportDeclaration
    } = _t;
    var ImportInjector = class {
      constructor(path9, importedSource, opts) {
        this._defaultOpts = {
          importedSource: null,
          importedType: "commonjs",
          importedInterop: "babel",
          importingInterop: "babel",
          ensureLiveReference: false,
          ensureNoContext: false,
          importPosition: "before"
        };
        const programPath = path9.find((p) => p.isProgram());
        this._programPath = programPath;
        this._programScope = programPath.scope;
        this._hub = programPath.hub;
        this._defaultOpts = this._applyDefaults(importedSource, opts, true);
      }
      addDefault(importedSourceIn, opts) {
        return this.addNamed("default", importedSourceIn, opts);
      }
      addNamed(importName, importedSourceIn, opts) {
        _assert(typeof importName === "string");
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), importName);
      }
      addNamespace(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), null);
      }
      addSideEffect(importedSourceIn, opts) {
        return this._generateImport(this._applyDefaults(importedSourceIn, opts), void 0);
      }
      _applyDefaults(importedSource, opts, isInit = false) {
        let newOpts;
        if (typeof importedSource === "string") {
          newOpts = Object.assign({}, this._defaultOpts, {
            importedSource
          }, opts);
        } else {
          _assert(!opts, "Unexpected secondary arguments.");
          newOpts = Object.assign({}, this._defaultOpts, importedSource);
        }
        if (!isInit && opts) {
          if (opts.nameHint !== void 0) newOpts.nameHint = opts.nameHint;
          if (opts.blockHoist !== void 0) newOpts.blockHoist = opts.blockHoist;
        }
        return newOpts;
      }
      _generateImport(opts, importName) {
        const isDefault = importName === "default";
        const isNamed = !!importName && !isDefault;
        const isNamespace2 = importName === null;
        const {
          importedSource,
          importedType,
          importedInterop,
          importingInterop,
          ensureLiveReference,
          ensureNoContext,
          nameHint,
          importPosition,
          blockHoist
        } = opts;
        let name2 = nameHint || importName;
        const isMod = (0, _isModule.default)(this._programPath);
        const isModuleForNode = isMod && importingInterop === "node";
        const isModuleForBabel = isMod && importingInterop === "babel";
        if (importPosition === "after" && !isMod) {
          throw new Error(`"importPosition": "after" is only supported in modules`);
        }
        const builder = new _importBuilder.default(importedSource, this._programScope, this._hub);
        if (importedType === "es6") {
          if (!isModuleForNode && !isModuleForBabel) {
            throw new Error("Cannot import an ES6 module from CommonJS");
          }
          builder.import();
          if (isNamespace2) {
            builder.namespace(nameHint || importedSource);
          } else if (isDefault || isNamed) {
            builder.named(name2, importName);
          }
        } else if (importedType !== "commonjs") {
          throw new Error(`Unexpected interopType "${importedType}"`);
        } else if (importedInterop === "babel") {
          if (isModuleForNode) {
            name2 = name2 !== "default" ? name2 : importedSource;
            const es6Default = `${importedSource}$es6Default`;
            builder.import();
            if (isNamespace2) {
              builder.default(es6Default).var(name2 || importedSource).wildcardInterop();
            } else if (isDefault) {
              if (ensureLiveReference) {
                builder.default(es6Default).var(name2 || importedSource).defaultInterop().read("default");
              } else {
                builder.default(es6Default).var(name2).defaultInterop().prop(importName);
              }
            } else if (isNamed) {
              builder.default(es6Default).read(importName);
            }
          } else if (isModuleForBabel) {
            builder.import();
            if (isNamespace2) {
              builder.namespace(name2 || importedSource);
            } else if (isDefault || isNamed) {
              builder.named(name2, importName);
            }
          } else {
            builder.require();
            if (isNamespace2) {
              builder.var(name2 || importedSource).wildcardInterop();
            } else if ((isDefault || isNamed) && ensureLiveReference) {
              if (isDefault) {
                name2 = name2 !== "default" ? name2 : importedSource;
                builder.var(name2).read(importName);
                builder.defaultInterop();
              } else {
                builder.var(importedSource).read(importName);
              }
            } else if (isDefault) {
              builder.var(name2).defaultInterop().prop(importName);
            } else if (isNamed) {
              builder.var(name2).prop(importName);
            }
          }
        } else if (importedInterop === "compiled") {
          if (isModuleForNode) {
            builder.import();
            if (isNamespace2) {
              builder.default(name2 || importedSource);
            } else if (isDefault || isNamed) {
              builder.default(importedSource).read(name2);
            }
          } else if (isModuleForBabel) {
            builder.import();
            if (isNamespace2) {
              builder.namespace(name2 || importedSource);
            } else if (isDefault || isNamed) {
              builder.named(name2, importName);
            }
          } else {
            builder.require();
            if (isNamespace2) {
              builder.var(name2 || importedSource);
            } else if (isDefault || isNamed) {
              if (ensureLiveReference) {
                builder.var(importedSource).read(name2);
              } else {
                builder.prop(importName).var(name2);
              }
            }
          }
        } else if (importedInterop === "uncompiled") {
          if (isDefault && ensureLiveReference) {
            throw new Error("No live reference for commonjs default");
          }
          if (isModuleForNode) {
            builder.import();
            if (isNamespace2) {
              builder.default(name2 || importedSource);
            } else if (isDefault) {
              builder.default(name2);
            } else if (isNamed) {
              builder.default(importedSource).read(name2);
            }
          } else if (isModuleForBabel) {
            builder.import();
            if (isNamespace2) {
              builder.default(name2 || importedSource);
            } else if (isDefault) {
              builder.default(name2);
            } else if (isNamed) {
              builder.named(name2, importName);
            }
          } else {
            builder.require();
            if (isNamespace2) {
              builder.var(name2 || importedSource);
            } else if (isDefault) {
              builder.var(name2);
            } else if (isNamed) {
              if (ensureLiveReference) {
                builder.var(importedSource).read(name2);
              } else {
                builder.var(name2).prop(importName);
              }
            }
          }
        } else {
          throw new Error(`Unknown importedInterop "${importedInterop}".`);
        }
        const {
          statements,
          resultName
        } = builder.done();
        this._insertStatements(statements, importPosition, blockHoist);
        if ((isDefault || isNamed) && ensureNoContext && resultName.type !== "Identifier") {
          return sequenceExpression([numericLiteral(0), resultName]);
        }
        return resultName;
      }
      _insertStatements(statements, importPosition = "before", blockHoist = 3) {
        if (importPosition === "after") {
          if (this._insertStatementsAfter(statements)) return;
        } else {
          if (this._insertStatementsBefore(statements, blockHoist)) return;
        }
        this._programPath.unshiftContainer("body", statements);
      }
      _insertStatementsBefore(statements, blockHoist) {
        if (statements.length === 1 && isImportDeclaration(statements[0]) && isValueImport(statements[0])) {
          const firstImportDecl = this._programPath.get("body").find((p) => {
            return p.isImportDeclaration() && isValueImport(p.node);
          });
          if ((firstImportDecl == null ? void 0 : firstImportDecl.node.source.value) === statements[0].source.value && maybeAppendImportSpecifiers(firstImportDecl.node, statements[0])) {
            return true;
          }
        }
        statements.forEach((node3) => {
          node3._blockHoist = blockHoist;
        });
        const targetPath = this._programPath.get("body").find((p) => {
          const val = p.node._blockHoist;
          return Number.isFinite(val) && val < 4;
        });
        if (targetPath) {
          targetPath.insertBefore(statements);
          return true;
        }
        return false;
      }
      _insertStatementsAfter(statements) {
        const statementsSet = new Set(statements);
        const importDeclarations = /* @__PURE__ */ new Map();
        for (const statement of statements) {
          if (isImportDeclaration(statement) && isValueImport(statement)) {
            const source = statement.source.value;
            if (!importDeclarations.has(source)) importDeclarations.set(source, []);
            importDeclarations.get(source).push(statement);
          }
        }
        let lastImportPath = null;
        for (const bodyStmt of this._programPath.get("body")) {
          if (bodyStmt.isImportDeclaration() && isValueImport(bodyStmt.node)) {
            lastImportPath = bodyStmt;
            const source = bodyStmt.node.source.value;
            const newImports = importDeclarations.get(source);
            if (!newImports) continue;
            for (const decl2 of newImports) {
              if (!statementsSet.has(decl2)) continue;
              if (maybeAppendImportSpecifiers(bodyStmt.node, decl2)) {
                statementsSet.delete(decl2);
              }
            }
          }
        }
        if (statementsSet.size === 0) return true;
        if (lastImportPath) lastImportPath.insertAfter(Array.from(statementsSet));
        return !!lastImportPath;
      }
    };
    exports2.default = ImportInjector;
    function isValueImport(node3) {
      return node3.importKind !== "type" && node3.importKind !== "typeof";
    }
    function hasNamespaceImport(node3) {
      return node3.specifiers.length === 1 && node3.specifiers[0].type === "ImportNamespaceSpecifier" || node3.specifiers.length === 2 && node3.specifiers[1].type === "ImportNamespaceSpecifier";
    }
    function hasDefaultImport(node3) {
      return node3.specifiers.length > 0 && node3.specifiers[0].type === "ImportDefaultSpecifier";
    }
    function maybeAppendImportSpecifiers(target, source) {
      if (!target.specifiers.length) {
        target.specifiers = source.specifiers;
        return true;
      }
      if (!source.specifiers.length) return true;
      if (hasNamespaceImport(target) || hasNamespaceImport(source)) return false;
      if (hasDefaultImport(source)) {
        if (hasDefaultImport(target)) {
          source.specifiers[0] = importSpecifier(source.specifiers[0].local, identifier("default"));
        } else {
          target.specifiers.unshift(source.specifiers.shift());
        }
      }
      target.specifiers.push(...source.specifiers);
      return true;
    }
  }
});

// node_modules/@babel/helper-module-imports/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/@babel/helper-module-imports/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ImportInjector", {
      enumerable: true,
      get: function() {
        return _importInjector.default;
      }
    });
    exports2.addDefault = addDefault;
    exports2.addNamed = addNamed;
    exports2.addNamespace = addNamespace;
    exports2.addSideEffect = addSideEffect;
    Object.defineProperty(exports2, "isModule", {
      enumerable: true,
      get: function() {
        return _isModule.default;
      }
    });
    var _importInjector = require_import_injector();
    var _isModule = require_is_module();
    function addDefault(path9, importedSource, opts) {
      return new _importInjector.default(path9).addDefault(importedSource, opts);
    }
    function addNamed(path9, name2, importedSource, opts) {
      return new _importInjector.default(path9).addNamed(name2, importedSource, opts);
    }
    function addNamespace(path9, importedSource, opts) {
      return new _importInjector.default(path9).addNamespace(importedSource, opts);
    }
    function addSideEffect(path9, importedSource, opts) {
      return new _importInjector.default(path9).addSideEffect(importedSource, opts);
    }
  }
});

// node_modules/@babel/helper-module-transforms/lib/rewrite-this.js
var require_rewrite_this = __commonJS({
  "node_modules/@babel/helper-module-transforms/lib/rewrite-this.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rewriteThis;
    var _core = require_lib15();
    var _traverse = require_lib9();
    var rewriteThisVisitor;
    function rewriteThis(programPath) {
      if (!rewriteThisVisitor) {
        rewriteThisVisitor = _traverse.visitors.environmentVisitor({
          ThisExpression(path9) {
            path9.replaceWith(_core.types.unaryExpression("void", _core.types.numericLiteral(0), true));
          }
        });
        rewriteThisVisitor.noScope = true;
      }
      (0, _traverse.default)(programPath.node, rewriteThisVisitor);
    }
  }
});

// node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js
var require_rewrite_live_references = __commonJS({
  "node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rewriteLiveReferences;
    var _core = require_lib15();
    function isInType(path9) {
      do {
        switch (path9.parent.type) {
          case "TSTypeAnnotation":
          case "TSTypeAliasDeclaration":
          case "TSTypeReference":
          case "TypeAnnotation":
          case "TypeAlias":
            return true;
          case "ExportSpecifier":
            return path9.parentPath.parent.exportKind === "type";
          default:
            if (path9.parentPath.isStatement() || path9.parentPath.isExpression()) {
              return false;
            }
        }
      } while (path9 = path9.parentPath);
    }
    function rewriteLiveReferences(programPath, metadata, wrapReference) {
      const imported = /* @__PURE__ */ new Map();
      const exported = /* @__PURE__ */ new Map();
      const requeueInParent = (path9) => {
        programPath.requeue(path9);
      };
      for (const [source, data] of metadata.source) {
        for (const [localName, importName] of data.imports) {
          imported.set(localName, [source, importName, null]);
        }
        for (const localName of data.importsNamespace) {
          imported.set(localName, [source, null, localName]);
        }
      }
      for (const [local, data] of metadata.local) {
        let exportMeta = exported.get(local);
        if (!exportMeta) {
          exportMeta = [];
          exported.set(local, exportMeta);
        }
        exportMeta.push(...data.names);
      }
      const rewriteBindingInitVisitorState = {
        metadata,
        requeueInParent,
        scope: programPath.scope,
        exported
      };
      programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);
      const rewriteReferencesVisitorState = {
        seen: /* @__PURE__ */ new WeakSet(),
        metadata,
        requeueInParent,
        scope: programPath.scope,
        imported,
        exported,
        buildImportReference([source, importName, localName], identNode) {
          const meta = metadata.source.get(source);
          meta.referenced = true;
          if (localName) {
            if (meta.wrap) {
              var _wrapReference;
              identNode = (_wrapReference = wrapReference(identNode, meta.wrap)) != null ? _wrapReference : identNode;
            }
            return identNode;
          }
          let namespace2 = _core.types.identifier(meta.name);
          if (meta.wrap) {
            var _wrapReference2;
            namespace2 = (_wrapReference2 = wrapReference(namespace2, meta.wrap)) != null ? _wrapReference2 : namespace2;
          }
          if (importName === "default" && meta.interop === "node-default") {
            return namespace2;
          }
          const computed = metadata.stringSpecifiers.has(importName);
          return _core.types.memberExpression(namespace2, computed ? _core.types.stringLiteral(importName) : _core.types.identifier(importName), computed);
        }
      };
      programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);
    }
    var rewriteBindingInitVisitor = {
      Scope(path9) {
        path9.skip();
      },
      ClassDeclaration(path9) {
        const {
          requeueInParent,
          exported,
          metadata
        } = this;
        const {
          id: id3
        } = path9.node;
        if (!id3) throw new Error("Expected class to have a name");
        const localName = id3.name;
        const exportNames = exported.get(localName) || [];
        if (exportNames.length > 0) {
          const statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, _core.types.identifier(localName), path9.scope));
          statement._blockHoist = path9.node._blockHoist;
          requeueInParent(path9.insertAfter(statement)[0]);
        }
      },
      VariableDeclaration(path9) {
        const {
          requeueInParent,
          exported,
          metadata
        } = this;
        const isVar = path9.node.kind === "var";
        for (const decl2 of path9.get("declarations")) {
          const {
            id: id3
          } = decl2.node;
          let {
            init: init2
          } = decl2.node;
          if (_core.types.isIdentifier(id3) && exported.has(id3.name) && !_core.types.isArrowFunctionExpression(init2) && (!_core.types.isFunctionExpression(init2) || init2.id) && (!_core.types.isClassExpression(init2) || init2.id)) {
            if (!init2) {
              if (isVar) {
                continue;
              } else {
                init2 = path9.scope.buildUndefinedNode();
              }
            }
            decl2.node.init = buildBindingExportAssignmentExpression(metadata, exported.get(id3.name), init2, path9.scope);
            requeueInParent(decl2.get("init"));
          } else {
            for (const localName of Object.keys(decl2.getOuterBindingIdentifiers())) {
              if (exported.has(localName)) {
                const statement = _core.types.expressionStatement(buildBindingExportAssignmentExpression(metadata, exported.get(localName), _core.types.identifier(localName), path9.scope));
                statement._blockHoist = path9.node._blockHoist;
                requeueInParent(path9.insertAfter(statement)[0]);
              }
            }
          }
        }
      }
    };
    var buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr, scope) => {
      const exportsObjectName = metadata.exportName;
      for (let currentScope = scope; currentScope != null; currentScope = currentScope.parent) {
        if (currentScope.hasOwnBinding(exportsObjectName)) {
          currentScope.rename(exportsObjectName);
        }
      }
      return (exportNames || []).reduce((expr, exportName) => {
        const {
          stringSpecifiers
        } = metadata;
        const computed = stringSpecifiers.has(exportName);
        return _core.types.assignmentExpression("=", _core.types.memberExpression(_core.types.identifier(exportsObjectName), computed ? _core.types.stringLiteral(exportName) : _core.types.identifier(exportName), computed), expr);
      }, localExpr);
    };
    var buildImportThrow = (localName) => {
      return _core.template.expression.ast`
    (function() {
      throw new Error('"' + '${localName}' + '" is read-only.');
    })()
  `;
    };
    var rewriteReferencesVisitor = {
      ReferencedIdentifier(path9) {
        const {
          seen: seen2,
          buildImportReference,
          scope,
          imported,
          requeueInParent
        } = this;
        if (seen2.has(path9.node)) return;
        seen2.add(path9.node);
        const localName = path9.node.name;
        const importData = imported.get(localName);
        if (importData) {
          if (isInType(path9)) {
            throw path9.buildCodeFrameError(`Cannot transform the imported binding "${localName}" since it's also used in a type annotation. Please strip type annotations using @babel/preset-typescript or @babel/preset-flow.`);
          }
          const localBinding = path9.scope.getBinding(localName);
          const rootBinding = scope.getBinding(localName);
          if (rootBinding !== localBinding) return;
          const ref = buildImportReference(importData, path9.node);
          ref.loc = path9.node.loc;
          if ((path9.parentPath.isCallExpression({
            callee: path9.node
          }) || path9.parentPath.isOptionalCallExpression({
            callee: path9.node
          }) || path9.parentPath.isTaggedTemplateExpression({
            tag: path9.node
          })) && _core.types.isMemberExpression(ref)) {
            path9.replaceWith(_core.types.sequenceExpression([_core.types.numericLiteral(0), ref]));
          } else if (path9.isJSXIdentifier() && _core.types.isMemberExpression(ref)) {
            const {
              object: object2,
              property
            } = ref;
            path9.replaceWith(_core.types.jsxMemberExpression(_core.types.jsxIdentifier(object2.name), _core.types.jsxIdentifier(property.name)));
          } else {
            path9.replaceWith(ref);
          }
          requeueInParent(path9);
          path9.skip();
        }
      },
      UpdateExpression(path9) {
        const {
          scope,
          seen: seen2,
          imported,
          exported,
          requeueInParent,
          buildImportReference
        } = this;
        if (seen2.has(path9.node)) return;
        seen2.add(path9.node);
        const arg = path9.get("argument");
        if (arg.isMemberExpression()) return;
        const update = path9.node;
        if (arg.isIdentifier()) {
          const localName = arg.node.name;
          if (scope.getBinding(localName) !== path9.scope.getBinding(localName)) {
            return;
          }
          const exportedNames = exported.get(localName);
          const importData = imported.get(localName);
          if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
            if (importData) {
              path9.replaceWith(_core.types.assignmentExpression(update.operator[0] + "=", buildImportReference(importData, arg.node), buildImportThrow(localName)));
            } else if (update.prefix) {
              path9.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.cloneNode(update), path9.scope));
            } else {
              const ref = scope.generateDeclaredUidIdentifier(localName);
              path9.replaceWith(_core.types.sequenceExpression([_core.types.assignmentExpression("=", _core.types.cloneNode(ref), _core.types.cloneNode(update)), buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path9.scope), _core.types.cloneNode(ref)]));
            }
          }
        }
        requeueInParent(path9);
        path9.skip();
      },
      AssignmentExpression: {
        exit(path9) {
          const {
            scope,
            seen: seen2,
            imported,
            exported,
            requeueInParent,
            buildImportReference
          } = this;
          if (seen2.has(path9.node)) return;
          seen2.add(path9.node);
          const left = path9.get("left");
          if (left.isMemberExpression()) return;
          if (left.isIdentifier()) {
            const localName = left.node.name;
            if (scope.getBinding(localName) !== path9.scope.getBinding(localName)) {
              return;
            }
            const exportedNames = exported.get(localName);
            const importData = imported.get(localName);
            if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {
              const assignment = path9.node;
              if (importData) {
                assignment.left = buildImportReference(importData, left.node);
                assignment.right = _core.types.sequenceExpression([assignment.right, buildImportThrow(localName)]);
              }
              const {
                operator
              } = assignment;
              let newExpr;
              if (operator === "=") {
                newExpr = assignment;
              } else if (operator === "&&=" || operator === "||=" || operator === "??=") {
                newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.logicalExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right));
              } else {
                newExpr = _core.types.assignmentExpression("=", assignment.left, _core.types.binaryExpression(operator.slice(0, -1), _core.types.cloneNode(assignment.left), assignment.right));
              }
              path9.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, newExpr, path9.scope));
              requeueInParent(path9);
              path9.skip();
            }
          } else {
            const ids = left.getOuterBindingIdentifiers();
            const programScopeIds = Object.keys(ids).filter((localName) => scope.getBinding(localName) === path9.scope.getBinding(localName));
            const id3 = programScopeIds.find((localName) => imported.has(localName));
            if (id3) {
              path9.node.right = _core.types.sequenceExpression([path9.node.right, buildImportThrow(id3)]);
            }
            const items = [];
            programScopeIds.forEach((localName) => {
              const exportedNames = exported.get(localName) || [];
              if (exportedNames.length > 0) {
                items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, _core.types.identifier(localName), path9.scope));
              }
            });
            if (items.length > 0) {
              let node3 = _core.types.sequenceExpression(items);
              if (path9.parentPath.isExpressionStatement()) {
                node3 = _core.types.expressionStatement(node3);
                node3._blockHoist = path9.parentPath.node._blockHoist;
              }
              const statement = path9.insertAfter(node3)[0];
              requeueInParent(statement);
            }
          }
        }
      },
      ForXStatement(path9) {
        const {
          scope,
          node: node3
        } = path9;
        const {
          left
        } = node3;
        const {
          exported,
          imported,
          scope: programScope
        } = this;
        if (!_core.types.isVariableDeclaration(left)) {
          let didTransformExport = false, importConstViolationName;
          const loopBodyScope = path9.get("body").scope;
          for (const name2 of Object.keys(_core.types.getOuterBindingIdentifiers(left))) {
            if (programScope.getBinding(name2) === scope.getBinding(name2)) {
              if (exported.has(name2)) {
                didTransformExport = true;
                if (loopBodyScope.hasOwnBinding(name2)) {
                  loopBodyScope.rename(name2);
                }
              }
              if (imported.has(name2) && !importConstViolationName) {
                importConstViolationName = name2;
              }
            }
          }
          if (!didTransformExport && !importConstViolationName) {
            return;
          }
          path9.ensureBlock();
          const bodyPath = path9.get("body");
          const newLoopId = scope.generateUidIdentifierBasedOnNode(left);
          path9.get("left").replaceWith(_core.types.variableDeclaration("let", [_core.types.variableDeclarator(_core.types.cloneNode(newLoopId))]));
          scope.registerDeclaration(path9.get("left"));
          if (didTransformExport) {
            bodyPath.unshiftContainer("body", _core.types.expressionStatement(_core.types.assignmentExpression("=", left, newLoopId)));
          }
          if (importConstViolationName) {
            bodyPath.unshiftContainer("body", _core.types.expressionStatement(buildImportThrow(importConstViolationName)));
          }
        }
      }
    };
  }
});

// node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js
var require_normalize_and_load_metadata = __commonJS({
  "node_modules/@babel/helper-module-transforms/lib/normalize-and-load-metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = normalizeModuleAndLoadMetadata;
    exports2.hasExports = hasExports;
    exports2.isSideEffectImport = isSideEffectImport;
    exports2.validateImportInteropOption = validateImportInteropOption;
    var _path2 = __require("path");
    var _helperValidatorIdentifier = require_lib();
    function hasExports(metadata) {
      return metadata.hasExports;
    }
    function isSideEffectImport(source) {
      return source.imports.size === 0 && source.importsNamespace.size === 0 && source.reexports.size === 0 && source.reexportNamespace.size === 0 && !source.reexportAll;
    }
    function validateImportInteropOption(importInterop) {
      if (typeof importInterop !== "function" && importInterop !== "none" && importInterop !== "babel" && importInterop !== "node") {
        throw new Error(`.importInterop must be one of "none", "babel", "node", or a function returning one of those values (received ${importInterop}).`);
      }
      return importInterop;
    }
    function resolveImportInterop(importInterop, source, filename) {
      if (typeof importInterop === "function") {
        return validateImportInteropOption(importInterop(source, filename));
      }
      return importInterop;
    }
    function normalizeModuleAndLoadMetadata(programPath, exportName, {
      importInterop,
      initializeReexports = false,
      getWrapperPayload,
      esNamespaceOnly = false,
      filename
    }) {
      if (!exportName) {
        exportName = programPath.scope.generateUidIdentifier("exports").name;
      }
      const stringSpecifiers = /* @__PURE__ */ new Set();
      nameAnonymousExports(programPath);
      const {
        local,
        sources,
        hasExports: hasExports2
      } = getModuleMetadata(programPath, {
        initializeReexports,
        getWrapperPayload
      }, stringSpecifiers);
      removeImportExportDeclarations(programPath);
      for (const [source, metadata] of sources) {
        const {
          importsNamespace,
          imports
        } = metadata;
        if (importsNamespace.size > 0 && imports.size === 0) {
          const [nameOfnamespace] = importsNamespace;
          metadata.name = nameOfnamespace;
        }
        const resolvedInterop = resolveImportInterop(importInterop, source, filename);
        if (resolvedInterop === "none") {
          metadata.interop = "none";
        } else if (resolvedInterop === "node" && metadata.interop === "namespace") {
          metadata.interop = "node-namespace";
        } else if (resolvedInterop === "node" && metadata.interop === "default") {
          metadata.interop = "node-default";
        } else if (esNamespaceOnly && metadata.interop === "namespace") {
          metadata.interop = "default";
        }
      }
      return {
        exportName,
        exportNameListName: null,
        hasExports: hasExports2,
        local,
        source: sources,
        stringSpecifiers
      };
    }
    function getExportSpecifierName(path9, stringSpecifiers) {
      if (path9.isIdentifier()) {
        return path9.node.name;
      } else if (path9.isStringLiteral()) {
        const stringValue = path9.node.value;
        if (!(0, _helperValidatorIdentifier.isIdentifierName)(stringValue)) {
          stringSpecifiers.add(stringValue);
        }
        return stringValue;
      } else {
        throw new Error(`Expected export specifier to be either Identifier or StringLiteral, got ${path9.node.type}`);
      }
    }
    function assertExportSpecifier(path9) {
      if (path9.isExportSpecifier()) {
        return;
      } else if (path9.isExportNamespaceSpecifier()) {
        throw path9.buildCodeFrameError("Export namespace should be first transformed by `@babel/plugin-transform-export-namespace-from`.");
      } else {
        throw path9.buildCodeFrameError("Unexpected export specifier type");
      }
    }
    function getModuleMetadata(programPath, {
      getWrapperPayload,
      initializeReexports
    }, stringSpecifiers) {
      const localData = getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers);
      const importNodes = /* @__PURE__ */ new Map();
      const sourceData = /* @__PURE__ */ new Map();
      const getData = (sourceNode, node3) => {
        const source = sourceNode.value;
        let data = sourceData.get(source);
        if (!data) {
          data = {
            name: programPath.scope.generateUidIdentifier((0, _path2.basename)(source, (0, _path2.extname)(source))).name,
            interop: "none",
            loc: null,
            imports: /* @__PURE__ */ new Map(),
            importsNamespace: /* @__PURE__ */ new Set(),
            reexports: /* @__PURE__ */ new Map(),
            reexportNamespace: /* @__PURE__ */ new Set(),
            reexportAll: null,
            wrap: null,
            get lazy() {
              return this.wrap === "lazy";
            },
            referenced: false
          };
          sourceData.set(source, data);
          importNodes.set(source, [node3]);
        } else {
          importNodes.get(source).push(node3);
        }
        return data;
      };
      let hasExports2 = false;
      programPath.get("body").forEach((child) => {
        if (child.isImportDeclaration()) {
          const data = getData(child.node.source, child.node);
          if (!data.loc) data.loc = child.node.loc;
          child.get("specifiers").forEach((spec) => {
            if (spec.isImportDefaultSpecifier()) {
              const localName = spec.get("local").node.name;
              data.imports.set(localName, "default");
              const reexport = localData.get(localName);
              if (reexport) {
                localData.delete(localName);
                reexport.names.forEach((name2) => {
                  data.reexports.set(name2, "default");
                });
                data.referenced = true;
              }
            } else if (spec.isImportNamespaceSpecifier()) {
              const localName = spec.get("local").node.name;
              data.importsNamespace.add(localName);
              const reexport = localData.get(localName);
              if (reexport) {
                localData.delete(localName);
                reexport.names.forEach((name2) => {
                  data.reexportNamespace.add(name2);
                });
                data.referenced = true;
              }
            } else if (spec.isImportSpecifier()) {
              const importName = getExportSpecifierName(spec.get("imported"), stringSpecifiers);
              const localName = spec.get("local").node.name;
              data.imports.set(localName, importName);
              const reexport = localData.get(localName);
              if (reexport) {
                localData.delete(localName);
                reexport.names.forEach((name2) => {
                  data.reexports.set(name2, importName);
                });
                data.referenced = true;
              }
            }
          });
        } else if (child.isExportAllDeclaration()) {
          hasExports2 = true;
          const data = getData(child.node.source, child.node);
          if (!data.loc) data.loc = child.node.loc;
          data.reexportAll = {
            loc: child.node.loc
          };
          data.referenced = true;
        } else if (child.isExportNamedDeclaration() && child.node.source) {
          hasExports2 = true;
          const data = getData(child.node.source, child.node);
          if (!data.loc) data.loc = child.node.loc;
          child.get("specifiers").forEach((spec) => {
            assertExportSpecifier(spec);
            const importName = getExportSpecifierName(spec.get("local"), stringSpecifiers);
            const exportName = getExportSpecifierName(spec.get("exported"), stringSpecifiers);
            data.reexports.set(exportName, importName);
            data.referenced = true;
            if (exportName === "__esModule") {
              throw spec.get("exported").buildCodeFrameError('Illegal export "__esModule".');
            }
          });
        } else if (child.isExportNamedDeclaration() || child.isExportDefaultDeclaration()) {
          hasExports2 = true;
        }
      });
      for (const metadata of sourceData.values()) {
        let needsDefault = false;
        let needsNamed = false;
        if (metadata.importsNamespace.size > 0) {
          needsDefault = true;
          needsNamed = true;
        }
        if (metadata.reexportAll) {
          needsNamed = true;
        }
        for (const importName of metadata.imports.values()) {
          if (importName === "default") needsDefault = true;
          else needsNamed = true;
        }
        for (const importName of metadata.reexports.values()) {
          if (importName === "default") needsDefault = true;
          else needsNamed = true;
        }
        if (needsDefault && needsNamed) {
          metadata.interop = "namespace";
        } else if (needsDefault) {
          metadata.interop = "default";
        }
      }
      if (getWrapperPayload) {
        for (const [source, metadata] of sourceData) {
          metadata.wrap = getWrapperPayload(source, metadata, importNodes.get(source));
        }
      }
      return {
        hasExports: hasExports2,
        local: localData,
        sources: sourceData
      };
    }
    function getLocalExportMetadata(programPath, initializeReexports, stringSpecifiers) {
      const bindingKindLookup = /* @__PURE__ */ new Map();
      programPath.get("body").forEach((child) => {
        let kind;
        if (child.isImportDeclaration()) {
          kind = "import";
        } else {
          if (child.isExportDefaultDeclaration()) {
            child = child.get("declaration");
          }
          if (child.isExportNamedDeclaration()) {
            if (child.node.declaration) {
              child = child.get("declaration");
            } else if (initializeReexports && child.node.source && child.get("source").isStringLiteral()) {
              child.get("specifiers").forEach((spec) => {
                assertExportSpecifier(spec);
                bindingKindLookup.set(spec.get("local").node.name, "block");
              });
              return;
            }
          }
          if (child.isFunctionDeclaration()) {
            kind = "hoisted";
          } else if (child.isClassDeclaration()) {
            kind = "block";
          } else if (child.isVariableDeclaration({
            kind: "var"
          })) {
            kind = "var";
          } else if (child.isVariableDeclaration()) {
            kind = "block";
          } else {
            return;
          }
        }
        Object.keys(child.getOuterBindingIdentifiers()).forEach((name2) => {
          bindingKindLookup.set(name2, kind);
        });
      });
      const localMetadata = /* @__PURE__ */ new Map();
      const getLocalMetadata = (idPath) => {
        const localName = idPath.node.name;
        let metadata = localMetadata.get(localName);
        if (!metadata) {
          const kind = bindingKindLookup.get(localName);
          if (kind === void 0) {
            throw idPath.buildCodeFrameError(`Exporting local "${localName}", which is not declared.`);
          }
          metadata = {
            names: [],
            kind
          };
          localMetadata.set(localName, metadata);
        }
        return metadata;
      };
      programPath.get("body").forEach((child) => {
        if (child.isExportNamedDeclaration() && (initializeReexports || !child.node.source)) {
          if (child.node.declaration) {
            const declaration = child.get("declaration");
            const ids = declaration.getOuterBindingIdentifierPaths();
            Object.keys(ids).forEach((name2) => {
              if (name2 === "__esModule") {
                throw declaration.buildCodeFrameError('Illegal export "__esModule".');
              }
              getLocalMetadata(ids[name2]).names.push(name2);
            });
          } else {
            child.get("specifiers").forEach((spec) => {
              const local = spec.get("local");
              const exported = spec.get("exported");
              const localMetadata2 = getLocalMetadata(local);
              const exportName = getExportSpecifierName(exported, stringSpecifiers);
              if (exportName === "__esModule") {
                throw exported.buildCodeFrameError('Illegal export "__esModule".');
              }
              localMetadata2.names.push(exportName);
            });
          }
        } else if (child.isExportDefaultDeclaration()) {
          const declaration = child.get("declaration");
          if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
            getLocalMetadata(declaration.get("id")).names.push("default");
          } else {
            throw declaration.buildCodeFrameError("Unexpected default expression export.");
          }
        }
      });
      return localMetadata;
    }
    function nameAnonymousExports(programPath) {
      programPath.get("body").forEach((child) => {
        if (!child.isExportDefaultDeclaration()) return;
        {
          var _child$splitExportDec;
          (_child$splitExportDec = child.splitExportDeclaration) != null ? _child$splitExportDec : child.splitExportDeclaration = require_lib9().NodePath.prototype.splitExportDeclaration;
        }
        child.splitExportDeclaration();
      });
    }
    function removeImportExportDeclarations(programPath) {
      programPath.get("body").forEach((child) => {
        if (child.isImportDeclaration()) {
          child.remove();
        } else if (child.isExportNamedDeclaration()) {
          if (child.node.declaration) {
            child.node.declaration._blockHoist = child.node._blockHoist;
            child.replaceWith(child.node.declaration);
          } else {
            child.remove();
          }
        } else if (child.isExportDefaultDeclaration()) {
          const declaration = child.get("declaration");
          if (declaration.isFunctionDeclaration() || declaration.isClassDeclaration()) {
            declaration._blockHoist = child.node._blockHoist;
            child.replaceWith(declaration);
          } else {
            throw declaration.buildCodeFrameError("Unexpected default expression export.");
          }
        } else if (child.isExportAllDeclaration()) {
          child.remove();
        }
      });
    }
  }
});

// node_modules/@babel/helper-module-transforms/lib/lazy-modules.js
var require_lazy_modules = __commonJS({
  "node_modules/@babel/helper-module-transforms/lib/lazy-modules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toGetWrapperPayload = toGetWrapperPayload;
    exports2.wrapReference = wrapReference;
    var _core = require_lib15();
    var _normalizeAndLoadMetadata = require_normalize_and_load_metadata();
    function toGetWrapperPayload(lazy) {
      return (source, metadata) => {
        if (lazy === false) return null;
        if ((0, _normalizeAndLoadMetadata.isSideEffectImport)(metadata) || metadata.reexportAll) return null;
        if (lazy === true) {
          return source.includes(".") ? null : "lazy";
        }
        if (Array.isArray(lazy)) {
          return !lazy.includes(source) ? null : "lazy";
        }
        if (typeof lazy === "function") {
          return lazy(source) ? "lazy" : null;
        }
        throw new Error(`.lazy must be a boolean, string array, or function`);
      };
    }
    function wrapReference(ref, payload) {
      if (payload === "lazy") return _core.types.callExpression(ref, []);
      return null;
    }
  }
});

// node_modules/@babel/helper-module-transforms/lib/dynamic-import.js
var require_dynamic_import = __commonJS({
  "node_modules/@babel/helper-module-transforms/lib/dynamic-import.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildDynamicImport = buildDynamicImport;
    var _core = require_lib15();
    {
      exports2.getDynamicImportSource = function getDynamicImportSource(node3) {
        const [source] = node3.arguments;
        return _core.types.isStringLiteral(source) || _core.types.isTemplateLiteral(source) ? source : _core.template.expression.ast`\`\${${source}}\``;
      };
    }
    function buildDynamicImport(node3, deferToThen, wrapWithPromise, builder) {
      const specifier = _core.types.isCallExpression(node3) ? node3.arguments[0] : node3.source;
      if (_core.types.isStringLiteral(specifier) || _core.types.isTemplateLiteral(specifier) && specifier.quasis.length === 0) {
        if (deferToThen) {
          return _core.template.expression.ast`
        Promise.resolve().then(() => ${builder(specifier)})
      `;
        } else return builder(specifier);
      }
      const specifierToString = _core.types.isTemplateLiteral(specifier) ? _core.types.identifier("specifier") : _core.types.templateLiteral([_core.types.templateElement({
        raw: ""
      }), _core.types.templateElement({
        raw: ""
      })], [_core.types.identifier("specifier")]);
      if (deferToThen) {
        return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${specifierToString}))
          .then(s => ${builder(_core.types.identifier("s"))})
      )(${specifier})
    `;
      } else if (wrapWithPromise) {
        return _core.template.expression.ast`
      (specifier =>
        new Promise(r => r(${builder(specifierToString)}))
      )(${specifier})
    `;
      } else {
        return _core.template.expression.ast`
      (specifier => ${builder(specifierToString)})(${specifier})
    `;
      }
    }
  }
});

// node_modules/@babel/helper-module-transforms/lib/get-module-name.js
var require_get_module_name = __commonJS({
  "node_modules/@babel/helper-module-transforms/lib/get-module-name.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = getModuleName;
    {
      const originalGetModuleName = getModuleName;
      exports2.default = getModuleName = function getModuleName2(rootOpts, pluginOpts) {
        var _pluginOpts$moduleId, _pluginOpts$moduleIds, _pluginOpts$getModule, _pluginOpts$moduleRoo;
        return originalGetModuleName(rootOpts, {
          moduleId: (_pluginOpts$moduleId = pluginOpts.moduleId) != null ? _pluginOpts$moduleId : rootOpts.moduleId,
          moduleIds: (_pluginOpts$moduleIds = pluginOpts.moduleIds) != null ? _pluginOpts$moduleIds : rootOpts.moduleIds,
          getModuleId: (_pluginOpts$getModule = pluginOpts.getModuleId) != null ? _pluginOpts$getModule : rootOpts.getModuleId,
          moduleRoot: (_pluginOpts$moduleRoo = pluginOpts.moduleRoot) != null ? _pluginOpts$moduleRoo : rootOpts.moduleRoot
        });
      };
    }
    function getModuleName(rootOpts, pluginOpts) {
      const {
        filename,
        filenameRelative = filename,
        sourceRoot = pluginOpts.moduleRoot
      } = rootOpts;
      const {
        moduleId,
        moduleIds = !!moduleId,
        getModuleId,
        moduleRoot = sourceRoot
      } = pluginOpts;
      if (!moduleIds) return null;
      if (moduleId != null && !getModuleId) {
        return moduleId;
      }
      let moduleName = moduleRoot != null ? moduleRoot + "/" : "";
      if (filenameRelative) {
        const sourceRootReplacer = sourceRoot != null ? new RegExp("^" + sourceRoot + "/?") : "";
        moduleName += filenameRelative.replace(sourceRootReplacer, "").replace(/\.\w*$/, "");
      }
      moduleName = moduleName.replace(/\\/g, "/");
      if (getModuleId) {
        return getModuleId(moduleName) || moduleName;
      } else {
        return moduleName;
      }
    }
  }
});

// node_modules/@babel/helper-module-transforms/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/@babel/helper-module-transforms/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "buildDynamicImport", {
      enumerable: true,
      get: function() {
        return _dynamicImport.buildDynamicImport;
      }
    });
    exports2.buildNamespaceInitStatements = buildNamespaceInitStatements;
    exports2.ensureStatementsHoisted = ensureStatementsHoisted;
    Object.defineProperty(exports2, "getModuleName", {
      enumerable: true,
      get: function() {
        return _getModuleName.default;
      }
    });
    Object.defineProperty(exports2, "hasExports", {
      enumerable: true,
      get: function() {
        return _normalizeAndLoadMetadata.hasExports;
      }
    });
    Object.defineProperty(exports2, "isModule", {
      enumerable: true,
      get: function() {
        return _helperModuleImports.isModule;
      }
    });
    Object.defineProperty(exports2, "isSideEffectImport", {
      enumerable: true,
      get: function() {
        return _normalizeAndLoadMetadata.isSideEffectImport;
      }
    });
    exports2.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;
    Object.defineProperty(exports2, "rewriteThis", {
      enumerable: true,
      get: function() {
        return _rewriteThis.default;
      }
    });
    exports2.wrapInterop = wrapInterop;
    var _assert = __require("assert");
    var _core = require_lib15();
    var _helperModuleImports = require_lib10();
    var _rewriteThis = require_rewrite_this();
    var _rewriteLiveReferences = require_rewrite_live_references();
    var _normalizeAndLoadMetadata = require_normalize_and_load_metadata();
    var Lazy = require_lazy_modules();
    var _dynamicImport = require_dynamic_import();
    var _getModuleName = require_get_module_name();
    {
      exports2.getDynamicImportSource = require_dynamic_import().getDynamicImportSource;
    }
    function rewriteModuleStatementsAndPrepareHeader(path9, {
      exportName,
      strict,
      allowTopLevelThis,
      strictMode,
      noInterop,
      importInterop = noInterop ? "none" : "babel",
      lazy,
      getWrapperPayload = Lazy.toGetWrapperPayload(lazy != null ? lazy : false),
      wrapReference = Lazy.wrapReference,
      esNamespaceOnly,
      filename,
      constantReexports = arguments[1].loose,
      enumerableModuleMeta = arguments[1].loose,
      noIncompleteNsImportDetection
    }) {
      (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);
      _assert((0, _helperModuleImports.isModule)(path9), "Cannot process module statements in a script");
      path9.node.sourceType = "script";
      const meta = (0, _normalizeAndLoadMetadata.default)(path9, exportName, {
        importInterop,
        initializeReexports: constantReexports,
        getWrapperPayload,
        esNamespaceOnly,
        filename
      });
      if (!allowTopLevelThis) {
        (0, _rewriteThis.default)(path9);
      }
      (0, _rewriteLiveReferences.default)(path9, meta, wrapReference);
      if (strictMode !== false) {
        const hasStrict = path9.node.directives.some((directive) => {
          return directive.value.value === "use strict";
        });
        if (!hasStrict) {
          path9.unshiftContainer("directives", _core.types.directive(_core.types.directiveLiteral("use strict")));
        }
      }
      const headers = [];
      if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {
        headers.push(buildESModuleHeader(meta, enumerableModuleMeta));
      }
      const nameList = buildExportNameListDeclaration(path9, meta);
      if (nameList) {
        meta.exportNameListName = nameList.name;
        headers.push(nameList.statement);
      }
      headers.push(...buildExportInitializationStatements(path9, meta, wrapReference, constantReexports, noIncompleteNsImportDetection));
      return {
        meta,
        headers
      };
    }
    function ensureStatementsHoisted(statements) {
      statements.forEach((header) => {
        header._blockHoist = 3;
      });
    }
    function wrapInterop(programPath, expr, type) {
      if (type === "none") {
        return null;
      }
      if (type === "node-namespace") {
        return _core.types.callExpression(programPath.hub.addHelper("interopRequireWildcard"), [expr, _core.types.booleanLiteral(true)]);
      } else if (type === "node-default") {
        return null;
      }
      let helper;
      if (type === "default") {
        helper = "interopRequireDefault";
      } else if (type === "namespace") {
        helper = "interopRequireWildcard";
      } else {
        throw new Error(`Unknown interop: ${type}`);
      }
      return _core.types.callExpression(programPath.hub.addHelper(helper), [expr]);
    }
    function buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false, wrapReference = Lazy.wrapReference) {
      var _wrapReference;
      const statements = [];
      const srcNamespaceId = _core.types.identifier(sourceMetadata.name);
      for (const localName of sourceMetadata.importsNamespace) {
        if (localName === sourceMetadata.name) continue;
        statements.push(_core.template.statement`var NAME = SOURCE;`({
          NAME: localName,
          SOURCE: _core.types.cloneNode(srcNamespaceId)
        }));
      }
      const srcNamespace = (_wrapReference = wrapReference(srcNamespaceId, sourceMetadata.wrap)) != null ? _wrapReference : srcNamespaceId;
      if (constantReexports) {
        statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true, wrapReference));
      }
      for (const exportName of sourceMetadata.reexportNamespace) {
        statements.push((!_core.types.isIdentifier(srcNamespace) ? _core.template.statement`
            Object.defineProperty(EXPORTS, "NAME", {
              enumerable: true,
              get: function() {
                return NAMESPACE;
              }
            });
          ` : _core.template.statement`EXPORTS.NAME = NAMESPACE;`)({
          EXPORTS: metadata.exportName,
          NAME: exportName,
          NAMESPACE: _core.types.cloneNode(srcNamespace)
        }));
      }
      if (sourceMetadata.reexportAll) {
        const statement = buildNamespaceReexport(metadata, _core.types.cloneNode(srcNamespace), constantReexports);
        statement.loc = sourceMetadata.reexportAll.loc;
        statements.push(statement);
      }
      return statements;
    }
    var ReexportTemplate = {
      constant: ({
        exports: exports3,
        exportName,
        namespaceImport
      }) => _core.template.statement.ast`
      ${exports3}.${exportName} = ${namespaceImport};
    `,
      constantComputed: ({
        exports: exports3,
        exportName,
        namespaceImport
      }) => _core.template.statement.ast`
      ${exports3}["${exportName}"] = ${namespaceImport};
    `,
      spec: ({
        exports: exports3,
        exportName,
        namespaceImport
      }) => _core.template.statement.ast`
      Object.defineProperty(${exports3}, "${exportName}", {
        enumerable: true,
        get: function() {
          return ${namespaceImport};
        },
      });
    `
    };
    function buildReexportsFromMeta(meta, metadata, constantReexports, wrapReference) {
      var _wrapReference2;
      let namespace2 = _core.types.identifier(metadata.name);
      namespace2 = (_wrapReference2 = wrapReference(namespace2, metadata.wrap)) != null ? _wrapReference2 : namespace2;
      const {
        stringSpecifiers
      } = meta;
      return Array.from(metadata.reexports, ([exportName, importName]) => {
        let namespaceImport = _core.types.cloneNode(namespace2);
        if (importName === "default" && metadata.interop === "node-default") {
        } else if (stringSpecifiers.has(importName)) {
          namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.stringLiteral(importName), true);
        } else {
          namespaceImport = _core.types.memberExpression(namespaceImport, _core.types.identifier(importName));
        }
        const astNodes = {
          exports: meta.exportName,
          exportName,
          namespaceImport
        };
        if (constantReexports || _core.types.isIdentifier(namespaceImport)) {
          if (stringSpecifiers.has(exportName)) {
            return ReexportTemplate.constantComputed(astNodes);
          } else {
            return ReexportTemplate.constant(astNodes);
          }
        } else {
          return ReexportTemplate.spec(astNodes);
        }
      });
    }
    function buildESModuleHeader(metadata, enumerableModuleMeta = false) {
      return (enumerableModuleMeta ? _core.template.statement`
        EXPORTS.__esModule = true;
      ` : _core.template.statement`
        Object.defineProperty(EXPORTS, "__esModule", {
          value: true,
        });
      `)({
        EXPORTS: metadata.exportName
      });
    }
    function buildNamespaceReexport(metadata, namespace2, constantReexports) {
      return (constantReexports ? _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          EXPORTS[key] = NAMESPACE[key];
        });
      ` : _core.template.statement`
        Object.keys(NAMESPACE).forEach(function(key) {
          if (key === "default" || key === "__esModule") return;
          VERIFY_NAME_LIST;
          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;

          Object.defineProperty(EXPORTS, key, {
            enumerable: true,
            get: function() {
              return NAMESPACE[key];
            },
          });
        });
    `)({
        NAMESPACE: namespace2,
        EXPORTS: metadata.exportName,
        VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _core.template)`
            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;
          `({
          EXPORTS_LIST: metadata.exportNameListName
        }) : null
      });
    }
    function buildExportNameListDeclaration(programPath, metadata) {
      const exportedVars = /* @__PURE__ */ Object.create(null);
      for (const data of metadata.local.values()) {
        for (const name3 of data.names) {
          exportedVars[name3] = true;
        }
      }
      let hasReexport = false;
      for (const data of metadata.source.values()) {
        for (const exportName of data.reexports.keys()) {
          exportedVars[exportName] = true;
        }
        for (const exportName of data.reexportNamespace) {
          exportedVars[exportName] = true;
        }
        hasReexport = hasReexport || !!data.reexportAll;
      }
      if (!hasReexport || Object.keys(exportedVars).length === 0) return null;
      const name2 = programPath.scope.generateUidIdentifier("exportNames");
      delete exportedVars.default;
      return {
        name: name2.name,
        statement: _core.types.variableDeclaration("var", [_core.types.variableDeclarator(name2, _core.types.valueToNode(exportedVars))])
      };
    }
    function buildExportInitializationStatements(programPath, metadata, wrapReference, constantReexports = false, noIncompleteNsImportDetection = false) {
      const initStatements = [];
      for (const [localName, data] of metadata.local) {
        if (data.kind === "import") {
        } else if (data.kind === "hoisted") {
          initStatements.push([data.names[0], buildInitStatement(metadata, data.names, _core.types.identifier(localName))]);
        } else if (!noIncompleteNsImportDetection) {
          for (const exportName of data.names) {
            initStatements.push([exportName, null]);
          }
        }
      }
      for (const data of metadata.source.values()) {
        if (!constantReexports) {
          const reexportsStatements = buildReexportsFromMeta(metadata, data, false, wrapReference);
          const reexports = [...data.reexports.keys()];
          for (let i = 0; i < reexportsStatements.length; i++) {
            initStatements.push([reexports[i], reexportsStatements[i]]);
          }
        }
        if (!noIncompleteNsImportDetection) {
          for (const exportName of data.reexportNamespace) {
            initStatements.push([exportName, null]);
          }
        }
      }
      initStatements.sort(([a], [b]) => {
        if (a < b) return -1;
        if (b < a) return 1;
        return 0;
      });
      const results = [];
      if (noIncompleteNsImportDetection) {
        for (const [, initStatement] of initStatements) {
          results.push(initStatement);
        }
      } else {
        const chunkSize = 100;
        for (let i = 0; i < initStatements.length; i += chunkSize) {
          let uninitializedExportNames = [];
          for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {
            const [exportName, initStatement] = initStatements[i + j];
            if (initStatement !== null) {
              if (uninitializedExportNames.length > 0) {
                results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
                uninitializedExportNames = [];
              }
              results.push(initStatement);
            } else {
              uninitializedExportNames.push(exportName);
            }
          }
          if (uninitializedExportNames.length > 0) {
            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));
          }
        }
      }
      return results;
    }
    var InitTemplate = {
      computed: ({
        exports: exports3,
        name: name2,
        value: value2
      }) => _core.template.expression.ast`${exports3}["${name2}"] = ${value2}`,
      default: ({
        exports: exports3,
        name: name2,
        value: value2
      }) => _core.template.expression.ast`${exports3}.${name2} = ${value2}`,
      define: ({
        exports: exports3,
        name: name2,
        value: value2
      }) => _core.template.expression.ast`
      Object.defineProperty(${exports3}, "${name2}", {
        enumerable: true,
        value: void 0,
        writable: true
      })["${name2}"] = ${value2}`
    };
    function buildInitStatement(metadata, exportNames, initExpr) {
      const {
        stringSpecifiers,
        exportName: exports3
      } = metadata;
      return _core.types.expressionStatement(exportNames.reduce((value2, name2) => {
        const params = {
          exports: exports3,
          name: name2,
          value: value2
        };
        if (name2 === "__proto__") {
          return InitTemplate.define(params);
        }
        if (stringSpecifiers.has(name2)) {
          return InitTemplate.computed(params);
        }
        return InitTemplate.default(params);
      }, initExpr));
    }
  }
});

// node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs
var require_babel_7_helpers = __commonJS({
  "node_modules/@babel/core/lib/transformation/file/babel-7-helpers.cjs"(exports2) {
    exports2.getModuleName = () => require_lib11().getModuleName;
  }
});

// node_modules/@babel/core/lib/transformation/file/file.js
var require_file = __commonJS({
  "node_modules/@babel/core/lib/transformation/file/file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function helpers() {
      const data = require_lib7();
      helpers = function() {
        return data;
      };
      return data;
    }
    function _traverse() {
      const data = require_lib9();
      _traverse = function() {
        return data;
      };
      return data;
    }
    function _codeFrame() {
      const data = require_lib5();
      _codeFrame = function() {
        return data;
      };
      return data;
    }
    function _t() {
      const data = require_lib3();
      _t = function() {
        return data;
      };
      return data;
    }
    function _semver() {
      const data = require_semver();
      _semver = function() {
        return data;
      };
      return data;
    }
    var babel7 = _interopRequireWildcard(require_babel_7_helpers(), true);
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var {
      cloneNode,
      interpreterDirective
    } = _t();
    var errorVisitor = {
      enter(path9, state) {
        const loc = path9.node.loc;
        if (loc) {
          state.loc = loc;
          path9.stop();
        }
      }
    };
    var File = class {
      constructor(options2, {
        code,
        ast,
        inputMap
      }) {
        this._map = /* @__PURE__ */ new Map();
        this.opts = void 0;
        this.declarations = {};
        this.path = void 0;
        this.ast = void 0;
        this.scope = void 0;
        this.metadata = {};
        this.code = "";
        this.inputMap = void 0;
        this.hub = {
          file: this,
          getCode: () => this.code,
          getScope: () => this.scope,
          addHelper: this.addHelper.bind(this),
          buildError: this.buildCodeFrameError.bind(this)
        };
        this.opts = options2;
        this.code = code;
        this.ast = ast;
        this.inputMap = inputMap;
        this.path = _traverse().NodePath.get({
          hub: this.hub,
          parentPath: null,
          parent: this.ast,
          container: this.ast,
          key: "program"
        }).setContext();
        this.scope = this.path.scope;
      }
      get shebang() {
        const {
          interpreter
        } = this.path.node;
        return interpreter ? interpreter.value : "";
      }
      set shebang(value2) {
        if (value2) {
          this.path.get("interpreter").replaceWith(interpreterDirective(value2));
        } else {
          this.path.get("interpreter").remove();
        }
      }
      set(key, val) {
        {
          if (key === "helpersNamespace") {
            throw new Error("Babel 7.0.0-beta.56 has dropped support for the 'helpersNamespace' utility.If you are using @babel/plugin-external-helpers you will need to use a newer version than the one you currently have installed. If you have your own implementation, you'll want to explore using 'helperGenerator' alongside 'file.availableHelper()'.");
          }
        }
        this._map.set(key, val);
      }
      get(key) {
        return this._map.get(key);
      }
      has(key) {
        return this._map.has(key);
      }
      availableHelper(name2, versionRange) {
        let minVersion;
        try {
          minVersion = helpers().minVersion(name2);
        } catch (err) {
          if (err.code !== "BABEL_HELPER_UNKNOWN") throw err;
          return false;
        }
        if (typeof versionRange !== "string") return true;
        if (_semver().valid(versionRange)) versionRange = `^${versionRange}`;
        {
          return !_semver().intersects(`<${minVersion}`, versionRange) && !_semver().intersects(`>=8.0.0`, versionRange);
        }
      }
      addHelper(name2) {
        const declar = this.declarations[name2];
        if (declar) return cloneNode(declar);
        const generator = this.get("helperGenerator");
        if (generator) {
          const res = generator(name2);
          if (res) return res;
        }
        helpers().minVersion(name2);
        const uid = this.declarations[name2] = this.scope.generateUidIdentifier(name2);
        const dependencies = {};
        for (const dep of helpers().getDependencies(name2)) {
          dependencies[dep] = this.addHelper(dep);
        }
        const {
          nodes,
          globals
        } = helpers().get(name2, (dep) => dependencies[dep], uid.name, Object.keys(this.scope.getAllBindings()));
        globals.forEach((name3) => {
          if (this.path.scope.hasBinding(name3, true)) {
            this.path.scope.rename(name3);
          }
        });
        nodes.forEach((node3) => {
          node3._compact = true;
        });
        const added = this.path.unshiftContainer("body", nodes);
        for (const path9 of added) {
          if (path9.isVariableDeclaration()) this.scope.registerDeclaration(path9);
        }
        return uid;
      }
      buildCodeFrameError(node3, msg, _Error = SyntaxError) {
        let loc = node3 == null ? void 0 : node3.loc;
        if (!loc && node3) {
          const state = {
            loc: null
          };
          (0, _traverse().default)(node3, errorVisitor, this.scope, state);
          loc = state.loc;
          let txt = "This is an error on an internal node. Probably an internal error.";
          if (loc) txt += " Location has been estimated.";
          msg += ` (${txt})`;
        }
        if (loc) {
          const {
            highlightCode = true
          } = this.opts;
          msg += "\n" + (0, _codeFrame().codeFrameColumns)(this.code, {
            start: {
              line: loc.start.line,
              column: loc.start.column + 1
            },
            end: loc.end && loc.start.line === loc.end.line ? {
              line: loc.end.line,
              column: loc.end.column + 1
            } : void 0
          }, {
            highlightCode
          });
        }
        return new _Error(msg);
      }
    };
    exports2.default = File;
    {
      File.prototype.addImport = function addImport() {
        throw new Error("This API has been removed. If you're looking for this functionality in Babel 7, you should import the '@babel/helper-module-imports' module and use the functions exposed  from that module, such as 'addNamed' or 'addDefault'.");
      };
      File.prototype.addTemplateObject = function addTemplateObject() {
        throw new Error("This function has been moved into the template literal transform itself.");
      };
      {
        File.prototype.getModuleName = function getModuleName() {
          return babel7.getModuleName()(this.opts, this.opts);
        };
      }
    }
  }
});

// node_modules/@babel/core/lib/tools/build-external-helpers.js
var require_build_external_helpers = __commonJS({
  "node_modules/@babel/core/lib/tools/build-external-helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    function helpers() {
      const data = require_lib7();
      helpers = function() {
        return data;
      };
      return data;
    }
    function _generator() {
      const data = require_lib8();
      _generator = function() {
        return data;
      };
      return data;
    }
    function _template() {
      const data = require_lib6();
      _template = function() {
        return data;
      };
      return data;
    }
    function _t() {
      const data = require_lib3();
      _t = function() {
        return data;
      };
      return data;
    }
    var {
      arrayExpression,
      assignmentExpression,
      binaryExpression,
      blockStatement,
      callExpression,
      cloneNode,
      conditionalExpression,
      exportNamedDeclaration,
      exportSpecifier,
      expressionStatement,
      functionExpression,
      identifier,
      memberExpression,
      objectExpression,
      program,
      stringLiteral,
      unaryExpression,
      variableDeclaration,
      variableDeclarator
    } = _t();
    var buildUmdWrapper = (replacements) => _template().default.statement`
    (function (root, factory) {
      if (typeof define === "function" && define.amd) {
        define(AMD_ARGUMENTS, factory);
      } else if (typeof exports === "object") {
        factory(COMMON_ARGUMENTS);
      } else {
        factory(BROWSER_ARGUMENTS);
      }
    })(UMD_ROOT, function (FACTORY_PARAMETERS) {
      FACTORY_BODY
    });
  `(replacements);
    function buildGlobal(allowlist) {
      const namespace2 = identifier("babelHelpers");
      const body = [];
      const container2 = functionExpression(null, [identifier("global")], blockStatement(body));
      const tree = program([expressionStatement(callExpression(container2, [conditionalExpression(binaryExpression("===", unaryExpression("typeof", identifier("global")), stringLiteral("undefined")), identifier("self"), identifier("global"))]))]);
      body.push(variableDeclaration("var", [variableDeclarator(namespace2, assignmentExpression("=", memberExpression(identifier("global"), namespace2), objectExpression([])))]));
      buildHelpers(body, namespace2, allowlist);
      return tree;
    }
    function buildModule(allowlist) {
      const body = [];
      const refs = buildHelpers(body, null, allowlist);
      body.unshift(exportNamedDeclaration(null, Object.keys(refs).map((name2) => {
        return exportSpecifier(cloneNode(refs[name2]), identifier(name2));
      })));
      return program(body, [], "module");
    }
    function buildUmd(allowlist) {
      const namespace2 = identifier("babelHelpers");
      const body = [];
      body.push(variableDeclaration("var", [variableDeclarator(namespace2, identifier("global"))]));
      buildHelpers(body, namespace2, allowlist);
      return program([buildUmdWrapper({
        FACTORY_PARAMETERS: identifier("global"),
        BROWSER_ARGUMENTS: assignmentExpression("=", memberExpression(identifier("root"), namespace2), objectExpression([])),
        COMMON_ARGUMENTS: identifier("exports"),
        AMD_ARGUMENTS: arrayExpression([stringLiteral("exports")]),
        FACTORY_BODY: body,
        UMD_ROOT: identifier("this")
      })]);
    }
    function buildVar(allowlist) {
      const namespace2 = identifier("babelHelpers");
      const body = [];
      body.push(variableDeclaration("var", [variableDeclarator(namespace2, objectExpression([]))]));
      const tree = program(body);
      buildHelpers(body, namespace2, allowlist);
      body.push(expressionStatement(namespace2));
      return tree;
    }
    function buildHelpers(body, namespace2, allowlist) {
      const getHelperReference = (name2) => {
        return namespace2 ? memberExpression(namespace2, identifier(name2)) : identifier(`_${name2}`);
      };
      const refs = {};
      helpers().list.forEach(function(name2) {
        if (allowlist && !allowlist.includes(name2)) return;
        const ref = refs[name2] = getHelperReference(name2);
        const {
          nodes
        } = helpers().get(name2, getHelperReference, namespace2 ? null : `_${name2}`, [], namespace2 ? (ast, exportName, mapExportBindingAssignments) => {
          mapExportBindingAssignments((node3) => assignmentExpression("=", ref, node3));
          ast.body.push(expressionStatement(assignmentExpression("=", ref, identifier(exportName))));
        } : null);
        body.push(...nodes);
      });
      return refs;
    }
    function _default(allowlist, outputType = "global") {
      let tree;
      const build3 = {
        global: buildGlobal,
        module: buildModule,
        umd: buildUmd,
        var: buildVar
      }[outputType];
      if (build3) {
        tree = build3(allowlist);
      } else {
        throw new Error(`Unsupported output type ${outputType}`);
      }
      return (0, _generator().default)(tree).code;
    }
  }
});

// node_modules/gensync/index.js
var require_gensync = __commonJS({
  "node_modules/gensync/index.js"(exports2, module) {
    "use strict";
    var GENSYNC_START = Symbol.for("gensync:v1:start");
    var GENSYNC_SUSPEND = Symbol.for("gensync:v1:suspend");
    var GENSYNC_EXPECTED_START = "GENSYNC_EXPECTED_START";
    var GENSYNC_EXPECTED_SUSPEND = "GENSYNC_EXPECTED_SUSPEND";
    var GENSYNC_OPTIONS_ERROR = "GENSYNC_OPTIONS_ERROR";
    var GENSYNC_RACE_NONEMPTY = "GENSYNC_RACE_NONEMPTY";
    var GENSYNC_ERRBACK_NO_CALLBACK = "GENSYNC_ERRBACK_NO_CALLBACK";
    module.exports = Object.assign(
      function gensync(optsOrFn) {
        let genFn = optsOrFn;
        if (typeof optsOrFn !== "function") {
          genFn = newGenerator(optsOrFn);
        } else {
          genFn = wrapGenerator(optsOrFn);
        }
        return Object.assign(genFn, makeFunctionAPI(genFn));
      },
      {
        all: buildOperation({
          name: "all",
          arity: 1,
          sync: function(args) {
            const items = Array.from(args[0]);
            return items.map((item) => evaluateSync(item));
          },
          async: function(args, resolve8, reject) {
            const items = Array.from(args[0]);
            if (items.length === 0) {
              Promise.resolve().then(() => resolve8([]));
              return;
            }
            let count = 0;
            const results = items.map(() => void 0);
            items.forEach((item, i) => {
              evaluateAsync(
                item,
                (val) => {
                  results[i] = val;
                  count += 1;
                  if (count === results.length) resolve8(results);
                },
                reject
              );
            });
          }
        }),
        race: buildOperation({
          name: "race",
          arity: 1,
          sync: function(args) {
            const items = Array.from(args[0]);
            if (items.length === 0) {
              throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
            }
            return evaluateSync(items[0]);
          },
          async: function(args, resolve8, reject) {
            const items = Array.from(args[0]);
            if (items.length === 0) {
              throw makeError("Must race at least 1 item", GENSYNC_RACE_NONEMPTY);
            }
            for (const item of items) {
              evaluateAsync(item, resolve8, reject);
            }
          }
        })
      }
    );
    function makeFunctionAPI(genFn) {
      const fns = {
        sync: function(...args) {
          return evaluateSync(genFn.apply(this, args));
        },
        async: function(...args) {
          return new Promise((resolve8, reject) => {
            evaluateAsync(genFn.apply(this, args), resolve8, reject);
          });
        },
        errback: function(...args) {
          const cb = args.pop();
          if (typeof cb !== "function") {
            throw makeError(
              "Asynchronous function called without callback",
              GENSYNC_ERRBACK_NO_CALLBACK
            );
          }
          let gen;
          try {
            gen = genFn.apply(this, args);
          } catch (err) {
            cb(err);
            return;
          }
          evaluateAsync(gen, (val) => cb(void 0, val), (err) => cb(err));
        }
      };
      return fns;
    }
    function assertTypeof(type, name2, value2, allowUndefined) {
      if (typeof value2 === type || allowUndefined && typeof value2 === "undefined") {
        return;
      }
      let msg;
      if (allowUndefined) {
        msg = `Expected opts.${name2} to be either a ${type}, or undefined.`;
      } else {
        msg = `Expected opts.${name2} to be a ${type}.`;
      }
      throw makeError(msg, GENSYNC_OPTIONS_ERROR);
    }
    function makeError(msg, code) {
      return Object.assign(new Error(msg), { code });
    }
    function newGenerator({ name: name2, arity, sync: sync2, async: async2, errback }) {
      assertTypeof(
        "string",
        "name",
        name2,
        true
        /* allowUndefined */
      );
      assertTypeof(
        "number",
        "arity",
        arity,
        true
        /* allowUndefined */
      );
      assertTypeof("function", "sync", sync2);
      assertTypeof(
        "function",
        "async",
        async2,
        true
        /* allowUndefined */
      );
      assertTypeof(
        "function",
        "errback",
        errback,
        true
        /* allowUndefined */
      );
      if (async2 && errback) {
        throw makeError(
          "Expected one of either opts.async or opts.errback, but got _both_.",
          GENSYNC_OPTIONS_ERROR
        );
      }
      if (typeof name2 !== "string") {
        let fnName;
        if (errback && errback.name && errback.name !== "errback") {
          fnName = errback.name;
        }
        if (async2 && async2.name && async2.name !== "async") {
          fnName = async2.name.replace(/Async$/, "");
        }
        if (sync2 && sync2.name && sync2.name !== "sync") {
          fnName = sync2.name.replace(/Sync$/, "");
        }
        if (typeof fnName === "string") {
          name2 = fnName;
        }
      }
      if (typeof arity !== "number") {
        arity = sync2.length;
      }
      return buildOperation({
        name: name2,
        arity,
        sync: function(args) {
          return sync2.apply(this, args);
        },
        async: function(args, resolve8, reject) {
          if (async2) {
            async2.apply(this, args).then(resolve8, reject);
          } else if (errback) {
            errback.call(this, ...args, (err, value2) => {
              if (err == null) resolve8(value2);
              else reject(err);
            });
          } else {
            resolve8(sync2.apply(this, args));
          }
        }
      });
    }
    function wrapGenerator(genFn) {
      return setFunctionMetadata(genFn.name, genFn.length, function(...args) {
        return genFn.apply(this, args);
      });
    }
    function buildOperation({ name: name2, arity, sync: sync2, async: async2 }) {
      return setFunctionMetadata(name2, arity, function* (...args) {
        const resume2 = yield GENSYNC_START;
        if (!resume2) {
          const res = sync2.call(this, args);
          return res;
        }
        let result;
        try {
          async2.call(
            this,
            args,
            (value2) => {
              if (result) return;
              result = { value: value2 };
              resume2();
            },
            (err) => {
              if (result) return;
              result = { err };
              resume2();
            }
          );
        } catch (err) {
          result = { err };
          resume2();
        }
        yield GENSYNC_SUSPEND;
        if (result.hasOwnProperty("err")) {
          throw result.err;
        }
        return result.value;
      });
    }
    function evaluateSync(gen) {
      let value2;
      while (!({ value: value2 } = gen.next()).done) {
        assertStart(value2, gen);
      }
      return value2;
    }
    function evaluateAsync(gen, resolve8, reject) {
      (function step() {
        try {
          let value2;
          while (!({ value: value2 } = gen.next()).done) {
            assertStart(value2, gen);
            let sync2 = true;
            let didSyncResume = false;
            const out = gen.next(() => {
              if (sync2) {
                didSyncResume = true;
              } else {
                step();
              }
            });
            sync2 = false;
            assertSuspend(out, gen);
            if (!didSyncResume) {
              return;
            }
          }
          return resolve8(value2);
        } catch (err) {
          return reject(err);
        }
      })();
    }
    function assertStart(value2, gen) {
      if (value2 === GENSYNC_START) return;
      throwError(
        gen,
        makeError(
          `Got unexpected yielded value in gensync generator: ${JSON.stringify(
            value2
          )}. Did you perhaps mean to use 'yield*' instead of 'yield'?`,
          GENSYNC_EXPECTED_START
        )
      );
    }
    function assertSuspend({ value: value2, done }, gen) {
      if (!done && value2 === GENSYNC_SUSPEND) return;
      throwError(
        gen,
        makeError(
          done ? "Unexpected generator completion. If you get this, it is probably a gensync bug." : `Expected GENSYNC_SUSPEND, got ${JSON.stringify(
            value2
          )}. If you get this, it is probably a gensync bug.`,
          GENSYNC_EXPECTED_SUSPEND
        )
      );
    }
    function throwError(gen, err) {
      if (gen.throw) gen.throw(err);
      throw err;
    }
    function setFunctionMetadata(name2, arity, fn) {
      if (typeof name2 === "string") {
        const nameDesc = Object.getOwnPropertyDescriptor(fn, "name");
        if (!nameDesc || nameDesc.configurable) {
          Object.defineProperty(
            fn,
            "name",
            Object.assign(nameDesc || {}, {
              configurable: true,
              value: name2
            })
          );
        }
      }
      if (typeof arity === "number") {
        const lengthDesc = Object.getOwnPropertyDescriptor(fn, "length");
        if (!lengthDesc || lengthDesc.configurable) {
          Object.defineProperty(
            fn,
            "length",
            Object.assign(lengthDesc || {}, {
              configurable: true,
              value: arity
            })
          );
        }
      }
      return fn;
    }
  }
});

// node_modules/@babel/core/lib/gensync-utils/async.js
var require_async = __commonJS({
  "node_modules/@babel/core/lib/gensync-utils/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.forwardAsync = forwardAsync;
    exports2.isAsync = void 0;
    exports2.isThenable = isThenable;
    exports2.maybeAsync = maybeAsync;
    exports2.waitFor = exports2.onFirstPause = void 0;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var runGenerator = _gensync()(function* (item) {
      return yield* item;
    });
    var isAsync = exports2.isAsync = _gensync()({
      sync: () => false,
      errback: (cb) => cb(null, true)
    });
    function maybeAsync(fn, message) {
      return _gensync()({
        sync(...args) {
          const result = fn.apply(this, args);
          if (isThenable(result)) throw new Error(message);
          return result;
        },
        async(...args) {
          return Promise.resolve(fn.apply(this, args));
        }
      });
    }
    var withKind = _gensync()({
      sync: (cb) => cb("sync"),
      async: function() {
        var _ref = _asyncToGenerator(function* (cb) {
          return cb("async");
        });
        return function async2(_x) {
          return _ref.apply(this, arguments);
        };
      }()
    });
    function forwardAsync(action, cb) {
      const g = _gensync()(action);
      return withKind((kind) => {
        const adapted = g[kind];
        return cb(adapted);
      });
    }
    var onFirstPause = exports2.onFirstPause = _gensync()({
      name: "onFirstPause",
      arity: 2,
      sync: function(item) {
        return runGenerator.sync(item);
      },
      errback: function(item, firstPause, cb) {
        let completed = false;
        runGenerator.errback(item, (err, value2) => {
          completed = true;
          cb(err, value2);
        });
        if (!completed) {
          firstPause();
        }
      }
    });
    var waitFor = exports2.waitFor = _gensync()({
      sync: (x) => x,
      async: function() {
        var _ref2 = _asyncToGenerator(function* (x) {
          return x;
        });
        return function async2(_x2) {
          return _ref2.apply(this, arguments);
        };
      }()
    });
    function isThenable(val) {
      return !!val && (typeof val === "object" || typeof val === "function") && !!val.then && typeof val.then === "function";
    }
  }
});

// node_modules/@babel/core/lib/config/util.js
var require_util3 = __commonJS({
  "node_modules/@babel/core/lib/config/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isIterableIterator = isIterableIterator;
    exports2.mergeOptions = mergeOptions;
    function mergeOptions(target, source) {
      for (const k of Object.keys(source)) {
        if ((k === "parserOpts" || k === "generatorOpts" || k === "assumptions") && source[k]) {
          const parserOpts = source[k];
          const targetObj = target[k] || (target[k] = {});
          mergeDefaultFields(targetObj, parserOpts);
        } else {
          const val = source[k];
          if (val !== void 0) target[k] = val;
        }
      }
    }
    function mergeDefaultFields(target, source) {
      for (const k of Object.keys(source)) {
        const val = source[k];
        if (val !== void 0) target[k] = val;
      }
    }
    function isIterableIterator(value2) {
      return !!value2 && typeof value2.next === "function" && typeof value2[Symbol.iterator] === "function";
    }
  }
});

// node_modules/@babel/core/lib/config/caching.js
var require_caching = __commonJS({
  "node_modules/@babel/core/lib/config/caching.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assertSimpleType = assertSimpleType;
    exports2.makeStrongCache = makeStrongCache;
    exports2.makeStrongCacheSync = makeStrongCacheSync;
    exports2.makeWeakCache = makeWeakCache;
    exports2.makeWeakCacheSync = makeWeakCacheSync;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _async = require_async();
    var _util = require_util3();
    var synchronize = (gen) => {
      return _gensync()(gen).sync;
    };
    function* genTrue() {
      return true;
    }
    function makeWeakCache(handler) {
      return makeCachedFunction(WeakMap, handler);
    }
    function makeWeakCacheSync(handler) {
      return synchronize(makeWeakCache(handler));
    }
    function makeStrongCache(handler) {
      return makeCachedFunction(Map, handler);
    }
    function makeStrongCacheSync(handler) {
      return synchronize(makeStrongCache(handler));
    }
    function makeCachedFunction(CallCache, handler) {
      const callCacheSync = new CallCache();
      const callCacheAsync = new CallCache();
      const futureCache = new CallCache();
      return function* cachedFunction(arg, data) {
        const asyncContext = yield* (0, _async.isAsync)();
        const callCache = asyncContext ? callCacheAsync : callCacheSync;
        const cached = yield* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data);
        if (cached.valid) return cached.value;
        const cache2 = new CacheConfigurator(data);
        const handlerResult = handler(arg, cache2);
        let finishLock;
        let value2;
        if ((0, _util.isIterableIterator)(handlerResult)) {
          value2 = yield* (0, _async.onFirstPause)(handlerResult, () => {
            finishLock = setupAsyncLocks(cache2, futureCache, arg);
          });
        } else {
          value2 = handlerResult;
        }
        updateFunctionCache(callCache, cache2, arg, value2);
        if (finishLock) {
          futureCache.delete(arg);
          finishLock.release(value2);
        }
        return value2;
      };
    }
    function* getCachedValue(cache2, arg, data) {
      const cachedValue = cache2.get(arg);
      if (cachedValue) {
        for (const {
          value: value2,
          valid
        } of cachedValue) {
          if (yield* valid(data)) return {
            valid: true,
            value: value2
          };
        }
      }
      return {
        valid: false,
        value: null
      };
    }
    function* getCachedValueOrWait(asyncContext, callCache, futureCache, arg, data) {
      const cached = yield* getCachedValue(callCache, arg, data);
      if (cached.valid) {
        return cached;
      }
      if (asyncContext) {
        const cached2 = yield* getCachedValue(futureCache, arg, data);
        if (cached2.valid) {
          const value2 = yield* (0, _async.waitFor)(cached2.value.promise);
          return {
            valid: true,
            value: value2
          };
        }
      }
      return {
        valid: false,
        value: null
      };
    }
    function setupAsyncLocks(config2, futureCache, arg) {
      const finishLock = new Lock();
      updateFunctionCache(futureCache, config2, arg, finishLock);
      return finishLock;
    }
    function updateFunctionCache(cache2, config2, arg, value2) {
      if (!config2.configured()) config2.forever();
      let cachedValue = cache2.get(arg);
      config2.deactivate();
      switch (config2.mode()) {
        case "forever":
          cachedValue = [{
            value: value2,
            valid: genTrue
          }];
          cache2.set(arg, cachedValue);
          break;
        case "invalidate":
          cachedValue = [{
            value: value2,
            valid: config2.validator()
          }];
          cache2.set(arg, cachedValue);
          break;
        case "valid":
          if (cachedValue) {
            cachedValue.push({
              value: value2,
              valid: config2.validator()
            });
          } else {
            cachedValue = [{
              value: value2,
              valid: config2.validator()
            }];
            cache2.set(arg, cachedValue);
          }
      }
    }
    var CacheConfigurator = class {
      constructor(data) {
        this._active = true;
        this._never = false;
        this._forever = false;
        this._invalidate = false;
        this._configured = false;
        this._pairs = [];
        this._data = void 0;
        this._data = data;
      }
      simple() {
        return makeSimpleConfigurator(this);
      }
      mode() {
        if (this._never) return "never";
        if (this._forever) return "forever";
        if (this._invalidate) return "invalidate";
        return "valid";
      }
      forever() {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }
        if (this._never) {
          throw new Error("Caching has already been configured with .never()");
        }
        this._forever = true;
        this._configured = true;
      }
      never() {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }
        if (this._forever) {
          throw new Error("Caching has already been configured with .forever()");
        }
        this._never = true;
        this._configured = true;
      }
      using(handler) {
        if (!this._active) {
          throw new Error("Cannot change caching after evaluation has completed.");
        }
        if (this._never || this._forever) {
          throw new Error("Caching has already been configured with .never or .forever()");
        }
        this._configured = true;
        const key = handler(this._data);
        const fn = (0, _async.maybeAsync)(handler, `You appear to be using an async cache handler, but Babel has been called synchronously`);
        if ((0, _async.isThenable)(key)) {
          return key.then((key2) => {
            this._pairs.push([key2, fn]);
            return key2;
          });
        }
        this._pairs.push([key, fn]);
        return key;
      }
      invalidate(handler) {
        this._invalidate = true;
        return this.using(handler);
      }
      validator() {
        const pairs2 = this._pairs;
        return function* (data) {
          for (const [key, fn] of pairs2) {
            if (key !== (yield* fn(data))) return false;
          }
          return true;
        };
      }
      deactivate() {
        this._active = false;
      }
      configured() {
        return this._configured;
      }
    };
    function makeSimpleConfigurator(cache2) {
      function cacheFn(val) {
        if (typeof val === "boolean") {
          if (val) cache2.forever();
          else cache2.never();
          return;
        }
        return cache2.using(() => assertSimpleType(val()));
      }
      cacheFn.forever = () => cache2.forever();
      cacheFn.never = () => cache2.never();
      cacheFn.using = (cb) => cache2.using(() => assertSimpleType(cb()));
      cacheFn.invalidate = (cb) => cache2.invalidate(() => assertSimpleType(cb()));
      return cacheFn;
    }
    function assertSimpleType(value2) {
      if ((0, _async.isThenable)(value2)) {
        throw new Error(`You appear to be using an async cache handler, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously handle your caching logic.`);
      }
      if (value2 != null && typeof value2 !== "string" && typeof value2 !== "boolean" && typeof value2 !== "number") {
        throw new Error("Cache keys must be either string, boolean, number, null, or undefined.");
      }
      return value2;
    }
    var Lock = class {
      constructor() {
        this.released = false;
        this.promise = void 0;
        this._resolve = void 0;
        this.promise = new Promise((resolve8) => {
          this._resolve = resolve8;
        });
      }
      release(value2) {
        this.released = true;
        this._resolve(value2);
      }
    };
  }
});

// node_modules/@babel/core/lib/gensync-utils/fs.js
var require_fs = __commonJS({
  "node_modules/@babel/core/lib/gensync-utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.stat = exports2.readFile = void 0;
    function _fs3() {
      const data = __require("fs");
      _fs3 = function() {
        return data;
      };
      return data;
    }
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var readFile2 = exports2.readFile = _gensync()({
      sync: _fs3().readFileSync,
      errback: _fs3().readFile
    });
    var stat3 = exports2.stat = _gensync()({
      sync: _fs3().statSync,
      errback: _fs3().stat
    });
  }
});

// node_modules/@babel/core/lib/config/files/utils.js
var require_utils2 = __commonJS({
  "node_modules/@babel/core/lib/config/files/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.makeStaticFileCache = makeStaticFileCache;
    var _caching = require_caching();
    var fs6 = require_fs();
    function _fs22() {
      const data = __require("fs");
      _fs22 = function() {
        return data;
      };
      return data;
    }
    function makeStaticFileCache(fn) {
      return (0, _caching.makeStrongCache)(function* (filepath, cache2) {
        const cached = cache2.invalidate(() => fileMtime(filepath));
        if (cached === null) {
          return null;
        }
        return fn(filepath, yield* fs6.readFile(filepath, "utf8"));
      });
    }
    function fileMtime(filepath) {
      if (!_fs22().existsSync(filepath)) return null;
      try {
        return +_fs22().statSync(filepath).mtime;
      } catch (e) {
        if (e.code !== "ENOENT" && e.code !== "ENOTDIR") throw e;
      }
      return null;
    }
  }
});

// node_modules/@babel/core/lib/errors/rewrite-stack-trace.js
var require_rewrite_stack_trace = __commonJS({
  "node_modules/@babel/core/lib/errors/rewrite-stack-trace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.beginHiddenCallStack = beginHiddenCallStack;
    exports2.endHiddenCallStack = endHiddenCallStack;
    exports2.expectedError = expectedError;
    exports2.injectVirtualStackFrame = injectVirtualStackFrame;
    var _Object$getOwnPropert;
    var ErrorToString = Function.call.bind(Error.prototype.toString);
    var SUPPORTED = !!Error.captureStackTrace && ((_Object$getOwnPropert = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit")) == null ? void 0 : _Object$getOwnPropert.writable) === true;
    var START_HIDING = "startHiding - secret - don't use this - v1";
    var STOP_HIDING = "stopHiding - secret - don't use this - v1";
    var expectedErrors = /* @__PURE__ */ new WeakSet();
    var virtualFrames = /* @__PURE__ */ new WeakMap();
    function CallSite(filename) {
      return /* @__PURE__ */ Object.create({
        isNative: () => false,
        isConstructor: () => false,
        isToplevel: () => true,
        getFileName: () => filename,
        getLineNumber: () => void 0,
        getColumnNumber: () => void 0,
        getFunctionName: () => void 0,
        getMethodName: () => void 0,
        getTypeName: () => void 0,
        toString: () => filename
      });
    }
    function injectVirtualStackFrame(error, filename) {
      if (!SUPPORTED) return;
      let frames = virtualFrames.get(error);
      if (!frames) virtualFrames.set(error, frames = []);
      frames.push(CallSite(filename));
      return error;
    }
    function expectedError(error) {
      if (!SUPPORTED) return;
      expectedErrors.add(error);
      return error;
    }
    function beginHiddenCallStack(fn) {
      if (!SUPPORTED) return fn;
      return Object.defineProperty(function(...args) {
        setupPrepareStackTrace();
        return fn(...args);
      }, "name", {
        value: STOP_HIDING
      });
    }
    function endHiddenCallStack(fn) {
      if (!SUPPORTED) return fn;
      return Object.defineProperty(function(...args) {
        return fn(...args);
      }, "name", {
        value: START_HIDING
      });
    }
    function setupPrepareStackTrace() {
      setupPrepareStackTrace = () => {
      };
      const {
        prepareStackTrace = defaultPrepareStackTrace
      } = Error;
      const MIN_STACK_TRACE_LIMIT = 50;
      Error.stackTraceLimit && (Error.stackTraceLimit = Math.max(Error.stackTraceLimit, MIN_STACK_TRACE_LIMIT));
      Error.prepareStackTrace = function stackTraceRewriter(err, trace) {
        let newTrace = [];
        const isExpected = expectedErrors.has(err);
        let status2 = isExpected ? "hiding" : "unknown";
        for (let i = 0; i < trace.length; i++) {
          const name2 = trace[i].getFunctionName();
          if (name2 === START_HIDING) {
            status2 = "hiding";
          } else if (name2 === STOP_HIDING) {
            if (status2 === "hiding") {
              status2 = "showing";
              if (virtualFrames.has(err)) {
                newTrace.unshift(...virtualFrames.get(err));
              }
            } else if (status2 === "unknown") {
              newTrace = trace;
              break;
            }
          } else if (status2 !== "hiding") {
            newTrace.push(trace[i]);
          }
        }
        return prepareStackTrace(err, newTrace);
      };
    }
    function defaultPrepareStackTrace(err, trace) {
      if (trace.length === 0) return ErrorToString(err);
      return `${ErrorToString(err)}
    at ${trace.join("\n    at ")}`;
    }
  }
});

// node_modules/@babel/core/lib/errors/config-error.js
var require_config_error = __commonJS({
  "node_modules/@babel/core/lib/errors/config-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rewriteStackTrace = require_rewrite_stack_trace();
    var ConfigError = class extends Error {
      constructor(message, filename) {
        super(message);
        (0, _rewriteStackTrace.expectedError)(this);
        if (filename) (0, _rewriteStackTrace.injectVirtualStackFrame)(this, filename);
      }
    };
    exports2.default = ConfigError;
  }
});

// node_modules/@babel/core/lib/config/files/package.js
var require_package = __commonJS({
  "node_modules/@babel/core/lib/config/files/package.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.findPackageData = findPackageData;
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    var _utils = require_utils2();
    var _configError = require_config_error();
    var PACKAGE_FILENAME = "package.json";
    var readConfigPackage = (0, _utils.makeStaticFileCache)((filepath, content) => {
      let options2;
      try {
        options2 = JSON.parse(content);
      } catch (err) {
        throw new _configError.default(`Error while parsing JSON - ${err.message}`, filepath);
      }
      if (!options2) throw new Error(`${filepath}: No config detected`);
      if (typeof options2 !== "object") {
        throw new _configError.default(`Config returned typeof ${typeof options2}`, filepath);
      }
      if (Array.isArray(options2)) {
        throw new _configError.default(`Expected config object but found array`, filepath);
      }
      return {
        filepath,
        dirname: _path2().dirname(filepath),
        options: options2
      };
    });
    function* findPackageData(filepath) {
      let pkg = null;
      const directories = [];
      let isPackage = true;
      let dirname4 = _path2().dirname(filepath);
      while (!pkg && _path2().basename(dirname4) !== "node_modules") {
        directories.push(dirname4);
        pkg = yield* readConfigPackage(_path2().join(dirname4, PACKAGE_FILENAME));
        const nextLoc = _path2().dirname(dirname4);
        if (dirname4 === nextLoc) {
          isPackage = false;
          break;
        }
        dirname4 = nextLoc;
      }
      return {
        filepath,
        directories,
        pkg,
        isPackage
      };
    }
  }
});

// node_modules/json5/lib/unicode.js
var require_unicode = __commonJS({
  "node_modules/json5/lib/unicode.js"(exports2, module) {
    module.exports.Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
    module.exports.ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
    module.exports.ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;
  }
});

// node_modules/json5/lib/util.js
var require_util4 = __commonJS({
  "node_modules/json5/lib/util.js"(exports2, module) {
    var unicode = require_unicode();
    module.exports = {
      isSpaceSeparator(c) {
        return typeof c === "string" && unicode.Space_Separator.test(c);
      },
      isIdStartChar(c) {
        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c === "$" || c === "_" || unicode.ID_Start.test(c));
      },
      isIdContinueChar(c) {
        return typeof c === "string" && (c >= "a" && c <= "z" || c >= "A" && c <= "Z" || c >= "0" && c <= "9" || c === "$" || c === "_" || c === "\u200C" || c === "\u200D" || unicode.ID_Continue.test(c));
      },
      isDigit(c) {
        return typeof c === "string" && /[0-9]/.test(c);
      },
      isHexDigit(c) {
        return typeof c === "string" && /[0-9A-Fa-f]/.test(c);
      }
    };
  }
});

// node_modules/json5/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/json5/lib/parse.js"(exports2, module) {
    var util3 = require_util4();
    var source;
    var parseState;
    var stack;
    var pos;
    var line;
    var column;
    var token;
    var key;
    var root4;
    module.exports = function parse6(text2, reviver) {
      source = String(text2);
      parseState = "start";
      stack = [];
      pos = 0;
      line = 1;
      column = 0;
      token = void 0;
      key = void 0;
      root4 = void 0;
      do {
        token = lex();
        parseStates[parseState]();
      } while (token.type !== "eof");
      if (typeof reviver === "function") {
        return internalize({ "": root4 }, "", reviver);
      }
      return root4;
    };
    function internalize(holder, name2, reviver) {
      const value2 = holder[name2];
      if (value2 != null && typeof value2 === "object") {
        if (Array.isArray(value2)) {
          for (let i = 0; i < value2.length; i++) {
            const key2 = String(i);
            const replacement = internalize(value2, key2, reviver);
            if (replacement === void 0) {
              delete value2[key2];
            } else {
              Object.defineProperty(value2, key2, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        } else {
          for (const key2 in value2) {
            const replacement = internalize(value2, key2, reviver);
            if (replacement === void 0) {
              delete value2[key2];
            } else {
              Object.defineProperty(value2, key2, {
                value: replacement,
                writable: true,
                enumerable: true,
                configurable: true
              });
            }
          }
        }
      }
      return reviver.call(holder, name2, value2);
    }
    var lexState;
    var buffer;
    var doubleQuote3;
    var sign;
    var c;
    function lex() {
      lexState = "default";
      buffer = "";
      doubleQuote3 = false;
      sign = 1;
      for (; ; ) {
        c = peek();
        const token2 = lexStates[lexState]();
        if (token2) {
          return token2;
        }
      }
    }
    function peek() {
      if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos));
      }
    }
    function read2() {
      const c2 = peek();
      if (c2 === "\n") {
        line++;
        column = 0;
      } else if (c2) {
        column += c2.length;
      } else {
        column++;
      }
      if (c2) {
        pos += c2.length;
      }
      return c2;
    }
    var lexStates = {
      default() {
        switch (c) {
          case "	":
          case "\v":
          case "\f":
          case " ":
          case "\xA0":
          case "\uFEFF":
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read2();
            return;
          case "/":
            read2();
            lexState = "comment";
            return;
          case void 0:
            read2();
            return newToken("eof");
        }
        if (util3.isSpaceSeparator(c)) {
          read2();
          return;
        }
        return lexStates[parseState]();
      },
      comment() {
        switch (c) {
          case "*":
            read2();
            lexState = "multiLineComment";
            return;
          case "/":
            read2();
            lexState = "singleLineComment";
            return;
        }
        throw invalidChar(read2());
      },
      multiLineComment() {
        switch (c) {
          case "*":
            read2();
            lexState = "multiLineCommentAsterisk";
            return;
          case void 0:
            throw invalidChar(read2());
        }
        read2();
      },
      multiLineCommentAsterisk() {
        switch (c) {
          case "*":
            read2();
            return;
          case "/":
            read2();
            lexState = "default";
            return;
          case void 0:
            throw invalidChar(read2());
        }
        read2();
        lexState = "multiLineComment";
      },
      singleLineComment() {
        switch (c) {
          case "\n":
          case "\r":
          case "\u2028":
          case "\u2029":
            read2();
            lexState = "default";
            return;
          case void 0:
            read2();
            return newToken("eof");
        }
        read2();
      },
      value() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read2());
          case "n":
            read2();
            literal("ull");
            return newToken("null", null);
          case "t":
            read2();
            literal("rue");
            return newToken("boolean", true);
          case "f":
            read2();
            literal("alse");
            return newToken("boolean", false);
          case "-":
          case "+":
            if (read2() === "-") {
              sign = -1;
            }
            lexState = "sign";
            return;
          case ".":
            buffer = read2();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read2();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read2();
            lexState = "decimalInteger";
            return;
          case "I":
            read2();
            literal("nfinity");
            return newToken("numeric", Infinity);
          case "N":
            read2();
            literal("aN");
            return newToken("numeric", NaN);
          case '"':
          case "'":
            doubleQuote3 = read2() === '"';
            buffer = "";
            lexState = "string";
            return;
        }
        throw invalidChar(read2());
      },
      identifierNameStartEscape() {
        if (c !== "u") {
          throw invalidChar(read2());
        }
        read2();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
            break;
          default:
            if (!util3.isIdStartChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      identifierName() {
        switch (c) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            buffer += read2();
            return;
          case "\\":
            read2();
            lexState = "identifierNameEscape";
            return;
        }
        if (util3.isIdContinueChar(c)) {
          buffer += read2();
          return;
        }
        return newToken("identifier", buffer);
      },
      identifierNameEscape() {
        if (c !== "u") {
          throw invalidChar(read2());
        }
        read2();
        const u = unicodeEscape();
        switch (u) {
          case "$":
          case "_":
          case "\u200C":
          case "\u200D":
            break;
          default:
            if (!util3.isIdContinueChar(u)) {
              throw invalidIdentifier();
            }
            break;
        }
        buffer += u;
        lexState = "identifierName";
      },
      sign() {
        switch (c) {
          case ".":
            buffer = read2();
            lexState = "decimalPointLeading";
            return;
          case "0":
            buffer = read2();
            lexState = "zero";
            return;
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9":
            buffer = read2();
            lexState = "decimalInteger";
            return;
          case "I":
            read2();
            literal("nfinity");
            return newToken("numeric", sign * Infinity);
          case "N":
            read2();
            literal("aN");
            return newToken("numeric", NaN);
        }
        throw invalidChar(read2());
      },
      zero() {
        switch (c) {
          case ".":
            buffer += read2();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
          case "x":
          case "X":
            buffer += read2();
            lexState = "hexadecimal";
            return;
        }
        return newToken("numeric", sign * 0);
      },
      decimalInteger() {
        switch (c) {
          case ".":
            buffer += read2();
            lexState = "decimalPoint";
            return;
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util3.isDigit(c)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalPointLeading() {
        if (util3.isDigit(c)) {
          buffer += read2();
          lexState = "decimalFraction";
          return;
        }
        throw invalidChar(read2());
      },
      decimalPoint() {
        switch (c) {
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util3.isDigit(c)) {
          buffer += read2();
          lexState = "decimalFraction";
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalFraction() {
        switch (c) {
          case "e":
          case "E":
            buffer += read2();
            lexState = "decimalExponent";
            return;
        }
        if (util3.isDigit(c)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      decimalExponent() {
        switch (c) {
          case "+":
          case "-":
            buffer += read2();
            lexState = "decimalExponentSign";
            return;
        }
        if (util3.isDigit(c)) {
          buffer += read2();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read2());
      },
      decimalExponentSign() {
        if (util3.isDigit(c)) {
          buffer += read2();
          lexState = "decimalExponentInteger";
          return;
        }
        throw invalidChar(read2());
      },
      decimalExponentInteger() {
        if (util3.isDigit(c)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      hexadecimal() {
        if (util3.isHexDigit(c)) {
          buffer += read2();
          lexState = "hexadecimalInteger";
          return;
        }
        throw invalidChar(read2());
      },
      hexadecimalInteger() {
        if (util3.isHexDigit(c)) {
          buffer += read2();
          return;
        }
        return newToken("numeric", sign * Number(buffer));
      },
      string() {
        switch (c) {
          case "\\":
            read2();
            buffer += escape2();
            return;
          case '"':
            if (doubleQuote3) {
              read2();
              return newToken("string", buffer);
            }
            buffer += read2();
            return;
          case "'":
            if (!doubleQuote3) {
              read2();
              return newToken("string", buffer);
            }
            buffer += read2();
            return;
          case "\n":
          case "\r":
            throw invalidChar(read2());
          case "\u2028":
          case "\u2029":
            separatorChar(c);
            break;
          case void 0:
            throw invalidChar(read2());
        }
        buffer += read2();
      },
      start() {
        switch (c) {
          case "{":
          case "[":
            return newToken("punctuator", read2());
        }
        lexState = "value";
      },
      beforePropertyName() {
        switch (c) {
          case "$":
          case "_":
            buffer = read2();
            lexState = "identifierName";
            return;
          case "\\":
            read2();
            lexState = "identifierNameStartEscape";
            return;
          case "}":
            return newToken("punctuator", read2());
          case '"':
          case "'":
            doubleQuote3 = read2() === '"';
            lexState = "string";
            return;
        }
        if (util3.isIdStartChar(c)) {
          buffer += read2();
          lexState = "identifierName";
          return;
        }
        throw invalidChar(read2());
      },
      afterPropertyName() {
        if (c === ":") {
          return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      },
      beforePropertyValue() {
        lexState = "value";
      },
      afterPropertyValue() {
        switch (c) {
          case ",":
          case "}":
            return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      },
      beforeArrayValue() {
        if (c === "]") {
          return newToken("punctuator", read2());
        }
        lexState = "value";
      },
      afterArrayValue() {
        switch (c) {
          case ",":
          case "]":
            return newToken("punctuator", read2());
        }
        throw invalidChar(read2());
      },
      end() {
        throw invalidChar(read2());
      }
    };
    function newToken(type, value2) {
      return {
        type,
        value: value2,
        line,
        column
      };
    }
    function literal(s) {
      for (const c2 of s) {
        const p = peek();
        if (p !== c2) {
          throw invalidChar(read2());
        }
        read2();
      }
    }
    function escape2() {
      const c2 = peek();
      switch (c2) {
        case "b":
          read2();
          return "\b";
        case "f":
          read2();
          return "\f";
        case "n":
          read2();
          return "\n";
        case "r":
          read2();
          return "\r";
        case "t":
          read2();
          return "	";
        case "v":
          read2();
          return "\v";
        case "0":
          read2();
          if (util3.isDigit(peek())) {
            throw invalidChar(read2());
          }
          return "\0";
        case "x":
          read2();
          return hexEscape();
        case "u":
          read2();
          return unicodeEscape();
        case "\n":
        case "\u2028":
        case "\u2029":
          read2();
          return "";
        case "\r":
          read2();
          if (peek() === "\n") {
            read2();
          }
          return "";
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          throw invalidChar(read2());
        case void 0:
          throw invalidChar(read2());
      }
      return read2();
    }
    function hexEscape() {
      let buffer2 = "";
      let c2 = peek();
      if (!util3.isHexDigit(c2)) {
        throw invalidChar(read2());
      }
      buffer2 += read2();
      c2 = peek();
      if (!util3.isHexDigit(c2)) {
        throw invalidChar(read2());
      }
      buffer2 += read2();
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    function unicodeEscape() {
      let buffer2 = "";
      let count = 4;
      while (count-- > 0) {
        const c2 = peek();
        if (!util3.isHexDigit(c2)) {
          throw invalidChar(read2());
        }
        buffer2 += read2();
      }
      return String.fromCodePoint(parseInt(buffer2, 16));
    }
    var parseStates = {
      start() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push2();
      },
      beforePropertyName() {
        switch (token.type) {
          case "identifier":
          case "string":
            key = token.value;
            parseState = "afterPropertyName";
            return;
          case "punctuator":
            pop();
            return;
          case "eof":
            throw invalidEOF();
        }
      },
      afterPropertyName() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        parseState = "beforePropertyValue";
      },
      beforePropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        push2();
      },
      beforeArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        if (token.type === "punctuator" && token.value === "]") {
          pop();
          return;
        }
        push2();
      },
      afterPropertyValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforePropertyName";
            return;
          case "}":
            pop();
        }
      },
      afterArrayValue() {
        if (token.type === "eof") {
          throw invalidEOF();
        }
        switch (token.value) {
          case ",":
            parseState = "beforeArrayValue";
            return;
          case "]":
            pop();
        }
      },
      end() {
      }
    };
    function push2() {
      let value2;
      switch (token.type) {
        case "punctuator":
          switch (token.value) {
            case "{":
              value2 = {};
              break;
            case "[":
              value2 = [];
              break;
          }
          break;
        case "null":
        case "boolean":
        case "numeric":
        case "string":
          value2 = token.value;
          break;
      }
      if (root4 === void 0) {
        root4 = value2;
      } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
          parent.push(value2);
        } else {
          Object.defineProperty(parent, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      if (value2 !== null && typeof value2 === "object") {
        stack.push(value2);
        if (Array.isArray(value2)) {
          parseState = "beforeArrayValue";
        } else {
          parseState = "beforePropertyName";
        }
      } else {
        const current = stack[stack.length - 1];
        if (current == null) {
          parseState = "end";
        } else if (Array.isArray(current)) {
          parseState = "afterArrayValue";
        } else {
          parseState = "afterPropertyValue";
        }
      }
    }
    function pop() {
      stack.pop();
      const current = stack[stack.length - 1];
      if (current == null) {
        parseState = "end";
      } else if (Array.isArray(current)) {
        parseState = "afterArrayValue";
      } else {
        parseState = "afterPropertyValue";
      }
    }
    function invalidChar(c2) {
      if (c2 === void 0) {
        return syntaxError2(`JSON5: invalid end of input at ${line}:${column}`);
      }
      return syntaxError2(`JSON5: invalid character '${formatChar(c2)}' at ${line}:${column}`);
    }
    function invalidEOF() {
      return syntaxError2(`JSON5: invalid end of input at ${line}:${column}`);
    }
    function invalidIdentifier() {
      column -= 5;
      return syntaxError2(`JSON5: invalid identifier character at ${line}:${column}`);
    }
    function separatorChar(c2) {
      console.warn(`JSON5: '${formatChar(c2)}' in strings is not valid ECMAScript; consider escaping`);
    }
    function formatChar(c2) {
      const replacements = {
        "'": "\\'",
        '"': '\\"',
        "\\": "\\\\",
        "\b": "\\b",
        "\f": "\\f",
        "\n": "\\n",
        "\r": "\\r",
        "	": "\\t",
        "\v": "\\v",
        "\0": "\\0",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029"
      };
      if (replacements[c2]) {
        return replacements[c2];
      }
      if (c2 < " ") {
        const hexString = c2.charCodeAt(0).toString(16);
        return "\\x" + ("00" + hexString).substring(hexString.length);
      }
      return c2;
    }
    function syntaxError2(message) {
      const err = new SyntaxError(message);
      err.lineNumber = line;
      err.columnNumber = column;
      return err;
    }
  }
});

// node_modules/json5/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/json5/lib/stringify.js"(exports2, module) {
    var util3 = require_util4();
    module.exports = function stringify5(value2, replacer, space2) {
      const stack = [];
      let indent = "";
      let propertyList;
      let replacerFunc;
      let gap = "";
      let quote3;
      if (replacer != null && typeof replacer === "object" && !Array.isArray(replacer)) {
        space2 = replacer.space;
        quote3 = replacer.quote;
        replacer = replacer.replacer;
      }
      if (typeof replacer === "function") {
        replacerFunc = replacer;
      } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer) {
          let item;
          if (typeof v === "string") {
            item = v;
          } else if (typeof v === "number" || v instanceof String || v instanceof Number) {
            item = String(v);
          }
          if (item !== void 0 && propertyList.indexOf(item) < 0) {
            propertyList.push(item);
          }
        }
      }
      if (space2 instanceof Number) {
        space2 = Number(space2);
      } else if (space2 instanceof String) {
        space2 = String(space2);
      }
      if (typeof space2 === "number") {
        if (space2 > 0) {
          space2 = Math.min(10, Math.floor(space2));
          gap = "          ".substr(0, space2);
        }
      } else if (typeof space2 === "string") {
        gap = space2.substr(0, 10);
      }
      return serializeProperty("", { "": value2 });
      function serializeProperty(key, holder) {
        let value3 = holder[key];
        if (value3 != null) {
          if (typeof value3.toJSON5 === "function") {
            value3 = value3.toJSON5(key);
          } else if (typeof value3.toJSON === "function") {
            value3 = value3.toJSON(key);
          }
        }
        if (replacerFunc) {
          value3 = replacerFunc.call(holder, key, value3);
        }
        if (value3 instanceof Number) {
          value3 = Number(value3);
        } else if (value3 instanceof String) {
          value3 = String(value3);
        } else if (value3 instanceof Boolean) {
          value3 = value3.valueOf();
        }
        switch (value3) {
          case null:
            return "null";
          case true:
            return "true";
          case false:
            return "false";
        }
        if (typeof value3 === "string") {
          return quoteString(value3, false);
        }
        if (typeof value3 === "number") {
          return String(value3);
        }
        if (typeof value3 === "object") {
          return Array.isArray(value3) ? serializeArray(value3) : serializeObject(value3);
        }
        return void 0;
      }
      function quoteString(value3) {
        const quotes = {
          "'": 0.1,
          '"': 0.2
        };
        const replacements = {
          "'": "\\'",
          '"': '\\"',
          "\\": "\\\\",
          "\b": "\\b",
          "\f": "\\f",
          "\n": "\\n",
          "\r": "\\r",
          "	": "\\t",
          "\v": "\\v",
          "\0": "\\0",
          "\u2028": "\\u2028",
          "\u2029": "\\u2029"
        };
        let product = "";
        for (let i = 0; i < value3.length; i++) {
          const c = value3[i];
          switch (c) {
            case "'":
            case '"':
              quotes[c]++;
              product += c;
              continue;
            case "\0":
              if (util3.isDigit(value3[i + 1])) {
                product += "\\x00";
                continue;
              }
          }
          if (replacements[c]) {
            product += replacements[c];
            continue;
          }
          if (c < " ") {
            let hexString = c.charCodeAt(0).toString(16);
            product += "\\x" + ("00" + hexString).substring(hexString.length);
            continue;
          }
          product += c;
        }
        const quoteChar = quote3 || Object.keys(quotes).reduce((a, b) => quotes[a] < quotes[b] ? a : b);
        product = product.replace(new RegExp(quoteChar, "g"), replacements[quoteChar]);
        return quoteChar + product + quoteChar;
      }
      function serializeObject(value3) {
        if (stack.indexOf(value3) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack.push(value3);
        let stepback = indent;
        indent = indent + gap;
        let keys = propertyList || Object.keys(value3);
        let partial2 = [];
        for (const key of keys) {
          const propertyString = serializeProperty(key, value3);
          if (propertyString !== void 0) {
            let member = serializeKey(key) + ":";
            if (gap !== "") {
              member += " ";
            }
            member += propertyString;
            partial2.push(member);
          }
        }
        let final;
        if (partial2.length === 0) {
          final = "{}";
        } else {
          let properties;
          if (gap === "") {
            properties = partial2.join(",");
            final = "{" + properties + "}";
          } else {
            let separator = ",\n" + indent;
            properties = partial2.join(separator);
            final = "{\n" + indent + properties + ",\n" + stepback + "}";
          }
        }
        stack.pop();
        indent = stepback;
        return final;
      }
      function serializeKey(key) {
        if (key.length === 0) {
          return quoteString(key, true);
        }
        const firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util3.isIdStartChar(firstChar)) {
          return quoteString(key, true);
        }
        for (let i = firstChar.length; i < key.length; i++) {
          if (!util3.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
            return quoteString(key, true);
          }
        }
        return key;
      }
      function serializeArray(value3) {
        if (stack.indexOf(value3) >= 0) {
          throw TypeError("Converting circular structure to JSON5");
        }
        stack.push(value3);
        let stepback = indent;
        indent = indent + gap;
        let partial2 = [];
        for (let i = 0; i < value3.length; i++) {
          const propertyString = serializeProperty(String(i), value3);
          partial2.push(propertyString !== void 0 ? propertyString : "null");
        }
        let final;
        if (partial2.length === 0) {
          final = "[]";
        } else {
          if (gap === "") {
            let properties = partial2.join(",");
            final = "[" + properties + "]";
          } else {
            let separator = ",\n" + indent;
            let properties = partial2.join(separator);
            final = "[\n" + indent + properties + ",\n" + stepback + "]";
          }
        }
        stack.pop();
        indent = stepback;
        return final;
      }
    };
  }
});

// node_modules/json5/lib/index.js
var require_lib12 = __commonJS({
  "node_modules/json5/lib/index.js"(exports2, module) {
    var parse6 = require_parse3();
    var stringify5 = require_stringify2();
    var JSON5 = {
      parse: parse6,
      stringify: stringify5
    };
    module.exports = JSON5;
  }
});

// node_modules/@babel/core/lib/config/helpers/config-api.js
var require_config_api = __commonJS({
  "node_modules/@babel/core/lib/config/helpers/config-api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.makeConfigAPI = makeConfigAPI;
    exports2.makePluginAPI = makePluginAPI;
    exports2.makePresetAPI = makePresetAPI;
    function _semver() {
      const data = require_semver();
      _semver = function() {
        return data;
      };
      return data;
    }
    var _index = require_lib15();
    var _caching = require_caching();
    function makeConfigAPI(cache2) {
      const env2 = (value2) => cache2.using((data) => {
        if (value2 === void 0) return data.envName;
        if (typeof value2 === "function") {
          return (0, _caching.assertSimpleType)(value2(data.envName));
        }
        return (Array.isArray(value2) ? value2 : [value2]).some((entry2) => {
          if (typeof entry2 !== "string") {
            throw new Error("Unexpected non-string value");
          }
          return entry2 === data.envName;
        });
      });
      const caller = (cb) => cache2.using((data) => (0, _caching.assertSimpleType)(cb(data.caller)));
      return {
        version: _index.version,
        cache: cache2.simple(),
        env: env2,
        async: () => false,
        caller,
        assertVersion
      };
    }
    function makePresetAPI(cache2, externalDependencies) {
      const targets = () => JSON.parse(cache2.using((data) => JSON.stringify(data.targets)));
      const addExternalDependency = (ref) => {
        externalDependencies.push(ref);
      };
      return Object.assign({}, makeConfigAPI(cache2), {
        targets,
        addExternalDependency
      });
    }
    function makePluginAPI(cache2, externalDependencies) {
      const assumption = (name2) => cache2.using((data) => data.assumptions[name2]);
      return Object.assign({}, makePresetAPI(cache2, externalDependencies), {
        assumption
      });
    }
    function assertVersion(range2) {
      if (typeof range2 === "number") {
        if (!Number.isInteger(range2)) {
          throw new Error("Expected string or integer value.");
        }
        range2 = `^${range2}.0.0-0`;
      }
      if (typeof range2 !== "string") {
        throw new Error("Expected string or integer value.");
      }
      if (range2 === "*" || _semver().satisfies(_index.version, range2)) return;
      const limit = Error.stackTraceLimit;
      if (typeof limit === "number" && limit < 25) {
        Error.stackTraceLimit = 25;
      }
      const err = new Error(`Requires Babel "${range2}", but was loaded with "${_index.version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
      if (typeof limit === "number") {
        Error.stackTraceLimit = limit;
      }
      throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version: _index.version,
        range: range2
      });
    }
  }
});

// node_modules/@babel/core/lib/config/helpers/deep-array.js
var require_deep_array = __commonJS({
  "node_modules/@babel/core/lib/config/helpers/deep-array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.finalize = finalize;
    exports2.flattenToSet = flattenToSet;
    function finalize(deepArr) {
      return Object.freeze(deepArr);
    }
    function flattenToSet(arr) {
      const result = /* @__PURE__ */ new Set();
      const stack = [arr];
      while (stack.length > 0) {
        for (const el of stack.pop()) {
          if (Array.isArray(el)) stack.push(el);
          else result.add(el);
        }
      }
      return result;
    }
  }
});

// node_modules/@babel/core/lib/config/plugin.js
var require_plugin = __commonJS({
  "node_modules/@babel/core/lib/config/plugin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _deepArray = require_deep_array();
    var Plugin = class {
      constructor(plugin3, options2, key, externalDependencies = (0, _deepArray.finalize)([])) {
        this.key = void 0;
        this.manipulateOptions = void 0;
        this.post = void 0;
        this.pre = void 0;
        this.visitor = void 0;
        this.parserOverride = void 0;
        this.generatorOverride = void 0;
        this.options = void 0;
        this.externalDependencies = void 0;
        this.key = plugin3.name || key;
        this.manipulateOptions = plugin3.manipulateOptions;
        this.post = plugin3.post;
        this.pre = plugin3.pre;
        this.visitor = plugin3.visitor || {};
        this.parserOverride = plugin3.parserOverride;
        this.generatorOverride = plugin3.generatorOverride;
        this.options = options2;
        this.externalDependencies = externalDependencies;
      }
    };
    exports2.default = Plugin;
  }
});

// node_modules/@babel/core/lib/gensync-utils/functional.js
var require_functional = __commonJS({
  "node_modules/@babel/core/lib/gensync-utils/functional.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.once = once;
    var _async = require_async();
    function once(fn) {
      let result;
      let resultP;
      let promiseReferenced = false;
      return function* () {
        if (!result) {
          if (resultP) {
            promiseReferenced = true;
            return yield* (0, _async.waitFor)(resultP);
          }
          if (!(yield* (0, _async.isAsync)())) {
            try {
              result = {
                ok: true,
                value: yield* fn()
              };
            } catch (error) {
              result = {
                ok: false,
                value: error
              };
            }
          } else {
            let resolve8, reject;
            resultP = new Promise((res, rej) => {
              resolve8 = res;
              reject = rej;
            });
            try {
              result = {
                ok: true,
                value: yield* fn()
              };
              resultP = null;
              if (promiseReferenced) resolve8(result.value);
            } catch (error) {
              result = {
                ok: false,
                value: error
              };
              resultP = null;
              if (promiseReferenced) reject(error);
            }
          }
        }
        if (result.ok) return result.value;
        else throw result.value;
      };
    }
  }
});

// node_modules/node-releases/data/processed/envs.json
var require_envs = __commonJS({
  "node_modules/node-releases/data/processed/envs.json"(exports2, module) {
    module.exports = [{ name: "nodejs", version: "0.2.0", date: "2011-08-26", lts: false, security: false, v8: "2.3.8.0" }, { name: "nodejs", version: "0.3.0", date: "2011-08-26", lts: false, security: false, v8: "2.5.1.0" }, { name: "nodejs", version: "0.4.0", date: "2011-08-26", lts: false, security: false, v8: "3.1.2.0" }, { name: "nodejs", version: "0.5.0", date: "2011-08-26", lts: false, security: false, v8: "3.1.8.25" }, { name: "nodejs", version: "0.6.0", date: "2011-11-04", lts: false, security: false, v8: "3.6.6.6" }, { name: "nodejs", version: "0.7.0", date: "2012-01-17", lts: false, security: false, v8: "3.8.6.0" }, { name: "nodejs", version: "0.8.0", date: "2012-06-22", lts: false, security: false, v8: "3.11.10.10" }, { name: "nodejs", version: "0.9.0", date: "2012-07-20", lts: false, security: false, v8: "3.11.10.15" }, { name: "nodejs", version: "0.10.0", date: "2013-03-11", lts: false, security: false, v8: "3.14.5.8" }, { name: "nodejs", version: "0.11.0", date: "2013-03-28", lts: false, security: false, v8: "3.17.13.0" }, { name: "nodejs", version: "0.12.0", date: "2015-02-06", lts: false, security: false, v8: "3.28.73.0" }, { name: "nodejs", version: "4.0.0", date: "2015-09-08", lts: false, security: false, v8: "4.5.103.30" }, { name: "nodejs", version: "4.1.0", date: "2015-09-17", lts: false, security: false, v8: "4.5.103.33" }, { name: "nodejs", version: "4.2.0", date: "2015-10-12", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.3.0", date: "2016-02-09", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.4.0", date: "2016-03-08", lts: "Argon", security: false, v8: "4.5.103.35" }, { name: "nodejs", version: "4.5.0", date: "2016-08-16", lts: "Argon", security: false, v8: "4.5.103.37" }, { name: "nodejs", version: "4.6.0", date: "2016-09-27", lts: "Argon", security: true, v8: "4.5.103.37" }, { name: "nodejs", version: "4.7.0", date: "2016-12-06", lts: "Argon", security: false, v8: "4.5.103.43" }, { name: "nodejs", version: "4.8.0", date: "2017-02-21", lts: "Argon", security: false, v8: "4.5.103.45" }, { name: "nodejs", version: "4.9.0", date: "2018-03-28", lts: "Argon", security: true, v8: "4.5.103.53" }, { name: "nodejs", version: "5.0.0", date: "2015-10-29", lts: false, security: false, v8: "4.6.85.28" }, { name: "nodejs", version: "5.1.0", date: "2015-11-17", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.2.0", date: "2015-12-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.3.0", date: "2015-12-15", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.4.0", date: "2016-01-06", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.5.0", date: "2016-01-21", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.6.0", date: "2016-02-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.7.0", date: "2016-02-23", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.8.0", date: "2016-03-09", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.9.0", date: "2016-03-16", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.10.0", date: "2016-04-01", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.11.0", date: "2016-04-21", lts: false, security: false, v8: "4.6.85.31" }, { name: "nodejs", version: "5.12.0", date: "2016-06-23", lts: false, security: false, v8: "4.6.85.32" }, { name: "nodejs", version: "6.0.0", date: "2016-04-26", lts: false, security: false, v8: "5.0.71.35" }, { name: "nodejs", version: "6.1.0", date: "2016-05-05", lts: false, security: false, v8: "5.0.71.35" }, { name: "nodejs", version: "6.2.0", date: "2016-05-17", lts: false, security: false, v8: "5.0.71.47" }, { name: "nodejs", version: "6.3.0", date: "2016-07-06", lts: false, security: false, v8: "5.0.71.52" }, { name: "nodejs", version: "6.4.0", date: "2016-08-12", lts: false, security: false, v8: "5.0.71.60" }, { name: "nodejs", version: "6.5.0", date: "2016-08-26", lts: false, security: false, v8: "5.1.281.81" }, { name: "nodejs", version: "6.6.0", date: "2016-09-14", lts: false, security: false, v8: "5.1.281.83" }, { name: "nodejs", version: "6.7.0", date: "2016-09-27", lts: false, security: true, v8: "5.1.281.83" }, { name: "nodejs", version: "6.8.0", date: "2016-10-12", lts: false, security: false, v8: "5.1.281.84" }, { name: "nodejs", version: "6.9.0", date: "2016-10-18", lts: "Boron", security: false, v8: "5.1.281.84" }, { name: "nodejs", version: "6.10.0", date: "2017-02-21", lts: "Boron", security: false, v8: "5.1.281.93" }, { name: "nodejs", version: "6.11.0", date: "2017-06-06", lts: "Boron", security: false, v8: "5.1.281.102" }, { name: "nodejs", version: "6.12.0", date: "2017-11-06", lts: "Boron", security: false, v8: "5.1.281.108" }, { name: "nodejs", version: "6.13.0", date: "2018-02-10", lts: "Boron", security: false, v8: "5.1.281.111" }, { name: "nodejs", version: "6.14.0", date: "2018-03-28", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "6.15.0", date: "2018-11-27", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "6.16.0", date: "2018-12-26", lts: "Boron", security: false, v8: "5.1.281.111" }, { name: "nodejs", version: "6.17.0", date: "2019-02-28", lts: "Boron", security: true, v8: "5.1.281.111" }, { name: "nodejs", version: "7.0.0", date: "2016-10-25", lts: false, security: false, v8: "5.4.500.36" }, { name: "nodejs", version: "7.1.0", date: "2016-11-08", lts: false, security: false, v8: "5.4.500.36" }, { name: "nodejs", version: "7.2.0", date: "2016-11-22", lts: false, security: false, v8: "5.4.500.43" }, { name: "nodejs", version: "7.3.0", date: "2016-12-20", lts: false, security: false, v8: "5.4.500.45" }, { name: "nodejs", version: "7.4.0", date: "2017-01-04", lts: false, security: false, v8: "5.4.500.45" }, { name: "nodejs", version: "7.5.0", date: "2017-01-31", lts: false, security: false, v8: "5.4.500.48" }, { name: "nodejs", version: "7.6.0", date: "2017-02-21", lts: false, security: false, v8: "5.5.372.40" }, { name: "nodejs", version: "7.7.0", date: "2017-02-28", lts: false, security: false, v8: "5.5.372.41" }, { name: "nodejs", version: "7.8.0", date: "2017-03-29", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "7.9.0", date: "2017-04-11", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "7.10.0", date: "2017-05-02", lts: false, security: false, v8: "5.5.372.43" }, { name: "nodejs", version: "8.0.0", date: "2017-05-30", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.1.0", date: "2017-06-08", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.2.0", date: "2017-07-19", lts: false, security: false, v8: "5.8.283.41" }, { name: "nodejs", version: "8.3.0", date: "2017-08-08", lts: false, security: false, v8: "6.0.286.52" }, { name: "nodejs", version: "8.4.0", date: "2017-08-15", lts: false, security: false, v8: "6.0.286.52" }, { name: "nodejs", version: "8.5.0", date: "2017-09-12", lts: false, security: false, v8: "6.0.287.53" }, { name: "nodejs", version: "8.6.0", date: "2017-09-26", lts: false, security: false, v8: "6.0.287.53" }, { name: "nodejs", version: "8.7.0", date: "2017-10-11", lts: false, security: false, v8: "6.1.534.42" }, { name: "nodejs", version: "8.8.0", date: "2017-10-24", lts: false, security: false, v8: "6.1.534.42" }, { name: "nodejs", version: "8.9.0", date: "2017-10-31", lts: "Carbon", security: false, v8: "6.1.534.46" }, { name: "nodejs", version: "8.10.0", date: "2018-03-06", lts: "Carbon", security: false, v8: "6.2.414.50" }, { name: "nodejs", version: "8.11.0", date: "2018-03-28", lts: "Carbon", security: true, v8: "6.2.414.50" }, { name: "nodejs", version: "8.12.0", date: "2018-09-10", lts: "Carbon", security: false, v8: "6.2.414.66" }, { name: "nodejs", version: "8.13.0", date: "2018-11-20", lts: "Carbon", security: false, v8: "6.2.414.72" }, { name: "nodejs", version: "8.14.0", date: "2018-11-27", lts: "Carbon", security: true, v8: "6.2.414.72" }, { name: "nodejs", version: "8.15.0", date: "2018-12-26", lts: "Carbon", security: false, v8: "6.2.414.75" }, { name: "nodejs", version: "8.16.0", date: "2019-04-16", lts: "Carbon", security: false, v8: "6.2.414.77" }, { name: "nodejs", version: "8.17.0", date: "2019-12-17", lts: "Carbon", security: true, v8: "6.2.414.78" }, { name: "nodejs", version: "9.0.0", date: "2017-10-31", lts: false, security: false, v8: "6.2.414.32" }, { name: "nodejs", version: "9.1.0", date: "2017-11-07", lts: false, security: false, v8: "6.2.414.32" }, { name: "nodejs", version: "9.2.0", date: "2017-11-14", lts: false, security: false, v8: "6.2.414.44" }, { name: "nodejs", version: "9.3.0", date: "2017-12-12", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.4.0", date: "2018-01-10", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.5.0", date: "2018-01-31", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.6.0", date: "2018-02-21", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.7.0", date: "2018-03-01", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.8.0", date: "2018-03-07", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.9.0", date: "2018-03-21", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "9.10.0", date: "2018-03-28", lts: false, security: true, v8: "6.2.414.46" }, { name: "nodejs", version: "9.11.0", date: "2018-04-04", lts: false, security: false, v8: "6.2.414.46" }, { name: "nodejs", version: "10.0.0", date: "2018-04-24", lts: false, security: false, v8: "6.6.346.24" }, { name: "nodejs", version: "10.1.0", date: "2018-05-08", lts: false, security: false, v8: "6.6.346.27" }, { name: "nodejs", version: "10.2.0", date: "2018-05-23", lts: false, security: false, v8: "6.6.346.32" }, { name: "nodejs", version: "10.3.0", date: "2018-05-29", lts: false, security: false, v8: "6.6.346.32" }, { name: "nodejs", version: "10.4.0", date: "2018-06-06", lts: false, security: false, v8: "6.7.288.43" }, { name: "nodejs", version: "10.5.0", date: "2018-06-20", lts: false, security: false, v8: "6.7.288.46" }, { name: "nodejs", version: "10.6.0", date: "2018-07-04", lts: false, security: false, v8: "6.7.288.46" }, { name: "nodejs", version: "10.7.0", date: "2018-07-18", lts: false, security: false, v8: "6.7.288.49" }, { name: "nodejs", version: "10.8.0", date: "2018-08-01", lts: false, security: false, v8: "6.7.288.49" }, { name: "nodejs", version: "10.9.0", date: "2018-08-15", lts: false, security: false, v8: "6.8.275.24" }, { name: "nodejs", version: "10.10.0", date: "2018-09-06", lts: false, security: false, v8: "6.8.275.30" }, { name: "nodejs", version: "10.11.0", date: "2018-09-19", lts: false, security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.12.0", date: "2018-10-10", lts: false, security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.13.0", date: "2018-10-30", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.14.0", date: "2018-11-27", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.15.0", date: "2018-12-26", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.16.0", date: "2019-05-28", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.17.0", date: "2019-10-22", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.18.0", date: "2019-12-17", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.19.0", date: "2020-02-05", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.20.0", date: "2020-03-26", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.21.0", date: "2020-06-02", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "10.22.0", date: "2020-07-21", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.23.0", date: "2020-10-27", lts: "Dubnium", security: false, v8: "6.8.275.32" }, { name: "nodejs", version: "10.24.0", date: "2021-02-23", lts: "Dubnium", security: true, v8: "6.8.275.32" }, { name: "nodejs", version: "11.0.0", date: "2018-10-23", lts: false, security: false, v8: "7.0.276.28" }, { name: "nodejs", version: "11.1.0", date: "2018-10-30", lts: false, security: false, v8: "7.0.276.32" }, { name: "nodejs", version: "11.2.0", date: "2018-11-15", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.3.0", date: "2018-11-27", lts: false, security: true, v8: "7.0.276.38" }, { name: "nodejs", version: "11.4.0", date: "2018-12-07", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.5.0", date: "2018-12-18", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.6.0", date: "2018-12-26", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.7.0", date: "2019-01-17", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.8.0", date: "2019-01-24", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.9.0", date: "2019-01-30", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.10.0", date: "2019-02-14", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.11.0", date: "2019-03-05", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.12.0", date: "2019-03-14", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.13.0", date: "2019-03-28", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.14.0", date: "2019-04-10", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "11.15.0", date: "2019-04-30", lts: false, security: false, v8: "7.0.276.38" }, { name: "nodejs", version: "12.0.0", date: "2019-04-23", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.1.0", date: "2019-04-29", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.2.0", date: "2019-05-07", lts: false, security: false, v8: "7.4.288.21" }, { name: "nodejs", version: "12.3.0", date: "2019-05-21", lts: false, security: false, v8: "7.4.288.27" }, { name: "nodejs", version: "12.4.0", date: "2019-06-04", lts: false, security: false, v8: "7.4.288.27" }, { name: "nodejs", version: "12.5.0", date: "2019-06-26", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.6.0", date: "2019-07-03", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.7.0", date: "2019-07-23", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.8.0", date: "2019-08-06", lts: false, security: false, v8: "7.5.288.22" }, { name: "nodejs", version: "12.9.0", date: "2019-08-20", lts: false, security: false, v8: "7.6.303.29" }, { name: "nodejs", version: "12.10.0", date: "2019-09-04", lts: false, security: false, v8: "7.6.303.29" }, { name: "nodejs", version: "12.11.0", date: "2019-09-25", lts: false, security: false, v8: "7.7.299.11" }, { name: "nodejs", version: "12.12.0", date: "2019-10-11", lts: false, security: false, v8: "7.7.299.13" }, { name: "nodejs", version: "12.13.0", date: "2019-10-21", lts: "Erbium", security: false, v8: "7.7.299.13" }, { name: "nodejs", version: "12.14.0", date: "2019-12-17", lts: "Erbium", security: true, v8: "7.7.299.13" }, { name: "nodejs", version: "12.15.0", date: "2020-02-05", lts: "Erbium", security: true, v8: "7.7.299.13" }, { name: "nodejs", version: "12.16.0", date: "2020-02-11", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.17.0", date: "2020-05-26", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.18.0", date: "2020-06-02", lts: "Erbium", security: true, v8: "7.8.279.23" }, { name: "nodejs", version: "12.19.0", date: "2020-10-06", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.20.0", date: "2020-11-24", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "12.21.0", date: "2021-02-23", lts: "Erbium", security: true, v8: "7.8.279.23" }, { name: "nodejs", version: "12.22.0", date: "2021-03-30", lts: "Erbium", security: false, v8: "7.8.279.23" }, { name: "nodejs", version: "13.0.0", date: "2019-10-22", lts: false, security: false, v8: "7.8.279.17" }, { name: "nodejs", version: "13.1.0", date: "2019-11-05", lts: false, security: false, v8: "7.8.279.17" }, { name: "nodejs", version: "13.2.0", date: "2019-11-21", lts: false, security: false, v8: "7.9.317.23" }, { name: "nodejs", version: "13.3.0", date: "2019-12-03", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.4.0", date: "2019-12-17", lts: false, security: true, v8: "7.9.317.25" }, { name: "nodejs", version: "13.5.0", date: "2019-12-18", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.6.0", date: "2020-01-07", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.7.0", date: "2020-01-21", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.8.0", date: "2020-02-05", lts: false, security: true, v8: "7.9.317.25" }, { name: "nodejs", version: "13.9.0", date: "2020-02-18", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.10.0", date: "2020-03-04", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.11.0", date: "2020-03-12", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.12.0", date: "2020-03-26", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.13.0", date: "2020-04-14", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "13.14.0", date: "2020-04-29", lts: false, security: false, v8: "7.9.317.25" }, { name: "nodejs", version: "14.0.0", date: "2020-04-21", lts: false, security: false, v8: "8.1.307.30" }, { name: "nodejs", version: "14.1.0", date: "2020-04-29", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.2.0", date: "2020-05-05", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.3.0", date: "2020-05-19", lts: false, security: false, v8: "8.1.307.31" }, { name: "nodejs", version: "14.4.0", date: "2020-06-02", lts: false, security: true, v8: "8.1.307.31" }, { name: "nodejs", version: "14.5.0", date: "2020-06-30", lts: false, security: false, v8: "8.3.110.9" }, { name: "nodejs", version: "14.6.0", date: "2020-07-20", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.7.0", date: "2020-07-29", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.8.0", date: "2020-08-11", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.9.0", date: "2020-08-27", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.10.0", date: "2020-09-08", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.11.0", date: "2020-09-15", lts: false, security: true, v8: "8.4.371.19" }, { name: "nodejs", version: "14.12.0", date: "2020-09-22", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.13.0", date: "2020-09-29", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.14.0", date: "2020-10-15", lts: false, security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.15.0", date: "2020-10-27", lts: "Fermium", security: false, v8: "8.4.371.19" }, { name: "nodejs", version: "14.16.0", date: "2021-02-23", lts: "Fermium", security: true, v8: "8.4.371.19" }, { name: "nodejs", version: "14.17.0", date: "2021-05-11", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.18.0", date: "2021-09-28", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.19.0", date: "2022-02-01", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "14.20.0", date: "2022-07-07", lts: "Fermium", security: true, v8: "8.4.371.23" }, { name: "nodejs", version: "14.21.0", date: "2022-11-01", lts: "Fermium", security: false, v8: "8.4.371.23" }, { name: "nodejs", version: "15.0.0", date: "2020-10-20", lts: false, security: false, v8: "8.6.395.16" }, { name: "nodejs", version: "15.1.0", date: "2020-11-04", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.2.0", date: "2020-11-10", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.3.0", date: "2020-11-24", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.4.0", date: "2020-12-09", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.5.0", date: "2020-12-22", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.6.0", date: "2021-01-14", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.7.0", date: "2021-01-25", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.8.0", date: "2021-02-02", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.9.0", date: "2021-02-18", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.10.0", date: "2021-02-23", lts: false, security: true, v8: "8.6.395.17" }, { name: "nodejs", version: "15.11.0", date: "2021-03-03", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.12.0", date: "2021-03-17", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.13.0", date: "2021-03-31", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "15.14.0", date: "2021-04-06", lts: false, security: false, v8: "8.6.395.17" }, { name: "nodejs", version: "16.0.0", date: "2021-04-20", lts: false, security: false, v8: "9.0.257.17" }, { name: "nodejs", version: "16.1.0", date: "2021-05-04", lts: false, security: false, v8: "9.0.257.24" }, { name: "nodejs", version: "16.2.0", date: "2021-05-19", lts: false, security: false, v8: "9.0.257.25" }, { name: "nodejs", version: "16.3.0", date: "2021-06-03", lts: false, security: false, v8: "9.0.257.25" }, { name: "nodejs", version: "16.4.0", date: "2021-06-23", lts: false, security: false, v8: "9.1.269.36" }, { name: "nodejs", version: "16.5.0", date: "2021-07-14", lts: false, security: false, v8: "9.1.269.38" }, { name: "nodejs", version: "16.6.0", date: "2021-07-29", lts: false, security: true, v8: "9.2.230.21" }, { name: "nodejs", version: "16.7.0", date: "2021-08-18", lts: false, security: false, v8: "9.2.230.21" }, { name: "nodejs", version: "16.8.0", date: "2021-08-25", lts: false, security: false, v8: "9.2.230.21" }, { name: "nodejs", version: "16.9.0", date: "2021-09-07", lts: false, security: false, v8: "9.3.345.16" }, { name: "nodejs", version: "16.10.0", date: "2021-09-22", lts: false, security: false, v8: "9.3.345.19" }, { name: "nodejs", version: "16.11.0", date: "2021-10-08", lts: false, security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.12.0", date: "2021-10-20", lts: false, security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.13.0", date: "2021-10-26", lts: "Gallium", security: false, v8: "9.4.146.19" }, { name: "nodejs", version: "16.14.0", date: "2022-02-08", lts: "Gallium", security: false, v8: "9.4.146.24" }, { name: "nodejs", version: "16.15.0", date: "2022-04-26", lts: "Gallium", security: false, v8: "9.4.146.24" }, { name: "nodejs", version: "16.16.0", date: "2022-07-07", lts: "Gallium", security: true, v8: "9.4.146.24" }, { name: "nodejs", version: "16.17.0", date: "2022-08-16", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.18.0", date: "2022-10-12", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.19.0", date: "2022-12-13", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "16.20.0", date: "2023-03-28", lts: "Gallium", security: false, v8: "9.4.146.26" }, { name: "nodejs", version: "17.0.0", date: "2021-10-19", lts: false, security: false, v8: "9.5.172.21" }, { name: "nodejs", version: "17.1.0", date: "2021-11-09", lts: false, security: false, v8: "9.5.172.25" }, { name: "nodejs", version: "17.2.0", date: "2021-11-30", lts: false, security: false, v8: "9.6.180.14" }, { name: "nodejs", version: "17.3.0", date: "2021-12-17", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.4.0", date: "2022-01-18", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.5.0", date: "2022-02-10", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.6.0", date: "2022-02-22", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.7.0", date: "2022-03-09", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.8.0", date: "2022-03-22", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "17.9.0", date: "2022-04-07", lts: false, security: false, v8: "9.6.180.15" }, { name: "nodejs", version: "18.0.0", date: "2022-04-18", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.1.0", date: "2022-05-03", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.2.0", date: "2022-05-17", lts: false, security: false, v8: "10.1.124.8" }, { name: "nodejs", version: "18.3.0", date: "2022-06-02", lts: false, security: false, v8: "10.2.154.4" }, { name: "nodejs", version: "18.4.0", date: "2022-06-16", lts: false, security: false, v8: "10.2.154.4" }, { name: "nodejs", version: "18.5.0", date: "2022-07-06", lts: false, security: true, v8: "10.2.154.4" }, { name: "nodejs", version: "18.6.0", date: "2022-07-13", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.7.0", date: "2022-07-26", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.8.0", date: "2022-08-24", lts: false, security: false, v8: "10.2.154.13" }, { name: "nodejs", version: "18.9.0", date: "2022-09-07", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.10.0", date: "2022-09-28", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.11.0", date: "2022-10-13", lts: false, security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.12.0", date: "2022-10-25", lts: "Hydrogen", security: false, v8: "10.2.154.15" }, { name: "nodejs", version: "18.13.0", date: "2023-01-05", lts: "Hydrogen", security: false, v8: "10.2.154.23" }, { name: "nodejs", version: "18.14.0", date: "2023-02-01", lts: "Hydrogen", security: false, v8: "10.2.154.23" }, { name: "nodejs", version: "18.15.0", date: "2023-03-05", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.16.0", date: "2023-04-12", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.17.0", date: "2023-07-18", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.18.0", date: "2023-09-18", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.19.0", date: "2023-11-29", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "18.20.0", date: "2024-03-26", lts: "Hydrogen", security: false, v8: "10.2.154.26" }, { name: "nodejs", version: "19.0.0", date: "2022-10-17", lts: false, security: false, v8: "10.7.193.13" }, { name: "nodejs", version: "19.1.0", date: "2022-11-14", lts: false, security: false, v8: "10.7.193.20" }, { name: "nodejs", version: "19.2.0", date: "2022-11-29", lts: false, security: false, v8: "10.8.168.20" }, { name: "nodejs", version: "19.3.0", date: "2022-12-14", lts: false, security: false, v8: "10.8.168.21" }, { name: "nodejs", version: "19.4.0", date: "2023-01-05", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.5.0", date: "2023-01-24", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.6.0", date: "2023-02-01", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.7.0", date: "2023-02-21", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.8.0", date: "2023-03-14", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "19.9.0", date: "2023-04-10", lts: false, security: false, v8: "10.8.168.25" }, { name: "nodejs", version: "20.0.0", date: "2023-04-17", lts: false, security: false, v8: "11.3.244.4" }, { name: "nodejs", version: "20.1.0", date: "2023-05-03", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.2.0", date: "2023-05-16", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.3.0", date: "2023-06-08", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.4.0", date: "2023-07-04", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.5.0", date: "2023-07-19", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.6.0", date: "2023-08-23", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.7.0", date: "2023-09-18", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.8.0", date: "2023-09-28", lts: false, security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.9.0", date: "2023-10-24", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.10.0", date: "2023-11-22", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.11.0", date: "2024-01-09", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.12.0", date: "2024-03-26", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.13.0", date: "2024-05-07", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.14.0", date: "2024-05-28", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "20.15.0", date: "2024-06-20", lts: "Iron", security: false, v8: "11.3.244.8" }, { name: "nodejs", version: "21.0.0", date: "2023-10-17", lts: false, security: false, v8: "11.8.172.13" }, { name: "nodejs", version: "21.1.0", date: "2023-10-24", lts: false, security: false, v8: "11.8.172.15" }, { name: "nodejs", version: "21.2.0", date: "2023-11-14", lts: false, security: false, v8: "11.8.172.17" }, { name: "nodejs", version: "21.3.0", date: "2023-11-30", lts: false, security: false, v8: "11.8.172.17" }, { name: "nodejs", version: "21.4.0", date: "2023-12-05", lts: false, security: false, v8: "11.8.172.17" }, { name: "nodejs", version: "21.5.0", date: "2023-12-19", lts: false, security: false, v8: "11.8.172.17" }, { name: "nodejs", version: "21.6.0", date: "2024-01-14", lts: false, security: false, v8: "11.8.172.17" }, { name: "nodejs", version: "21.7.0", date: "2024-03-06", lts: false, security: false, v8: "11.8.172.17" }, { name: "nodejs", version: "22.0.0", date: "2024-04-24", lts: false, security: false, v8: "12.4.254.14" }, { name: "nodejs", version: "22.1.0", date: "2024-05-02", lts: false, security: false, v8: "12.4.254.14" }, { name: "nodejs", version: "22.2.0", date: "2024-05-15", lts: false, security: false, v8: "12.4.254.14" }, { name: "nodejs", version: "22.3.0", date: "2024-06-11", lts: false, security: false, v8: "12.4.254.20" }, { name: "nodejs", version: "22.4.0", date: "2024-07-02", lts: false, security: false, v8: "12.4.254.21" }, { name: "nodejs", version: "22.5.0", date: "2024-07-17", lts: false, security: false, v8: "12.4.254.21" }];
  }
});

// node_modules/caniuse-lite/data/browsers.js
var require_browsers = __commonJS({
  "node_modules/caniuse-lite/data/browsers.js"(exports2, module) {
    module.exports = { A: "ie", B: "edge", C: "firefox", D: "chrome", E: "safari", F: "opera", G: "ios_saf", H: "op_mini", I: "android", J: "bb", K: "op_mob", L: "and_chr", M: "and_ff", N: "ie_mob", O: "and_uc", P: "samsung", Q: "and_qq", R: "baidu", S: "kaios" };
  }
});

// node_modules/caniuse-lite/dist/unpacker/browsers.js
var require_browsers2 = __commonJS({
  "node_modules/caniuse-lite/dist/unpacker/browsers.js"(exports2, module) {
    module.exports.browsers = require_browsers();
  }
});

// node_modules/caniuse-lite/data/browserVersions.js
var require_browserVersions = __commonJS({
  "node_modules/caniuse-lite/data/browserVersions.js"(exports2, module) {
    module.exports = { "0": "22", "1": "23", "2": "24", "3": "25", "4": "26", "5": "115", "6": "116", "7": "117", "8": "118", "9": "119", A: "10", B: "11", C: "12", D: "130", E: "7", F: "8", G: "9", H: "15", I: "80", J: "4", K: "6", L: "13", M: "14", N: "16", O: "17", P: "18", Q: "79", R: "81", S: "83", T: "84", U: "85", V: "86", W: "87", X: "88", Y: "89", Z: "90", a: "91", b: "92", c: "93", d: "94", e: "95", f: "96", g: "97", h: "98", i: "99", j: "100", k: "101", l: "102", m: "103", n: "104", o: "105", p: "106", q: "107", r: "108", s: "109", t: "110", u: "111", v: "112", w: "113", x: "114", y: "20", z: "21", AB: "120", BB: "121", CB: "122", DB: "123", EB: "124", FB: "125", GB: "126", HB: "127", IB: "128", JB: "129", KB: "5", LB: "19", MB: "27", NB: "28", OB: "29", PB: "30", QB: "31", RB: "32", SB: "33", TB: "34", UB: "35", VB: "36", WB: "37", XB: "38", YB: "39", ZB: "40", aB: "41", bB: "42", cB: "43", dB: "44", eB: "45", fB: "46", gB: "47", hB: "48", iB: "49", jB: "50", kB: "51", lB: "52", mB: "53", nB: "54", oB: "55", pB: "56", qB: "57", rB: "58", sB: "60", tB: "62", uB: "63", vB: "64", wB: "65", xB: "66", yB: "67", zB: "68", "0B": "69", "1B": "70", "2B": "71", "3B": "72", "4B": "73", "5B": "74", "6B": "75", "7B": "76", "8B": "77", "9B": "78", AC: "11.1", BC: "12.1", CC: "15.5", DC: "16.0", EC: "17.0", FC: "18.0", GC: "3", HC: "59", IC: "61", JC: "82", KC: "131", LC: "132", MC: "133", NC: "3.2", OC: "10.1", PC: "15.2-15.3", QC: "15.4", RC: "16.1", SC: "16.2", TC: "16.3", UC: "16.4", VC: "16.5", WC: "17.1", XC: "17.2", YC: "17.3", ZC: "17.4", aC: "17.5", bC: "18.1", cC: "11.5", dC: "4.2-4.3", eC: "5.5", fC: "2", gC: "134", hC: "135", iC: "3.5", jC: "3.6", kC: "3.1", lC: "5.1", mC: "6.1", nC: "7.1", oC: "9.1", pC: "13.1", qC: "14.1", rC: "15.1", sC: "15.6", tC: "16.6", uC: "17.6", vC: "TP", wC: "9.5-9.6", xC: "10.0-10.1", yC: "10.5", zC: "10.6", "0C": "11.6", "1C": "4.0-4.1", "2C": "5.0-5.1", "3C": "6.0-6.1", "4C": "7.0-7.1", "5C": "8.1-8.4", "6C": "9.0-9.2", "7C": "9.3", "8C": "10.0-10.2", "9C": "10.3", AD: "11.0-11.2", BD: "11.3-11.4", CD: "12.0-12.1", DD: "12.2-12.5", ED: "13.0-13.1", FD: "13.2", GD: "13.3", HD: "13.4-13.7", ID: "14.0-14.4", JD: "14.5-14.8", KD: "15.0-15.1", LD: "15.6-15.8", MD: "16.6-16.7", ND: "17.6-17.7", OD: "all", PD: "2.1", QD: "2.2", RD: "2.3", SD: "4.1", TD: "4.4", UD: "4.4.3-4.4.4", VD: "5.0-5.4", WD: "6.2-6.4", XD: "7.2-7.4", YD: "8.2", ZD: "9.2", aD: "11.1-11.2", bD: "12.0", cD: "13.0", dD: "14.0", eD: "15.0", fD: "19.0", gD: "14.9", hD: "13.52", iD: "2.5", jD: "3.0-3.1" };
  }
});

// node_modules/caniuse-lite/dist/unpacker/browserVersions.js
var require_browserVersions2 = __commonJS({
  "node_modules/caniuse-lite/dist/unpacker/browserVersions.js"(exports2, module) {
    module.exports.browserVersions = require_browserVersions();
  }
});

// node_modules/caniuse-lite/data/agents.js
var require_agents = __commonJS({
  "node_modules/caniuse-lite/data/agents.js"(exports2, module) {
    module.exports = { A: { A: { K: 0, E: 0, F: 0.0417486, G: 0.0417486, A: 0, B: 0.445318, eC: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "eC", "K", "E", "F", "G", "A", "B", "", "", ""], E: "IE", F: { eC: 962323200, K: 998870400, E: 1161129600, F: 1237420800, G: 1300060800, A: 1346716800, B: 1381968e3 } }, B: { A: { "5": 3647e-6, "6": 3647e-6, "7": 7294e-6, "8": 3647e-6, "9": 0.010941, C: 0, L: 0, M: 0, H: 0, N: 0, O: 3647e-6, P: 0.047411, Q: 0, I: 0, R: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0.014588, c: 0, d: 0, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0, m: 0, n: 0, o: 0, p: 0, q: 3647e-6, r: 7294e-6, s: 0.061999, t: 7294e-6, u: 7294e-6, v: 3647e-6, w: 7294e-6, x: 0.010941, AB: 0.032823, BB: 0.014588, CB: 0.018235, DB: 0.010941, EB: 0.018235, FB: 0.025529, GB: 0.061999, HB: 0.193291, IB: 3.1656, JB: 1.29104, D: 3647e-6 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "C", "L", "M", "H", "N", "O", "P", "Q", "I", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "D", "", "", ""], E: "Edge", F: { "5": 1689897600, "6": 1692576e3, "7": 1694649600, "8": 1697155200, "9": 1698969600, C: 1438128e3, L: 1447286400, M: 1470096e3, H: 1491868800, N: 1508198400, O: 1525046400, P: 1542067200, Q: 1579046400, I: 1581033600, R: 1586736e3, S: 1590019200, T: 1594857600, U: 1598486400, V: 1602201600, W: 1605830400, X: 161136e4, Y: 1614816e3, Z: 1618358400, a: 1622073600, b: 1626912e3, c: 1630627200, d: 1632441600, e: 1634774400, f: 1637539200, g: 1641427200, h: 1643932800, i: 1646265600, j: 1649635200, k: 1651190400, l: 1653955200, m: 1655942400, n: 1659657600, o: 1661990400, p: 1664755200, q: 1666915200, r: 1670198400, s: 1673481600, t: 1675900800, u: 1678665600, v: 1680825600, w: 1683158400, x: 1685664e3, AB: 1701993600, BB: 1706227200, CB: 1708732800, DB: 1711152e3, EB: 1713398400, FB: 1715990400, GB: 1718841600, HB: 1721865600, IB: 1724371200, JB: 1726704e3, D: 1729123200 }, D: { C: "ms", L: "ms", M: "ms", H: "ms", N: "ms", O: "ms", P: "ms" } }, C: { A: { "0": 0, "1": 0, "2": 0, "3": 0, "4": 0, "5": 0.335524, "6": 0, "7": 3647e-6, "8": 0.076587, "9": 0, fC: 0, GC: 0, J: 3647e-6, KB: 0, K: 0, E: 0, F: 0, G: 0, A: 0, B: 0.014588, C: 0, L: 0, M: 0, H: 0, N: 0, O: 0, P: 0, LB: 0, y: 0, z: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 7294e-6, dB: 7294e-6, eB: 3647e-6, fB: 0, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0.040117, mB: 0, nB: 0, oB: 3647e-6, pB: 0.014588, qB: 0, rB: 0, HC: 3647e-6, sB: 0, IC: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0.010941, Q: 0, I: 0, R: 0, JC: 0, S: 0, T: 0, U: 0, V: 0, W: 0, X: 7294e-6, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 3647e-6, e: 0, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 3647e-6, m: 7294e-6, n: 0, o: 3647e-6, p: 0, q: 0, r: 0, s: 3647e-6, t: 0, u: 0, v: 0, w: 7294e-6, x: 0, AB: 7294e-6, BB: 3647e-6, CB: 3647e-6, DB: 3647e-6, EB: 3647e-6, FB: 0.014588, GB: 0.010941, HB: 0.021882, IB: 0.03647, JB: 0.299054, D: 1.30198, KC: 7294e-6, LC: 0, MC: 0, gC: 0, hC: 0, iC: 0, jC: 0 }, B: "moz", C: ["fC", "GC", "iC", "jC", "J", "KB", "K", "E", "F", "G", "A", "B", "C", "L", "M", "H", "N", "O", "P", "LB", "y", "z", "0", "1", "2", "3", "4", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "HC", "sB", "IC", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "Q", "I", "R", "JC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "D", "KC", "LC", "MC", "gC", "hC"], E: "Firefox", F: { "0": 1368489600, "1": 1372118400, "2": 1375747200, "3": 1379376e3, "4": 1386633600, "5": 1688428800, "6": 1690848e3, "7": 1693267200, "8": 1695686400, "9": 1698105600, fC: 1161648e3, GC: 1213660800, iC: 124632e4, jC: 1264032e3, J: 1300752e3, KB: 1308614400, K: 1313452800, E: 1317081600, F: 1317081600, G: 1320710400, A: 1324339200, B: 1327968e3, C: 1331596800, L: 1335225600, M: 1338854400, H: 1342483200, N: 1346112e3, O: 1349740800, P: 1353628800, LB: 1357603200, y: 1361232e3, z: 1364860800, MB: 1391472e3, NB: 1395100800, OB: 1398729600, PB: 1402358400, QB: 1405987200, RB: 1409616e3, SB: 1413244800, TB: 1417392e3, UB: 1421107200, VB: 1424736e3, WB: 1428278400, XB: 1431475200, YB: 1435881600, ZB: 1439251200, aB: 144288e4, bB: 1446508800, cB: 1450137600, dB: 1453852800, eB: 1457395200, fB: 1461628800, gB: 1465257600, hB: 1470096e3, iB: 1474329600, jB: 1479168e3, kB: 1485216e3, lB: 1488844800, mB: 149256e4, nB: 1497312e3, oB: 1502150400, pB: 1506556800, qB: 1510617600, rB: 1516665600, HC: 1520985600, sB: 1525824e3, IC: 1529971200, tB: 1536105600, uB: 1540252800, vB: 1544486400, wB: 154872e4, xB: 1552953600, yB: 1558396800, zB: 1562630400, "0B": 1567468800, "1B": 1571788800, "2B": 1575331200, "3B": 1578355200, "4B": 1581379200, "5B": 1583798400, "6B": 1586304e3, "7B": 1588636800, "8B": 1591056e3, "9B": 1593475200, Q: 1595894400, I: 1598313600, R: 1600732800, JC: 1603152e3, S: 1605571200, T: 1607990400, U: 1611619200, V: 1614038400, W: 1616457600, X: 1618790400, Y: 1622505600, Z: 1626134400, a: 1628553600, b: 1630972800, c: 1633392e3, d: 1635811200, e: 1638835200, f: 1641859200, g: 1644364800, h: 1646697600, i: 1649116800, j: 1651536e3, k: 1653955200, l: 1656374400, m: 1658793600, n: 1661212800, o: 1663632e3, p: 1666051200, q: 1668470400, r: 1670889600, s: 1673913600, t: 1676332800, u: 1678752e3, v: 1681171200, w: 1683590400, x: 1686009600, AB: 1700524800, BB: 1702944e3, CB: 1705968e3, DB: 1708387200, EB: 1710806400, FB: 1713225600, GB: 1715644800, HB: 1718064e3, IB: 1720483200, JB: 1722902400, D: 1725321600, KC: 1727740800, LC: 173016e4, MC: null, gC: null, hC: null } }, D: { A: { "0": 0, "1": 0, "2": 0, "3": 0, "4": 0, "5": 0.025529, "6": 0.156821, "7": 0.098469, "8": 0.07294, "9": 0.058352, J: 0, KB: 0, K: 0, E: 0, F: 0, G: 0, A: 0, B: 0, C: 0, L: 0, M: 0, H: 0, N: 0, O: 0, P: 0, LB: 0, y: 0, z: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0.010941, YB: 0, ZB: 0, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0, gB: 3647e-6, hB: 0.018235, iB: 0.018235, jB: 7294e-6, kB: 3647e-6, lB: 3647e-6, mB: 7294e-6, nB: 0, oB: 0, pB: 0.021882, qB: 0, rB: 3647e-6, HC: 0, sB: 0, IC: 3647e-6, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0.021882, yB: 3647e-6, zB: 0, "0B": 0.076587, "1B": 7294e-6, "2B": 0, "3B": 0, "4B": 7294e-6, "5B": 7294e-6, "6B": 7294e-6, "7B": 7294e-6, "8B": 0.018235, "9B": 0.014588, Q: 0.098469, I: 0.010941, R: 0.018235, S: 0.032823, T: 7294e-6, U: 7294e-6, V: 0.025529, W: 0.069293, X: 0.014588, Y: 0.010941, Z: 0.010941, a: 0.058352, b: 0.021882, c: 0.014588, d: 0.047411, e: 7294e-6, f: 7294e-6, g: 0.014588, h: 0.040117, i: 0.025529, j: 0.029176, k: 0.018235, l: 0.014588, m: 0.131292, n: 0.040117, o: 0.014588, p: 0.025529, q: 0.029176, r: 0.043764, s: 1.36033, t: 0.021882, u: 0.040117, v: 0.043764, w: 0.091175, x: 0.091175, AB: 0.094822, BB: 0.098469, CB: 0.10941, DB: 0.142233, EB: 0.262584, FB: 0.258937, GB: 0.419405, HB: 1.15975, IB: 12.4691, JB: 4.05546, D: 0.014588, KC: 3647e-6, LC: 0, MC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "J", "KB", "K", "E", "F", "G", "A", "B", "C", "L", "M", "H", "N", "O", "P", "LB", "y", "z", "0", "1", "2", "3", "4", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "HC", "sB", "IC", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "Q", "I", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "5", "6", "7", "8", "9", "AB", "BB", "CB", "DB", "EB", "FB", "GB", "HB", "IB", "JB", "D", "KC", "LC", "MC"], E: "Chrome", F: { "0": 1343692800, "1": 1348531200, "2": 1352246400, "3": 1357862400, "4": 1361404800, "5": 1689724800, "6": 1692057600, "7": 1694476800, "8": 1696896e3, "9": 1698710400, J: 1264377600, KB: 1274745600, K: 1283385600, E: 1287619200, F: 1291248e3, G: 1296777600, A: 1299542400, B: 1303862400, C: 1307404800, L: 1312243200, M: 1316131200, H: 1316131200, N: 1319500800, O: 1323734400, P: 1328659200, LB: 1332892800, y: 133704e4, z: 1340668800, MB: 1364428800, NB: 1369094400, OB: 1374105600, PB: 1376956800, QB: 1384214400, RB: 1389657600, SB: 1392940800, TB: 1397001600, UB: 1400544e3, VB: 1405468800, WB: 1409011200, XB: 141264e4, YB: 1416268800, ZB: 1421798400, aB: 1425513600, bB: 1429401600, cB: 143208e4, dB: 1437523200, eB: 1441152e3, fB: 1444780800, gB: 1449014400, hB: 1453248e3, iB: 1456963200, jB: 1460592e3, kB: 1464134400, lB: 1469059200, mB: 1472601600, nB: 1476230400, oB: 1480550400, pB: 1485302400, qB: 1489017600, rB: 149256e4, HC: 1496707200, sB: 1500940800, IC: 1504569600, tB: 1508198400, uB: 1512518400, vB: 1516752e3, wB: 1520294400, xB: 1523923200, yB: 1527552e3, zB: 1532390400, "0B": 1536019200, "1B": 1539648e3, "2B": 1543968e3, "3B": 154872e4, "4B": 1552348800, "5B": 1555977600, "6B": 1559606400, "7B": 1564444800, "8B": 1568073600, "9B": 1571702400, Q: 1575936e3, I: 1580860800, R: 1586304e3, S: 1589846400, T: 1594684800, U: 1598313600, V: 1601942400, W: 1605571200, X: 1611014400, Y: 1614556800, Z: 1618272e3, a: 1621987200, b: 1626739200, c: 1630368e3, d: 1632268800, e: 1634601600, f: 1637020800, g: 1641340800, h: 1643673600, i: 1646092800, j: 1648512e3, k: 1650931200, l: 1653350400, m: 1655769600, n: 1659398400, o: 1661817600, p: 1664236800, q: 1666656e3, r: 166968e4, s: 1673308800, t: 1675728e3, u: 1678147200, v: 1680566400, w: 1682985600, x: 1685404800, AB: 1701993600, BB: 1705968e3, CB: 1708387200, DB: 1710806400, EB: 1713225600, FB: 1715644800, GB: 1718064e3, HB: 1721174400, IB: 1724112e3, JB: 1726531200, D: 1728950400, KC: null, LC: null, MC: null } }, E: { A: { J: 0, KB: 0, K: 0, E: 0, F: 0, G: 0, A: 0, B: 0, C: 0, L: 3647e-6, M: 0.025529, H: 7294e-6, kC: 0, NC: 0, lC: 0, mC: 0, nC: 0, oC: 0, OC: 0, AC: 3647e-6, BC: 7294e-6, pC: 0.058352, qC: 0.076587, rC: 0.021882, PC: 7294e-6, QC: 0.018235, CC: 0.029176, sC: 0.21882, DC: 0.029176, RC: 0.03647, SC: 0.029176, TC: 0.069293, UC: 0.021882, VC: 0.040117, tC: 0.273525, EC: 0.018235, WC: 0.03647, XC: 0.03647, YC: 0.043764, ZC: 0.10941, aC: 0.309995, uC: 1.53903, FC: 0.149527, bC: 7294e-6, vC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "kC", "NC", "J", "KB", "lC", "K", "mC", "E", "nC", "F", "G", "oC", "A", "OC", "B", "AC", "C", "BC", "L", "pC", "M", "qC", "H", "rC", "PC", "QC", "CC", "sC", "DC", "RC", "SC", "TC", "UC", "VC", "tC", "EC", "WC", "XC", "YC", "ZC", "aC", "uC", "FC", "bC", "vC", ""], E: "Safari", F: { kC: 1205798400, NC: 1226534400, J: 1244419200, KB: 1275868800, lC: 131112e4, K: 1343174400, mC: 13824e5, E: 13824e5, nC: 1410998400, F: 1413417600, G: 1443657600, oC: 1458518400, A: 1474329600, OC: 1490572800, B: 1505779200, AC: 1522281600, C: 1537142400, BC: 1553472e3, L: 1568851200, pC: 1585008e3, M: 1600214400, qC: 1619395200, H: 1632096e3, rC: 1635292800, PC: 1639353600, QC: 1647216e3, CC: 1652745600, sC: 1658275200, DC: 1662940800, RC: 1666569600, SC: 1670889600, TC: 1674432e3, UC: 1679875200, VC: 1684368e3, tC: 1690156800, EC: 1695686400, WC: 1698192e3, XC: 1702252800, YC: 1705881600, ZC: 1709596800, aC: 1715558400, uC: 1722211200, FC: 1726444800, bC: null, vC: null } }, F: { A: { "0": 0, "1": 0, "2": 0, "3": 0, "4": 0, G: 0, B: 0, C: 0, H: 0, N: 0, O: 0, P: 0, LB: 0, y: 0, z: 0, MB: 0, NB: 0, OB: 0, PB: 0, QB: 0, RB: 0, SB: 0, TB: 0, UB: 0, VB: 0, WB: 0, XB: 0, YB: 0, ZB: 3647e-6, aB: 0, bB: 0, cB: 0, dB: 0, eB: 0, fB: 0.014588, gB: 0, hB: 0, iB: 0, jB: 0, kB: 0, lB: 0, mB: 0, nB: 0, oB: 0, pB: 0, qB: 0, rB: 0, sB: 0, tB: 0, uB: 0, vB: 0, wB: 0, xB: 0, yB: 0, zB: 0, "0B": 0, "1B": 0, "2B": 0, "3B": 0, "4B": 0, "5B": 0, "6B": 0, "7B": 0, "8B": 0, "9B": 0, Q: 0, I: 0, R: 0, JC: 0, S: 0, T: 0.018235, U: 0, V: 0, W: 0, X: 0, Y: 0, Z: 0, a: 0, b: 0, c: 0, d: 0, e: 0.03647, f: 0, g: 0, h: 0, i: 0, j: 0, k: 0, l: 0.029176, m: 0, n: 0, o: 0, p: 0, q: 0, r: 0, s: 0.018235, t: 0, u: 7294e-6, v: 0.495992, w: 0.382935, x: 3647e-6, wC: 0, xC: 0, yC: 0, zC: 0, AC: 0, cC: 0, "0C": 0, BC: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "G", "wC", "xC", "yC", "zC", "B", "AC", "cC", "0C", "C", "BC", "H", "N", "O", "P", "LB", "y", "z", "0", "1", "2", "3", "4", "MB", "NB", "OB", "PB", "QB", "RB", "SB", "TB", "UB", "VB", "WB", "XB", "YB", "ZB", "aB", "bB", "cB", "dB", "eB", "fB", "gB", "hB", "iB", "jB", "kB", "lB", "mB", "nB", "oB", "pB", "qB", "rB", "sB", "tB", "uB", "vB", "wB", "xB", "yB", "zB", "0B", "1B", "2B", "3B", "4B", "5B", "6B", "7B", "8B", "9B", "Q", "I", "R", "JC", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "", "", ""], E: "Opera", F: { "0": 1401753600, "1": 1405987200, "2": 1409616e3, "3": 1413331200, "4": 1417132800, G: 1150761600, wC: 1223424e3, xC: 1251763200, yC: 1267488e3, zC: 1277942400, B: 1292457600, AC: 1302566400, cC: 1309219200, "0C": 1323129600, C: 1323129600, BC: 1352073600, H: 1372723200, N: 1377561600, O: 1381104e3, P: 1386288e3, LB: 1390867200, y: 1393891200, z: 1399334400, MB: 1422316800, NB: 1425945600, OB: 1430179200, PB: 1433808e3, QB: 1438646400, RB: 1442448e3, SB: 1445904e3, TB: 1449100800, UB: 1454371200, VB: 1457308800, WB: 146232e4, XB: 1465344e3, YB: 1470096e3, ZB: 1474329600, aB: 1477267200, bB: 1481587200, cB: 1486425600, dB: 1490054400, eB: 1494374400, fB: 1498003200, gB: 1502236800, hB: 1506470400, iB: 1510099200, jB: 1515024e3, kB: 1517961600, lB: 1521676800, mB: 1525910400, nB: 1530144e3, oB: 1534982400, pB: 1537833600, qB: 1543363200, rB: 1548201600, sB: 1554768e3, tB: 1561593600, uB: 1566259200, vB: 1570406400, wB: 1573689600, xB: 1578441600, yB: 1583971200, zB: 1587513600, "0B": 1592956800, "1B": 1595894400, "2B": 1600128e3, "3B": 1603238400, "4B": 161352e4, "5B": 1612224e3, "6B": 1616544e3, "7B": 1619568e3, "8B": 1623715200, "9B": 1627948800, Q: 1631577600, I: 1633392e3, R: 1635984e3, JC: 1638403200, S: 1642550400, T: 1644969600, U: 1647993600, V: 1650412800, W: 1652745600, X: 1654646400, Y: 1657152e3, Z: 1660780800, a: 1663113600, b: 1668816e3, c: 1668643200, d: 1671062400, e: 1675209600, f: 1677024e3, g: 1679529600, h: 1681948800, i: 1684195200, j: 1687219200, k: 1690329600, l: 1692748800, m: 1696204800, n: 169992e4, o: 169992e4, p: 1702944e3, q: 1707264e3, r: 1710115200, s: 1711497600, t: 1716336e3, u: 1719273600, v: 1721088e3, w: 1724284800, x: 1727222400 }, D: { G: "o", B: "o", C: "o", wC: "o", xC: "o", yC: "o", zC: "o", AC: "o", cC: "o", "0C": "o", BC: "o" } }, G: { A: { F: 0, NC: 0, "1C": 0, dC: 292873e-8, "2C": 146437e-8, "3C": 87862e-7, "4C": 0.0102506, "5C": 0, "6C": 0.0102506, "7C": 0.0248942, "8C": 732183e-8, "9C": 0.0424666, AD: 0.156687, BD: 0.0117149, CD: 732183e-8, DD: 0.177188, ED: 292873e-8, FD: 0.0556459, GD: 732183e-8, HD: 0.0292873, ID: 0.102506, JD: 0.0893264, KD: 0.0512528, PC: 0.0512528, QC: 0.0571103, CC: 0.0702896, LD: 0.69411, DC: 0.139115, RC: 0.276765, SC: 0.139115, TC: 0.234299, UC: 0.0497885, VC: 0.0981126, MD: 0.834689, EC: 0.0702896, WC: 0.111292, XC: 0.101041, YC: 0.144972, ZC: 0.31191, aC: 1.48926, ND: 7.75382, FC: 0.998698, bC: 0.0453954 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "NC", "1C", "dC", "2C", "3C", "4C", "F", "5C", "6C", "7C", "8C", "9C", "AD", "BD", "CD", "DD", "ED", "FD", "GD", "HD", "ID", "JD", "KD", "PC", "QC", "CC", "LD", "DC", "RC", "SC", "TC", "UC", "VC", "MD", "EC", "WC", "XC", "YC", "ZC", "aC", "ND", "FC", "bC", "", ""], E: "Safari on iOS", F: { NC: 1270252800, "1C": 1283904e3, dC: 1299628800, "2C": 1331078400, "3C": 1359331200, "4C": 1394409600, F: 1410912e3, "5C": 1413763200, "6C": 1442361600, "7C": 1458518400, "8C": 1473724800, "9C": 1490572800, AD: 1505779200, BD: 1522281600, CD: 1537142400, DD: 1553472e3, ED: 1568851200, FD: 1572220800, GD: 1580169600, HD: 1585008e3, ID: 1600214400, JD: 1619395200, KD: 1632096e3, PC: 1639353600, QC: 1647216e3, CC: 1652659200, LD: 1658275200, DC: 1662940800, RC: 1666569600, SC: 1670889600, TC: 1674432e3, UC: 1679875200, VC: 1684368e3, MD: 1690156800, EC: 1694995200, WC: 1698192e3, XC: 1702252800, YC: 1705881600, ZC: 1709596800, aC: 1715558400, ND: 1722211200, FC: 1726444800, bC: null } }, H: { A: { OD: 0.05 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "OD", "", "", ""], E: "Opera Mini", F: { OD: 1426464e3 } }, I: { A: { GC: 0, J: 0, D: 0.266132, PD: 0, QD: 0, RD: 0, SD: 266826e-10, dC: 10673e-8, TD: 0, UD: 426922e-9 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "PD", "QD", "RD", "GC", "J", "SD", "dC", "TD", "UD", "D", "", "", ""], E: "Android Browser", F: { PD: 1256515200, QD: 1274313600, RD: 1291593600, GC: 1298332800, J: 1318896e3, SD: 1341792e3, dC: 1374624e3, TD: 1386547200, UD: 1401667200, D: 1728864e3 } }, J: { A: { E: 0, A: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "E", "A", "", "", ""], E: "Blackberry Browser", F: { E: 1325376e3, A: 1359504e3 } }, K: { A: { A: 0, B: 0, C: 0, I: 1.15072, AC: 0, cC: 0, BC: 0 }, B: "o", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "AC", "cC", "C", "BC", "I", "", "", ""], E: "Opera Mobile", F: { A: 1287100800, B: 1300752e3, AC: 1314835200, cC: 1318291200, C: 1330300800, BC: 1349740800, I: 1709769600 }, D: { I: "webkit" } }, L: { A: { D: 43.6637 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "", "", ""], E: "Chrome for Android", F: { D: 1728864e3 } }, M: { A: { D: 0.343062 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "D", "", "", ""], E: "Firefox for Android", F: { D: 1725321600 } }, N: { A: { A: 0, B: 0 }, B: "ms", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "A", "B", "", "", ""], E: "IE Mobile", F: { A: 1340150400, B: 1353456e3 } }, O: { A: { CC: 1.23248 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "CC", "", "", ""], E: "UC Browser for Android", F: { CC: 1710115200 }, D: { CC: "webkit" } }, P: { A: { "0": 0.0434355, "1": 0.0542944, "2": 0.0651532, "3": 0.206319, "4": 0, J: 0.086871, y: 0.0108589, z: 0.0434355, VD: 0.0108589, WD: 0.0108589, XD: 0.0325766, YD: 0, ZD: 0, OC: 0, aD: 0, bD: 0, cD: 0, dD: 0, eD: 0, DC: 0, EC: 0.0217177, FC: 0, fD: 0.0108589 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "J", "VD", "WD", "XD", "YD", "ZD", "OC", "aD", "bD", "cD", "dD", "eD", "DC", "EC", "FC", "fD", "y", "z", "0", "1", "2", "3", "4", "", "", ""], E: "Samsung Internet", F: { "0": 1689292800, "1": 1697587200, "2": 1711497600, "3": 1715126400, "4": 1717718400, J: 1461024e3, VD: 1481846400, WD: 1509408e3, XD: 1528329600, YD: 1546128e3, ZD: 1554163200, OC: 1567900800, aD: 1582588800, bD: 1593475200, cD: 1605657600, dD: 1618531200, eD: 1629072e3, DC: 1640736e3, EC: 1651708800, FC: 1659657600, fD: 1667260800, y: 1677369600, z: 1684454400 } }, Q: { A: { gD: 0.273179 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "gD", "", "", ""], E: "QQ Browser", F: { gD: 1710288e3 } }, R: { A: { hD: 0 }, B: "webkit", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "hD", "", "", ""], E: "Baidu Browser", F: { hD: 1710201600 } }, S: { A: { iD: 0.031765, jD: 0 }, B: "moz", C: ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "iD", "jD", "", "", ""], E: "KaiOS Browser", F: { iD: 1527811200, jD: 1631664e3 } } };
  }
});

// node_modules/caniuse-lite/dist/unpacker/agents.js
var require_agents2 = __commonJS({
  "node_modules/caniuse-lite/dist/unpacker/agents.js"(exports2, module) {
    "use strict";
    var browsers = require_browsers2().browsers;
    var versions = require_browserVersions2().browserVersions;
    var agentsData = require_agents();
    function unpackBrowserVersions(versionsData) {
      return Object.keys(versionsData).reduce((usage, version4) => {
        usage[versions[version4]] = versionsData[version4];
        return usage;
      }, {});
    }
    module.exports.agents = Object.keys(agentsData).reduce((map, key) => {
      let versionsData = agentsData[key];
      map[browsers[key]] = Object.keys(versionsData).reduce((data, entry2) => {
        if (entry2 === "A") {
          data.usage_global = unpackBrowserVersions(versionsData[entry2]);
        } else if (entry2 === "C") {
          data.versions = versionsData[entry2].reduce((list2, version4) => {
            if (version4 === "") {
              list2.push(null);
            } else {
              list2.push(versions[version4]);
            }
            return list2;
          }, []);
        } else if (entry2 === "D") {
          data.prefix_exceptions = unpackBrowserVersions(versionsData[entry2]);
        } else if (entry2 === "E") {
          data.browser = versionsData[entry2];
        } else if (entry2 === "F") {
          data.release_date = Object.keys(versionsData[entry2]).reduce(
            (map2, key2) => {
              map2[versions[key2]] = versionsData[entry2][key2];
              return map2;
            },
            {}
          );
        } else {
          data.prefix = versionsData[entry2];
        }
        return data;
      }, {});
      return map;
    }, {});
  }
});

// node_modules/electron-to-chromium/versions.js
var require_versions = __commonJS({
  "node_modules/electron-to-chromium/versions.js"(exports2, module) {
    module.exports = {
      "0.20": "39",
      "0.21": "41",
      "0.22": "41",
      "0.23": "41",
      "0.24": "41",
      "0.25": "42",
      "0.26": "42",
      "0.27": "43",
      "0.28": "43",
      "0.29": "43",
      "0.30": "44",
      "0.31": "45",
      "0.32": "45",
      "0.33": "45",
      "0.34": "45",
      "0.35": "45",
      "0.36": "47",
      "0.37": "49",
      "1.0": "49",
      "1.1": "50",
      "1.2": "51",
      "1.3": "52",
      "1.4": "53",
      "1.5": "54",
      "1.6": "56",
      "1.7": "58",
      "1.8": "59",
      "2.0": "61",
      "2.1": "61",
      "3.0": "66",
      "3.1": "66",
      "4.0": "69",
      "4.1": "69",
      "4.2": "69",
      "5.0": "73",
      "6.0": "76",
      "6.1": "76",
      "7.0": "78",
      "7.1": "78",
      "7.2": "78",
      "7.3": "78",
      "8.0": "80",
      "8.1": "80",
      "8.2": "80",
      "8.3": "80",
      "8.4": "80",
      "8.5": "80",
      "9.0": "83",
      "9.1": "83",
      "9.2": "83",
      "9.3": "83",
      "9.4": "83",
      "10.0": "85",
      "10.1": "85",
      "10.2": "85",
      "10.3": "85",
      "10.4": "85",
      "11.0": "87",
      "11.1": "87",
      "11.2": "87",
      "11.3": "87",
      "11.4": "87",
      "11.5": "87",
      "12.0": "89",
      "12.1": "89",
      "12.2": "89",
      "13.0": "91",
      "13.1": "91",
      "13.2": "91",
      "13.3": "91",
      "13.4": "91",
      "13.5": "91",
      "13.6": "91",
      "14.0": "93",
      "14.1": "93",
      "14.2": "93",
      "15.0": "94",
      "15.1": "94",
      "15.2": "94",
      "15.3": "94",
      "15.4": "94",
      "15.5": "94",
      "16.0": "96",
      "16.1": "96",
      "16.2": "96",
      "17.0": "98",
      "17.1": "98",
      "17.2": "98",
      "17.3": "98",
      "17.4": "98",
      "18.0": "100",
      "18.1": "100",
      "18.2": "100",
      "18.3": "100",
      "19.0": "102",
      "19.1": "102",
      "20.0": "104",
      "20.1": "104",
      "20.2": "104",
      "20.3": "104",
      "21.0": "106",
      "21.1": "106",
      "21.2": "106",
      "21.3": "106",
      "21.4": "106",
      "22.0": "108",
      "22.1": "108",
      "22.2": "108",
      "22.3": "108",
      "23.0": "110",
      "23.1": "110",
      "23.2": "110",
      "23.3": "110",
      "24.0": "112",
      "24.1": "112",
      "24.2": "112",
      "24.3": "112",
      "24.4": "112",
      "24.5": "112",
      "24.6": "112",
      "24.7": "112",
      "24.8": "112",
      "25.0": "114",
      "25.1": "114",
      "25.2": "114",
      "25.3": "114",
      "25.4": "114",
      "25.5": "114",
      "25.6": "114",
      "25.7": "114",
      "25.8": "114",
      "25.9": "114",
      "26.0": "116",
      "26.1": "116",
      "26.2": "116",
      "26.3": "116",
      "26.4": "116",
      "26.5": "116",
      "26.6": "116",
      "27.0": "118",
      "27.1": "118",
      "27.2": "118",
      "27.3": "118",
      "28.0": "120",
      "28.1": "120",
      "28.2": "120",
      "28.3": "120",
      "29.0": "122",
      "29.1": "122",
      "29.2": "122",
      "29.3": "122",
      "29.4": "122",
      "30.0": "124",
      "30.1": "124",
      "30.2": "124",
      "30.3": "124",
      "30.4": "124",
      "30.5": "124",
      "31.0": "126",
      "31.1": "126",
      "31.2": "126",
      "31.3": "126",
      "31.4": "126",
      "31.5": "126",
      "31.6": "126",
      "31.7": "126",
      "32.0": "128",
      "32.1": "128",
      "32.2": "128",
      "33.0": "130",
      "34.0": "132"
    };
  }
});

// node_modules/node-releases/data/release-schedule/release-schedule.json
var require_release_schedule = __commonJS({
  "node_modules/node-releases/data/release-schedule/release-schedule.json"(exports2, module) {
    module.exports = { "v0.8": { start: "2012-06-25", end: "2014-07-31" }, "v0.10": { start: "2013-03-11", end: "2016-10-31" }, "v0.12": { start: "2015-02-06", end: "2016-12-31" }, v4: { start: "2015-09-08", lts: "2015-10-12", maintenance: "2017-04-01", end: "2018-04-30", codename: "Argon" }, v5: { start: "2015-10-29", maintenance: "2016-04-30", end: "2016-06-30" }, v6: { start: "2016-04-26", lts: "2016-10-18", maintenance: "2018-04-30", end: "2019-04-30", codename: "Boron" }, v7: { start: "2016-10-25", maintenance: "2017-04-30", end: "2017-06-30" }, v8: { start: "2017-05-30", lts: "2017-10-31", maintenance: "2019-01-01", end: "2019-12-31", codename: "Carbon" }, v9: { start: "2017-10-01", maintenance: "2018-04-01", end: "2018-06-30" }, v10: { start: "2018-04-24", lts: "2018-10-30", maintenance: "2020-05-19", end: "2021-04-30", codename: "Dubnium" }, v11: { start: "2018-10-23", maintenance: "2019-04-22", end: "2019-06-01" }, v12: { start: "2019-04-23", lts: "2019-10-21", maintenance: "2020-11-30", end: "2022-04-30", codename: "Erbium" }, v13: { start: "2019-10-22", maintenance: "2020-04-01", end: "2020-06-01" }, v14: { start: "2020-04-21", lts: "2020-10-27", maintenance: "2021-10-19", end: "2023-04-30", codename: "Fermium" }, v15: { start: "2020-10-20", maintenance: "2021-04-01", end: "2021-06-01" }, v16: { start: "2021-04-20", lts: "2021-10-26", maintenance: "2022-10-18", end: "2023-09-11", codename: "Gallium" }, v17: { start: "2021-10-19", maintenance: "2022-04-01", end: "2022-06-01" }, v18: { start: "2022-04-19", lts: "2022-10-25", maintenance: "2023-10-18", end: "2025-04-30", codename: "Hydrogen" }, v19: { start: "2022-10-18", maintenance: "2023-04-01", end: "2023-06-01" }, v20: { start: "2023-04-18", lts: "2023-10-24", maintenance: "2024-10-22", end: "2026-04-30", codename: "Iron" }, v21: { start: "2023-10-17", maintenance: "2024-04-01", end: "2024-06-01" }, v22: { start: "2024-04-24", lts: "2024-10-29", maintenance: "2025-10-21", end: "2027-04-30", codename: "" }, v23: { start: "2024-10-15", maintenance: "2025-04-01", end: "2025-06-01" }, v24: { start: "2025-04-22", lts: "2025-10-28", maintenance: "2026-10-20", end: "2028-04-30", codename: "" } };
  }
});

// node_modules/browserslist/error.js
var require_error = __commonJS({
  "node_modules/browserslist/error.js"(exports2, module) {
    function BrowserslistError(message) {
      this.name = "BrowserslistError";
      this.message = message;
      this.browserslist = true;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, BrowserslistError);
      }
    }
    BrowserslistError.prototype = Error.prototype;
    module.exports = BrowserslistError;
  }
});

// node_modules/caniuse-lite/dist/lib/statuses.js
var require_statuses = __commonJS({
  "node_modules/caniuse-lite/dist/lib/statuses.js"(exports2, module) {
    module.exports = {
      1: "ls",
      // WHATWG Living Standard
      2: "rec",
      // W3C Recommendation
      3: "pr",
      // W3C Proposed Recommendation
      4: "cr",
      // W3C Candidate Recommendation
      5: "wd",
      // W3C Working Draft
      6: "other",
      // Non-W3C, but reputable
      7: "unoff"
      // Unofficial, Editor's Draft or W3C "Note"
    };
  }
});

// node_modules/caniuse-lite/dist/lib/supported.js
var require_supported = __commonJS({
  "node_modules/caniuse-lite/dist/lib/supported.js"(exports2, module) {
    module.exports = {
      y: 1 << 0,
      n: 1 << 1,
      a: 1 << 2,
      p: 1 << 3,
      u: 1 << 4,
      x: 1 << 5,
      d: 1 << 6
    };
  }
});

// node_modules/caniuse-lite/dist/unpacker/feature.js
var require_feature = __commonJS({
  "node_modules/caniuse-lite/dist/unpacker/feature.js"(exports2, module) {
    "use strict";
    var statuses2 = require_statuses();
    var supported = require_supported();
    var browsers = require_browsers2().browsers;
    var versions = require_browserVersions2().browserVersions;
    var MATH2LOG = Math.log(2);
    function unpackSupport(cipher) {
      let stats = Object.keys(supported).reduce((list2, support) => {
        if (cipher & supported[support]) list2.push(support);
        return list2;
      }, []);
      let notes = cipher >> 7;
      let notesArray = [];
      while (notes) {
        let note = Math.floor(Math.log(notes) / MATH2LOG) + 1;
        notesArray.unshift(`#${note}`);
        notes -= Math.pow(2, note - 1);
      }
      return stats.concat(notesArray).join(" ");
    }
    function unpackFeature(packed) {
      let unpacked = {
        status: statuses2[packed.B],
        title: packed.C,
        shown: packed.D
      };
      unpacked.stats = Object.keys(packed.A).reduce((browserStats, key) => {
        let browser2 = packed.A[key];
        browserStats[browsers[key]] = Object.keys(browser2).reduce(
          (stats, support) => {
            let packedVersions = browser2[support].split(" ");
            let unpacked2 = unpackSupport(support);
            packedVersions.forEach((v) => stats[versions[v]] = unpacked2);
            return stats;
          },
          {}
        );
        return browserStats;
      }, {});
      return unpacked;
    }
    module.exports = unpackFeature;
    module.exports.default = unpackFeature;
  }
});

// node_modules/caniuse-lite/dist/unpacker/region.js
var require_region = __commonJS({
  "node_modules/caniuse-lite/dist/unpacker/region.js"(exports2, module) {
    "use strict";
    var browsers = require_browsers2().browsers;
    function unpackRegion(packed) {
      return Object.keys(packed).reduce((list2, browser2) => {
        let data = packed[browser2];
        list2[browsers[browser2]] = Object.keys(data).reduce((memo, key) => {
          let stats = data[key];
          if (key === "_") {
            stats.split(" ").forEach((version4) => memo[version4] = null);
          } else {
            memo[key] = stats;
          }
          return memo;
        }, {});
        return list2;
      }, {});
    }
    module.exports = unpackRegion;
    module.exports.default = unpackRegion;
  }
});

// node_modules/browserslist/node.js
var require_node5 = __commonJS({
  "node_modules/browserslist/node.js"(exports2, module) {
    var feature = require_feature().default;
    var region = require_region().default;
    var fs6 = __require("fs");
    var path9 = __require("path");
    var BrowserslistError = require_error();
    var IS_SECTION = /^\s*\[(.+)]\s*$/;
    var CONFIG_PATTERN = /^browserslist-config-/;
    var SCOPED_CONFIG__PATTERN = /@[^/]+(?:\/[^/]+)?\/browserslist-config(?:-|$|\/)/;
    var FORMAT = "Browserslist config should be a string or an array of strings with browser queries";
    var dataTimeChecked = false;
    var filenessCache = {};
    var configCache = {};
    function checkExtend(name2) {
      var use2 = " Use `dangerousExtend` option to disable.";
      if (!CONFIG_PATTERN.test(name2) && !SCOPED_CONFIG__PATTERN.test(name2)) {
        throw new BrowserslistError(
          "Browserslist config needs `browserslist-config-` prefix. " + use2
        );
      }
      if (name2.replace(/^@[^/]+\//, "").indexOf(".") !== -1) {
        throw new BrowserslistError(
          "`.` not allowed in Browserslist config name. " + use2
        );
      }
      if (name2.indexOf("node_modules") !== -1) {
        throw new BrowserslistError(
          "`node_modules` not allowed in Browserslist config." + use2
        );
      }
    }
    function isFile(file) {
      if (file in filenessCache) {
        return filenessCache[file];
      }
      var result = fs6.existsSync(file) && fs6.statSync(file).isFile();
      if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
        filenessCache[file] = result;
      }
      return result;
    }
    function eachParent(file, callback) {
      var dir = isFile(file) ? path9.dirname(file) : file;
      var loc = path9.resolve(dir);
      do {
        if (!pathInRoot(loc)) break;
        var result = callback(loc);
        if (typeof result !== "undefined") return result;
      } while (loc !== (loc = path9.dirname(loc)));
      return void 0;
    }
    function pathInRoot(p) {
      if (!process.env.BROWSERSLIST_ROOT_PATH) return true;
      var rootPath = path9.resolve(process.env.BROWSERSLIST_ROOT_PATH);
      if (path9.relative(rootPath, p).substring(0, 2) === "..") {
        return false;
      }
      return true;
    }
    function check(section) {
      if (Array.isArray(section)) {
        for (var i = 0; i < section.length; i++) {
          if (typeof section[i] !== "string") {
            throw new BrowserslistError(FORMAT);
          }
        }
      } else if (typeof section !== "string") {
        throw new BrowserslistError(FORMAT);
      }
    }
    function pickEnv(config2, opts) {
      if (typeof config2 !== "object") return config2;
      var name2;
      if (typeof opts.env === "string") {
        name2 = opts.env;
      } else if (process.env.BROWSERSLIST_ENV) {
        name2 = process.env.BROWSERSLIST_ENV;
      } else if (process.env.NODE_ENV) {
        name2 = process.env.NODE_ENV;
      } else {
        name2 = "production";
      }
      if (opts.throwOnMissing) {
        if (name2 && name2 !== "defaults" && !config2[name2]) {
          throw new BrowserslistError(
            "Missing config for Browserslist environment `" + name2 + "`"
          );
        }
      }
      return config2[name2] || config2.defaults;
    }
    function parsePackage(file) {
      var config2 = JSON.parse(
        fs6.readFileSync(file).toString().replace(/^\uFEFF/m, "")
      );
      if (config2.browserlist && !config2.browserslist) {
        throw new BrowserslistError(
          "`browserlist` key instead of `browserslist` in " + file
        );
      }
      var list2 = config2.browserslist;
      if (Array.isArray(list2) || typeof list2 === "string") {
        list2 = { defaults: list2 };
      }
      for (var i in list2) {
        check(list2[i]);
      }
      return list2;
    }
    function parsePackageOrReadConfig(file) {
      if (path9.basename(file) === "package.json") {
        return parsePackage(file);
      } else {
        return module.exports.readConfig(file);
      }
    }
    function latestReleaseTime(agents) {
      var latest = 0;
      for (var name2 in agents) {
        var dates = agents[name2].releaseDate || {};
        for (var key in dates) {
          if (latest < dates[key]) {
            latest = dates[key];
          }
        }
      }
      return latest * 1e3;
    }
    function getMonthsPassed(date) {
      var now = /* @__PURE__ */ new Date();
      var past = new Date(date);
      var years = now.getFullYear() - past.getFullYear();
      var months = now.getMonth() - past.getMonth();
      return years * 12 + months;
    }
    function normalizeStats(data, stats) {
      if (!data) {
        data = {};
      }
      if (stats && "dataByBrowser" in stats) {
        stats = stats.dataByBrowser;
      }
      if (typeof stats !== "object") return void 0;
      var normalized = {};
      for (var i in stats) {
        var versions = Object.keys(stats[i]);
        if (versions.length === 1 && data[i] && data[i].versions.length === 1) {
          var normal = data[i].versions[0];
          normalized[i] = {};
          normalized[i][normal] = stats[i][versions[0]];
        } else {
          normalized[i] = stats[i];
        }
      }
      return normalized;
    }
    function normalizeUsageData(usageData, data) {
      for (var browser2 in usageData) {
        var browserUsage = usageData[browser2];
        if ("0" in browserUsage) {
          var versions = data[browser2].versions;
          browserUsage[versions[versions.length - 1]] = browserUsage[0];
          delete browserUsage[0];
        }
      }
    }
    module.exports = {
      loadQueries: function loadQueries(ctx, name2) {
        if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
          checkExtend(name2);
        }
        var queries = __require(__require.resolve(name2, { paths: [".", ctx.path] }));
        if (queries) {
          if (Array.isArray(queries)) {
            return queries;
          } else if (typeof queries === "object") {
            if (!queries.defaults) queries.defaults = [];
            return pickEnv(queries, ctx, name2);
          }
        }
        throw new BrowserslistError(
          "`" + name2 + "` config exports not an array of queries or an object of envs"
        );
      },
      loadStat: function loadStat(ctx, name2, data) {
        if (!ctx.dangerousExtend && !process.env.BROWSERSLIST_DANGEROUS_EXTEND) {
          checkExtend(name2);
        }
        var stats = __require(__require.resolve(
          path9.join(name2, "browserslist-stats.json"),
          { paths: ["."] }
        ));
        return normalizeStats(data, stats);
      },
      getStat: function getStat(opts, data) {
        var stats;
        if (opts.stats) {
          stats = opts.stats;
        } else if (process.env.BROWSERSLIST_STATS) {
          stats = process.env.BROWSERSLIST_STATS;
        } else if (opts.path && path9.resolve && fs6.existsSync) {
          stats = eachParent(opts.path, function(dir) {
            var file = path9.join(dir, "browserslist-stats.json");
            return isFile(file) ? file : void 0;
          });
        }
        if (typeof stats === "string") {
          try {
            stats = JSON.parse(fs6.readFileSync(stats));
          } catch (e) {
            throw new BrowserslistError("Can't read " + stats);
          }
        }
        return normalizeStats(data, stats);
      },
      loadConfig: function loadConfig(opts) {
        if (process.env.BROWSERSLIST) {
          return process.env.BROWSERSLIST;
        } else if (opts.config || process.env.BROWSERSLIST_CONFIG) {
          var file = opts.config || process.env.BROWSERSLIST_CONFIG;
          return pickEnv(parsePackageOrReadConfig(file), opts);
        } else if (opts.path) {
          return pickEnv(module.exports.findConfig(opts.path), opts);
        } else {
          return void 0;
        }
      },
      loadCountry: function loadCountry(usage, country, data) {
        var code = country.replace(/[^\w-]/g, "");
        if (!usage[code]) {
          var compressed;
          try {
            compressed = __require("caniuse-lite/data/regions/" + code + ".js");
          } catch (e) {
            throw new BrowserslistError("Unknown region name `" + code + "`.");
          }
          var usageData = region(compressed);
          normalizeUsageData(usageData, data);
          usage[country] = {};
          for (var i in usageData) {
            for (var j in usageData[i]) {
              usage[country][i + " " + j] = usageData[i][j];
            }
          }
        }
      },
      loadFeature: function loadFeature(features, name2) {
        name2 = name2.replace(/[^\w-]/g, "");
        if (features[name2]) return;
        var compressed;
        try {
          compressed = __require("caniuse-lite/data/features/" + name2 + ".js");
        } catch (e) {
          throw new BrowserslistError("Unknown feature name `" + name2 + "`.");
        }
        var stats = feature(compressed).stats;
        features[name2] = {};
        for (var i in stats) {
          features[name2][i] = {};
          for (var j in stats[i]) {
            features[name2][i][j] = stats[i][j];
          }
        }
      },
      parseConfig: function parseConfig(string4) {
        var result = { defaults: [] };
        var sections = ["defaults"];
        string4.toString().replace(/#[^\n]*/g, "").split(/\n|,/).map(function(line) {
          return line.trim();
        }).filter(function(line) {
          return line !== "";
        }).forEach(function(line) {
          if (IS_SECTION.test(line)) {
            sections = line.match(IS_SECTION)[1].trim().split(" ");
            sections.forEach(function(section) {
              if (result[section]) {
                throw new BrowserslistError(
                  "Duplicate section " + section + " in Browserslist config"
                );
              }
              result[section] = [];
            });
          } else {
            sections.forEach(function(section) {
              result[section].push(line);
            });
          }
        });
        return result;
      },
      readConfig: function readConfig(file) {
        if (!isFile(file)) {
          throw new BrowserslistError("Can't read " + file + " config");
        }
        return module.exports.parseConfig(fs6.readFileSync(file));
      },
      findConfigFile: function findConfigFile(from) {
        var resolved = eachParent(from, function(dir) {
          var config2 = path9.join(dir, "browserslist");
          var pkg = path9.join(dir, "package.json");
          var rc2 = path9.join(dir, ".browserslistrc");
          var pkgBrowserslist;
          if (isFile(pkg)) {
            try {
              pkgBrowserslist = parsePackage(pkg);
            } catch (e) {
              if (e.name === "BrowserslistError") throw e;
              console.warn(
                "[Browserslist] Could not parse " + pkg + ". Ignoring it."
              );
            }
          }
          if (isFile(config2) && pkgBrowserslist) {
            throw new BrowserslistError(
              dir + " contains both browserslist and package.json with browsers"
            );
          } else if (isFile(rc2) && pkgBrowserslist) {
            throw new BrowserslistError(
              dir + " contains both .browserslistrc and package.json with browsers"
            );
          } else if (isFile(config2) && isFile(rc2)) {
            throw new BrowserslistError(
              dir + " contains both .browserslistrc and browserslist"
            );
          } else if (isFile(config2)) {
            return config2;
          } else if (isFile(rc2)) {
            return rc2;
          } else if (pkgBrowserslist) {
            return pkg;
          }
        });
        return resolved;
      },
      findConfig: function findConfig(from) {
        from = path9.resolve(from);
        var fromDir = isFile(from) ? path9.dirname(from) : from;
        if (fromDir in configCache) {
          return configCache[fromDir];
        }
        var resolved;
        var configFile = this.findConfigFile(from);
        if (configFile) {
          resolved = parsePackageOrReadConfig(configFile);
        }
        if (!process.env.BROWSERSLIST_DISABLE_CACHE) {
          var configDir = configFile && path9.dirname(configFile);
          eachParent(from, function(dir) {
            configCache[dir] = resolved;
            if (dir === configDir) {
              return null;
            }
          });
        }
        return resolved;
      },
      clearCaches: function clearCaches() {
        dataTimeChecked = false;
        filenessCache = {};
        configCache = {};
        this.cache = {};
      },
      oldDataWarning: function oldDataWarning(agentsObj) {
        if (dataTimeChecked) return;
        dataTimeChecked = true;
        if (process.env.BROWSERSLIST_IGNORE_OLD_DATA) return;
        var latest = latestReleaseTime(agentsObj);
        var monthsPassed = getMonthsPassed(latest);
        if (latest !== 0 && monthsPassed >= 6) {
          var months = monthsPassed + " " + (monthsPassed > 1 ? "months" : "month");
          console.warn(
            "Browserslist: browsers data (caniuse-lite) is " + months + " old. Please run:\n  npx update-browserslist-db@latest\n  Why you should do it regularly: https://github.com/browserslist/update-db#readme"
          );
        }
      },
      currentNode: function currentNode() {
        return "node " + process.versions.node;
      },
      env: process.env
    };
  }
});

// node_modules/browserslist/parse.js
var require_parse4 = __commonJS({
  "node_modules/browserslist/parse.js"(exports2, module) {
    var AND_REGEXP = /^\s+and\s+(.*)/i;
    var OR_REGEXP = /^(?:,\s*|\s+or\s+)(.*)/i;
    function flatten2(array2) {
      if (!Array.isArray(array2)) return [array2];
      return array2.reduce(function(a, b) {
        return a.concat(flatten2(b));
      }, []);
    }
    function find(string4, predicate) {
      for (var max = string4.length, n = 1; n <= max; n++) {
        var parsed = string4.substr(-n, n);
        if (predicate(parsed, n, max)) {
          return string4.slice(0, -n);
        }
      }
      return "";
    }
    function matchQuery(all, query) {
      var node3 = { query };
      if (query.indexOf("not ") === 0) {
        node3.not = true;
        query = query.slice(4);
      }
      for (var name2 in all) {
        var type = all[name2];
        var match2 = query.match(type.regexp);
        if (match2) {
          node3.type = name2;
          for (var i = 0; i < type.matches.length; i++) {
            node3[type.matches[i]] = match2[i + 1];
          }
          return node3;
        }
      }
      node3.type = "unknown";
      return node3;
    }
    function matchBlock(all, string4, qs) {
      var node3;
      return find(string4, function(parsed, n, max) {
        if (AND_REGEXP.test(parsed)) {
          node3 = matchQuery(all, parsed.match(AND_REGEXP)[1]);
          node3.compose = "and";
          qs.unshift(node3);
          return true;
        } else if (OR_REGEXP.test(parsed)) {
          node3 = matchQuery(all, parsed.match(OR_REGEXP)[1]);
          node3.compose = "or";
          qs.unshift(node3);
          return true;
        } else if (n === max) {
          node3 = matchQuery(all, parsed.trim());
          node3.compose = "or";
          qs.unshift(node3);
          return true;
        }
        return false;
      });
    }
    module.exports = function parse6(all, queries) {
      if (!Array.isArray(queries)) queries = [queries];
      return flatten2(
        queries.map(function(block) {
          var qs = [];
          do {
            block = matchBlock(all, block, qs);
          } while (block);
          return qs;
        })
      );
    };
  }
});

// node_modules/browserslist/index.js
var require_browserslist = __commonJS({
  "node_modules/browserslist/index.js"(exports2, module) {
    var jsReleases = require_envs();
    var agents = require_agents2().agents;
    var e2c = require_versions();
    var jsEOL = require_release_schedule();
    var path9 = __require("path");
    var BrowserslistError = require_error();
    var env2 = require_node5();
    var parse6 = require_parse4();
    var YEAR = 365.259641 * 24 * 60 * 60 * 1e3;
    var ANDROID_EVERGREEN_FIRST = "37";
    var OP_MOB_BLINK_FIRST = 14;
    function isVersionsMatch(versionA, versionB) {
      return (versionA + ".").indexOf(versionB + ".") === 0;
    }
    function isEolReleased(name2) {
      var version4 = name2.slice(1);
      return browserslist.nodeVersions.some(function(i) {
        return isVersionsMatch(i, version4);
      });
    }
    function normalize2(versions) {
      return versions.filter(function(version4) {
        return typeof version4 === "string";
      });
    }
    function normalizeElectron(version4) {
      var versionToUse = version4;
      if (version4.split(".").length === 3) {
        versionToUse = version4.split(".").slice(0, -1).join(".");
      }
      return versionToUse;
    }
    function nameMapper(name2) {
      return function mapName(version4) {
        return name2 + " " + version4;
      };
    }
    function getMajor(version4) {
      return parseInt(version4.split(".")[0]);
    }
    function getMajorVersions(released, number) {
      if (released.length === 0) return [];
      var majorVersions = uniq(released.map(getMajor));
      var minimum = majorVersions[majorVersions.length - number];
      if (!minimum) {
        return released;
      }
      var selected = [];
      for (var i = released.length - 1; i >= 0; i--) {
        if (minimum > getMajor(released[i])) break;
        selected.unshift(released[i]);
      }
      return selected;
    }
    function uniq(array2) {
      var filtered = [];
      for (var i = 0; i < array2.length; i++) {
        if (filtered.indexOf(array2[i]) === -1) filtered.push(array2[i]);
      }
      return filtered;
    }
    function fillUsage(result, name2, data) {
      for (var i in data) {
        result[name2 + " " + i] = data[i];
      }
    }
    function generateFilter(sign, version4) {
      version4 = parseFloat(version4);
      if (sign === ">") {
        return function(v) {
          return parseLatestFloat(v) > version4;
        };
      } else if (sign === ">=") {
        return function(v) {
          return parseLatestFloat(v) >= version4;
        };
      } else if (sign === "<") {
        return function(v) {
          return parseFloat(v) < version4;
        };
      } else {
        return function(v) {
          return parseFloat(v) <= version4;
        };
      }
      function parseLatestFloat(v) {
        return parseFloat(v.split("-")[1] || v);
      }
    }
    function generateSemverFilter(sign, version4) {
      version4 = version4.split(".").map(parseSimpleInt);
      version4[1] = version4[1] || 0;
      version4[2] = version4[2] || 0;
      if (sign === ">") {
        return function(v) {
          v = v.split(".").map(parseSimpleInt);
          return compareSemver(v, version4) > 0;
        };
      } else if (sign === ">=") {
        return function(v) {
          v = v.split(".").map(parseSimpleInt);
          return compareSemver(v, version4) >= 0;
        };
      } else if (sign === "<") {
        return function(v) {
          v = v.split(".").map(parseSimpleInt);
          return compareSemver(version4, v) > 0;
        };
      } else {
        return function(v) {
          v = v.split(".").map(parseSimpleInt);
          return compareSemver(version4, v) >= 0;
        };
      }
    }
    function parseSimpleInt(x) {
      return parseInt(x);
    }
    function compare2(a, b) {
      if (a < b) return -1;
      if (a > b) return 1;
      return 0;
    }
    function compareSemver(a, b) {
      return compare2(parseInt(a[0]), parseInt(b[0])) || compare2(parseInt(a[1] || "0"), parseInt(b[1] || "0")) || compare2(parseInt(a[2] || "0"), parseInt(b[2] || "0"));
    }
    function semverFilterLoose(operator, range2) {
      range2 = range2.split(".").map(parseSimpleInt);
      if (typeof range2[1] === "undefined") {
        range2[1] = "x";
      }
      switch (operator) {
        case "<=":
          return function(version4) {
            version4 = version4.split(".").map(parseSimpleInt);
            return compareSemverLoose(version4, range2) <= 0;
          };
        case ">=":
        default:
          return function(version4) {
            version4 = version4.split(".").map(parseSimpleInt);
            return compareSemverLoose(version4, range2) >= 0;
          };
      }
    }
    function compareSemverLoose(version4, range2) {
      if (version4[0] !== range2[0]) {
        return version4[0] < range2[0] ? -1 : 1;
      }
      if (range2[1] === "x") {
        return 0;
      }
      if (version4[1] !== range2[1]) {
        return version4[1] < range2[1] ? -1 : 1;
      }
      return 0;
    }
    function resolveVersion(data, version4) {
      if (data.versions.indexOf(version4) !== -1) {
        return version4;
      } else if (browserslist.versionAliases[data.name][version4]) {
        return browserslist.versionAliases[data.name][version4];
      } else {
        return false;
      }
    }
    function normalizeVersion(data, version4) {
      var resolved = resolveVersion(data, version4);
      if (resolved) {
        return resolved;
      } else if (data.versions.length === 1) {
        return data.versions[0];
      } else {
        return false;
      }
    }
    function filterByYear(since, context) {
      since = since / 1e3;
      return Object.keys(agents).reduce(function(selected, name2) {
        var data = byName(name2, context);
        if (!data) return selected;
        var versions = Object.keys(data.releaseDate).filter(function(v) {
          var date = data.releaseDate[v];
          return date !== null && date >= since;
        });
        return selected.concat(versions.map(nameMapper(data.name)));
      }, []);
    }
    function cloneData(data) {
      return {
        name: data.name,
        versions: data.versions,
        released: data.released,
        releaseDate: data.releaseDate
      };
    }
    function byName(name2, context) {
      name2 = name2.toLowerCase();
      name2 = browserslist.aliases[name2] || name2;
      if (context.mobileToDesktop && browserslist.desktopNames[name2]) {
        var desktop = browserslist.data[browserslist.desktopNames[name2]];
        if (name2 === "android") {
          return normalizeAndroidData(cloneData(browserslist.data[name2]), desktop);
        } else {
          var cloned = cloneData(desktop);
          cloned.name = name2;
          return cloned;
        }
      }
      return browserslist.data[name2];
    }
    function normalizeAndroidVersions(androidVersions, chromeVersions) {
      var iFirstEvergreen = chromeVersions.indexOf(ANDROID_EVERGREEN_FIRST);
      return androidVersions.filter(function(version4) {
        return /^(?:[2-4]\.|[34]$)/.test(version4);
      }).concat(chromeVersions.slice(iFirstEvergreen));
    }
    function copyObject(obj) {
      var copy = {};
      for (var key in obj) {
        copy[key] = obj[key];
      }
      return copy;
    }
    function normalizeAndroidData(android, chrome2) {
      android.released = normalizeAndroidVersions(android.released, chrome2.released);
      android.versions = normalizeAndroidVersions(android.versions, chrome2.versions);
      android.releaseDate = copyObject(android.releaseDate);
      android.released.forEach(function(v) {
        if (android.releaseDate[v] === void 0) {
          android.releaseDate[v] = chrome2.releaseDate[v];
        }
      });
      return android;
    }
    function checkName(name2, context) {
      var data = byName(name2, context);
      if (!data) throw new BrowserslistError("Unknown browser " + name2);
      return data;
    }
    function unknownQuery(query) {
      return new BrowserslistError(
        "Unknown browser query `" + query + "`. Maybe you are using old Browserslist or made typo in query."
      );
    }
    function filterJumps(list2, name2, nVersions, context) {
      var jump = 1;
      switch (name2) {
        case "android":
          if (context.mobileToDesktop) return list2;
          var released = browserslist.data.chrome.released;
          jump = released.length - released.indexOf(ANDROID_EVERGREEN_FIRST);
          break;
        case "op_mob":
          var latest = browserslist.data.op_mob.released.slice(-1)[0];
          jump = getMajor(latest) - OP_MOB_BLINK_FIRST + 1;
          break;
        default:
          return list2;
      }
      if (nVersions <= jump) {
        return list2.slice(-1);
      }
      return list2.slice(jump - 1 - nVersions);
    }
    function isSupported(flags, withPartial) {
      return typeof flags === "string" && (flags.indexOf("y") >= 0 || withPartial && flags.indexOf("a") >= 0);
    }
    function resolve8(queries, context) {
      return parse6(QUERIES, queries).reduce(function(result, node3, index4) {
        if (node3.not && index4 === 0) {
          throw new BrowserslistError(
            "Write any browsers query (for instance, `defaults`) before `" + node3.query + "`"
          );
        }
        var type = QUERIES[node3.type];
        var array2 = type.select.call(browserslist, context, node3).map(function(j) {
          var parts = j.split(" ");
          if (parts[1] === "0") {
            return parts[0] + " " + byName(parts[0], context).versions[0];
          } else {
            return j;
          }
        });
        if (node3.compose === "and") {
          if (node3.not) {
            return result.filter(function(j) {
              return array2.indexOf(j) === -1;
            });
          } else {
            return result.filter(function(j) {
              return array2.indexOf(j) !== -1;
            });
          }
        } else {
          if (node3.not) {
            var filter2 = {};
            array2.forEach(function(j) {
              filter2[j] = true;
            });
            return result.filter(function(j) {
              return !filter2[j];
            });
          }
          return result.concat(array2);
        }
      }, []);
    }
    function prepareOpts(opts) {
      if (typeof opts === "undefined") opts = {};
      if (typeof opts.path === "undefined") {
        opts.path = path9.resolve ? path9.resolve(".") : ".";
      }
      return opts;
    }
    function prepareQueries(queries, opts) {
      if (typeof queries === "undefined" || queries === null) {
        var config2 = browserslist.loadConfig(opts);
        if (config2) {
          queries = config2;
        } else {
          queries = browserslist.defaults;
        }
      }
      return queries;
    }
    function checkQueries(queries) {
      if (!(typeof queries === "string" || Array.isArray(queries))) {
        throw new BrowserslistError(
          "Browser queries must be an array or string. Got " + typeof queries + "."
        );
      }
    }
    var cache2 = {};
    function browserslist(queries, opts) {
      opts = prepareOpts(opts);
      queries = prepareQueries(queries, opts);
      checkQueries(queries);
      var context = {
        ignoreUnknownVersions: opts.ignoreUnknownVersions,
        dangerousExtend: opts.dangerousExtend,
        mobileToDesktop: opts.mobileToDesktop,
        path: opts.path,
        env: opts.env
      };
      env2.oldDataWarning(browserslist.data);
      var stats = env2.getStat(opts, browserslist.data);
      if (stats) {
        context.customUsage = {};
        for (var browser2 in stats) {
          fillUsage(context.customUsage, browser2, stats[browser2]);
        }
      }
      var cacheKey = JSON.stringify([queries, context]);
      if (cache2[cacheKey]) return cache2[cacheKey];
      var result = uniq(resolve8(queries, context)).sort(function(name1, name2) {
        name1 = name1.split(" ");
        name2 = name2.split(" ");
        if (name1[0] === name2[0]) {
          var version1 = name1[1].split("-")[0];
          var version22 = name2[1].split("-")[0];
          return compareSemver(version22.split("."), version1.split("."));
        } else {
          return compare2(name1[0], name2[0]);
        }
      });
      if (!env2.env.BROWSERSLIST_DISABLE_CACHE) {
        cache2[cacheKey] = result;
      }
      return result;
    }
    browserslist.parse = function(queries, opts) {
      opts = prepareOpts(opts);
      queries = prepareQueries(queries, opts);
      checkQueries(queries);
      return parse6(QUERIES, queries);
    };
    browserslist.cache = {};
    browserslist.data = {};
    browserslist.usage = {
      global: {},
      custom: null
    };
    browserslist.defaults = ["> 0.5%", "last 2 versions", "Firefox ESR", "not dead"];
    browserslist.aliases = {
      fx: "firefox",
      ff: "firefox",
      ios: "ios_saf",
      explorer: "ie",
      blackberry: "bb",
      explorermobile: "ie_mob",
      operamini: "op_mini",
      operamobile: "op_mob",
      chromeandroid: "and_chr",
      firefoxandroid: "and_ff",
      ucandroid: "and_uc",
      qqandroid: "and_qq"
    };
    browserslist.desktopNames = {
      and_chr: "chrome",
      and_ff: "firefox",
      ie_mob: "ie",
      android: "chrome"
      // has extra processing logic
    };
    browserslist.versionAliases = {};
    browserslist.clearCaches = env2.clearCaches;
    browserslist.parseConfig = env2.parseConfig;
    browserslist.readConfig = env2.readConfig;
    browserslist.findConfigFile = env2.findConfigFile;
    browserslist.findConfig = env2.findConfig;
    browserslist.loadConfig = env2.loadConfig;
    browserslist.coverage = function(browsers, stats) {
      var data;
      if (typeof stats === "undefined") {
        data = browserslist.usage.global;
      } else if (stats === "my stats") {
        var opts = {};
        opts.path = path9.resolve ? path9.resolve(".") : ".";
        var customStats = env2.getStat(opts);
        if (!customStats) {
          throw new BrowserslistError("Custom usage statistics was not provided");
        }
        data = {};
        for (var browser2 in customStats) {
          fillUsage(data, browser2, customStats[browser2]);
        }
      } else if (typeof stats === "string") {
        if (stats.length > 2) {
          stats = stats.toLowerCase();
        } else {
          stats = stats.toUpperCase();
        }
        env2.loadCountry(browserslist.usage, stats, browserslist.data);
        data = browserslist.usage[stats];
      } else {
        if ("dataByBrowser" in stats) {
          stats = stats.dataByBrowser;
        }
        data = {};
        for (var name2 in stats) {
          for (var version4 in stats[name2]) {
            data[name2 + " " + version4] = stats[name2][version4];
          }
        }
      }
      return browsers.reduce(function(all, i) {
        var usage = data[i];
        if (usage === void 0) {
          usage = data[i.replace(/ \S+$/, " 0")];
        }
        return all + (usage || 0);
      }, 0);
    };
    function nodeQuery(context, node3) {
      var matched = browserslist.nodeVersions.filter(function(i) {
        return isVersionsMatch(i, node3.version);
      });
      if (matched.length === 0) {
        if (context.ignoreUnknownVersions) {
          return [];
        } else {
          throw new BrowserslistError(
            "Unknown version " + node3.version + " of Node.js"
          );
        }
      }
      return ["node " + matched[matched.length - 1]];
    }
    function sinceQuery(context, node3) {
      var year = parseInt(node3.year);
      var month = parseInt(node3.month || "01") - 1;
      var day = parseInt(node3.day || "01");
      return filterByYear(Date.UTC(year, month, day, 0, 0, 0), context);
    }
    function coverQuery(context, node3) {
      var coverage = parseFloat(node3.coverage);
      var usage = browserslist.usage.global;
      if (node3.place) {
        if (node3.place.match(/^my\s+stats$/i)) {
          if (!context.customUsage) {
            throw new BrowserslistError("Custom usage statistics was not provided");
          }
          usage = context.customUsage;
        } else {
          var place;
          if (node3.place.length === 2) {
            place = node3.place.toUpperCase();
          } else {
            place = node3.place.toLowerCase();
          }
          env2.loadCountry(browserslist.usage, place, browserslist.data);
          usage = browserslist.usage[place];
        }
      }
      var versions = Object.keys(usage).sort(function(a, b) {
        return usage[b] - usage[a];
      });
      var coveraged = 0;
      var result = [];
      var version4;
      for (var i = 0; i < versions.length; i++) {
        version4 = versions[i];
        if (usage[version4] === 0) break;
        coveraged += usage[version4];
        result.push(version4);
        if (coveraged >= coverage) break;
      }
      return result;
    }
    var QUERIES = {
      last_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+major\s+versions?$/i,
        select: function(context, node3) {
          return Object.keys(agents).reduce(function(selected, name2) {
            var data = byName(name2, context);
            if (!data) return selected;
            var list2 = getMajorVersions(data.released, node3.versions);
            list2 = list2.map(nameMapper(data.name));
            list2 = filterJumps(list2, data.name, node3.versions, context);
            return selected.concat(list2);
          }, []);
        }
      },
      last_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+versions?$/i,
        select: function(context, node3) {
          return Object.keys(agents).reduce(function(selected, name2) {
            var data = byName(name2, context);
            if (!data) return selected;
            var list2 = data.released.slice(-node3.versions);
            list2 = list2.map(nameMapper(data.name));
            list2 = filterJumps(list2, data.name, node3.versions, context);
            return selected.concat(list2);
          }, []);
        }
      },
      last_electron_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+electron\s+major\s+versions?$/i,
        select: function(context, node3) {
          var validVersions = getMajorVersions(Object.keys(e2c), node3.versions);
          return validVersions.map(function(i) {
            return "chrome " + e2c[i];
          });
        }
      },
      last_node_major_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+node\s+major\s+versions?$/i,
        select: function(context, node3) {
          return getMajorVersions(browserslist.nodeVersions, node3.versions).map(
            function(version4) {
              return "node " + version4;
            }
          );
        }
      },
      last_browser_major_versions: {
        matches: ["versions", "browser"],
        regexp: /^last\s+(\d+)\s+(\w+)\s+major\s+versions?$/i,
        select: function(context, node3) {
          var data = checkName(node3.browser, context);
          var validVersions = getMajorVersions(data.released, node3.versions);
          var list2 = validVersions.map(nameMapper(data.name));
          list2 = filterJumps(list2, data.name, node3.versions, context);
          return list2;
        }
      },
      last_electron_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+electron\s+versions?$/i,
        select: function(context, node3) {
          return Object.keys(e2c).slice(-node3.versions).map(function(i) {
            return "chrome " + e2c[i];
          });
        }
      },
      last_node_versions: {
        matches: ["versions"],
        regexp: /^last\s+(\d+)\s+node\s+versions?$/i,
        select: function(context, node3) {
          return browserslist.nodeVersions.slice(-node3.versions).map(function(version4) {
            return "node " + version4;
          });
        }
      },
      last_browser_versions: {
        matches: ["versions", "browser"],
        regexp: /^last\s+(\d+)\s+(\w+)\s+versions?$/i,
        select: function(context, node3) {
          var data = checkName(node3.browser, context);
          var list2 = data.released.slice(-node3.versions).map(nameMapper(data.name));
          list2 = filterJumps(list2, data.name, node3.versions, context);
          return list2;
        }
      },
      unreleased_versions: {
        matches: [],
        regexp: /^unreleased\s+versions$/i,
        select: function(context) {
          return Object.keys(agents).reduce(function(selected, name2) {
            var data = byName(name2, context);
            if (!data) return selected;
            var list2 = data.versions.filter(function(v) {
              return data.released.indexOf(v) === -1;
            });
            list2 = list2.map(nameMapper(data.name));
            return selected.concat(list2);
          }, []);
        }
      },
      unreleased_electron_versions: {
        matches: [],
        regexp: /^unreleased\s+electron\s+versions?$/i,
        select: function() {
          return [];
        }
      },
      unreleased_browser_versions: {
        matches: ["browser"],
        regexp: /^unreleased\s+(\w+)\s+versions?$/i,
        select: function(context, node3) {
          var data = checkName(node3.browser, context);
          return data.versions.filter(function(v) {
            return data.released.indexOf(v) === -1;
          }).map(nameMapper(data.name));
        }
      },
      last_years: {
        matches: ["years"],
        regexp: /^last\s+(\d*.?\d+)\s+years?$/i,
        select: function(context, node3) {
          return filterByYear(Date.now() - YEAR * node3.years, context);
        }
      },
      since_y: {
        matches: ["year"],
        regexp: /^since (\d+)$/i,
        select: sinceQuery
      },
      since_y_m: {
        matches: ["year", "month"],
        regexp: /^since (\d+)-(\d+)$/i,
        select: sinceQuery
      },
      since_y_m_d: {
        matches: ["year", "month", "day"],
        regexp: /^since (\d+)-(\d+)-(\d+)$/i,
        select: sinceQuery
      },
      popularity: {
        matches: ["sign", "popularity"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%$/,
        select: function(context, node3) {
          var popularity = parseFloat(node3.popularity);
          var usage = browserslist.usage.global;
          return Object.keys(usage).reduce(function(result, version4) {
            if (node3.sign === ">") {
              if (usage[version4] > popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<") {
              if (usage[version4] < popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<=") {
              if (usage[version4] <= popularity) {
                result.push(version4);
              }
            } else if (usage[version4] >= popularity) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      popularity_in_my_stats: {
        matches: ["sign", "popularity"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+my\s+stats$/,
        select: function(context, node3) {
          var popularity = parseFloat(node3.popularity);
          if (!context.customUsage) {
            throw new BrowserslistError("Custom usage statistics was not provided");
          }
          var usage = context.customUsage;
          return Object.keys(usage).reduce(function(result, version4) {
            var percentage = usage[version4];
            if (percentage == null) {
              return result;
            }
            if (node3.sign === ">") {
              if (percentage > popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<") {
              if (percentage < popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<=") {
              if (percentage <= popularity) {
                result.push(version4);
              }
            } else if (percentage >= popularity) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      popularity_in_config_stats: {
        matches: ["sign", "popularity", "config"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+(\S+)\s+stats$/,
        select: function(context, node3) {
          var popularity = parseFloat(node3.popularity);
          var stats = env2.loadStat(context, node3.config, browserslist.data);
          if (stats) {
            context.customUsage = {};
            for (var browser2 in stats) {
              fillUsage(context.customUsage, browser2, stats[browser2]);
            }
          }
          if (!context.customUsage) {
            throw new BrowserslistError("Custom usage statistics was not provided");
          }
          var usage = context.customUsage;
          return Object.keys(usage).reduce(function(result, version4) {
            var percentage = usage[version4];
            if (percentage == null) {
              return result;
            }
            if (node3.sign === ">") {
              if (percentage > popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<") {
              if (percentage < popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<=") {
              if (percentage <= popularity) {
                result.push(version4);
              }
            } else if (percentage >= popularity) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      popularity_in_place: {
        matches: ["sign", "popularity", "place"],
        regexp: /^(>=?|<=?)\s*(\d+|\d+\.\d+|\.\d+)%\s+in\s+((alt-)?\w\w)$/,
        select: function(context, node3) {
          var popularity = parseFloat(node3.popularity);
          var place = node3.place;
          if (place.length === 2) {
            place = place.toUpperCase();
          } else {
            place = place.toLowerCase();
          }
          env2.loadCountry(browserslist.usage, place, browserslist.data);
          var usage = browserslist.usage[place];
          return Object.keys(usage).reduce(function(result, version4) {
            var percentage = usage[version4];
            if (percentage == null) {
              return result;
            }
            if (node3.sign === ">") {
              if (percentage > popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<") {
              if (percentage < popularity) {
                result.push(version4);
              }
            } else if (node3.sign === "<=") {
              if (percentage <= popularity) {
                result.push(version4);
              }
            } else if (percentage >= popularity) {
              result.push(version4);
            }
            return result;
          }, []);
        }
      },
      cover: {
        matches: ["coverage"],
        regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%$/i,
        select: coverQuery
      },
      cover_in: {
        matches: ["coverage", "place"],
        regexp: /^cover\s+(\d+|\d+\.\d+|\.\d+)%\s+in\s+(my\s+stats|(alt-)?\w\w)$/i,
        select: coverQuery
      },
      supports: {
        matches: ["supportType", "feature"],
        regexp: /^(?:(fully|partially)\s+)?supports\s+([\w-]+)$/,
        select: function(context, node3) {
          env2.loadFeature(browserslist.cache, node3.feature);
          var withPartial = node3.supportType !== "fully";
          var features = browserslist.cache[node3.feature];
          var result = [];
          for (var name2 in features) {
            var data = byName(name2, context);
            var iMax = data.released.length - 1;
            while (iMax >= 0) {
              if (data.released[iMax] in features[name2]) break;
              iMax--;
            }
            var checkDesktop = context.mobileToDesktop && name2 in browserslist.desktopNames && isSupported(features[name2][data.released[iMax]], withPartial);
            data.versions.forEach(function(version4) {
              var flags = features[name2][version4];
              if (flags === void 0 && checkDesktop) {
                flags = features[browserslist.desktopNames[name2]][version4];
              }
              if (isSupported(flags, withPartial)) {
                result.push(name2 + " " + version4);
              }
            });
          }
          return result;
        }
      },
      electron_range: {
        matches: ["from", "to"],
        regexp: /^electron\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node3) {
          var fromToUse = normalizeElectron(node3.from);
          var toToUse = normalizeElectron(node3.to);
          var from = parseFloat(node3.from);
          var to = parseFloat(node3.to);
          if (!e2c[fromToUse]) {
            throw new BrowserslistError("Unknown version " + from + " of electron");
          }
          if (!e2c[toToUse]) {
            throw new BrowserslistError("Unknown version " + to + " of electron");
          }
          return Object.keys(e2c).filter(function(i) {
            var parsed = parseFloat(i);
            return parsed >= from && parsed <= to;
          }).map(function(i) {
            return "chrome " + e2c[i];
          });
        }
      },
      node_range: {
        matches: ["from", "to"],
        regexp: /^node\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node3) {
          return browserslist.nodeVersions.filter(semverFilterLoose(">=", node3.from)).filter(semverFilterLoose("<=", node3.to)).map(function(v) {
            return "node " + v;
          });
        }
      },
      browser_range: {
        matches: ["browser", "from", "to"],
        regexp: /^(\w+)\s+([\d.]+)\s*-\s*([\d.]+)$/i,
        select: function(context, node3) {
          var data = checkName(node3.browser, context);
          var from = parseFloat(normalizeVersion(data, node3.from) || node3.from);
          var to = parseFloat(normalizeVersion(data, node3.to) || node3.to);
          function filter2(v) {
            var parsed = parseFloat(v);
            return parsed >= from && parsed <= to;
          }
          return data.released.filter(filter2).map(nameMapper(data.name));
        }
      },
      electron_ray: {
        matches: ["sign", "version"],
        regexp: /^electron\s*(>=?|<=?)\s*([\d.]+)$/i,
        select: function(context, node3) {
          var versionToUse = normalizeElectron(node3.version);
          return Object.keys(e2c).filter(generateFilter(node3.sign, versionToUse)).map(function(i) {
            return "chrome " + e2c[i];
          });
        }
      },
      node_ray: {
        matches: ["sign", "version"],
        regexp: /^node\s*(>=?|<=?)\s*([\d.]+)$/i,
        select: function(context, node3) {
          return browserslist.nodeVersions.filter(generateSemverFilter(node3.sign, node3.version)).map(function(v) {
            return "node " + v;
          });
        }
      },
      browser_ray: {
        matches: ["browser", "sign", "version"],
        regexp: /^(\w+)\s*(>=?|<=?)\s*([\d.]+)$/,
        select: function(context, node3) {
          var version4 = node3.version;
          var data = checkName(node3.browser, context);
          var alias = browserslist.versionAliases[data.name][version4];
          if (alias) version4 = alias;
          return data.released.filter(generateFilter(node3.sign, version4)).map(function(v) {
            return data.name + " " + v;
          });
        }
      },
      firefox_esr: {
        matches: [],
        regexp: /^(firefox|ff|fx)\s+esr$/i,
        select: function() {
          return ["firefox 115", "firefox 128"];
        }
      },
      opera_mini_all: {
        matches: [],
        regexp: /(operamini|op_mini)\s+all/i,
        select: function() {
          return ["op_mini all"];
        }
      },
      electron_version: {
        matches: ["version"],
        regexp: /^electron\s+([\d.]+)$/i,
        select: function(context, node3) {
          var versionToUse = normalizeElectron(node3.version);
          var chrome2 = e2c[versionToUse];
          if (!chrome2) {
            throw new BrowserslistError(
              "Unknown version " + node3.version + " of electron"
            );
          }
          return ["chrome " + chrome2];
        }
      },
      node_major_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+)$/i,
        select: nodeQuery
      },
      node_minor_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+\.\d+)$/i,
        select: nodeQuery
      },
      node_patch_version: {
        matches: ["version"],
        regexp: /^node\s+(\d+\.\d+\.\d+)$/i,
        select: nodeQuery
      },
      current_node: {
        matches: [],
        regexp: /^current\s+node$/i,
        select: function(context) {
          return [env2.currentNode(resolve8, context)];
        }
      },
      maintained_node: {
        matches: [],
        regexp: /^maintained\s+node\s+versions$/i,
        select: function(context) {
          var now = Date.now();
          var queries = Object.keys(jsEOL).filter(function(key) {
            return now < Date.parse(jsEOL[key].end) && now > Date.parse(jsEOL[key].start) && isEolReleased(key);
          }).map(function(key) {
            return "node " + key.slice(1);
          });
          return resolve8(queries, context);
        }
      },
      phantomjs_1_9: {
        matches: [],
        regexp: /^phantomjs\s+1.9$/i,
        select: function() {
          return ["safari 5"];
        }
      },
      phantomjs_2_1: {
        matches: [],
        regexp: /^phantomjs\s+2.1$/i,
        select: function() {
          return ["safari 6"];
        }
      },
      browser_version: {
        matches: ["browser", "version"],
        regexp: /^(\w+)\s+(tp|[\d.]+)$/i,
        select: function(context, node3) {
          var version4 = node3.version;
          if (/^tp$/i.test(version4)) version4 = "TP";
          var data = checkName(node3.browser, context);
          var alias = normalizeVersion(data, version4);
          if (alias) {
            version4 = alias;
          } else {
            if (version4.indexOf(".") === -1) {
              alias = version4 + ".0";
            } else {
              alias = version4.replace(/\.0$/, "");
            }
            alias = normalizeVersion(data, alias);
            if (alias) {
              version4 = alias;
            } else if (context.ignoreUnknownVersions) {
              return [];
            } else {
              throw new BrowserslistError(
                "Unknown version " + version4 + " of " + node3.browser
              );
            }
          }
          return [data.name + " " + version4];
        }
      },
      browserslist_config: {
        matches: [],
        regexp: /^browserslist config$/i,
        select: function(context) {
          return browserslist(void 0, context);
        }
      },
      extends: {
        matches: ["config"],
        regexp: /^extends (.+)$/i,
        select: function(context, node3) {
          return resolve8(env2.loadQueries(context, node3.config), context);
        }
      },
      defaults: {
        matches: [],
        regexp: /^defaults$/i,
        select: function(context) {
          return resolve8(browserslist.defaults, context);
        }
      },
      dead: {
        matches: [],
        regexp: /^dead$/i,
        select: function(context) {
          var dead = [
            "Baidu >= 0",
            "ie <= 11",
            "ie_mob <= 11",
            "bb <= 10",
            "op_mob <= 12.1",
            "samsung 4"
          ];
          return resolve8(dead, context);
        }
      },
      unknown: {
        matches: [],
        regexp: /^(\w+)$/i,
        select: function(context, node3) {
          if (byName(node3.query, context)) {
            throw new BrowserslistError(
              "Specify versions in Browserslist query for browser " + node3.query
            );
          } else {
            throw unknownQuery(node3.query);
          }
        }
      }
    };
    (function() {
      for (var name2 in agents) {
        var browser2 = agents[name2];
        browserslist.data[name2] = {
          name: name2,
          versions: normalize2(agents[name2].versions),
          released: normalize2(agents[name2].versions.slice(0, -3)),
          releaseDate: agents[name2].release_date
        };
        fillUsage(browserslist.usage.global, name2, browser2.usage_global);
        browserslist.versionAliases[name2] = {};
        for (var i = 0; i < browser2.versions.length; i++) {
          var full = browser2.versions[i];
          if (!full) continue;
          if (full.indexOf("-") !== -1) {
            var interval = full.split("-");
            for (var j = 0; j < interval.length; j++) {
              browserslist.versionAliases[name2][interval[j]] = full;
            }
          }
        }
      }
      browserslist.nodeVersions = jsReleases.map(function(release) {
        return release.version;
      });
    })();
    module.exports = browserslist;
  }
});

// node_modules/@babel/helper-validator-option/lib/find-suggestion.js
var require_find_suggestion = __commonJS({
  "node_modules/@babel/helper-validator-option/lib/find-suggestion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.findSuggestion = findSuggestion;
    var {
      min: min2
    } = Math;
    function levenshtein(a, b) {
      let t = [], u = [], i, j;
      const m = a.length, n = b.length;
      if (!m) {
        return n;
      }
      if (!n) {
        return m;
      }
      for (j = 0; j <= n; j++) {
        t[j] = j;
      }
      for (i = 1; i <= m; i++) {
        for (u = [i], j = 1; j <= n; j++) {
          u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : min2(t[j - 1], t[j], u[j - 1]) + 1;
        }
        t = u;
      }
      return u[n];
    }
    function findSuggestion(str2, arr) {
      const distances = arr.map((el) => levenshtein(el, str2));
      return arr[distances.indexOf(min2(...distances))];
    }
  }
});

// node_modules/@babel/helper-validator-option/lib/validator.js
var require_validator = __commonJS({
  "node_modules/@babel/helper-validator-option/lib/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.OptionValidator = void 0;
    var _findSuggestion = require_find_suggestion();
    var OptionValidator = class {
      constructor(descriptor) {
        this.descriptor = descriptor;
      }
      validateTopLevelOptions(options2, TopLevelOptionShape) {
        const validOptionNames = Object.keys(TopLevelOptionShape);
        for (const option of Object.keys(options2)) {
          if (!validOptionNames.includes(option)) {
            throw new Error(this.formatMessage(`'${option}' is not a valid top-level option.
- Did you mean '${(0, _findSuggestion.findSuggestion)(option, validOptionNames)}'?`));
          }
        }
      }
      validateBooleanOption(name2, value2, defaultValue) {
        if (value2 === void 0) {
          return defaultValue;
        } else {
          this.invariant(typeof value2 === "boolean", `'${name2}' option must be a boolean.`);
        }
        return value2;
      }
      validateStringOption(name2, value2, defaultValue) {
        if (value2 === void 0) {
          return defaultValue;
        } else {
          this.invariant(typeof value2 === "string", `'${name2}' option must be a string.`);
        }
        return value2;
      }
      invariant(condition, message) {
        if (!condition) {
          throw new Error(this.formatMessage(message));
        }
      }
      formatMessage(message) {
        return `${this.descriptor}: ${message}`;
      }
    };
    exports2.OptionValidator = OptionValidator;
  }
});

// node_modules/@babel/helper-validator-option/lib/index.js
var require_lib13 = __commonJS({
  "node_modules/@babel/helper-validator-option/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "OptionValidator", {
      enumerable: true,
      get: function() {
        return _validator.OptionValidator;
      }
    });
    Object.defineProperty(exports2, "findSuggestion", {
      enumerable: true,
      get: function() {
        return _findSuggestion.findSuggestion;
      }
    });
    var _validator = require_validator();
    var _findSuggestion = require_find_suggestion();
  }
});

// node_modules/@babel/compat-data/data/native-modules.json
var require_native_modules = __commonJS({
  "node_modules/@babel/compat-data/data/native-modules.json"(exports2, module) {
    module.exports = {
      "es6.module": {
        chrome: "61",
        and_chr: "61",
        edge: "16",
        firefox: "60",
        and_ff: "60",
        node: "13.2.0",
        opera: "48",
        op_mob: "45",
        safari: "10.1",
        ios: "10.3",
        samsung: "8.2",
        android: "61",
        electron: "2.0",
        ios_saf: "10.3"
      }
    };
  }
});

// node_modules/@babel/compat-data/native-modules.js
var require_native_modules2 = __commonJS({
  "node_modules/@babel/compat-data/native-modules.js"(exports2, module) {
    module.exports = require_native_modules();
  }
});

// node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/yallist/iterator.js"(exports2, module) {
    "use strict";
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/yallist/yallist.js"(exports2, module) {
    "use strict";
    module.exports = Yallist;
    Yallist.Node = Node2;
    Yallist.create = Yallist;
    function Yallist(list2) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list2 && typeof list2.forEach === "function") {
        list2.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node3) {
      if (node3.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node3.next;
      var prev = node3.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node3 === this.head) {
        this.head = next;
      }
      if (node3 === this.tail) {
        this.tail = prev;
      }
      node3.list.length--;
      node3.next = null;
      node3.prev = null;
      node3.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node3) {
      if (node3 === this.head) {
        return;
      }
      if (node3.list) {
        node3.list.removeNode(node3);
      }
      var head = this.head;
      node3.list = this;
      node3.next = head;
      if (head) {
        head.prev = node3;
      }
      this.head = node3;
      if (!this.tail) {
        this.tail = node3;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node3) {
      if (node3 === this.tail) {
        return;
      }
      if (node3.list) {
        node3.list.removeNode(node3);
      }
      var tail = this.tail;
      node3.list = this;
      node3.prev = tail;
      if (tail) {
        tail.next = node3;
      }
      this.tail = node3;
      if (!this.head) {
        this.head = node3;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push2(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 2; i < arguments.length; i++) {
        walker = insert(this, walker, arguments[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node3, value2) {
      var inserted = node3 === self2.head ? new Node2(value2, null, node3, self2) : new Node2(value2, node3, node3.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    function push2(self2, item) {
      self2.tail = new Node2(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node2(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node2(value2, prev, next, list2) {
      if (!(this instanceof Node2)) {
        return new Node2(value2, prev, next, list2);
      }
      this.list = list2;
      this.value = value2;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-cache/index.js"(exports2, module) {
    "use strict";
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = () => 1;
    var LRUCache2 = class {
      constructor(options2) {
        if (typeof options2 === "number")
          options2 = { max: options2 };
        if (!options2)
          options2 = {};
        if (options2.max && (typeof options2.max !== "number" || options2.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options2.max || Infinity;
        const lc = options2.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options2.stale || false;
        if (options2.maxAge && typeof options2.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options2.maxAge || 0;
        this[DISPOSE] = options2.dispose;
        this[NO_DISPOSE_ON_SET] = options2.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options2.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value2, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value2, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node3 = this[CACHE].get(key);
          const item = node3.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value2;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value2, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value2);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get(this, key, true);
      }
      peek(key) {
        return get(this, key, false);
      }
      pop() {
        const node3 = this[LRU_LIST].tail;
        if (!node3)
          return null;
        del(this, node3);
        return node3.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value2, key) => get(this, key, false));
      }
    };
    var get = (self2, key, doUse) => {
      const node3 = self2[CACHE].get(key);
      if (node3) {
        const hit = node3.value;
        if (isStale(self2, hit)) {
          del(self2, node3);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node3.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node3);
          }
        }
        return hit.value;
      }
    };
    var isStale = (self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    };
    var trim = (self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    };
    var del = (self2, node3) => {
      if (node3) {
        const hit = node3.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node3);
      }
    };
    var Entry = class {
      constructor(key, value2, length, now, maxAge) {
        this.key = key;
        this.value = value2;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = (self2, fn, node3, thisp) => {
      let hit = node3.value;
      if (isStale(self2, hit)) {
        del(self2, node3);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    };
    module.exports = LRUCache2;
  }
});

// node_modules/@babel/helper-compilation-targets/lib/targets.js
var require_targets = __commonJS({
  "node_modules/@babel/helper-compilation-targets/lib/targets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.unreleasedLabels = exports2.browserNameMap = void 0;
    var unreleasedLabels = exports2.unreleasedLabels = {
      safari: "tp"
    };
    var browserNameMap = exports2.browserNameMap = {
      and_chr: "chrome",
      and_ff: "firefox",
      android: "android",
      chrome: "chrome",
      edge: "edge",
      firefox: "firefox",
      ie: "ie",
      ie_mob: "ie",
      ios_saf: "ios",
      node: "node",
      deno: "deno",
      op_mob: "opera_mobile",
      opera: "opera",
      safari: "safari",
      samsung: "samsung"
    };
  }
});

// node_modules/@babel/helper-compilation-targets/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/@babel/helper-compilation-targets/lib/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getHighestUnreleased = getHighestUnreleased;
    exports2.getLowestImplementedVersion = getLowestImplementedVersion;
    exports2.getLowestUnreleased = getLowestUnreleased;
    exports2.isUnreleasedVersion = isUnreleasedVersion;
    exports2.semverMin = semverMin;
    exports2.semverify = semverify;
    var _semver = require_semver();
    var _helperValidatorOption = require_lib13();
    var _targets = require_targets();
    var versionRegExp = /^(?:\d+|\d(?:\d?[^\d\n\r\u2028\u2029]\d+|\d{2,}(?:[^\d\n\r\u2028\u2029]\d+)?))$/;
    var v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
    function semverMin(first2, second) {
      return first2 && _semver.lt(first2, second) ? first2 : second;
    }
    function semverify(version4) {
      if (typeof version4 === "string" && _semver.valid(version4)) {
        return version4;
      }
      v.invariant(typeof version4 === "number" || typeof version4 === "string" && versionRegExp.test(version4), `'${version4}' is not a valid version`);
      version4 = version4.toString();
      let pos = 0;
      let num = 0;
      while ((pos = version4.indexOf(".", pos + 1)) > 0) {
        num++;
      }
      return version4 + ".0".repeat(2 - num);
    }
    function isUnreleasedVersion(version4, env2) {
      const unreleasedLabel = _targets.unreleasedLabels[env2];
      return !!unreleasedLabel && unreleasedLabel === version4.toString().toLowerCase();
    }
    function getLowestUnreleased(a, b, env2) {
      const unreleasedLabel = _targets.unreleasedLabels[env2];
      if (a === unreleasedLabel) {
        return b;
      }
      if (b === unreleasedLabel) {
        return a;
      }
      return semverMin(a, b);
    }
    function getHighestUnreleased(a, b, env2) {
      return getLowestUnreleased(a, b, env2) === a ? b : a;
    }
    function getLowestImplementedVersion(plugin3, environment) {
      const result = plugin3[environment];
      if (!result && environment === "android") {
        return plugin3.chrome;
      }
      return result;
    }
  }
});

// node_modules/@babel/helper-compilation-targets/lib/options.js
var require_options2 = __commonJS({
  "node_modules/@babel/helper-compilation-targets/lib/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TargetNames = void 0;
    var TargetNames = exports2.TargetNames = {
      node: "node",
      deno: "deno",
      chrome: "chrome",
      opera: "opera",
      edge: "edge",
      firefox: "firefox",
      safari: "safari",
      ie: "ie",
      ios: "ios",
      android: "android",
      electron: "electron",
      samsung: "samsung",
      rhino: "rhino",
      opera_mobile: "opera_mobile"
    };
  }
});

// node_modules/@babel/helper-compilation-targets/lib/pretty.js
var require_pretty = __commonJS({
  "node_modules/@babel/helper-compilation-targets/lib/pretty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.prettifyTargets = prettifyTargets;
    exports2.prettifyVersion = prettifyVersion;
    var _semver = require_semver();
    var _targets = require_targets();
    function prettifyVersion(version4) {
      if (typeof version4 !== "string") {
        return version4;
      }
      const {
        major,
        minor,
        patch
      } = _semver.parse(version4);
      const parts = [major];
      if (minor || patch) {
        parts.push(minor);
      }
      if (patch) {
        parts.push(patch);
      }
      return parts.join(".");
    }
    function prettifyTargets(targets) {
      return Object.keys(targets).reduce((results, target) => {
        let value2 = targets[target];
        const unreleasedLabel = _targets.unreleasedLabels[target];
        if (typeof value2 === "string" && unreleasedLabel !== value2) {
          value2 = prettifyVersion(value2);
        }
        results[target] = value2;
        return results;
      }, {});
    }
  }
});

// node_modules/@babel/helper-compilation-targets/lib/debug.js
var require_debug = __commonJS({
  "node_modules/@babel/helper-compilation-targets/lib/debug.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getInclusionReasons = getInclusionReasons;
    var _semver = require_semver();
    var _pretty = require_pretty();
    var _utils = require_utils3();
    function getInclusionReasons(item, targetVersions, list2) {
      const minVersions = list2[item] || {};
      return Object.keys(targetVersions).reduce((result, env2) => {
        const minVersion = (0, _utils.getLowestImplementedVersion)(minVersions, env2);
        const targetVersion = targetVersions[env2];
        if (!minVersion) {
          result[env2] = (0, _pretty.prettifyVersion)(targetVersion);
        } else {
          const minIsUnreleased = (0, _utils.isUnreleasedVersion)(minVersion, env2);
          const targetIsUnreleased = (0, _utils.isUnreleasedVersion)(targetVersion, env2);
          if (!targetIsUnreleased && (minIsUnreleased || _semver.lt(targetVersion.toString(), (0, _utils.semverify)(minVersion)))) {
            result[env2] = (0, _pretty.prettifyVersion)(targetVersion);
          }
        }
        return result;
      }, {});
    }
  }
});

// node_modules/@babel/compat-data/data/plugins.json
var require_plugins = __commonJS({
  "node_modules/@babel/compat-data/data/plugins.json"(exports2, module) {
    module.exports = {
      "transform-duplicate-named-capturing-groups-regex": {
        chrome: "126",
        opera: "112",
        edge: "126",
        firefox: "129",
        safari: "17.4",
        node: "23",
        ios: "17.4",
        electron: "31.0"
      },
      "transform-regexp-modifiers": {
        chrome: "125",
        opera: "111",
        edge: "125",
        firefox: "132",
        node: "23",
        electron: "31.0"
      },
      "transform-unicode-sets-regex": {
        chrome: "112",
        opera: "98",
        edge: "112",
        firefox: "116",
        safari: "17",
        node: "20",
        deno: "1.32",
        ios: "17",
        opera_mobile: "75",
        electron: "24.0"
      },
      "bugfix/transform-v8-static-class-fields-redefine-readonly": {
        chrome: "98",
        opera: "84",
        edge: "98",
        firefox: "75",
        safari: "15",
        node: "12",
        deno: "1.18",
        ios: "15",
        samsung: "11",
        opera_mobile: "52",
        electron: "17.0"
      },
      "bugfix/transform-firefox-class-in-computed-class-key": {
        chrome: "74",
        opera: "62",
        edge: "79",
        safari: "16",
        node: "12",
        deno: "1",
        ios: "16",
        samsung: "11",
        opera_mobile: "53",
        electron: "6.0"
      },
      "bugfix/transform-safari-class-field-initializer-scope": {
        chrome: "74",
        opera: "62",
        edge: "79",
        firefox: "69",
        safari: "16",
        node: "12",
        deno: "1",
        ios: "16",
        samsung: "11",
        opera_mobile: "53",
        electron: "6.0"
      },
      "transform-class-static-block": {
        chrome: "94",
        opera: "80",
        edge: "94",
        firefox: "93",
        safari: "16.4",
        node: "16.11",
        deno: "1.14",
        ios: "16.4",
        samsung: "17",
        opera_mobile: "66",
        electron: "15.0"
      },
      "proposal-class-static-block": {
        chrome: "94",
        opera: "80",
        edge: "94",
        firefox: "93",
        safari: "16.4",
        node: "16.11",
        deno: "1.14",
        ios: "16.4",
        samsung: "17",
        opera_mobile: "66",
        electron: "15.0"
      },
      "transform-private-property-in-object": {
        chrome: "91",
        opera: "77",
        edge: "91",
        firefox: "90",
        safari: "15",
        node: "16.9",
        deno: "1.9",
        ios: "15",
        samsung: "16",
        opera_mobile: "64",
        electron: "13.0"
      },
      "proposal-private-property-in-object": {
        chrome: "91",
        opera: "77",
        edge: "91",
        firefox: "90",
        safari: "15",
        node: "16.9",
        deno: "1.9",
        ios: "15",
        samsung: "16",
        opera_mobile: "64",
        electron: "13.0"
      },
      "transform-class-properties": {
        chrome: "74",
        opera: "62",
        edge: "79",
        firefox: "90",
        safari: "14.1",
        node: "12",
        deno: "1",
        ios: "14.5",
        samsung: "11",
        opera_mobile: "53",
        electron: "6.0"
      },
      "proposal-class-properties": {
        chrome: "74",
        opera: "62",
        edge: "79",
        firefox: "90",
        safari: "14.1",
        node: "12",
        deno: "1",
        ios: "14.5",
        samsung: "11",
        opera_mobile: "53",
        electron: "6.0"
      },
      "transform-private-methods": {
        chrome: "84",
        opera: "70",
        edge: "84",
        firefox: "90",
        safari: "15",
        node: "14.6",
        deno: "1",
        ios: "15",
        samsung: "14",
        opera_mobile: "60",
        electron: "10.0"
      },
      "proposal-private-methods": {
        chrome: "84",
        opera: "70",
        edge: "84",
        firefox: "90",
        safari: "15",
        node: "14.6",
        deno: "1",
        ios: "15",
        samsung: "14",
        opera_mobile: "60",
        electron: "10.0"
      },
      "transform-numeric-separator": {
        chrome: "75",
        opera: "62",
        edge: "79",
        firefox: "70",
        safari: "13",
        node: "12.5",
        deno: "1",
        ios: "13",
        samsung: "11",
        rhino: "1.7.14",
        opera_mobile: "54",
        electron: "6.0"
      },
      "proposal-numeric-separator": {
        chrome: "75",
        opera: "62",
        edge: "79",
        firefox: "70",
        safari: "13",
        node: "12.5",
        deno: "1",
        ios: "13",
        samsung: "11",
        rhino: "1.7.14",
        opera_mobile: "54",
        electron: "6.0"
      },
      "transform-logical-assignment-operators": {
        chrome: "85",
        opera: "71",
        edge: "85",
        firefox: "79",
        safari: "14",
        node: "15",
        deno: "1.2",
        ios: "14",
        samsung: "14",
        opera_mobile: "60",
        electron: "10.0"
      },
      "proposal-logical-assignment-operators": {
        chrome: "85",
        opera: "71",
        edge: "85",
        firefox: "79",
        safari: "14",
        node: "15",
        deno: "1.2",
        ios: "14",
        samsung: "14",
        opera_mobile: "60",
        electron: "10.0"
      },
      "transform-nullish-coalescing-operator": {
        chrome: "80",
        opera: "67",
        edge: "80",
        firefox: "72",
        safari: "13.1",
        node: "14",
        deno: "1",
        ios: "13.4",
        samsung: "13",
        opera_mobile: "57",
        electron: "8.0"
      },
      "proposal-nullish-coalescing-operator": {
        chrome: "80",
        opera: "67",
        edge: "80",
        firefox: "72",
        safari: "13.1",
        node: "14",
        deno: "1",
        ios: "13.4",
        samsung: "13",
        opera_mobile: "57",
        electron: "8.0"
      },
      "transform-optional-chaining": {
        chrome: "91",
        opera: "77",
        edge: "91",
        firefox: "74",
        safari: "13.1",
        node: "16.9",
        deno: "1.9",
        ios: "13.4",
        samsung: "16",
        opera_mobile: "64",
        electron: "13.0"
      },
      "proposal-optional-chaining": {
        chrome: "91",
        opera: "77",
        edge: "91",
        firefox: "74",
        safari: "13.1",
        node: "16.9",
        deno: "1.9",
        ios: "13.4",
        samsung: "16",
        opera_mobile: "64",
        electron: "13.0"
      },
      "transform-json-strings": {
        chrome: "66",
        opera: "53",
        edge: "79",
        firefox: "62",
        safari: "12",
        node: "10",
        deno: "1",
        ios: "12",
        samsung: "9",
        rhino: "1.7.14",
        opera_mobile: "47",
        electron: "3.0"
      },
      "proposal-json-strings": {
        chrome: "66",
        opera: "53",
        edge: "79",
        firefox: "62",
        safari: "12",
        node: "10",
        deno: "1",
        ios: "12",
        samsung: "9",
        rhino: "1.7.14",
        opera_mobile: "47",
        electron: "3.0"
      },
      "transform-optional-catch-binding": {
        chrome: "66",
        opera: "53",
        edge: "79",
        firefox: "58",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "proposal-optional-catch-binding": {
        chrome: "66",
        opera: "53",
        edge: "79",
        firefox: "58",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "transform-parameters": {
        chrome: "49",
        opera: "36",
        edge: "18",
        firefox: "53",
        safari: "16.3",
        node: "6",
        deno: "1",
        ios: "16.3",
        samsung: "5",
        opera_mobile: "36",
        electron: "0.37"
      },
      "transform-async-generator-functions": {
        chrome: "63",
        opera: "50",
        edge: "79",
        firefox: "57",
        safari: "12",
        node: "10",
        deno: "1",
        ios: "12",
        samsung: "8",
        opera_mobile: "46",
        electron: "3.0"
      },
      "proposal-async-generator-functions": {
        chrome: "63",
        opera: "50",
        edge: "79",
        firefox: "57",
        safari: "12",
        node: "10",
        deno: "1",
        ios: "12",
        samsung: "8",
        opera_mobile: "46",
        electron: "3.0"
      },
      "transform-object-rest-spread": {
        chrome: "60",
        opera: "47",
        edge: "79",
        firefox: "55",
        safari: "11.1",
        node: "8.3",
        deno: "1",
        ios: "11.3",
        samsung: "8",
        opera_mobile: "44",
        electron: "2.0"
      },
      "proposal-object-rest-spread": {
        chrome: "60",
        opera: "47",
        edge: "79",
        firefox: "55",
        safari: "11.1",
        node: "8.3",
        deno: "1",
        ios: "11.3",
        samsung: "8",
        opera_mobile: "44",
        electron: "2.0"
      },
      "transform-dotall-regex": {
        chrome: "62",
        opera: "49",
        edge: "79",
        firefox: "78",
        safari: "11.1",
        node: "8.10",
        deno: "1",
        ios: "11.3",
        samsung: "8",
        rhino: "1.7.15",
        opera_mobile: "46",
        electron: "3.0"
      },
      "transform-unicode-property-regex": {
        chrome: "64",
        opera: "51",
        edge: "79",
        firefox: "78",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "proposal-unicode-property-regex": {
        chrome: "64",
        opera: "51",
        edge: "79",
        firefox: "78",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "transform-named-capturing-groups-regex": {
        chrome: "64",
        opera: "51",
        edge: "79",
        firefox: "78",
        safari: "11.1",
        node: "10",
        deno: "1",
        ios: "11.3",
        samsung: "9",
        opera_mobile: "47",
        electron: "3.0"
      },
      "transform-async-to-generator": {
        chrome: "55",
        opera: "42",
        edge: "15",
        firefox: "52",
        safari: "11",
        node: "7.6",
        deno: "1",
        ios: "11",
        samsung: "6",
        opera_mobile: "42",
        electron: "1.6"
      },
      "transform-exponentiation-operator": {
        chrome: "52",
        opera: "39",
        edge: "14",
        firefox: "52",
        safari: "10.1",
        node: "7",
        deno: "1",
        ios: "10.3",
        samsung: "6",
        rhino: "1.7.14",
        opera_mobile: "41",
        electron: "1.3"
      },
      "transform-template-literals": {
        chrome: "41",
        opera: "28",
        edge: "13",
        firefox: "34",
        safari: "13",
        node: "4",
        deno: "1",
        ios: "13",
        samsung: "3.4",
        opera_mobile: "28",
        electron: "0.21"
      },
      "transform-literals": {
        chrome: "44",
        opera: "31",
        edge: "12",
        firefox: "53",
        safari: "9",
        node: "4",
        deno: "1",
        ios: "9",
        samsung: "4",
        rhino: "1.7.15",
        opera_mobile: "32",
        electron: "0.30"
      },
      "transform-function-name": {
        chrome: "51",
        opera: "38",
        edge: "79",
        firefox: "53",
        safari: "10",
        node: "6.5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "41",
        electron: "1.2"
      },
      "transform-arrow-functions": {
        chrome: "47",
        opera: "34",
        edge: "13",
        firefox: "43",
        safari: "10",
        node: "6",
        deno: "1",
        ios: "10",
        samsung: "5",
        rhino: "1.7.13",
        opera_mobile: "34",
        electron: "0.36"
      },
      "transform-block-scoped-functions": {
        chrome: "41",
        opera: "28",
        edge: "12",
        firefox: "46",
        safari: "10",
        node: "4",
        deno: "1",
        ie: "11",
        ios: "10",
        samsung: "3.4",
        opera_mobile: "28",
        electron: "0.21"
      },
      "transform-classes": {
        chrome: "46",
        opera: "33",
        edge: "13",
        firefox: "45",
        safari: "10",
        node: "5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "33",
        electron: "0.36"
      },
      "transform-object-super": {
        chrome: "46",
        opera: "33",
        edge: "13",
        firefox: "45",
        safari: "10",
        node: "5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "33",
        electron: "0.36"
      },
      "transform-shorthand-properties": {
        chrome: "43",
        opera: "30",
        edge: "12",
        firefox: "33",
        safari: "9",
        node: "4",
        deno: "1",
        ios: "9",
        samsung: "4",
        rhino: "1.7.14",
        opera_mobile: "30",
        electron: "0.27"
      },
      "transform-duplicate-keys": {
        chrome: "42",
        opera: "29",
        edge: "12",
        firefox: "34",
        safari: "9",
        node: "4",
        deno: "1",
        ios: "9",
        samsung: "3.4",
        opera_mobile: "29",
        electron: "0.25"
      },
      "transform-computed-properties": {
        chrome: "44",
        opera: "31",
        edge: "12",
        firefox: "34",
        safari: "7.1",
        node: "4",
        deno: "1",
        ios: "8",
        samsung: "4",
        opera_mobile: "32",
        electron: "0.30"
      },
      "transform-for-of": {
        chrome: "51",
        opera: "38",
        edge: "15",
        firefox: "53",
        safari: "10",
        node: "6.5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "41",
        electron: "1.2"
      },
      "transform-sticky-regex": {
        chrome: "49",
        opera: "36",
        edge: "13",
        firefox: "3",
        safari: "10",
        node: "6",
        deno: "1",
        ios: "10",
        samsung: "5",
        rhino: "1.7.15",
        opera_mobile: "36",
        electron: "0.37"
      },
      "transform-unicode-escapes": {
        chrome: "44",
        opera: "31",
        edge: "12",
        firefox: "53",
        safari: "9",
        node: "4",
        deno: "1",
        ios: "9",
        samsung: "4",
        rhino: "1.7.15",
        opera_mobile: "32",
        electron: "0.30"
      },
      "transform-unicode-regex": {
        chrome: "50",
        opera: "37",
        edge: "13",
        firefox: "46",
        safari: "12",
        node: "6",
        deno: "1",
        ios: "12",
        samsung: "5",
        opera_mobile: "37",
        electron: "1.1"
      },
      "transform-spread": {
        chrome: "46",
        opera: "33",
        edge: "13",
        firefox: "45",
        safari: "10",
        node: "5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "33",
        electron: "0.36"
      },
      "transform-destructuring": {
        chrome: "51",
        opera: "38",
        edge: "15",
        firefox: "53",
        safari: "10",
        node: "6.5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "41",
        electron: "1.2"
      },
      "transform-block-scoping": {
        chrome: "50",
        opera: "37",
        edge: "14",
        firefox: "53",
        safari: "11",
        node: "6",
        deno: "1",
        ios: "11",
        samsung: "5",
        opera_mobile: "37",
        electron: "1.1"
      },
      "transform-typeof-symbol": {
        chrome: "38",
        opera: "25",
        edge: "12",
        firefox: "36",
        safari: "9",
        node: "0.12",
        deno: "1",
        ios: "9",
        samsung: "3",
        rhino: "1.7.13",
        opera_mobile: "25",
        electron: "0.20"
      },
      "transform-new-target": {
        chrome: "46",
        opera: "33",
        edge: "14",
        firefox: "41",
        safari: "10",
        node: "5",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "33",
        electron: "0.36"
      },
      "transform-regenerator": {
        chrome: "50",
        opera: "37",
        edge: "13",
        firefox: "53",
        safari: "10",
        node: "6",
        deno: "1",
        ios: "10",
        samsung: "5",
        opera_mobile: "37",
        electron: "1.1"
      },
      "transform-member-expression-literals": {
        chrome: "7",
        opera: "12",
        edge: "12",
        firefox: "2",
        safari: "5.1",
        node: "0.4",
        deno: "1",
        ie: "9",
        android: "4",
        ios: "6",
        phantom: "1.9",
        samsung: "1",
        rhino: "1.7.13",
        opera_mobile: "12",
        electron: "0.20"
      },
      "transform-property-literals": {
        chrome: "7",
        opera: "12",
        edge: "12",
        firefox: "2",
        safari: "5.1",
        node: "0.4",
        deno: "1",
        ie: "9",
        android: "4",
        ios: "6",
        phantom: "1.9",
        samsung: "1",
        rhino: "1.7.13",
        opera_mobile: "12",
        electron: "0.20"
      },
      "transform-reserved-words": {
        chrome: "13",
        opera: "10.50",
        edge: "12",
        firefox: "2",
        safari: "3.1",
        node: "0.6",
        deno: "1",
        ie: "9",
        android: "4.4",
        ios: "6",
        phantom: "1.9",
        samsung: "1",
        rhino: "1.7.13",
        opera_mobile: "10.1",
        electron: "0.20"
      },
      "transform-export-namespace-from": {
        chrome: "72",
        deno: "1.0",
        edge: "79",
        firefox: "80",
        node: "13.2",
        opera: "60",
        opera_mobile: "51",
        safari: "14.1",
        ios: "14.5",
        samsung: "11.0",
        android: "72",
        electron: "5.0"
      },
      "proposal-export-namespace-from": {
        chrome: "72",
        deno: "1.0",
        edge: "79",
        firefox: "80",
        node: "13.2",
        opera: "60",
        opera_mobile: "51",
        safari: "14.1",
        ios: "14.5",
        samsung: "11.0",
        android: "72",
        electron: "5.0"
      }
    };
  }
});

// node_modules/@babel/compat-data/plugins.js
var require_plugins2 = __commonJS({
  "node_modules/@babel/compat-data/plugins.js"(exports2, module) {
    module.exports = require_plugins();
  }
});

// node_modules/@babel/helper-compilation-targets/lib/filter-items.js
var require_filter_items = __commonJS({
  "node_modules/@babel/helper-compilation-targets/lib/filter-items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = filterItems;
    exports2.isRequired = isRequired;
    exports2.targetsSupported = targetsSupported;
    var _semver = require_semver();
    var _plugins = require_plugins2();
    var _utils = require_utils3();
    function targetsSupported(target, support) {
      const targetEnvironments = Object.keys(target);
      if (targetEnvironments.length === 0) {
        return false;
      }
      const unsupportedEnvironments = targetEnvironments.filter((environment) => {
        const lowestImplementedVersion = (0, _utils.getLowestImplementedVersion)(support, environment);
        if (!lowestImplementedVersion) {
          return true;
        }
        const lowestTargetedVersion = target[environment];
        if ((0, _utils.isUnreleasedVersion)(lowestTargetedVersion, environment)) {
          return false;
        }
        if ((0, _utils.isUnreleasedVersion)(lowestImplementedVersion, environment)) {
          return true;
        }
        if (!_semver.valid(lowestTargetedVersion.toString())) {
          throw new Error(`Invalid version passed for target "${environment}": "${lowestTargetedVersion}". Versions must be in semver format (major.minor.patch)`);
        }
        return _semver.gt((0, _utils.semverify)(lowestImplementedVersion), lowestTargetedVersion.toString());
      });
      return unsupportedEnvironments.length === 0;
    }
    function isRequired(name2, targets, {
      compatData = _plugins,
      includes,
      excludes
    } = {}) {
      if (excludes != null && excludes.has(name2)) return false;
      if (includes != null && includes.has(name2)) return true;
      return !targetsSupported(targets, compatData[name2]);
    }
    function filterItems(list2, includes, excludes, targets, defaultIncludes, defaultExcludes, pluginSyntaxMap) {
      const result = /* @__PURE__ */ new Set();
      const options2 = {
        compatData: list2,
        includes,
        excludes
      };
      for (const item in list2) {
        if (isRequired(item, targets, options2)) {
          result.add(item);
        } else if (pluginSyntaxMap) {
          const shippedProposalsSyntax = pluginSyntaxMap.get(item);
          if (shippedProposalsSyntax) {
            result.add(shippedProposalsSyntax);
          }
        }
      }
      defaultIncludes == null || defaultIncludes.forEach((item) => !excludes.has(item) && result.add(item));
      defaultExcludes == null || defaultExcludes.forEach((item) => !includes.has(item) && result.delete(item));
      return result;
    }
  }
});

// node_modules/@babel/helper-compilation-targets/lib/index.js
var require_lib14 = __commonJS({
  "node_modules/@babel/helper-compilation-targets/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "TargetNames", {
      enumerable: true,
      get: function() {
        return _options.TargetNames;
      }
    });
    exports2.default = getTargets;
    Object.defineProperty(exports2, "filterItems", {
      enumerable: true,
      get: function() {
        return _filterItems.default;
      }
    });
    Object.defineProperty(exports2, "getInclusionReasons", {
      enumerable: true,
      get: function() {
        return _debug2.getInclusionReasons;
      }
    });
    exports2.isBrowsersQueryValid = isBrowsersQueryValid;
    Object.defineProperty(exports2, "isRequired", {
      enumerable: true,
      get: function() {
        return _filterItems.isRequired;
      }
    });
    Object.defineProperty(exports2, "prettifyTargets", {
      enumerable: true,
      get: function() {
        return _pretty.prettifyTargets;
      }
    });
    Object.defineProperty(exports2, "unreleasedLabels", {
      enumerable: true,
      get: function() {
        return _targets.unreleasedLabels;
      }
    });
    var _browserslist = require_browserslist();
    var _helperValidatorOption = require_lib13();
    var _nativeModules = require_native_modules2();
    var _lruCache = require_lru_cache();
    var _utils = require_utils3();
    var _targets = require_targets();
    var _options = require_options2();
    var _pretty = require_pretty();
    var _debug2 = require_debug();
    var _filterItems = require_filter_items();
    var ESM_SUPPORT = _nativeModules["es6.module"];
    var v = new _helperValidatorOption.OptionValidator("@babel/helper-compilation-targets");
    function validateTargetNames(targets) {
      const validTargets = Object.keys(_options.TargetNames);
      for (const target of Object.keys(targets)) {
        if (!(target in _options.TargetNames)) {
          throw new Error(v.formatMessage(`'${target}' is not a valid target
- Did you mean '${(0, _helperValidatorOption.findSuggestion)(target, validTargets)}'?`));
        }
      }
      return targets;
    }
    function isBrowsersQueryValid(browsers) {
      return typeof browsers === "string" || Array.isArray(browsers) && browsers.every((b) => typeof b === "string");
    }
    function validateBrowsers(browsers) {
      v.invariant(browsers === void 0 || isBrowsersQueryValid(browsers), `'${String(browsers)}' is not a valid browserslist query`);
      return browsers;
    }
    function getLowestVersions(browsers) {
      return browsers.reduce((all, browser2) => {
        const [browserName, browserVersion] = browser2.split(" ");
        const target = _targets.browserNameMap[browserName];
        if (!target) {
          return all;
        }
        try {
          const splitVersion = browserVersion.split("-")[0].toLowerCase();
          const isSplitUnreleased = (0, _utils.isUnreleasedVersion)(splitVersion, target);
          if (!all[target]) {
            all[target] = isSplitUnreleased ? splitVersion : (0, _utils.semverify)(splitVersion);
            return all;
          }
          const version4 = all[target];
          const isUnreleased = (0, _utils.isUnreleasedVersion)(version4, target);
          if (isUnreleased && isSplitUnreleased) {
            all[target] = (0, _utils.getLowestUnreleased)(version4, splitVersion, target);
          } else if (isUnreleased) {
            all[target] = (0, _utils.semverify)(splitVersion);
          } else if (!isUnreleased && !isSplitUnreleased) {
            const parsedBrowserVersion = (0, _utils.semverify)(splitVersion);
            all[target] = (0, _utils.semverMin)(version4, parsedBrowserVersion);
          }
        } catch (_) {
        }
        return all;
      }, {});
    }
    function outputDecimalWarning(decimalTargets) {
      if (!decimalTargets.length) {
        return;
      }
      console.warn("Warning, the following targets are using a decimal version:\n");
      decimalTargets.forEach(({
        target,
        value: value2
      }) => console.warn(`  ${target}: ${value2}`));
      console.warn(`
We recommend using a string for minor/patch versions to avoid numbers like 6.10
getting parsed as 6.1, which can lead to unexpected behavior.
`);
    }
    function semverifyTarget(target, value2) {
      try {
        return (0, _utils.semverify)(value2);
      } catch (_) {
        throw new Error(v.formatMessage(`'${value2}' is not a valid value for 'targets.${target}'.`));
      }
    }
    function nodeTargetParser(value2) {
      const parsed = value2 === true || value2 === "current" ? process.versions.node : semverifyTarget("node", value2);
      return ["node", parsed];
    }
    function defaultTargetParser(target, value2) {
      const version4 = (0, _utils.isUnreleasedVersion)(value2, target) ? value2.toLowerCase() : semverifyTarget(target, value2);
      return [target, version4];
    }
    function generateTargets(inputTargets) {
      const input = Object.assign({}, inputTargets);
      delete input.esmodules;
      delete input.browsers;
      return input;
    }
    function resolveTargets(queries, env2) {
      const resolved = _browserslist(queries, {
        mobileToDesktop: true,
        env: env2
      });
      return getLowestVersions(resolved);
    }
    var targetsCache = new _lruCache({
      max: 64
    });
    function resolveTargetsCached(queries, env2) {
      const cacheKey = typeof queries === "string" ? queries : queries.join() + env2;
      let cached = targetsCache.get(cacheKey);
      if (!cached) {
        cached = resolveTargets(queries, env2);
        targetsCache.set(cacheKey, cached);
      }
      return Object.assign({}, cached);
    }
    function getTargets(inputTargets = {}, options2 = {}) {
      var _browsers, _browsers2;
      let {
        browsers,
        esmodules
      } = inputTargets;
      const {
        configPath = ".",
        onBrowserslistConfigFound
      } = options2;
      validateBrowsers(browsers);
      const input = generateTargets(inputTargets);
      let targets = validateTargetNames(input);
      const shouldParseBrowsers = !!browsers;
      const hasTargets = shouldParseBrowsers || Object.keys(targets).length > 0;
      const shouldSearchForConfig = !options2.ignoreBrowserslistConfig && !hasTargets;
      if (!browsers && shouldSearchForConfig) {
        browsers = process.env.BROWSERSLIST;
        if (!browsers) {
          const configFile = options2.configFile || process.env.BROWSERSLIST_CONFIG || _browserslist.findConfigFile(configPath);
          if (configFile != null) {
            onBrowserslistConfigFound == null || onBrowserslistConfigFound(configFile);
            browsers = _browserslist.loadConfig({
              config: configFile,
              env: options2.browserslistEnv
            });
          }
        }
        if (browsers == null) {
          {
            browsers = [];
          }
        }
      }
      if (esmodules && (esmodules !== "intersect" || !((_browsers = browsers) != null && _browsers.length))) {
        browsers = Object.keys(ESM_SUPPORT).map((browser2) => `${browser2} >= ${ESM_SUPPORT[browser2]}`).join(", ");
        esmodules = false;
      }
      if ((_browsers2 = browsers) != null && _browsers2.length) {
        const queryBrowsers = resolveTargetsCached(browsers, options2.browserslistEnv);
        if (esmodules === "intersect") {
          for (const browser2 of Object.keys(queryBrowsers)) {
            if (browser2 !== "deno" && browser2 !== "ie") {
              const esmSupportVersion = ESM_SUPPORT[browser2 === "opera_mobile" ? "op_mob" : browser2];
              if (esmSupportVersion) {
                const version4 = queryBrowsers[browser2];
                queryBrowsers[browser2] = (0, _utils.getHighestUnreleased)(version4, (0, _utils.semverify)(esmSupportVersion), browser2);
              } else {
                delete queryBrowsers[browser2];
              }
            } else {
              delete queryBrowsers[browser2];
            }
          }
        }
        targets = Object.assign(queryBrowsers, targets);
      }
      const result = {};
      const decimalWarnings = [];
      for (const target of Object.keys(targets).sort()) {
        const value2 = targets[target];
        if (typeof value2 === "number" && value2 % 1 !== 0) {
          decimalWarnings.push({
            target,
            value: value2
          });
        }
        const [parsedTarget, parsedValue] = target === "node" ? nodeTargetParser(value2) : defaultTargetParser(target, value2);
        if (parsedValue) {
          result[parsedTarget] = parsedValue;
        }
      }
      outputDecimalWarning(decimalWarnings);
      return result;
    }
  }
});

// node_modules/@babel/core/lib/config/resolve-targets.js
var require_resolve_targets = __commonJS({
  "node_modules/@babel/core/lib/config/resolve-targets.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.resolveBrowserslistConfigFile = resolveBrowserslistConfigFile;
    exports2.resolveTargets = resolveTargets;
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    function _helperCompilationTargets() {
      const data = require_lib14();
      _helperCompilationTargets = function() {
        return data;
      };
      return data;
    }
    function resolveBrowserslistConfigFile(browserslistConfigFile, configFileDir) {
      return _path2().resolve(configFileDir, browserslistConfigFile);
    }
    function resolveTargets(options2, root4) {
      const optTargets = options2.targets;
      let targets;
      if (typeof optTargets === "string" || Array.isArray(optTargets)) {
        targets = {
          browsers: optTargets
        };
      } else if (optTargets) {
        if ("esmodules" in optTargets) {
          targets = Object.assign({}, optTargets, {
            esmodules: "intersect"
          });
        } else {
          targets = optTargets;
        }
      }
      const {
        browserslistConfigFile
      } = options2;
      let configFile;
      let ignoreBrowserslistConfig = false;
      if (typeof browserslistConfigFile === "string") {
        configFile = browserslistConfigFile;
      } else {
        ignoreBrowserslistConfig = browserslistConfigFile === false;
      }
      return (0, _helperCompilationTargets().default)(targets, {
        ignoreBrowserslistConfig,
        configFile,
        configPath: root4,
        browserslistEnv: options2.browserslistEnv
      });
    }
  }
});

// node_modules/@babel/core/lib/config/config-descriptors.js
var require_config_descriptors = __commonJS({
  "node_modules/@babel/core/lib/config/config-descriptors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createCachedDescriptors = createCachedDescriptors;
    exports2.createDescriptor = createDescriptor;
    exports2.createUncachedDescriptors = createUncachedDescriptors;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _functional = require_functional();
    var _index = require_files();
    var _item = require_item();
    var _caching = require_caching();
    var _resolveTargets = require_resolve_targets();
    function isEqualDescriptor(a, b) {
      var _a$file, _b$file, _a$file2, _b$file2;
      return a.name === b.name && a.value === b.value && a.options === b.options && a.dirname === b.dirname && a.alias === b.alias && a.ownPass === b.ownPass && ((_a$file = a.file) == null ? void 0 : _a$file.request) === ((_b$file = b.file) == null ? void 0 : _b$file.request) && ((_a$file2 = a.file) == null ? void 0 : _a$file2.resolved) === ((_b$file2 = b.file) == null ? void 0 : _b$file2.resolved);
    }
    function* handlerOf(value2) {
      return value2;
    }
    function optionsWithResolvedBrowserslistConfigFile(options2, dirname4) {
      if (typeof options2.browserslistConfigFile === "string") {
        options2.browserslistConfigFile = (0, _resolveTargets.resolveBrowserslistConfigFile)(options2.browserslistConfigFile, dirname4);
      }
      return options2;
    }
    function createCachedDescriptors(dirname4, options2, alias) {
      const {
        plugins: plugins2,
        presets,
        passPerPreset
      } = options2;
      return {
        options: optionsWithResolvedBrowserslistConfigFile(options2, dirname4),
        plugins: plugins2 ? () => createCachedPluginDescriptors(plugins2, dirname4)(alias) : () => handlerOf([]),
        presets: presets ? () => createCachedPresetDescriptors(presets, dirname4)(alias)(!!passPerPreset) : () => handlerOf([])
      };
    }
    function createUncachedDescriptors(dirname4, options2, alias) {
      return {
        options: optionsWithResolvedBrowserslistConfigFile(options2, dirname4),
        plugins: (0, _functional.once)(() => createPluginDescriptors(options2.plugins || [], dirname4, alias)),
        presets: (0, _functional.once)(() => createPresetDescriptors(options2.presets || [], dirname4, alias, !!options2.passPerPreset))
      };
    }
    var PRESET_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap();
    var createCachedPresetDescriptors = (0, _caching.makeWeakCacheSync)((items, cache2) => {
      const dirname4 = cache2.using((dir) => dir);
      return (0, _caching.makeStrongCacheSync)((alias) => (0, _caching.makeStrongCache)(function* (passPerPreset) {
        const descriptors = yield* createPresetDescriptors(items, dirname4, alias, passPerPreset);
        return descriptors.map((desc) => loadCachedDescriptor(PRESET_DESCRIPTOR_CACHE, desc));
      }));
    });
    var PLUGIN_DESCRIPTOR_CACHE = /* @__PURE__ */ new WeakMap();
    var createCachedPluginDescriptors = (0, _caching.makeWeakCacheSync)((items, cache2) => {
      const dirname4 = cache2.using((dir) => dir);
      return (0, _caching.makeStrongCache)(function* (alias) {
        const descriptors = yield* createPluginDescriptors(items, dirname4, alias);
        return descriptors.map((desc) => loadCachedDescriptor(PLUGIN_DESCRIPTOR_CACHE, desc));
      });
    });
    var DEFAULT_OPTIONS2 = {};
    function loadCachedDescriptor(cache2, desc) {
      const {
        value: value2,
        options: options2 = DEFAULT_OPTIONS2
      } = desc;
      if (options2 === false) return desc;
      let cacheByOptions = cache2.get(value2);
      if (!cacheByOptions) {
        cacheByOptions = /* @__PURE__ */ new WeakMap();
        cache2.set(value2, cacheByOptions);
      }
      let possibilities = cacheByOptions.get(options2);
      if (!possibilities) {
        possibilities = [];
        cacheByOptions.set(options2, possibilities);
      }
      if (!possibilities.includes(desc)) {
        const matches = possibilities.filter((possibility) => isEqualDescriptor(possibility, desc));
        if (matches.length > 0) {
          return matches[0];
        }
        possibilities.push(desc);
      }
      return desc;
    }
    function* createPresetDescriptors(items, dirname4, alias, passPerPreset) {
      return yield* createDescriptors("preset", items, dirname4, alias, passPerPreset);
    }
    function* createPluginDescriptors(items, dirname4, alias) {
      return yield* createDescriptors("plugin", items, dirname4, alias);
    }
    function* createDescriptors(type, items, dirname4, alias, ownPass) {
      const descriptors = yield* _gensync().all(items.map((item, index4) => createDescriptor(item, dirname4, {
        type,
        alias: `${alias}$${index4}`,
        ownPass: !!ownPass
      })));
      assertNoDuplicates(descriptors);
      return descriptors;
    }
    function* createDescriptor(pair, dirname4, {
      type,
      alias,
      ownPass
    }) {
      const desc = (0, _item.getItemDescriptor)(pair);
      if (desc) {
        return desc;
      }
      let name2;
      let options2;
      let value2 = pair;
      if (Array.isArray(value2)) {
        if (value2.length === 3) {
          [value2, options2, name2] = value2;
        } else {
          [value2, options2] = value2;
        }
      }
      let file = void 0;
      let filepath = null;
      if (typeof value2 === "string") {
        if (typeof type !== "string") {
          throw new Error("To resolve a string-based item, the type of item must be given");
        }
        const resolver = type === "plugin" ? _index.loadPlugin : _index.loadPreset;
        const request = value2;
        ({
          filepath,
          value: value2
        } = yield* resolver(value2, dirname4));
        file = {
          request,
          resolved: filepath
        };
      }
      if (!value2) {
        throw new Error(`Unexpected falsy value: ${String(value2)}`);
      }
      if (typeof value2 === "object" && value2.__esModule) {
        if (value2.default) {
          value2 = value2.default;
        } else {
          throw new Error("Must export a default export when using ES6 modules.");
        }
      }
      if (typeof value2 !== "object" && typeof value2 !== "function") {
        throw new Error(`Unsupported format: ${typeof value2}. Expected an object or a function.`);
      }
      if (filepath !== null && typeof value2 === "object" && value2) {
        throw new Error(`Plugin/Preset files are not allowed to export objects, only functions. In ${filepath}`);
      }
      return {
        name: name2,
        alias: filepath || alias,
        value: value2,
        options: options2,
        dirname: dirname4,
        ownPass,
        file
      };
    }
    function assertNoDuplicates(items) {
      const map = /* @__PURE__ */ new Map();
      for (const item of items) {
        if (typeof item.value !== "function") continue;
        let nameMap = map.get(item.value);
        if (!nameMap) {
          nameMap = /* @__PURE__ */ new Set();
          map.set(item.value, nameMap);
        }
        if (nameMap.has(item.name)) {
          const conflicts = items.filter((i) => i.value === item.value);
          throw new Error([`Duplicate plugin/preset detected.`, `If you'd like to use two separate instances of a plugin,`, `they need separate names, e.g.`, ``, `  plugins: [`, `    ['some-plugin', {}],`, `    ['some-plugin', {}, 'some unique name'],`, `  ]`, ``, `Duplicates detected are:`, `${JSON.stringify(conflicts, null, 2)}`].join("\n"));
        }
        nameMap.add(item.name);
      }
    }
  }
});

// node_modules/@babel/core/lib/config/item.js
var require_item = __commonJS({
  "node_modules/@babel/core/lib/config/item.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createConfigItem = createConfigItem;
    exports2.createItemFromDescriptor = createItemFromDescriptor;
    exports2.getItemDescriptor = getItemDescriptor;
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    var _configDescriptors = require_config_descriptors();
    function createItemFromDescriptor(desc) {
      return new ConfigItem(desc);
    }
    function* createConfigItem(value2, {
      dirname: dirname4 = ".",
      type
    } = {}) {
      const descriptor = yield* (0, _configDescriptors.createDescriptor)(value2, _path2().resolve(dirname4), {
        type,
        alias: "programmatic item"
      });
      return createItemFromDescriptor(descriptor);
    }
    var CONFIG_ITEM_BRAND = Symbol.for("@babel/core@7 - ConfigItem");
    function getItemDescriptor(item) {
      if (item != null && item[CONFIG_ITEM_BRAND]) {
        return item._descriptor;
      }
      return void 0;
    }
    var ConfigItem = class {
      constructor(descriptor) {
        this._descriptor = void 0;
        this[CONFIG_ITEM_BRAND] = true;
        this.value = void 0;
        this.options = void 0;
        this.dirname = void 0;
        this.name = void 0;
        this.file = void 0;
        this._descriptor = descriptor;
        Object.defineProperty(this, "_descriptor", {
          enumerable: false
        });
        Object.defineProperty(this, CONFIG_ITEM_BRAND, {
          enumerable: false
        });
        this.value = this._descriptor.value;
        this.options = this._descriptor.options;
        this.dirname = this._descriptor.dirname;
        this.name = this._descriptor.name;
        this.file = this._descriptor.file ? {
          request: this._descriptor.file.request,
          resolved: this._descriptor.file.resolved
        } : void 0;
        Object.freeze(this);
      }
    };
    Object.freeze(ConfigItem.prototype);
  }
});

// node_modules/@babel/core/lib/config/validation/removed.js
var require_removed = __commonJS({
  "node_modules/@babel/core/lib/config/validation/removed.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = exports2.default = {
      auxiliaryComment: {
        message: "Use `auxiliaryCommentBefore` or `auxiliaryCommentAfter`"
      },
      blacklist: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      breakConfig: {
        message: "This is not a necessary option in Babel 6"
      },
      experimental: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      externalHelpers: {
        message: "Use the `external-helpers` plugin instead. Check out http://babeljs.io/docs/plugins/external-helpers/"
      },
      extra: {
        message: ""
      },
      jsxPragma: {
        message: "use the `pragma` option in the `react-jsx` plugin. Check out http://babeljs.io/docs/plugins/transform-react-jsx/"
      },
      loose: {
        message: "Specify the `loose` option for the relevant plugin you are using or use a preset that sets the option."
      },
      metadataUsedHelpers: {
        message: "Not required anymore as this is enabled by default"
      },
      modules: {
        message: "Use the corresponding module transform plugin in the `plugins` option. Check out http://babeljs.io/docs/plugins/#modules"
      },
      nonStandard: {
        message: "Use the `react-jsx` and `flow-strip-types` plugins to support JSX and Flow. Also check out the react preset http://babeljs.io/docs/plugins/preset-react/"
      },
      optional: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      sourceMapName: {
        message: "The `sourceMapName` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
      },
      stage: {
        message: "Check out the corresponding stage-x presets http://babeljs.io/docs/plugins/#presets"
      },
      whitelist: {
        message: "Put the specific transforms you want in the `plugins` option"
      },
      resolveModuleSource: {
        version: 6,
        message: "Use `babel-plugin-module-resolver@3`'s 'resolvePath' options"
      },
      metadata: {
        version: 6,
        message: "Generated plugin metadata is always included in the output result"
      },
      sourceMapTarget: {
        version: 6,
        message: "The `sourceMapTarget` option has been removed because it makes more sense for the tooling that calls Babel to assign `map.file` themselves."
      }
    };
  }
});

// node_modules/@babel/core/lib/config/validation/option-assertions.js
var require_option_assertions = __commonJS({
  "node_modules/@babel/core/lib/config/validation/option-assertions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.access = access;
    exports2.assertArray = assertArray;
    exports2.assertAssumptions = assertAssumptions;
    exports2.assertBabelrcSearch = assertBabelrcSearch;
    exports2.assertBoolean = assertBoolean;
    exports2.assertCallerMetadata = assertCallerMetadata;
    exports2.assertCompact = assertCompact;
    exports2.assertConfigApplicableTest = assertConfigApplicableTest;
    exports2.assertConfigFileSearch = assertConfigFileSearch;
    exports2.assertFunction = assertFunction;
    exports2.assertIgnoreList = assertIgnoreList;
    exports2.assertInputSourceMap = assertInputSourceMap;
    exports2.assertObject = assertObject;
    exports2.assertPluginList = assertPluginList;
    exports2.assertRootMode = assertRootMode;
    exports2.assertSourceMaps = assertSourceMaps;
    exports2.assertSourceType = assertSourceType;
    exports2.assertString = assertString;
    exports2.assertTargets = assertTargets;
    exports2.msg = msg;
    function _helperCompilationTargets() {
      const data = require_lib14();
      _helperCompilationTargets = function() {
        return data;
      };
      return data;
    }
    var _options = require_options3();
    function msg(loc) {
      switch (loc.type) {
        case "root":
          return ``;
        case "env":
          return `${msg(loc.parent)}.env["${loc.name}"]`;
        case "overrides":
          return `${msg(loc.parent)}.overrides[${loc.index}]`;
        case "option":
          return `${msg(loc.parent)}.${loc.name}`;
        case "access":
          return `${msg(loc.parent)}[${JSON.stringify(loc.name)}]`;
        default:
          throw new Error(`Assertion failure: Unknown type ${loc.type}`);
      }
    }
    function access(loc, name2) {
      return {
        type: "access",
        name: name2,
        parent: loc
      };
    }
    function assertRootMode(loc, value2) {
      if (value2 !== void 0 && value2 !== "root" && value2 !== "upward" && value2 !== "upward-optional") {
        throw new Error(`${msg(loc)} must be a "root", "upward", "upward-optional" or undefined`);
      }
      return value2;
    }
    function assertSourceMaps(loc, value2) {
      if (value2 !== void 0 && typeof value2 !== "boolean" && value2 !== "inline" && value2 !== "both") {
        throw new Error(`${msg(loc)} must be a boolean, "inline", "both", or undefined`);
      }
      return value2;
    }
    function assertCompact(loc, value2) {
      if (value2 !== void 0 && typeof value2 !== "boolean" && value2 !== "auto") {
        throw new Error(`${msg(loc)} must be a boolean, "auto", or undefined`);
      }
      return value2;
    }
    function assertSourceType(loc, value2) {
      if (value2 !== void 0 && value2 !== "module" && value2 !== "script" && value2 !== "unambiguous") {
        throw new Error(`${msg(loc)} must be "module", "script", "unambiguous", or undefined`);
      }
      return value2;
    }
    function assertCallerMetadata(loc, value2) {
      const obj = assertObject(loc, value2);
      if (obj) {
        if (typeof obj.name !== "string") {
          throw new Error(`${msg(loc)} set but does not contain "name" property string`);
        }
        for (const prop of Object.keys(obj)) {
          const propLoc = access(loc, prop);
          const value3 = obj[prop];
          if (value3 != null && typeof value3 !== "boolean" && typeof value3 !== "string" && typeof value3 !== "number") {
            throw new Error(`${msg(propLoc)} must be null, undefined, a boolean, a string, or a number.`);
          }
        }
      }
      return value2;
    }
    function assertInputSourceMap(loc, value2) {
      if (value2 !== void 0 && typeof value2 !== "boolean" && (typeof value2 !== "object" || !value2)) {
        throw new Error(`${msg(loc)} must be a boolean, object, or undefined`);
      }
      return value2;
    }
    function assertString(loc, value2) {
      if (value2 !== void 0 && typeof value2 !== "string") {
        throw new Error(`${msg(loc)} must be a string, or undefined`);
      }
      return value2;
    }
    function assertFunction(loc, value2) {
      if (value2 !== void 0 && typeof value2 !== "function") {
        throw new Error(`${msg(loc)} must be a function, or undefined`);
      }
      return value2;
    }
    function assertBoolean(loc, value2) {
      if (value2 !== void 0 && typeof value2 !== "boolean") {
        throw new Error(`${msg(loc)} must be a boolean, or undefined`);
      }
      return value2;
    }
    function assertObject(loc, value2) {
      if (value2 !== void 0 && (typeof value2 !== "object" || Array.isArray(value2) || !value2)) {
        throw new Error(`${msg(loc)} must be an object, or undefined`);
      }
      return value2;
    }
    function assertArray(loc, value2) {
      if (value2 != null && !Array.isArray(value2)) {
        throw new Error(`${msg(loc)} must be an array, or undefined`);
      }
      return value2;
    }
    function assertIgnoreList(loc, value2) {
      const arr = assertArray(loc, value2);
      arr == null || arr.forEach((item, i) => assertIgnoreItem(access(loc, i), item));
      return arr;
    }
    function assertIgnoreItem(loc, value2) {
      if (typeof value2 !== "string" && typeof value2 !== "function" && !(value2 instanceof RegExp)) {
        throw new Error(`${msg(loc)} must be an array of string/Function/RegExp values, or undefined`);
      }
      return value2;
    }
    function assertConfigApplicableTest(loc, value2) {
      if (value2 === void 0) {
        return value2;
      }
      if (Array.isArray(value2)) {
        value2.forEach((item, i) => {
          if (!checkValidTest(item)) {
            throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
          }
        });
      } else if (!checkValidTest(value2)) {
        throw new Error(`${msg(loc)} must be a string/Function/RegExp, or an array of those`);
      }
      return value2;
    }
    function checkValidTest(value2) {
      return typeof value2 === "string" || typeof value2 === "function" || value2 instanceof RegExp;
    }
    function assertConfigFileSearch(loc, value2) {
      if (value2 !== void 0 && typeof value2 !== "boolean" && typeof value2 !== "string") {
        throw new Error(`${msg(loc)} must be a undefined, a boolean, a string, got ${JSON.stringify(value2)}`);
      }
      return value2;
    }
    function assertBabelrcSearch(loc, value2) {
      if (value2 === void 0 || typeof value2 === "boolean") {
        return value2;
      }
      if (Array.isArray(value2)) {
        value2.forEach((item, i) => {
          if (!checkValidTest(item)) {
            throw new Error(`${msg(access(loc, i))} must be a string/Function/RegExp.`);
          }
        });
      } else if (!checkValidTest(value2)) {
        throw new Error(`${msg(loc)} must be a undefined, a boolean, a string/Function/RegExp or an array of those, got ${JSON.stringify(value2)}`);
      }
      return value2;
    }
    function assertPluginList(loc, value2) {
      const arr = assertArray(loc, value2);
      if (arr) {
        arr.forEach((item, i) => assertPluginItem(access(loc, i), item));
      }
      return arr;
    }
    function assertPluginItem(loc, value2) {
      if (Array.isArray(value2)) {
        if (value2.length === 0) {
          throw new Error(`${msg(loc)} must include an object`);
        }
        if (value2.length > 3) {
          throw new Error(`${msg(loc)} may only be a two-tuple or three-tuple`);
        }
        assertPluginTarget(access(loc, 0), value2[0]);
        if (value2.length > 1) {
          const opts = value2[1];
          if (opts !== void 0 && opts !== false && (typeof opts !== "object" || Array.isArray(opts) || opts === null)) {
            throw new Error(`${msg(access(loc, 1))} must be an object, false, or undefined`);
          }
        }
        if (value2.length === 3) {
          const name2 = value2[2];
          if (name2 !== void 0 && typeof name2 !== "string") {
            throw new Error(`${msg(access(loc, 2))} must be a string, or undefined`);
          }
        }
      } else {
        assertPluginTarget(loc, value2);
      }
      return value2;
    }
    function assertPluginTarget(loc, value2) {
      if ((typeof value2 !== "object" || !value2) && typeof value2 !== "string" && typeof value2 !== "function") {
        throw new Error(`${msg(loc)} must be a string, object, function`);
      }
      return value2;
    }
    function assertTargets(loc, value2) {
      if ((0, _helperCompilationTargets().isBrowsersQueryValid)(value2)) return value2;
      if (typeof value2 !== "object" || !value2 || Array.isArray(value2)) {
        throw new Error(`${msg(loc)} must be a string, an array of strings or an object`);
      }
      const browsersLoc = access(loc, "browsers");
      const esmodulesLoc = access(loc, "esmodules");
      assertBrowsersList(browsersLoc, value2.browsers);
      assertBoolean(esmodulesLoc, value2.esmodules);
      for (const key of Object.keys(value2)) {
        const val = value2[key];
        const subLoc = access(loc, key);
        if (key === "esmodules") assertBoolean(subLoc, val);
        else if (key === "browsers") assertBrowsersList(subLoc, val);
        else if (!hasOwnProperty.call(_helperCompilationTargets().TargetNames, key)) {
          const validTargets = Object.keys(_helperCompilationTargets().TargetNames).join(", ");
          throw new Error(`${msg(subLoc)} is not a valid target. Supported targets are ${validTargets}`);
        } else assertBrowserVersion(subLoc, val);
      }
      return value2;
    }
    function assertBrowsersList(loc, value2) {
      if (value2 !== void 0 && !(0, _helperCompilationTargets().isBrowsersQueryValid)(value2)) {
        throw new Error(`${msg(loc)} must be undefined, a string or an array of strings`);
      }
    }
    function assertBrowserVersion(loc, value2) {
      if (typeof value2 === "number" && Math.round(value2) === value2) return;
      if (typeof value2 === "string") return;
      throw new Error(`${msg(loc)} must be a string or an integer number`);
    }
    function assertAssumptions(loc, value2) {
      if (value2 === void 0) return;
      if (typeof value2 !== "object" || value2 === null) {
        throw new Error(`${msg(loc)} must be an object or undefined.`);
      }
      let root4 = loc;
      do {
        root4 = root4.parent;
      } while (root4.type !== "root");
      const inPreset = root4.source === "preset";
      for (const name2 of Object.keys(value2)) {
        const subLoc = access(loc, name2);
        if (!_options.assumptionsNames.has(name2)) {
          throw new Error(`${msg(subLoc)} is not a supported assumption.`);
        }
        if (typeof value2[name2] !== "boolean") {
          throw new Error(`${msg(subLoc)} must be a boolean.`);
        }
        if (inPreset && value2[name2] === false) {
          throw new Error(`${msg(subLoc)} cannot be set to 'false' inside presets.`);
        }
      }
      return value2;
    }
  }
});

// node_modules/@babel/core/lib/config/validation/options.js
var require_options3 = __commonJS({
  "node_modules/@babel/core/lib/config/validation/options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.assumptionsNames = void 0;
    exports2.checkNoUnwrappedItemOptionPairs = checkNoUnwrappedItemOptionPairs;
    exports2.validate = validate;
    var _removed = require_removed();
    var _optionAssertions = require_option_assertions();
    var _configError = require_config_error();
    var ROOT_VALIDATORS = {
      cwd: _optionAssertions.assertString,
      root: _optionAssertions.assertString,
      rootMode: _optionAssertions.assertRootMode,
      configFile: _optionAssertions.assertConfigFileSearch,
      caller: _optionAssertions.assertCallerMetadata,
      filename: _optionAssertions.assertString,
      filenameRelative: _optionAssertions.assertString,
      code: _optionAssertions.assertBoolean,
      ast: _optionAssertions.assertBoolean,
      cloneInputAst: _optionAssertions.assertBoolean,
      envName: _optionAssertions.assertString
    };
    var BABELRC_VALIDATORS = {
      babelrc: _optionAssertions.assertBoolean,
      babelrcRoots: _optionAssertions.assertBabelrcSearch
    };
    var NONPRESET_VALIDATORS = {
      extends: _optionAssertions.assertString,
      ignore: _optionAssertions.assertIgnoreList,
      only: _optionAssertions.assertIgnoreList,
      targets: _optionAssertions.assertTargets,
      browserslistConfigFile: _optionAssertions.assertConfigFileSearch,
      browserslistEnv: _optionAssertions.assertString
    };
    var COMMON_VALIDATORS = {
      inputSourceMap: _optionAssertions.assertInputSourceMap,
      presets: _optionAssertions.assertPluginList,
      plugins: _optionAssertions.assertPluginList,
      passPerPreset: _optionAssertions.assertBoolean,
      assumptions: _optionAssertions.assertAssumptions,
      env: assertEnvSet,
      overrides: assertOverridesList,
      test: _optionAssertions.assertConfigApplicableTest,
      include: _optionAssertions.assertConfigApplicableTest,
      exclude: _optionAssertions.assertConfigApplicableTest,
      retainLines: _optionAssertions.assertBoolean,
      comments: _optionAssertions.assertBoolean,
      shouldPrintComment: _optionAssertions.assertFunction,
      compact: _optionAssertions.assertCompact,
      minified: _optionAssertions.assertBoolean,
      auxiliaryCommentBefore: _optionAssertions.assertString,
      auxiliaryCommentAfter: _optionAssertions.assertString,
      sourceType: _optionAssertions.assertSourceType,
      wrapPluginVisitorMethod: _optionAssertions.assertFunction,
      highlightCode: _optionAssertions.assertBoolean,
      sourceMaps: _optionAssertions.assertSourceMaps,
      sourceMap: _optionAssertions.assertSourceMaps,
      sourceFileName: _optionAssertions.assertString,
      sourceRoot: _optionAssertions.assertString,
      parserOpts: _optionAssertions.assertObject,
      generatorOpts: _optionAssertions.assertObject
    };
    {
      Object.assign(COMMON_VALIDATORS, {
        getModuleId: _optionAssertions.assertFunction,
        moduleRoot: _optionAssertions.assertString,
        moduleIds: _optionAssertions.assertBoolean,
        moduleId: _optionAssertions.assertString
      });
    }
    var knownAssumptions = ["arrayLikeIsIterable", "constantReexports", "constantSuper", "enumerableModuleMeta", "ignoreFunctionLength", "ignoreToPrimitiveHint", "iterableIsArray", "mutableTemplateObject", "noClassCalls", "noDocumentAll", "noIncompleteNsImportDetection", "noNewArrows", "noUninitializedPrivateFieldAccess", "objectRestNoSymbols", "privateFieldsAsSymbols", "privateFieldsAsProperties", "pureGetters", "setClassMethods", "setComputedProperties", "setPublicClassFields", "setSpreadProperties", "skipForOfIteratorClosing", "superIsCallableConstructor"];
    var assumptionsNames = exports2.assumptionsNames = new Set(knownAssumptions);
    function getSource(loc) {
      return loc.type === "root" ? loc.source : getSource(loc.parent);
    }
    function validate(type, opts, filename) {
      try {
        return validateNested({
          type: "root",
          source: type
        }, opts);
      } catch (error) {
        const configError = new _configError.default(error.message, filename);
        if (error.code) configError.code = error.code;
        throw configError;
      }
    }
    function validateNested(loc, opts) {
      const type = getSource(loc);
      assertNoDuplicateSourcemap(opts);
      Object.keys(opts).forEach((key) => {
        const optLoc = {
          type: "option",
          name: key,
          parent: loc
        };
        if (type === "preset" && NONPRESET_VALIDATORS[key]) {
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in preset options`);
        }
        if (type !== "arguments" && ROOT_VALIDATORS[key]) {
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options`);
        }
        if (type !== "arguments" && type !== "configfile" && BABELRC_VALIDATORS[key]) {
          if (type === "babelrcfile" || type === "extendsfile") {
            throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is not allowed in .babelrc or "extends"ed files, only in root programmatic options, or babel.config.js/config file options`);
          }
          throw new Error(`${(0, _optionAssertions.msg)(optLoc)} is only allowed in root programmatic options, or babel.config.js/config file options`);
        }
        const validator = COMMON_VALIDATORS[key] || NONPRESET_VALIDATORS[key] || BABELRC_VALIDATORS[key] || ROOT_VALIDATORS[key] || throwUnknownError;
        validator(optLoc, opts[key]);
      });
      return opts;
    }
    function throwUnknownError(loc) {
      const key = loc.name;
      if (_removed.default[key]) {
        const {
          message,
          version: version4 = 5
        } = _removed.default[key];
        throw new Error(`Using removed Babel ${version4} option: ${(0, _optionAssertions.msg)(loc)} - ${message}`);
      } else {
        const unknownOptErr = new Error(`Unknown option: ${(0, _optionAssertions.msg)(loc)}. Check out https://babeljs.io/docs/en/babel-core/#options for more information about options.`);
        unknownOptErr.code = "BABEL_UNKNOWN_OPTION";
        throw unknownOptErr;
      }
    }
    function assertNoDuplicateSourcemap(opts) {
      if (hasOwnProperty.call(opts, "sourceMap") && hasOwnProperty.call(opts, "sourceMaps")) {
        throw new Error(".sourceMap is an alias for .sourceMaps, cannot use both");
      }
    }
    function assertEnvSet(loc, value2) {
      if (loc.parent.type === "env") {
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside of another .env block`);
      }
      const parent = loc.parent;
      const obj = (0, _optionAssertions.assertObject)(loc, value2);
      if (obj) {
        for (const envName of Object.keys(obj)) {
          const env2 = (0, _optionAssertions.assertObject)((0, _optionAssertions.access)(loc, envName), obj[envName]);
          if (!env2) continue;
          const envLoc = {
            type: "env",
            name: envName,
            parent
          };
          validateNested(envLoc, env2);
        }
      }
      return obj;
    }
    function assertOverridesList(loc, value2) {
      if (loc.parent.type === "env") {
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .env block`);
      }
      if (loc.parent.type === "overrides") {
        throw new Error(`${(0, _optionAssertions.msg)(loc)} is not allowed inside an .overrides block`);
      }
      const parent = loc.parent;
      const arr = (0, _optionAssertions.assertArray)(loc, value2);
      if (arr) {
        for (const [index4, item] of arr.entries()) {
          const objLoc = (0, _optionAssertions.access)(loc, index4);
          const env2 = (0, _optionAssertions.assertObject)(objLoc, item);
          if (!env2) throw new Error(`${(0, _optionAssertions.msg)(objLoc)} must be an object`);
          const overridesLoc = {
            type: "overrides",
            index: index4,
            parent
          };
          validateNested(overridesLoc, env2);
        }
      }
      return arr;
    }
    function checkNoUnwrappedItemOptionPairs(items, index4, type, e) {
      if (index4 === 0) return;
      const lastItem = items[index4 - 1];
      const thisItem = items[index4];
      if (lastItem.file && lastItem.options === void 0 && typeof thisItem.value === "object") {
        e.message += `
- Maybe you meant to use
"${type}s": [
  ["${lastItem.file.request}", ${JSON.stringify(thisItem.value, void 0, 2)}]
]
To be a valid ${type}, its name and options should be wrapped in a pair of brackets`;
      }
    }
  }
});

// node_modules/@babel/core/lib/config/pattern-to-regex.js
var require_pattern_to_regex = __commonJS({
  "node_modules/@babel/core/lib/config/pattern-to-regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = pathToPattern;
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    var sep2 = `\\${_path2().sep}`;
    var endSep = `(?:${sep2}|$)`;
    var substitution = `[^${sep2}]+`;
    var starPat = `(?:${substitution}${sep2})`;
    var starPatLast = `(?:${substitution}${endSep})`;
    var starStarPat = `${starPat}*?`;
    var starStarPatLast = `${starPat}*?${starPatLast}?`;
    function escapeRegExp(string4) {
      return string4.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&");
    }
    function pathToPattern(pattern2, dirname4) {
      const parts = _path2().resolve(dirname4, pattern2).split(_path2().sep);
      return new RegExp(["^", ...parts.map((part, i) => {
        const last = i === parts.length - 1;
        if (part === "**") return last ? starStarPatLast : starStarPat;
        if (part === "*") return last ? starPatLast : starPat;
        if (part.indexOf("*.") === 0) {
          return substitution + escapeRegExp(part.slice(1)) + (last ? endSep : sep2);
        }
        return escapeRegExp(part) + (last ? endSep : sep2);
      })].join(""));
    }
  }
});

// node_modules/@babel/core/lib/config/printer.js
var require_printer2 = __commonJS({
  "node_modules/@babel/core/lib/config/printer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConfigPrinter = exports2.ChainFormatter = void 0;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var ChainFormatter = exports2.ChainFormatter = {
      Programmatic: 0,
      Config: 1
    };
    var Formatter = {
      title(type, callerName, filepath) {
        let title = "";
        if (type === ChainFormatter.Programmatic) {
          title = "programmatic options";
          if (callerName) {
            title += " from " + callerName;
          }
        } else {
          title = "config " + filepath;
        }
        return title;
      },
      loc(index4, envName) {
        let loc = "";
        if (index4 != null) {
          loc += `.overrides[${index4}]`;
        }
        if (envName != null) {
          loc += `.env["${envName}"]`;
        }
        return loc;
      },
      *optionsAndDescriptors(opt) {
        const content = Object.assign({}, opt.options);
        delete content.overrides;
        delete content.env;
        const pluginDescriptors = [...yield* opt.plugins()];
        if (pluginDescriptors.length) {
          content.plugins = pluginDescriptors.map((d) => descriptorToConfig(d));
        }
        const presetDescriptors = [...yield* opt.presets()];
        if (presetDescriptors.length) {
          content.presets = [...presetDescriptors].map((d) => descriptorToConfig(d));
        }
        return JSON.stringify(content, void 0, 2);
      }
    };
    function descriptorToConfig(d) {
      var _d$file;
      let name2 = (_d$file = d.file) == null ? void 0 : _d$file.request;
      if (name2 == null) {
        if (typeof d.value === "object") {
          name2 = d.value;
        } else if (typeof d.value === "function") {
          name2 = `[Function: ${d.value.toString().slice(0, 50)} ... ]`;
        }
      }
      if (name2 == null) {
        name2 = "[Unknown]";
      }
      if (d.options === void 0) {
        return name2;
      } else if (d.name == null) {
        return [name2, d.options];
      } else {
        return [name2, d.options, d.name];
      }
    }
    var ConfigPrinter = class _ConfigPrinter {
      constructor() {
        this._stack = [];
      }
      configure(enabled, type, {
        callerName,
        filepath
      }) {
        if (!enabled) return () => {
        };
        return (content, index4, envName) => {
          this._stack.push({
            type,
            callerName,
            filepath,
            content,
            index: index4,
            envName
          });
        };
      }
      static *format(config2) {
        let title = Formatter.title(config2.type, config2.callerName, config2.filepath);
        const loc = Formatter.loc(config2.index, config2.envName);
        if (loc) title += ` ${loc}`;
        const content = yield* Formatter.optionsAndDescriptors(config2.content);
        return `${title}
${content}`;
      }
      *output() {
        if (this._stack.length === 0) return "";
        const configs = yield* _gensync().all(this._stack.map((s) => _ConfigPrinter.format(s)));
        return configs.join("\n\n");
      }
    };
    exports2.ConfigPrinter = ConfigPrinter;
  }
});

// node_modules/@babel/core/lib/config/config-chain.js
var require_config_chain = __commonJS({
  "node_modules/@babel/core/lib/config/config-chain.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.buildPresetChain = buildPresetChain;
    exports2.buildPresetChainWalker = void 0;
    exports2.buildRootChain = buildRootChain;
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    function _debug2() {
      const data = require_src();
      _debug2 = function() {
        return data;
      };
      return data;
    }
    var _options = require_options3();
    var _patternToRegex = require_pattern_to_regex();
    var _printer = require_printer2();
    var _rewriteStackTrace = require_rewrite_stack_trace();
    var _configError = require_config_error();
    var _index = require_files();
    var _caching = require_caching();
    var _configDescriptors = require_config_descriptors();
    var debug2 = _debug2()("babel:config:config-chain");
    function* buildPresetChain(arg, context) {
      const chain = yield* buildPresetChainWalker(arg, context);
      if (!chain) return null;
      return {
        plugins: dedupDescriptors(chain.plugins),
        presets: dedupDescriptors(chain.presets),
        options: chain.options.map((o) => normalizeOptions(o)),
        files: /* @__PURE__ */ new Set()
      };
    }
    var buildPresetChainWalker = exports2.buildPresetChainWalker = makeChainWalker({
      root: (preset) => loadPresetDescriptors(preset),
      env: (preset, envName) => loadPresetEnvDescriptors(preset)(envName),
      overrides: (preset, index4) => loadPresetOverridesDescriptors(preset)(index4),
      overridesEnv: (preset, index4, envName) => loadPresetOverridesEnvDescriptors(preset)(index4)(envName),
      createLogger: () => () => {
      }
    });
    var loadPresetDescriptors = (0, _caching.makeWeakCacheSync)((preset) => buildRootDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors));
    var loadPresetEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, envName)));
    var loadPresetOverridesDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index4) => buildOverrideDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index4)));
    var loadPresetOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((preset) => (0, _caching.makeStrongCacheSync)((index4) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(preset, preset.alias, _configDescriptors.createUncachedDescriptors, index4, envName))));
    function* buildRootChain(opts, context) {
      let configReport, babelRcReport;
      const programmaticLogger = new _printer.ConfigPrinter();
      const programmaticChain = yield* loadProgrammaticChain({
        options: opts,
        dirname: context.cwd
      }, context, void 0, programmaticLogger);
      if (!programmaticChain) return null;
      const programmaticReport = yield* programmaticLogger.output();
      let configFile;
      if (typeof opts.configFile === "string") {
        configFile = yield* (0, _index.loadConfig)(opts.configFile, context.cwd, context.envName, context.caller);
      } else if (opts.configFile !== false) {
        configFile = yield* (0, _index.findRootConfig)(context.root, context.envName, context.caller);
      }
      let {
        babelrc,
        babelrcRoots
      } = opts;
      let babelrcRootsDirectory = context.cwd;
      const configFileChain = emptyChain();
      const configFileLogger = new _printer.ConfigPrinter();
      if (configFile) {
        const validatedFile = validateConfigFile(configFile);
        const result = yield* loadFileChain(validatedFile, context, void 0, configFileLogger);
        if (!result) return null;
        configReport = yield* configFileLogger.output();
        if (babelrc === void 0) {
          babelrc = validatedFile.options.babelrc;
        }
        if (babelrcRoots === void 0) {
          babelrcRootsDirectory = validatedFile.dirname;
          babelrcRoots = validatedFile.options.babelrcRoots;
        }
        mergeChain(configFileChain, result);
      }
      let ignoreFile, babelrcFile;
      let isIgnored = false;
      const fileChain = emptyChain();
      if ((babelrc === true || babelrc === void 0) && typeof context.filename === "string") {
        const pkgData = yield* (0, _index.findPackageData)(context.filename);
        if (pkgData && babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory)) {
          ({
            ignore: ignoreFile,
            config: babelrcFile
          } = yield* (0, _index.findRelativeConfig)(pkgData, context.envName, context.caller));
          if (ignoreFile) {
            fileChain.files.add(ignoreFile.filepath);
          }
          if (ignoreFile && shouldIgnore(context, ignoreFile.ignore, null, ignoreFile.dirname)) {
            isIgnored = true;
          }
          if (babelrcFile && !isIgnored) {
            const validatedFile = validateBabelrcFile(babelrcFile);
            const babelrcLogger = new _printer.ConfigPrinter();
            const result = yield* loadFileChain(validatedFile, context, void 0, babelrcLogger);
            if (!result) {
              isIgnored = true;
            } else {
              babelRcReport = yield* babelrcLogger.output();
              mergeChain(fileChain, result);
            }
          }
          if (babelrcFile && isIgnored) {
            fileChain.files.add(babelrcFile.filepath);
          }
        }
      }
      if (context.showConfig) {
        console.log(`Babel configs on "${context.filename}" (ascending priority):
` + [configReport, babelRcReport, programmaticReport].filter((x) => !!x).join("\n\n") + "\n-----End Babel configs-----");
      }
      const chain = mergeChain(mergeChain(mergeChain(emptyChain(), configFileChain), fileChain), programmaticChain);
      return {
        plugins: isIgnored ? [] : dedupDescriptors(chain.plugins),
        presets: isIgnored ? [] : dedupDescriptors(chain.presets),
        options: isIgnored ? [] : chain.options.map((o) => normalizeOptions(o)),
        fileHandling: isIgnored ? "ignored" : "transpile",
        ignore: ignoreFile || void 0,
        babelrc: babelrcFile || void 0,
        config: configFile || void 0,
        files: chain.files
      };
    }
    function babelrcLoadEnabled(context, pkgData, babelrcRoots, babelrcRootsDirectory) {
      if (typeof babelrcRoots === "boolean") return babelrcRoots;
      const absoluteRoot = context.root;
      if (babelrcRoots === void 0) {
        return pkgData.directories.includes(absoluteRoot);
      }
      let babelrcPatterns = babelrcRoots;
      if (!Array.isArray(babelrcPatterns)) {
        babelrcPatterns = [babelrcPatterns];
      }
      babelrcPatterns = babelrcPatterns.map((pat) => {
        return typeof pat === "string" ? _path2().resolve(babelrcRootsDirectory, pat) : pat;
      });
      if (babelrcPatterns.length === 1 && babelrcPatterns[0] === absoluteRoot) {
        return pkgData.directories.includes(absoluteRoot);
      }
      return babelrcPatterns.some((pat) => {
        if (typeof pat === "string") {
          pat = (0, _patternToRegex.default)(pat, babelrcRootsDirectory);
        }
        return pkgData.directories.some((directory) => {
          return matchPattern(pat, babelrcRootsDirectory, directory, context);
        });
      });
    }
    var validateConfigFile = (0, _caching.makeWeakCacheSync)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("configfile", file.options, file.filepath)
    }));
    var validateBabelrcFile = (0, _caching.makeWeakCacheSync)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("babelrcfile", file.options, file.filepath)
    }));
    var validateExtendFile = (0, _caching.makeWeakCacheSync)((file) => ({
      filepath: file.filepath,
      dirname: file.dirname,
      options: (0, _options.validate)("extendsfile", file.options, file.filepath)
    }));
    var loadProgrammaticChain = makeChainWalker({
      root: (input) => buildRootDescriptors(input, "base", _configDescriptors.createCachedDescriptors),
      env: (input, envName) => buildEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, envName),
      overrides: (input, index4) => buildOverrideDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index4),
      overridesEnv: (input, index4, envName) => buildOverrideEnvDescriptors(input, "base", _configDescriptors.createCachedDescriptors, index4, envName),
      createLogger: (input, context, baseLogger) => buildProgrammaticLogger(input, context, baseLogger)
    });
    var loadFileChainWalker = makeChainWalker({
      root: (file) => loadFileDescriptors(file),
      env: (file, envName) => loadFileEnvDescriptors(file)(envName),
      overrides: (file, index4) => loadFileOverridesDescriptors(file)(index4),
      overridesEnv: (file, index4, envName) => loadFileOverridesEnvDescriptors(file)(index4)(envName),
      createLogger: (file, context, baseLogger) => buildFileLogger(file.filepath, context, baseLogger)
    });
    function* loadFileChain(input, context, files, baseLogger) {
      const chain = yield* loadFileChainWalker(input, context, files, baseLogger);
      chain == null || chain.files.add(input.filepath);
      return chain;
    }
    var loadFileDescriptors = (0, _caching.makeWeakCacheSync)((file) => buildRootDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors));
    var loadFileEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((envName) => buildEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, envName)));
    var loadFileOverridesDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index4) => buildOverrideDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index4)));
    var loadFileOverridesEnvDescriptors = (0, _caching.makeWeakCacheSync)((file) => (0, _caching.makeStrongCacheSync)((index4) => (0, _caching.makeStrongCacheSync)((envName) => buildOverrideEnvDescriptors(file, file.filepath, _configDescriptors.createUncachedDescriptors, index4, envName))));
    function buildFileLogger(filepath, context, baseLogger) {
      if (!baseLogger) {
        return () => {
        };
      }
      return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Config, {
        filepath
      });
    }
    function buildRootDescriptors({
      dirname: dirname4,
      options: options2
    }, alias, descriptors) {
      return descriptors(dirname4, options2, alias);
    }
    function buildProgrammaticLogger(_, context, baseLogger) {
      var _context$caller;
      if (!baseLogger) {
        return () => {
        };
      }
      return baseLogger.configure(context.showConfig, _printer.ChainFormatter.Programmatic, {
        callerName: (_context$caller = context.caller) == null ? void 0 : _context$caller.name
      });
    }
    function buildEnvDescriptors({
      dirname: dirname4,
      options: options2
    }, alias, descriptors, envName) {
      var _options$env;
      const opts = (_options$env = options2.env) == null ? void 0 : _options$env[envName];
      return opts ? descriptors(dirname4, opts, `${alias}.env["${envName}"]`) : null;
    }
    function buildOverrideDescriptors({
      dirname: dirname4,
      options: options2
    }, alias, descriptors, index4) {
      var _options$overrides;
      const opts = (_options$overrides = options2.overrides) == null ? void 0 : _options$overrides[index4];
      if (!opts) throw new Error("Assertion failure - missing override");
      return descriptors(dirname4, opts, `${alias}.overrides[${index4}]`);
    }
    function buildOverrideEnvDescriptors({
      dirname: dirname4,
      options: options2
    }, alias, descriptors, index4, envName) {
      var _options$overrides2, _override$env;
      const override = (_options$overrides2 = options2.overrides) == null ? void 0 : _options$overrides2[index4];
      if (!override) throw new Error("Assertion failure - missing override");
      const opts = (_override$env = override.env) == null ? void 0 : _override$env[envName];
      return opts ? descriptors(dirname4, opts, `${alias}.overrides[${index4}].env["${envName}"]`) : null;
    }
    function makeChainWalker({
      root: root4,
      env: env2,
      overrides,
      overridesEnv,
      createLogger: createLogger2
    }) {
      return function* chainWalker(input, context, files = /* @__PURE__ */ new Set(), baseLogger) {
        const {
          dirname: dirname4
        } = input;
        const flattenedConfigs = [];
        const rootOpts = root4(input);
        if (configIsApplicable(rootOpts, dirname4, context, input.filepath)) {
          flattenedConfigs.push({
            config: rootOpts,
            envName: void 0,
            index: void 0
          });
          const envOpts = env2(input, context.envName);
          if (envOpts && configIsApplicable(envOpts, dirname4, context, input.filepath)) {
            flattenedConfigs.push({
              config: envOpts,
              envName: context.envName,
              index: void 0
            });
          }
          (rootOpts.options.overrides || []).forEach((_, index4) => {
            const overrideOps = overrides(input, index4);
            if (configIsApplicable(overrideOps, dirname4, context, input.filepath)) {
              flattenedConfigs.push({
                config: overrideOps,
                index: index4,
                envName: void 0
              });
              const overrideEnvOpts = overridesEnv(input, index4, context.envName);
              if (overrideEnvOpts && configIsApplicable(overrideEnvOpts, dirname4, context, input.filepath)) {
                flattenedConfigs.push({
                  config: overrideEnvOpts,
                  index: index4,
                  envName: context.envName
                });
              }
            }
          });
        }
        if (flattenedConfigs.some(({
          config: {
            options: {
              ignore,
              only
            }
          }
        }) => shouldIgnore(context, ignore, only, dirname4))) {
          return null;
        }
        const chain = emptyChain();
        const logger = createLogger2(input, context, baseLogger);
        for (const {
          config: config2,
          index: index4,
          envName
        } of flattenedConfigs) {
          if (!(yield* mergeExtendsChain(chain, config2.options, dirname4, context, files, baseLogger))) {
            return null;
          }
          logger(config2, index4, envName);
          yield* mergeChainOpts(chain, config2);
        }
        return chain;
      };
    }
    function* mergeExtendsChain(chain, opts, dirname4, context, files, baseLogger) {
      if (opts.extends === void 0) return true;
      const file = yield* (0, _index.loadConfig)(opts.extends, dirname4, context.envName, context.caller);
      if (files.has(file)) {
        throw new Error(`Configuration cycle detected loading ${file.filepath}.
File already loaded following the config chain:
` + Array.from(files, (file2) => ` - ${file2.filepath}`).join("\n"));
      }
      files.add(file);
      const fileChain = yield* loadFileChain(validateExtendFile(file), context, files, baseLogger);
      files.delete(file);
      if (!fileChain) return false;
      mergeChain(chain, fileChain);
      return true;
    }
    function mergeChain(target, source) {
      target.options.push(...source.options);
      target.plugins.push(...source.plugins);
      target.presets.push(...source.presets);
      for (const file of source.files) {
        target.files.add(file);
      }
      return target;
    }
    function* mergeChainOpts(target, {
      options: options2,
      plugins: plugins2,
      presets
    }) {
      target.options.push(options2);
      target.plugins.push(...yield* plugins2());
      target.presets.push(...yield* presets());
      return target;
    }
    function emptyChain() {
      return {
        options: [],
        presets: [],
        plugins: [],
        files: /* @__PURE__ */ new Set()
      };
    }
    function normalizeOptions(opts) {
      const options2 = Object.assign({}, opts);
      delete options2.extends;
      delete options2.env;
      delete options2.overrides;
      delete options2.plugins;
      delete options2.presets;
      delete options2.passPerPreset;
      delete options2.ignore;
      delete options2.only;
      delete options2.test;
      delete options2.include;
      delete options2.exclude;
      if (hasOwnProperty.call(options2, "sourceMap")) {
        options2.sourceMaps = options2.sourceMap;
        delete options2.sourceMap;
      }
      return options2;
    }
    function dedupDescriptors(items) {
      const map = /* @__PURE__ */ new Map();
      const descriptors = [];
      for (const item of items) {
        if (typeof item.value === "function") {
          const fnKey = item.value;
          let nameMap = map.get(fnKey);
          if (!nameMap) {
            nameMap = /* @__PURE__ */ new Map();
            map.set(fnKey, nameMap);
          }
          let desc = nameMap.get(item.name);
          if (!desc) {
            desc = {
              value: item
            };
            descriptors.push(desc);
            if (!item.ownPass) nameMap.set(item.name, desc);
          } else {
            desc.value = item;
          }
        } else {
          descriptors.push({
            value: item
          });
        }
      }
      return descriptors.reduce((acc, desc) => {
        acc.push(desc.value);
        return acc;
      }, []);
    }
    function configIsApplicable({
      options: options2
    }, dirname4, context, configName) {
      return (options2.test === void 0 || configFieldIsApplicable(context, options2.test, dirname4, configName)) && (options2.include === void 0 || configFieldIsApplicable(context, options2.include, dirname4, configName)) && (options2.exclude === void 0 || !configFieldIsApplicable(context, options2.exclude, dirname4, configName));
    }
    function configFieldIsApplicable(context, test, dirname4, configName) {
      const patterns = Array.isArray(test) ? test : [test];
      return matchesPatterns(context, patterns, dirname4, configName);
    }
    function ignoreListReplacer(_key, value2) {
      if (value2 instanceof RegExp) {
        return String(value2);
      }
      return value2;
    }
    function shouldIgnore(context, ignore, only, dirname4) {
      if (ignore && matchesPatterns(context, ignore, dirname4)) {
        var _context$filename;
        const message = `No config is applied to "${(_context$filename = context.filename) != null ? _context$filename : "(unknown)"}" because it matches one of \`ignore: ${JSON.stringify(ignore, ignoreListReplacer)}\` from "${dirname4}"`;
        debug2(message);
        if (context.showConfig) {
          console.log(message);
        }
        return true;
      }
      if (only && !matchesPatterns(context, only, dirname4)) {
        var _context$filename2;
        const message = `No config is applied to "${(_context$filename2 = context.filename) != null ? _context$filename2 : "(unknown)"}" because it fails to match one of \`only: ${JSON.stringify(only, ignoreListReplacer)}\` from "${dirname4}"`;
        debug2(message);
        if (context.showConfig) {
          console.log(message);
        }
        return true;
      }
      return false;
    }
    function matchesPatterns(context, patterns, dirname4, configName) {
      return patterns.some((pattern2) => matchPattern(pattern2, dirname4, context.filename, context, configName));
    }
    function matchPattern(pattern2, dirname4, pathToTest, context, configName) {
      if (typeof pattern2 === "function") {
        return !!(0, _rewriteStackTrace.endHiddenCallStack)(pattern2)(pathToTest, {
          dirname: dirname4,
          envName: context.envName,
          caller: context.caller
        });
      }
      if (typeof pathToTest !== "string") {
        throw new _configError.default(`Configuration contains string/RegExp pattern, but no filename was passed to Babel`, configName);
      }
      if (typeof pattern2 === "string") {
        pattern2 = (0, _patternToRegex.default)(pattern2, dirname4);
      }
      return pattern2.test(pathToTest);
    }
  }
});

// node_modules/@babel/core/lib/config/validation/plugins.js
var require_plugins3 = __commonJS({
  "node_modules/@babel/core/lib/config/validation/plugins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validatePluginObject = validatePluginObject;
    var _optionAssertions = require_option_assertions();
    var VALIDATORS = {
      name: _optionAssertions.assertString,
      manipulateOptions: _optionAssertions.assertFunction,
      pre: _optionAssertions.assertFunction,
      post: _optionAssertions.assertFunction,
      inherits: _optionAssertions.assertFunction,
      visitor: assertVisitorMap,
      parserOverride: _optionAssertions.assertFunction,
      generatorOverride: _optionAssertions.assertFunction
    };
    function assertVisitorMap(loc, value2) {
      const obj = (0, _optionAssertions.assertObject)(loc, value2);
      if (obj) {
        Object.keys(obj).forEach((prop) => {
          if (prop !== "_exploded" && prop !== "_verified") {
            assertVisitorHandler(prop, obj[prop]);
          }
        });
        if (obj.enter || obj.exit) {
          throw new Error(`${(0, _optionAssertions.msg)(loc)} cannot contain catch-all "enter" or "exit" handlers. Please target individual nodes.`);
        }
      }
      return obj;
    }
    function assertVisitorHandler(key, value2) {
      if (value2 && typeof value2 === "object") {
        Object.keys(value2).forEach((handler) => {
          if (handler !== "enter" && handler !== "exit") {
            throw new Error(`.visitor["${key}"] may only have .enter and/or .exit handlers.`);
          }
        });
      } else if (typeof value2 !== "function") {
        throw new Error(`.visitor["${key}"] must be a function`);
      }
    }
    function validatePluginObject(obj) {
      const rootPath = {
        type: "root",
        source: "plugin"
      };
      Object.keys(obj).forEach((key) => {
        const validator = VALIDATORS[key];
        if (validator) {
          const optLoc = {
            type: "option",
            name: key,
            parent: rootPath
          };
          validator(optLoc, obj[key]);
        } else {
          const invalidPluginPropertyError = new Error(`.${key} is not a valid Plugin property`);
          invalidPluginPropertyError.code = "BABEL_UNKNOWN_PLUGIN_PROPERTY";
          throw invalidPluginPropertyError;
        }
      });
      return obj;
    }
  }
});

// node_modules/@babel/core/lib/config/helpers/environment.js
var require_environment = __commonJS({
  "node_modules/@babel/core/lib/config/helpers/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getEnv = getEnv;
    function getEnv(defaultValue = "development") {
      return process.env.BABEL_ENV || process.env.NODE_ENV || defaultValue;
    }
  }
});

// node_modules/@babel/core/lib/config/partial.js
var require_partial = __commonJS({
  "node_modules/@babel/core/lib/config/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = loadPrivatePartialConfig;
    exports2.loadPartialConfig = loadPartialConfig;
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    var _plugin = require_plugin();
    var _util = require_util3();
    var _item = require_item();
    var _configChain = require_config_chain();
    var _environment = require_environment();
    var _options = require_options3();
    var _index = require_files();
    var _resolveTargets = require_resolve_targets();
    var _excluded = ["showIgnoredFiles"];
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    function resolveRootMode(rootDir, rootMode) {
      switch (rootMode) {
        case "root":
          return rootDir;
        case "upward-optional": {
          const upwardRootDir = (0, _index.findConfigUpwards)(rootDir);
          return upwardRootDir === null ? rootDir : upwardRootDir;
        }
        case "upward": {
          const upwardRootDir = (0, _index.findConfigUpwards)(rootDir);
          if (upwardRootDir !== null) return upwardRootDir;
          throw Object.assign(new Error(`Babel was run with rootMode:"upward" but a root could not be found when searching upward from "${rootDir}".
One of the following config files must be in the directory tree: "${_index.ROOT_CONFIG_FILENAMES.join(", ")}".`), {
            code: "BABEL_ROOT_NOT_FOUND",
            dirname: rootDir
          });
        }
        default:
          throw new Error(`Assertion failure - unknown rootMode value.`);
      }
    }
    function* loadPrivatePartialConfig(inputOpts) {
      if (inputOpts != null && (typeof inputOpts !== "object" || Array.isArray(inputOpts))) {
        throw new Error("Babel options must be an object, null, or undefined");
      }
      const args = inputOpts ? (0, _options.validate)("arguments", inputOpts) : {};
      const {
        envName = (0, _environment.getEnv)(),
        cwd = ".",
        root: rootDir = ".",
        rootMode = "root",
        caller,
        cloneInputAst = true
      } = args;
      const absoluteCwd = _path2().resolve(cwd);
      const absoluteRootDir = resolveRootMode(_path2().resolve(absoluteCwd, rootDir), rootMode);
      const filename = typeof args.filename === "string" ? _path2().resolve(cwd, args.filename) : void 0;
      const showConfigPath = yield* (0, _index.resolveShowConfigPath)(absoluteCwd);
      const context = {
        filename,
        cwd: absoluteCwd,
        root: absoluteRootDir,
        envName,
        caller,
        showConfig: showConfigPath === filename
      };
      const configChain = yield* (0, _configChain.buildRootChain)(args, context);
      if (!configChain) return null;
      const merged = {
        assumptions: {}
      };
      configChain.options.forEach((opts) => {
        (0, _util.mergeOptions)(merged, opts);
      });
      const options2 = Object.assign({}, merged, {
        targets: (0, _resolveTargets.resolveTargets)(merged, absoluteRootDir),
        cloneInputAst,
        babelrc: false,
        configFile: false,
        browserslistConfigFile: false,
        passPerPreset: false,
        envName: context.envName,
        cwd: context.cwd,
        root: context.root,
        rootMode: "root",
        filename: typeof context.filename === "string" ? context.filename : void 0,
        plugins: configChain.plugins.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor)),
        presets: configChain.presets.map((descriptor) => (0, _item.createItemFromDescriptor)(descriptor))
      });
      return {
        options: options2,
        context,
        fileHandling: configChain.fileHandling,
        ignore: configChain.ignore,
        babelrc: configChain.babelrc,
        config: configChain.config,
        files: configChain.files
      };
    }
    function* loadPartialConfig(opts) {
      let showIgnoredFiles = false;
      if (typeof opts === "object" && opts !== null && !Array.isArray(opts)) {
        var _opts = opts;
        ({
          showIgnoredFiles
        } = _opts);
        opts = _objectWithoutPropertiesLoose(_opts, _excluded);
        _opts;
      }
      const result = yield* loadPrivatePartialConfig(opts);
      if (!result) return null;
      const {
        options: options2,
        babelrc,
        ignore,
        config: config2,
        fileHandling,
        files
      } = result;
      if (fileHandling === "ignored" && !showIgnoredFiles) {
        return null;
      }
      (options2.plugins || []).forEach((item) => {
        if (item.value instanceof _plugin.default) {
          throw new Error("Passing cached plugin instances is not supported in babel.loadPartialConfig()");
        }
      });
      return new PartialConfig(options2, babelrc ? babelrc.filepath : void 0, ignore ? ignore.filepath : void 0, config2 ? config2.filepath : void 0, fileHandling, files);
    }
    var PartialConfig = class {
      constructor(options2, babelrc, ignore, config2, fileHandling, files) {
        this.options = void 0;
        this.babelrc = void 0;
        this.babelignore = void 0;
        this.config = void 0;
        this.fileHandling = void 0;
        this.files = void 0;
        this.options = options2;
        this.babelignore = ignore;
        this.babelrc = babelrc;
        this.config = config2;
        this.fileHandling = fileHandling;
        this.files = files;
        Object.freeze(this);
      }
      hasFilesystemConfig() {
        return this.babelrc !== void 0 || this.config !== void 0;
      }
    };
    Object.freeze(PartialConfig.prototype);
  }
});

// node_modules/@babel/core/lib/config/full.js
var require_full = __commonJS({
  "node_modules/@babel/core/lib/config/full.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _async = require_async();
    var _util = require_util3();
    var context = require_lib15();
    var _plugin = require_plugin();
    var _item = require_item();
    var _configChain = require_config_chain();
    var _deepArray = require_deep_array();
    function _traverse() {
      const data = require_lib9();
      _traverse = function() {
        return data;
      };
      return data;
    }
    var _caching = require_caching();
    var _options = require_options3();
    var _plugins = require_plugins3();
    var _configApi = require_config_api();
    var _partial = require_partial();
    var _configError = require_config_error();
    var _default = exports2.default = _gensync()(function* loadFullConfig(inputOpts) {
      var _opts$assumptions;
      const result = yield* (0, _partial.default)(inputOpts);
      if (!result) {
        return null;
      }
      const {
        options: options2,
        context: context2,
        fileHandling
      } = result;
      if (fileHandling === "ignored") {
        return null;
      }
      const optionDefaults = {};
      const {
        plugins: plugins2,
        presets
      } = options2;
      if (!plugins2 || !presets) {
        throw new Error("Assertion failure - plugins and presets exist");
      }
      const presetContext = Object.assign({}, context2, {
        targets: options2.targets
      });
      const toDescriptor = (item) => {
        const desc = (0, _item.getItemDescriptor)(item);
        if (!desc) {
          throw new Error("Assertion failure - must be config item");
        }
        return desc;
      };
      const presetsDescriptors = presets.map(toDescriptor);
      const initialPluginsDescriptors = plugins2.map(toDescriptor);
      const pluginDescriptorsByPass = [[]];
      const passes = [];
      const externalDependencies = [];
      const ignored = yield* enhanceError(context2, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {
        const presets2 = [];
        for (let i = 0; i < rawPresets.length; i++) {
          const descriptor = rawPresets[i];
          if (descriptor.options !== false) {
            try {
              var preset = yield* loadPresetDescriptor(descriptor, presetContext);
            } catch (e) {
              if (e.code === "BABEL_UNKNOWN_OPTION") {
                (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, "preset", e);
              }
              throw e;
            }
            externalDependencies.push(preset.externalDependencies);
            if (descriptor.ownPass) {
              presets2.push({
                preset: preset.chain,
                pass: []
              });
            } else {
              presets2.unshift({
                preset: preset.chain,
                pass: pluginDescriptorsPass
              });
            }
          }
        }
        if (presets2.length > 0) {
          pluginDescriptorsByPass.splice(1, 0, ...presets2.map((o) => o.pass).filter((p) => p !== pluginDescriptorsPass));
          for (const {
            preset: preset2,
            pass
          } of presets2) {
            if (!preset2) return true;
            pass.push(...preset2.plugins);
            const ignored2 = yield* recursePresetDescriptors(preset2.presets, pass);
            if (ignored2) return true;
            preset2.options.forEach((opts2) => {
              (0, _util.mergeOptions)(optionDefaults, opts2);
            });
          }
        }
      })(presetsDescriptors, pluginDescriptorsByPass[0]);
      if (ignored) return null;
      const opts = optionDefaults;
      (0, _util.mergeOptions)(opts, options2);
      const pluginContext = Object.assign({}, presetContext, {
        assumptions: (_opts$assumptions = opts.assumptions) != null ? _opts$assumptions : {}
      });
      yield* enhanceError(context2, function* loadPluginDescriptors() {
        pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);
        for (const descs of pluginDescriptorsByPass) {
          const pass = [];
          passes.push(pass);
          for (let i = 0; i < descs.length; i++) {
            const descriptor = descs[i];
            if (descriptor.options !== false) {
              try {
                var plugin3 = yield* loadPluginDescriptor(descriptor, pluginContext);
              } catch (e) {
                if (e.code === "BABEL_UNKNOWN_PLUGIN_PROPERTY") {
                  (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, "plugin", e);
                }
                throw e;
              }
              pass.push(plugin3);
              externalDependencies.push(plugin3.externalDependencies);
            }
          }
        }
      })();
      opts.plugins = passes[0];
      opts.presets = passes.slice(1).filter((plugins3) => plugins3.length > 0).map((plugins3) => ({
        plugins: plugins3
      }));
      opts.passPerPreset = opts.presets.length > 0;
      return {
        options: opts,
        passes,
        externalDependencies: (0, _deepArray.finalize)(externalDependencies)
      };
    });
    function enhanceError(context2, fn) {
      return function* (arg1, arg2) {
        try {
          return yield* fn(arg1, arg2);
        } catch (e) {
          if (!/^\[BABEL\]/.test(e.message)) {
            var _context$filename;
            e.message = `[BABEL] ${(_context$filename = context2.filename) != null ? _context$filename : "unknown file"}: ${e.message}`;
          }
          throw e;
        }
      };
    }
    var makeDescriptorLoader = (apiFactory) => (0, _caching.makeWeakCache)(function* ({
      value: value2,
      options: options2,
      dirname: dirname4,
      alias
    }, cache2) {
      if (options2 === false) throw new Error("Assertion failure");
      options2 = options2 || {};
      const externalDependencies = [];
      let item = value2;
      if (typeof value2 === "function") {
        const factory = (0, _async.maybeAsync)(value2, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);
        const api = Object.assign({}, context, apiFactory(cache2, externalDependencies));
        try {
          item = yield* factory(api, options2, dirname4);
        } catch (e) {
          if (alias) {
            e.message += ` (While processing: ${JSON.stringify(alias)})`;
          }
          throw e;
        }
      }
      if (!item || typeof item !== "object") {
        throw new Error("Plugin/Preset did not return an object.");
      }
      if ((0, _async.isThenable)(item)) {
        yield* [];
        throw new Error(`You appear to be using a promise as a plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version. As an alternative, you can prefix the promise with "await". (While processing: ${JSON.stringify(alias)})`);
      }
      if (externalDependencies.length > 0 && (!cache2.configured() || cache2.mode() === "forever")) {
        let error = `A plugin/preset has external untracked dependencies (${externalDependencies[0]}), but the cache `;
        if (!cache2.configured()) {
          error += `has not been configured to be invalidated when the external dependencies change. `;
        } else {
          error += ` has been configured to never be invalidated. `;
        }
        error += `Plugins/presets should configure their cache to be invalidated when the external dependencies change, for example using \`api.cache.invalidate(() => statSync(filepath).mtimeMs)\` or \`api.cache.never()\`
(While processing: ${JSON.stringify(alias)})`;
        throw new Error(error);
      }
      return {
        value: item,
        options: options2,
        dirname: dirname4,
        alias,
        externalDependencies: (0, _deepArray.finalize)(externalDependencies)
      };
    });
    var pluginDescriptorLoader = makeDescriptorLoader(_configApi.makePluginAPI);
    var presetDescriptorLoader = makeDescriptorLoader(_configApi.makePresetAPI);
    var instantiatePlugin = (0, _caching.makeWeakCache)(function* ({
      value: value2,
      options: options2,
      dirname: dirname4,
      alias,
      externalDependencies
    }, cache2) {
      const pluginObj = (0, _plugins.validatePluginObject)(value2);
      const plugin3 = Object.assign({}, pluginObj);
      if (plugin3.visitor) {
        plugin3.visitor = _traverse().default.explode(Object.assign({}, plugin3.visitor));
      }
      if (plugin3.inherits) {
        const inheritsDescriptor = {
          name: void 0,
          alias: `${alias}$inherits`,
          value: plugin3.inherits,
          options: options2,
          dirname: dirname4
        };
        const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, (run) => {
          return cache2.invalidate((data) => run(inheritsDescriptor, data));
        });
        plugin3.pre = chainMaybeAsync(inherits.pre, plugin3.pre);
        plugin3.post = chainMaybeAsync(inherits.post, plugin3.post);
        plugin3.manipulateOptions = chainMaybeAsync(inherits.manipulateOptions, plugin3.manipulateOptions);
        plugin3.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin3.visitor || {}]);
        if (inherits.externalDependencies.length > 0) {
          if (externalDependencies.length === 0) {
            externalDependencies = inherits.externalDependencies;
          } else {
            externalDependencies = (0, _deepArray.finalize)([externalDependencies, inherits.externalDependencies]);
          }
        }
      }
      return new _plugin.default(plugin3, options2, alias, externalDependencies);
    });
    function* loadPluginDescriptor(descriptor, context2) {
      if (descriptor.value instanceof _plugin.default) {
        if (descriptor.options) {
          throw new Error("Passed options to an existing Plugin instance will not work.");
        }
        return descriptor.value;
      }
      return yield* instantiatePlugin(yield* pluginDescriptorLoader(descriptor, context2), context2);
    }
    var needsFilename = (val) => val && typeof val !== "function";
    var validateIfOptionNeedsFilename = (options2, descriptor) => {
      if (needsFilename(options2.test) || needsFilename(options2.include) || needsFilename(options2.exclude)) {
        const formattedPresetName = descriptor.name ? `"${descriptor.name}"` : "/* your preset */";
        throw new _configError.default([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\`\`\``, `babel.transformSync(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\`\`\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join("\n"));
      }
    };
    var validatePreset = (preset, context2, descriptor) => {
      if (!context2.filename) {
        var _options$overrides;
        const {
          options: options2
        } = preset;
        validateIfOptionNeedsFilename(options2, descriptor);
        (_options$overrides = options2.overrides) == null || _options$overrides.forEach((overrideOptions) => validateIfOptionNeedsFilename(overrideOptions, descriptor));
      }
    };
    var instantiatePreset = (0, _caching.makeWeakCacheSync)(({
      value: value2,
      dirname: dirname4,
      alias,
      externalDependencies
    }) => {
      return {
        options: (0, _options.validate)("preset", value2),
        alias,
        dirname: dirname4,
        externalDependencies
      };
    });
    function* loadPresetDescriptor(descriptor, context2) {
      const preset = instantiatePreset(yield* presetDescriptorLoader(descriptor, context2));
      validatePreset(preset, context2, descriptor);
      return {
        chain: yield* (0, _configChain.buildPresetChain)(preset, context2),
        externalDependencies: preset.externalDependencies
      };
    }
    function chainMaybeAsync(a, b) {
      if (!a) return b;
      if (!b) return a;
      return function(...args) {
        const res = a.apply(this, args);
        if (res && typeof res.then === "function") {
          return res.then(() => b.apply(this, args));
        }
        return b.apply(this, args);
      };
    }
  }
});

// node_modules/@babel/core/lib/config/index.js
var require_config = __commonJS({
  "node_modules/@babel/core/lib/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createConfigItem = createConfigItem;
    exports2.createConfigItemAsync = createConfigItemAsync;
    exports2.createConfigItemSync = createConfigItemSync;
    Object.defineProperty(exports2, "default", {
      enumerable: true,
      get: function() {
        return _full.default;
      }
    });
    exports2.loadOptions = loadOptions2;
    exports2.loadOptionsAsync = loadOptionsAsync;
    exports2.loadOptionsSync = loadOptionsSync;
    exports2.loadPartialConfig = loadPartialConfig;
    exports2.loadPartialConfigAsync = loadPartialConfigAsync;
    exports2.loadPartialConfigSync = loadPartialConfigSync;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _full = require_full();
    var _partial = require_partial();
    var _item = require_item();
    var _rewriteStackTrace = require_rewrite_stack_trace();
    var loadPartialConfigRunner = _gensync()(_partial.loadPartialConfig);
    function loadPartialConfigAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.async)(...args);
    }
    function loadPartialConfigSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.sync)(...args);
    }
    function loadPartialConfig(opts, callback) {
      if (callback !== void 0) {
        (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(opts, callback);
      } else if (typeof opts === "function") {
        (0, _rewriteStackTrace.beginHiddenCallStack)(loadPartialConfigRunner.errback)(void 0, opts);
      } else {
        {
          return loadPartialConfigSync(opts);
        }
      }
    }
    function* loadOptionsImpl(opts) {
      var _config$options;
      const config2 = yield* (0, _full.default)(opts);
      return (_config$options = config2 == null ? void 0 : config2.options) != null ? _config$options : null;
    }
    var loadOptionsRunner = _gensync()(loadOptionsImpl);
    function loadOptionsAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.async)(...args);
    }
    function loadOptionsSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.sync)(...args);
    }
    function loadOptions2(opts, callback) {
      if (callback !== void 0) {
        (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(opts, callback);
      } else if (typeof opts === "function") {
        (0, _rewriteStackTrace.beginHiddenCallStack)(loadOptionsRunner.errback)(void 0, opts);
      } else {
        {
          return loadOptionsSync(opts);
        }
      }
    }
    var createConfigItemRunner = _gensync()(_item.createConfigItem);
    function createConfigItemAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.async)(...args);
    }
    function createConfigItemSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.sync)(...args);
    }
    function createConfigItem(target, options2, callback) {
      if (callback !== void 0) {
        (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target, options2, callback);
      } else if (typeof options2 === "function") {
        (0, _rewriteStackTrace.beginHiddenCallStack)(createConfigItemRunner.errback)(target, void 0, callback);
      } else {
        {
          return createConfigItemSync(target, options2);
        }
      }
    }
  }
});

// node_modules/@babel/core/lib/transformation/plugin-pass.js
var require_plugin_pass = __commonJS({
  "node_modules/@babel/core/lib/transformation/plugin-pass.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var PluginPass = class {
      constructor(file, key, options2, isAsync) {
        this._map = /* @__PURE__ */ new Map();
        this.key = void 0;
        this.file = void 0;
        this.opts = void 0;
        this.cwd = void 0;
        this.filename = void 0;
        this.isAsync = void 0;
        this.key = key;
        this.file = file;
        this.opts = options2 || {};
        this.cwd = file.opts.cwd;
        this.filename = file.opts.filename;
        this.isAsync = isAsync;
      }
      set(key, val) {
        this._map.set(key, val);
      }
      get(key) {
        return this._map.get(key);
      }
      availableHelper(name2, versionRange) {
        return this.file.availableHelper(name2, versionRange);
      }
      addHelper(name2) {
        return this.file.addHelper(name2);
      }
      buildCodeFrameError(node3, msg, _Error) {
        return this.file.buildCodeFrameError(node3, msg, _Error);
      }
    };
    exports2.default = PluginPass;
    {
      PluginPass.prototype.getModuleName = function getModuleName() {
        return this.file.getModuleName();
      };
      PluginPass.prototype.addImport = function addImport() {
        this.file.addImport();
      };
    }
  }
});

// node_modules/@babel/core/lib/transformation/block-hoist-plugin.js
var require_block_hoist_plugin = __commonJS({
  "node_modules/@babel/core/lib/transformation/block-hoist-plugin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = loadBlockHoistPlugin;
    function _traverse() {
      const data = require_lib9();
      _traverse = function() {
        return data;
      };
      return data;
    }
    var _plugin = require_plugin();
    var LOADED_PLUGIN;
    var blockHoistPlugin = {
      name: "internal.blockHoist",
      visitor: {
        Block: {
          exit({
            node: node3
          }) {
            node3.body = performHoisting(node3.body);
          }
        },
        SwitchCase: {
          exit({
            node: node3
          }) {
            node3.consequent = performHoisting(node3.consequent);
          }
        }
      }
    };
    function performHoisting(body) {
      let max = Math.pow(2, 30) - 1;
      let hasChange = false;
      for (let i = 0; i < body.length; i++) {
        const n = body[i];
        const p = priority(n);
        if (p > max) {
          hasChange = true;
          break;
        }
        max = p;
      }
      if (!hasChange) return body;
      return stableSort(body.slice());
    }
    function loadBlockHoistPlugin() {
      if (!LOADED_PLUGIN) {
        LOADED_PLUGIN = new _plugin.default(Object.assign({}, blockHoistPlugin, {
          visitor: _traverse().default.explode(blockHoistPlugin.visitor)
        }), {});
      }
      return LOADED_PLUGIN;
    }
    function priority(bodyNode) {
      const priority2 = bodyNode == null ? void 0 : bodyNode._blockHoist;
      if (priority2 == null) return 1;
      if (priority2 === true) return 2;
      return priority2;
    }
    function stableSort(body) {
      const buckets = /* @__PURE__ */ Object.create(null);
      for (let i = 0; i < body.length; i++) {
        const n = body[i];
        const p = priority(n);
        const bucket = buckets[p] || (buckets[p] = []);
        bucket.push(n);
      }
      const keys = Object.keys(buckets).map((k) => +k).sort((a, b) => b - a);
      let index4 = 0;
      for (const key of keys) {
        const bucket = buckets[key];
        for (const n of bucket) {
          body[index4++] = n;
        }
      }
      return body;
    }
  }
});

// node_modules/@babel/core/lib/transformation/normalize-opts.js
var require_normalize_opts = __commonJS({
  "node_modules/@babel/core/lib/transformation/normalize-opts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = normalizeOptions;
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    function normalizeOptions(config2) {
      const {
        filename,
        cwd,
        filenameRelative = typeof filename === "string" ? _path2().relative(cwd, filename) : "unknown",
        sourceType = "module",
        inputSourceMap,
        sourceMaps = !!inputSourceMap,
        sourceRoot = config2.options.moduleRoot,
        sourceFileName = _path2().basename(filenameRelative),
        comments = true,
        compact = "auto"
      } = config2.options;
      const opts = config2.options;
      const options2 = Object.assign({}, opts, {
        parserOpts: Object.assign({
          sourceType: _path2().extname(filenameRelative) === ".mjs" ? "module" : sourceType,
          sourceFileName: filename,
          plugins: []
        }, opts.parserOpts),
        generatorOpts: Object.assign({
          filename,
          auxiliaryCommentBefore: opts.auxiliaryCommentBefore,
          auxiliaryCommentAfter: opts.auxiliaryCommentAfter,
          retainLines: opts.retainLines,
          comments,
          shouldPrintComment: opts.shouldPrintComment,
          compact,
          minified: opts.minified,
          sourceMaps,
          sourceRoot,
          sourceFileName
        }, opts.generatorOpts)
      });
      for (const plugins2 of config2.passes) {
        for (const plugin3 of plugins2) {
          if (plugin3.manipulateOptions) {
            plugin3.manipulateOptions(options2, options2.parserOpts);
          }
        }
      }
      return options2;
    }
  }
});

// node_modules/convert-source-map/index.js
var require_convert_source_map = __commonJS({
  "node_modules/convert-source-map/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "commentRegex", {
      get: function getCommentRegex() {
        return /^\s*?\/[\/\*][@#]\s+?sourceMappingURL=data:(((?:application|text)\/json)(?:;charset=([^;,]+?)?)?)?(?:;(base64))?,(.*?)$/mg;
      }
    });
    Object.defineProperty(exports2, "mapFileCommentRegex", {
      get: function getMapFileCommentRegex() {
        return /(?:\/\/[@#][ \t]+?sourceMappingURL=([^\s'"`]+?)[ \t]*?$)|(?:\/\*[@#][ \t]+sourceMappingURL=([^*]+?)[ \t]*?(?:\*\/){1}[ \t]*?$)/mg;
      }
    });
    var decodeBase64;
    if (typeof Buffer !== "undefined") {
      if (typeof Buffer.from === "function") {
        decodeBase64 = decodeBase64WithBufferFrom;
      } else {
        decodeBase64 = decodeBase64WithNewBuffer;
      }
    } else {
      decodeBase64 = decodeBase64WithAtob;
    }
    function decodeBase64WithBufferFrom(base64) {
      return Buffer.from(base64, "base64").toString();
    }
    function decodeBase64WithNewBuffer(base64) {
      if (typeof value === "number") {
        throw new TypeError("The value to decode must not be of type number.");
      }
      return new Buffer(base64, "base64").toString();
    }
    function decodeBase64WithAtob(base64) {
      return decodeURIComponent(escape(atob(base64)));
    }
    function stripComment(sm) {
      return sm.split(",").pop();
    }
    function readFromFileMap(sm, read2) {
      var r = exports2.mapFileCommentRegex.exec(sm);
      var filename = r[1] || r[2];
      try {
        var sm = read2(filename);
        if (sm != null && typeof sm.catch === "function") {
          return sm.catch(throwError);
        } else {
          return sm;
        }
      } catch (e) {
        throwError(e);
      }
      function throwError(e) {
        throw new Error("An error occurred while trying to read the map file at " + filename + "\n" + e.stack);
      }
    }
    function Converter(sm, opts) {
      opts = opts || {};
      if (opts.hasComment) {
        sm = stripComment(sm);
      }
      if (opts.encoding === "base64") {
        sm = decodeBase64(sm);
      } else if (opts.encoding === "uri") {
        sm = decodeURIComponent(sm);
      }
      if (opts.isJSON || opts.encoding) {
        sm = JSON.parse(sm);
      }
      this.sourcemap = sm;
    }
    Converter.prototype.toJSON = function(space2) {
      return JSON.stringify(this.sourcemap, null, space2);
    };
    if (typeof Buffer !== "undefined") {
      if (typeof Buffer.from === "function") {
        Converter.prototype.toBase64 = encodeBase64WithBufferFrom;
      } else {
        Converter.prototype.toBase64 = encodeBase64WithNewBuffer;
      }
    } else {
      Converter.prototype.toBase64 = encodeBase64WithBtoa;
    }
    function encodeBase64WithBufferFrom() {
      var json = this.toJSON();
      return Buffer.from(json, "utf8").toString("base64");
    }
    function encodeBase64WithNewBuffer() {
      var json = this.toJSON();
      if (typeof json === "number") {
        throw new TypeError("The json to encode must not be of type number.");
      }
      return new Buffer(json, "utf8").toString("base64");
    }
    function encodeBase64WithBtoa() {
      var json = this.toJSON();
      return btoa(unescape(encodeURIComponent(json)));
    }
    Converter.prototype.toURI = function() {
      var json = this.toJSON();
      return encodeURIComponent(json);
    };
    Converter.prototype.toComment = function(options2) {
      var encoding, content, data;
      if (options2 != null && options2.encoding === "uri") {
        encoding = "";
        content = this.toURI();
      } else {
        encoding = ";base64";
        content = this.toBase64();
      }
      data = "sourceMappingURL=data:application/json;charset=utf-8" + encoding + "," + content;
      return options2 != null && options2.multiline ? "/*# " + data + " */" : "//# " + data;
    };
    Converter.prototype.toObject = function() {
      return JSON.parse(this.toJSON());
    };
    Converter.prototype.addProperty = function(key, value2) {
      if (this.sourcemap.hasOwnProperty(key)) throw new Error('property "' + key + '" already exists on the sourcemap, use set property instead');
      return this.setProperty(key, value2);
    };
    Converter.prototype.setProperty = function(key, value2) {
      this.sourcemap[key] = value2;
      return this;
    };
    Converter.prototype.getProperty = function(key) {
      return this.sourcemap[key];
    };
    exports2.fromObject = function(obj) {
      return new Converter(obj);
    };
    exports2.fromJSON = function(json) {
      return new Converter(json, { isJSON: true });
    };
    exports2.fromURI = function(uri) {
      return new Converter(uri, { encoding: "uri" });
    };
    exports2.fromBase64 = function(base64) {
      return new Converter(base64, { encoding: "base64" });
    };
    exports2.fromComment = function(comment4) {
      var m, encoding;
      comment4 = comment4.replace(/^\/\*/g, "//").replace(/\*\/$/g, "");
      m = exports2.commentRegex.exec(comment4);
      encoding = m && m[4] || "uri";
      return new Converter(comment4, { encoding, hasComment: true });
    };
    function makeConverter(sm) {
      return new Converter(sm, { isJSON: true });
    }
    exports2.fromMapFileComment = function(comment4, read2) {
      if (typeof read2 === "string") {
        throw new Error(
          "String directory paths are no longer supported with `fromMapFileComment`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
        );
      }
      var sm = readFromFileMap(comment4, read2);
      if (sm != null && typeof sm.then === "function") {
        return sm.then(makeConverter);
      } else {
        return makeConverter(sm);
      }
    };
    exports2.fromSource = function(content) {
      var m = content.match(exports2.commentRegex);
      return m ? exports2.fromComment(m.pop()) : null;
    };
    exports2.fromMapFileSource = function(content, read2) {
      if (typeof read2 === "string") {
        throw new Error(
          "String directory paths are no longer supported with `fromMapFileSource`\nPlease review the Upgrading documentation at https://github.com/thlorenz/convert-source-map#upgrading"
        );
      }
      var m = content.match(exports2.mapFileCommentRegex);
      return m ? exports2.fromMapFileComment(m.pop(), read2) : null;
    };
    exports2.removeComments = function(src3) {
      return src3.replace(exports2.commentRegex, "");
    };
    exports2.removeMapFileComments = function(src3) {
      return src3.replace(exports2.mapFileCommentRegex, "");
    };
    exports2.generateMapFileComment = function(file, options2) {
      var data = "sourceMappingURL=" + file;
      return options2 && options2.multiline ? "/*# " + data + " */" : "//# " + data;
    };
  }
});

// node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js
var require_missing_plugin_helper = __commonJS({
  "node_modules/@babel/core/lib/parser/util/missing-plugin-helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = generateMissingPluginMessage;
    var pluginNameMap = {
      asyncDoExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-async-do-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-do-expressions"
        }
      },
      decimal: {
        syntax: {
          name: "@babel/plugin-syntax-decimal",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decimal"
        }
      },
      decorators: {
        syntax: {
          name: "@babel/plugin-syntax-decorators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-decorators"
        },
        transform: {
          name: "@babel/plugin-proposal-decorators",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-decorators"
        }
      },
      doExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-do-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-do-expressions"
        },
        transform: {
          name: "@babel/plugin-proposal-do-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-do-expressions"
        }
      },
      exportDefaultFrom: {
        syntax: {
          name: "@babel/plugin-syntax-export-default-from",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-default-from"
        },
        transform: {
          name: "@babel/plugin-proposal-export-default-from",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-export-default-from"
        }
      },
      flow: {
        syntax: {
          name: "@babel/plugin-syntax-flow",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-flow"
        },
        transform: {
          name: "@babel/preset-flow",
          url: "https://github.com/babel/babel/tree/main/packages/babel-preset-flow"
        }
      },
      functionBind: {
        syntax: {
          name: "@babel/plugin-syntax-function-bind",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-bind"
        },
        transform: {
          name: "@babel/plugin-proposal-function-bind",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-bind"
        }
      },
      functionSent: {
        syntax: {
          name: "@babel/plugin-syntax-function-sent",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-function-sent"
        },
        transform: {
          name: "@babel/plugin-proposal-function-sent",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-function-sent"
        }
      },
      jsx: {
        syntax: {
          name: "@babel/plugin-syntax-jsx",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-jsx"
        },
        transform: {
          name: "@babel/preset-react",
          url: "https://github.com/babel/babel/tree/main/packages/babel-preset-react"
        }
      },
      pipelineOperator: {
        syntax: {
          name: "@babel/plugin-syntax-pipeline-operator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-pipeline-operator"
        },
        transform: {
          name: "@babel/plugin-proposal-pipeline-operator",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-pipeline-operator"
        }
      },
      recordAndTuple: {
        syntax: {
          name: "@babel/plugin-syntax-record-and-tuple",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-record-and-tuple"
        }
      },
      throwExpressions: {
        syntax: {
          name: "@babel/plugin-syntax-throw-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-throw-expressions"
        },
        transform: {
          name: "@babel/plugin-proposal-throw-expressions",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-proposal-throw-expressions"
        }
      },
      typescript: {
        syntax: {
          name: "@babel/plugin-syntax-typescript",
          url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-typescript"
        },
        transform: {
          name: "@babel/preset-typescript",
          url: "https://github.com/babel/babel/tree/main/packages/babel-preset-typescript"
        }
      }
    };
    {
      Object.assign(pluginNameMap, {
        asyncGenerators: {
          syntax: {
            name: "@babel/plugin-syntax-async-generators",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-async-generators"
          },
          transform: {
            name: "@babel/plugin-transform-async-generator-functions",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-async-generator-functions"
          }
        },
        classProperties: {
          syntax: {
            name: "@babel/plugin-syntax-class-properties",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
          },
          transform: {
            name: "@babel/plugin-transform-class-properties",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
          }
        },
        classPrivateProperties: {
          syntax: {
            name: "@babel/plugin-syntax-class-properties",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
          },
          transform: {
            name: "@babel/plugin-transform-class-properties",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-class-properties"
          }
        },
        classPrivateMethods: {
          syntax: {
            name: "@babel/plugin-syntax-class-properties",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-class-properties"
          },
          transform: {
            name: "@babel/plugin-transform-private-methods",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-methods"
          }
        },
        classStaticBlock: {
          syntax: {
            name: "@babel/plugin-syntax-class-static-block",
            url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-syntax-class-static-block"
          },
          transform: {
            name: "@babel/plugin-transform-class-static-block",
            url: "https://github.com/babel/babel/tree/HEAD/packages/babel-plugin-transform-class-static-block"
          }
        },
        dynamicImport: {
          syntax: {
            name: "@babel/plugin-syntax-dynamic-import",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-dynamic-import"
          }
        },
        exportNamespaceFrom: {
          syntax: {
            name: "@babel/plugin-syntax-export-namespace-from",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-export-namespace-from"
          },
          transform: {
            name: "@babel/plugin-transform-export-namespace-from",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-export-namespace-from"
          }
        },
        importAssertions: {
          syntax: {
            name: "@babel/plugin-syntax-import-assertions",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-assertions"
          }
        },
        importAttributes: {
          syntax: {
            name: "@babel/plugin-syntax-import-attributes",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-attributes"
          }
        },
        importMeta: {
          syntax: {
            name: "@babel/plugin-syntax-import-meta",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-import-meta"
          }
        },
        logicalAssignment: {
          syntax: {
            name: "@babel/plugin-syntax-logical-assignment-operators",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-logical-assignment-operators"
          },
          transform: {
            name: "@babel/plugin-transform-logical-assignment-operators",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-logical-assignment-operators"
          }
        },
        moduleStringNames: {
          syntax: {
            name: "@babel/plugin-syntax-module-string-names",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-module-string-names"
          }
        },
        numericSeparator: {
          syntax: {
            name: "@babel/plugin-syntax-numeric-separator",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-numeric-separator"
          },
          transform: {
            name: "@babel/plugin-transform-numeric-separator",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-numeric-separator"
          }
        },
        nullishCoalescingOperator: {
          syntax: {
            name: "@babel/plugin-syntax-nullish-coalescing-operator",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-nullish-coalescing-operator"
          },
          transform: {
            name: "@babel/plugin-transform-nullish-coalescing-operator",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-nullish-coalescing-opearator"
          }
        },
        objectRestSpread: {
          syntax: {
            name: "@babel/plugin-syntax-object-rest-spread",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-object-rest-spread"
          },
          transform: {
            name: "@babel/plugin-transform-object-rest-spread",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-object-rest-spread"
          }
        },
        optionalCatchBinding: {
          syntax: {
            name: "@babel/plugin-syntax-optional-catch-binding",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-catch-binding"
          },
          transform: {
            name: "@babel/plugin-transform-optional-catch-binding",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-catch-binding"
          }
        },
        optionalChaining: {
          syntax: {
            name: "@babel/plugin-syntax-optional-chaining",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-optional-chaining"
          },
          transform: {
            name: "@babel/plugin-transform-optional-chaining",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-optional-chaining"
          }
        },
        privateIn: {
          syntax: {
            name: "@babel/plugin-syntax-private-property-in-object",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-syntax-private-property-in-object"
          },
          transform: {
            name: "@babel/plugin-transform-private-property-in-object",
            url: "https://github.com/babel/babel/tree/main/packages/babel-plugin-transform-private-property-in-object"
          }
        },
        regexpUnicodeSets: {
          syntax: {
            name: "@babel/plugin-syntax-unicode-sets-regex",
            url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-syntax-unicode-sets-regex/README.md"
          },
          transform: {
            name: "@babel/plugin-transform-unicode-sets-regex",
            url: "https://github.com/babel/babel/blob/main/packages/babel-plugin-proposalunicode-sets-regex/README.md"
          }
        }
      });
    }
    var getNameURLCombination = ({
      name: name2,
      url: url2
    }) => `${name2} (${url2})`;
    function generateMissingPluginMessage(missingPluginName, loc, codeFrame, filename) {
      let helpMessage = `Support for the experimental syntax '${missingPluginName}' isn't currently enabled (${loc.line}:${loc.column + 1}):

` + codeFrame;
      const pluginInfo = pluginNameMap[missingPluginName];
      if (pluginInfo) {
        const {
          syntax: syntaxPlugin,
          transform: transformPlugin
        } = pluginInfo;
        if (syntaxPlugin) {
          const syntaxPluginInfo = getNameURLCombination(syntaxPlugin);
          if (transformPlugin) {
            const transformPluginInfo = getNameURLCombination(transformPlugin);
            const sectionType = transformPlugin.name.startsWith("@babel/plugin") ? "plugins" : "presets";
            helpMessage += `

Add ${transformPluginInfo} to the '${sectionType}' section of your Babel config to enable transformation.
If you want to leave it as-is, add ${syntaxPluginInfo} to the 'plugins' section to enable parsing.`;
          } else {
            helpMessage += `

Add ${syntaxPluginInfo} to the 'plugins' section of your Babel config to enable parsing.`;
          }
        }
      }
      const msgFilename = filename === "unknown" ? "<name of the input file>" : filename;
      helpMessage += `

If you already added the plugin for this syntax to your config, it's possible that your config isn't being loaded.
You can re-run Babel with the BABEL_SHOW_CONFIG_FOR environment variable to show the loaded configuration:
	npx cross-env BABEL_SHOW_CONFIG_FOR=${msgFilename} <your build command>
See https://babeljs.io/docs/configuration#print-effective-configs for more info.
`;
      return helpMessage;
    }
  }
});

// node_modules/@babel/core/lib/parser/index.js
var require_parser2 = __commonJS({
  "node_modules/@babel/core/lib/parser/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = parser2;
    function _parser() {
      const data = require_lib4();
      _parser = function() {
        return data;
      };
      return data;
    }
    function _codeFrame() {
      const data = require_lib5();
      _codeFrame = function() {
        return data;
      };
      return data;
    }
    var _missingPluginHelper = require_missing_plugin_helper();
    function* parser2(pluginPasses, {
      parserOpts,
      highlightCode = true,
      filename = "unknown"
    }, code) {
      try {
        const results = [];
        for (const plugins2 of pluginPasses) {
          for (const plugin3 of plugins2) {
            const {
              parserOverride
            } = plugin3;
            if (parserOverride) {
              const ast = parserOverride(code, parserOpts, _parser().parse);
              if (ast !== void 0) results.push(ast);
            }
          }
        }
        if (results.length === 0) {
          return (0, _parser().parse)(code, parserOpts);
        } else if (results.length === 1) {
          yield* [];
          if (typeof results[0].then === "function") {
            throw new Error(`You appear to be using an async parser plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
          }
          return results[0];
        }
        throw new Error("More than one plugin attempted to override parsing.");
      } catch (err) {
        if (err.code === "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED") {
          err.message += "\nConsider renaming the file to '.mjs', or setting sourceType:module or sourceType:unambiguous in your Babel config for this file.";
        }
        const {
          loc,
          missingPlugin
        } = err;
        if (loc) {
          const codeFrame = (0, _codeFrame().codeFrameColumns)(code, {
            start: {
              line: loc.line,
              column: loc.column + 1
            }
          }, {
            highlightCode
          });
          if (missingPlugin) {
            err.message = `${filename}: ` + (0, _missingPluginHelper.default)(missingPlugin[0], loc, codeFrame, filename);
          } else {
            err.message = `${filename}: ${err.message}

` + codeFrame;
          }
          err.code = "BABEL_PARSE_ERROR";
        }
        throw err;
      }
    }
  }
});

// node_modules/@babel/core/lib/transformation/util/clone-deep.js
var require_clone_deep = __commonJS({
  "node_modules/@babel/core/lib/transformation/util/clone-deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    function deepClone(value2, cache2) {
      if (value2 !== null) {
        if (cache2.has(value2)) return cache2.get(value2);
        let cloned;
        if (Array.isArray(value2)) {
          cloned = new Array(value2.length);
          cache2.set(value2, cloned);
          for (let i = 0; i < value2.length; i++) {
            cloned[i] = typeof value2[i] !== "object" ? value2[i] : deepClone(value2[i], cache2);
          }
        } else {
          cloned = {};
          cache2.set(value2, cloned);
          const keys = Object.keys(value2);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            cloned[key] = typeof value2[key] !== "object" ? value2[key] : deepClone(value2[key], cache2);
          }
        }
        return cloned;
      }
      return value2;
    }
    function _default(value2) {
      if (typeof value2 !== "object") return value2;
      return deepClone(value2, /* @__PURE__ */ new Map());
    }
  }
});

// node_modules/@babel/core/lib/transformation/normalize-file.js
var require_normalize_file = __commonJS({
  "node_modules/@babel/core/lib/transformation/normalize-file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = normalizeFile;
    function _fs3() {
      const data = __require("fs");
      _fs3 = function() {
        return data;
      };
      return data;
    }
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    function _debug2() {
      const data = require_src();
      _debug2 = function() {
        return data;
      };
      return data;
    }
    function _t() {
      const data = require_lib3();
      _t = function() {
        return data;
      };
      return data;
    }
    function _convertSourceMap() {
      const data = require_convert_source_map();
      _convertSourceMap = function() {
        return data;
      };
      return data;
    }
    var _file = require_file();
    var _index = require_parser2();
    var _cloneDeep = require_clone_deep();
    var {
      file,
      traverseFast
    } = _t();
    var debug2 = _debug2()("babel:transform:file");
    var INLINE_SOURCEMAP_REGEX = /^[@#]\s+sourceMappingURL=data:(?:application|text)\/json;(?:charset[:=]\S+?;)?base64,.*$/;
    var EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \t]+sourceMappingURL=([^\s'"`]+)[ \t]*$/;
    function* normalizeFile(pluginPasses, options2, code, ast) {
      code = `${code || ""}`;
      if (ast) {
        if (ast.type === "Program") {
          ast = file(ast, [], []);
        } else if (ast.type !== "File") {
          throw new Error("AST root must be a Program or File node");
        }
        if (options2.cloneInputAst) {
          ast = (0, _cloneDeep.default)(ast);
        }
      } else {
        ast = yield* (0, _index.default)(pluginPasses, options2, code);
      }
      let inputMap = null;
      if (options2.inputSourceMap !== false) {
        if (typeof options2.inputSourceMap === "object") {
          inputMap = _convertSourceMap().fromObject(options2.inputSourceMap);
        }
        if (!inputMap) {
          const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);
          if (lastComment) {
            try {
              inputMap = _convertSourceMap().fromComment("//" + lastComment);
            } catch (err) {
              {
                debug2("discarding unknown inline input sourcemap");
              }
            }
          }
        }
        if (!inputMap) {
          const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);
          if (typeof options2.filename === "string" && lastComment) {
            try {
              const match2 = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment);
              const inputMapContent = _fs3().readFileSync(_path2().resolve(_path2().dirname(options2.filename), match2[1]), "utf8");
              inputMap = _convertSourceMap().fromJSON(inputMapContent);
            } catch (err) {
              debug2("discarding unknown file input sourcemap", err);
            }
          } else if (lastComment) {
            debug2("discarding un-loadable file input sourcemap");
          }
        }
      }
      return new _file.default(options2, {
        code,
        ast,
        inputMap
      });
    }
    function extractCommentsFromList(regex2, comments, lastComment) {
      if (comments) {
        comments = comments.filter(({
          value: value2
        }) => {
          if (regex2.test(value2)) {
            lastComment = value2;
            return false;
          }
          return true;
        });
      }
      return [comments, lastComment];
    }
    function extractComments(regex2, ast) {
      let lastComment = null;
      traverseFast(ast, (node3) => {
        [node3.leadingComments, lastComment] = extractCommentsFromList(regex2, node3.leadingComments, lastComment);
        [node3.innerComments, lastComment] = extractCommentsFromList(regex2, node3.innerComments, lastComment);
        [node3.trailingComments, lastComment] = extractCommentsFromList(regex2, node3.trailingComments, lastComment);
      });
      return lastComment;
    }
  }
});

// node_modules/@ampproject/remapping/dist/remapping.umd.js
var require_remapping_umd = __commonJS({
  "node_modules/@ampproject/remapping/dist/remapping.umd.js"(exports2, module) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module !== "undefined" ? module.exports = factory(require_trace_mapping_umd(), require_gen_mapping_umd()) : typeof define === "function" && define.amd ? define(["@jridgewell/trace-mapping", "@jridgewell/gen-mapping"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.remapping = factory(global2.traceMapping, global2.genMapping));
    })(exports2, function(traceMapping, genMapping) {
      "use strict";
      const SOURCELESS_MAPPING = /* @__PURE__ */ SegmentObject("", -1, -1, "", null, false);
      const EMPTY_SOURCES = [];
      function SegmentObject(source, line, column, name2, content, ignore) {
        return { source, line, column, name: name2, content, ignore };
      }
      function Source(map, sources, source, content, ignore) {
        return {
          map,
          sources,
          source,
          content,
          ignore
        };
      }
      function MapSource(map, sources) {
        return Source(map, sources, "", null, false);
      }
      function OriginalSource(source, content, ignore) {
        return Source(null, EMPTY_SOURCES, source, content, ignore);
      }
      function traceMappings(tree) {
        const gen = new genMapping.GenMapping({ file: tree.map.file });
        const { sources: rootSources, map } = tree;
        const rootNames = map.names;
        const rootMappings = traceMapping.decodedMappings(map);
        for (let i = 0; i < rootMappings.length; i++) {
          const segments = rootMappings[i];
          for (let j = 0; j < segments.length; j++) {
            const segment = segments[j];
            const genCol = segment[0];
            let traced = SOURCELESS_MAPPING;
            if (segment.length !== 1) {
              const source2 = rootSources[segment[1]];
              traced = originalPositionFor2(source2, segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
              if (traced == null)
                continue;
            }
            const { column, line, name: name2, content, source, ignore } = traced;
            genMapping.maybeAddSegment(gen, i, genCol, source, line, column, name2);
            if (source && content != null)
              genMapping.setSourceContent(gen, source, content);
            if (ignore)
              genMapping.setIgnore(gen, source, true);
          }
        }
        return gen;
      }
      function originalPositionFor2(source, line, column, name2) {
        if (!source.map) {
          return SegmentObject(source.source, line, column, name2, source.content, source.ignore);
        }
        const segment = traceMapping.traceSegment(source.map, line, column);
        if (segment == null)
          return null;
        if (segment.length === 1)
          return SOURCELESS_MAPPING;
        return originalPositionFor2(source.sources[segment[1]], segment[2], segment[3], segment.length === 5 ? source.map.names[segment[4]] : name2);
      }
      function asArray(value2) {
        if (Array.isArray(value2))
          return value2;
        return [value2];
      }
      function buildSourceMapTree(input, loader) {
        const maps = asArray(input).map((m) => new traceMapping.TraceMap(m, ""));
        const map = maps.pop();
        for (let i = 0; i < maps.length; i++) {
          if (maps[i].sources.length > 1) {
            throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
          }
        }
        let tree = build3(map, loader, "", 0);
        for (let i = maps.length - 1; i >= 0; i--) {
          tree = MapSource(maps[i], [tree]);
        }
        return tree;
      }
      function build3(map, loader, importer, importerDepth) {
        const { resolvedSources, sourcesContent, ignoreList } = map;
        const depth2 = importerDepth + 1;
        const children = resolvedSources.map((sourceFile, i) => {
          const ctx = {
            importer,
            depth: depth2,
            source: sourceFile || "",
            content: void 0,
            ignore: void 0
          };
          const sourceMap = loader(ctx.source, ctx);
          const { source, content, ignore } = ctx;
          if (sourceMap)
            return build3(new traceMapping.TraceMap(sourceMap, source), loader, source, depth2);
          const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
          const ignored = ignore !== void 0 ? ignore : ignoreList ? ignoreList.includes(i) : false;
          return OriginalSource(source, sourceContent, ignored);
        });
        return MapSource(map, children);
      }
      class SourceMap {
        constructor(map, options2) {
          const out = options2.decodedMappings ? genMapping.toDecodedMap(map) : genMapping.toEncodedMap(map);
          this.version = out.version;
          this.file = out.file;
          this.mappings = out.mappings;
          this.names = out.names;
          this.ignoreList = out.ignoreList;
          this.sourceRoot = out.sourceRoot;
          this.sources = out.sources;
          if (!options2.excludeContent) {
            this.sourcesContent = out.sourcesContent;
          }
        }
        toString() {
          return JSON.stringify(this);
        }
      }
      function remapping(input, loader, options2) {
        const opts = typeof options2 === "object" ? options2 : { excludeContent: !!options2, decodedMappings: false };
        const tree = buildSourceMapTree(input, loader);
        return new SourceMap(traceMappings(tree), opts);
      }
      return remapping;
    });
  }
});

// node_modules/@babel/core/lib/transformation/file/merge-map.js
var require_merge_map = __commonJS({
  "node_modules/@babel/core/lib/transformation/file/merge-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = mergeSourceMap;
    function _remapping() {
      const data = require_remapping_umd();
      _remapping = function() {
        return data;
      };
      return data;
    }
    function mergeSourceMap(inputMap, map, sourceFileName) {
      const source = sourceFileName.replace(/\\/g, "/");
      let found2 = false;
      const result = _remapping()(rootless(map), (s, ctx) => {
        if (s === source && !found2) {
          found2 = true;
          ctx.source = "";
          return rootless(inputMap);
        }
        return null;
      });
      if (typeof inputMap.sourceRoot === "string") {
        result.sourceRoot = inputMap.sourceRoot;
      }
      return Object.assign({}, result);
    }
    function rootless(map) {
      return Object.assign({}, map, {
        sourceRoot: null
      });
    }
  }
});

// node_modules/@babel/core/lib/transformation/file/generate.js
var require_generate = __commonJS({
  "node_modules/@babel/core/lib/transformation/file/generate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = generateCode;
    function _convertSourceMap() {
      const data = require_convert_source_map();
      _convertSourceMap = function() {
        return data;
      };
      return data;
    }
    function _generator() {
      const data = require_lib8();
      _generator = function() {
        return data;
      };
      return data;
    }
    var _mergeMap = require_merge_map();
    function generateCode(pluginPasses, file) {
      const {
        opts,
        ast,
        code,
        inputMap
      } = file;
      const {
        generatorOpts
      } = opts;
      generatorOpts.inputSourceMap = inputMap == null ? void 0 : inputMap.toObject();
      const results = [];
      for (const plugins2 of pluginPasses) {
        for (const plugin3 of plugins2) {
          const {
            generatorOverride
          } = plugin3;
          if (generatorOverride) {
            const result2 = generatorOverride(ast, generatorOpts, code, _generator().default);
            if (result2 !== void 0) results.push(result2);
          }
        }
      }
      let result;
      if (results.length === 0) {
        result = (0, _generator().default)(ast, generatorOpts, code);
      } else if (results.length === 1) {
        result = results[0];
        if (typeof result.then === "function") {
          throw new Error(`You appear to be using an async codegen plugin, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version.`);
        }
      } else {
        throw new Error("More than one plugin attempted to override codegen.");
      }
      let {
        code: outputCode,
        decodedMap: outputMap = result.map
      } = result;
      if (result.__mergedMap) {
        outputMap = Object.assign({}, result.map);
      } else {
        if (outputMap) {
          if (inputMap) {
            outputMap = (0, _mergeMap.default)(inputMap.toObject(), outputMap, generatorOpts.sourceFileName);
          } else {
            outputMap = result.map;
          }
        }
      }
      if (opts.sourceMaps === "inline" || opts.sourceMaps === "both") {
        outputCode += "\n" + _convertSourceMap().fromObject(outputMap).toComment();
      }
      if (opts.sourceMaps === "inline") {
        outputMap = null;
      }
      return {
        outputCode,
        outputMap
      };
    }
  }
});

// node_modules/@babel/core/lib/transformation/index.js
var require_transformation = __commonJS({
  "node_modules/@babel/core/lib/transformation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.run = run;
    function _traverse() {
      const data = require_lib9();
      _traverse = function() {
        return data;
      };
      return data;
    }
    var _pluginPass = require_plugin_pass();
    var _blockHoistPlugin = require_block_hoist_plugin();
    var _normalizeOpts = require_normalize_opts();
    var _normalizeFile = require_normalize_file();
    var _generate = require_generate();
    var _deepArray = require_deep_array();
    var _async = require_async();
    function* run(config2, code, ast) {
      const file = yield* (0, _normalizeFile.default)(config2.passes, (0, _normalizeOpts.default)(config2), code, ast);
      const opts = file.opts;
      try {
        yield* transformFile(file, config2.passes);
      } catch (e) {
        var _opts$filename;
        e.message = `${(_opts$filename = opts.filename) != null ? _opts$filename : "unknown file"}: ${e.message}`;
        if (!e.code) {
          e.code = "BABEL_TRANSFORM_ERROR";
        }
        throw e;
      }
      let outputCode, outputMap;
      try {
        if (opts.code !== false) {
          ({
            outputCode,
            outputMap
          } = (0, _generate.default)(config2.passes, file));
        }
      } catch (e) {
        var _opts$filename2;
        e.message = `${(_opts$filename2 = opts.filename) != null ? _opts$filename2 : "unknown file"}: ${e.message}`;
        if (!e.code) {
          e.code = "BABEL_GENERATE_ERROR";
        }
        throw e;
      }
      return {
        metadata: file.metadata,
        options: opts,
        ast: opts.ast === true ? file.ast : null,
        code: outputCode === void 0 ? null : outputCode,
        map: outputMap === void 0 ? null : outputMap,
        sourceType: file.ast.program.sourceType,
        externalDependencies: (0, _deepArray.flattenToSet)(config2.externalDependencies)
      };
    }
    function* transformFile(file, pluginPasses) {
      const async2 = yield* (0, _async.isAsync)();
      for (const pluginPairs of pluginPasses) {
        const passPairs = [];
        const passes = [];
        const visitors = [];
        for (const plugin3 of pluginPairs.concat([(0, _blockHoistPlugin.default)()])) {
          const pass = new _pluginPass.default(file, plugin3.key, plugin3.options, async2);
          passPairs.push([plugin3, pass]);
          passes.push(pass);
          visitors.push(plugin3.visitor);
        }
        for (const [plugin3, pass] of passPairs) {
          if (plugin3.pre) {
            const fn = (0, _async.maybeAsync)(plugin3.pre, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);
            yield* fn.call(pass, file);
          }
        }
        const visitor = _traverse().default.visitors.merge(visitors, passes, file.opts.wrapPluginVisitorMethod);
        {
          (0, _traverse().default)(file.ast, visitor, file.scope);
        }
        for (const [plugin3, pass] of passPairs) {
          if (plugin3.post) {
            const fn = (0, _async.maybeAsync)(plugin3.post, `You appear to be using an async plugin/preset, but Babel has been called synchronously`);
            yield* fn.call(pass, file);
          }
        }
      }
    }
  }
});

// node_modules/@babel/core/lib/transform-file.js
var require_transform_file = __commonJS({
  "node_modules/@babel/core/lib/transform-file.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.transformFile = transformFile;
    exports2.transformFileAsync = transformFileAsync;
    exports2.transformFileSync = transformFileSync;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _index = require_config();
    var _index2 = require_transformation();
    var fs6 = require_fs();
    var transformFileRunner = _gensync()(function* (filename, opts) {
      const options2 = Object.assign({}, opts, {
        filename
      });
      const config2 = yield* (0, _index.default)(options2);
      if (config2 === null) return null;
      const code = yield* fs6.readFile(filename, "utf8");
      return yield* (0, _index2.run)(config2, code);
    });
    function transformFile(...args) {
      transformFileRunner.errback(...args);
    }
    function transformFileSync(...args) {
      return transformFileRunner.sync(...args);
    }
    function transformFileAsync(...args) {
      return transformFileRunner.async(...args);
    }
  }
});

// node_modules/@babel/core/lib/config/files/import.cjs
var require_import = __commonJS({
  "node_modules/@babel/core/lib/config/files/import.cjs"(exports2, module) {
    module.exports = function import_(filepath) {
      return import(filepath);
    };
  }
});

// node_modules/@babel/core/lib/config/files/module-types.js
var require_module_types = __commonJS({
  "node_modules/@babel/core/lib/config/files/module-types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = loadCodeDefault;
    exports2.supportsESM = void 0;
    var _async3 = require_async();
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    function _url() {
      const data = __require("url");
      _url = function() {
        return data;
      };
      return data;
    }
    function _semver() {
      const data = require_semver();
      _semver = function() {
        return data;
      };
      return data;
    }
    function _debug2() {
      const data = require_src();
      _debug2 = function() {
        return data;
      };
      return data;
    }
    var _rewriteStackTrace = require_rewrite_stack_trace();
    var _configError = require_config_error();
    var _transformFile = require_transform_file();
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var debug2 = _debug2()("babel:config:loading:files:module-types");
    {
      try {
        import_ = require_import();
      } catch (_unused) {
      }
    }
    var import_;
    var supportsESM = exports2.supportsESM = _semver().satisfies(process.versions.node, "^12.17 || >=13.2");
    var LOADING_CJS_FILES = /* @__PURE__ */ new Set();
    function loadCjsDefault(filepath) {
      if (LOADING_CJS_FILES.has(filepath)) {
        debug2("Auto-ignoring usage of config %o.", filepath);
        return {};
      }
      let module2;
      try {
        LOADING_CJS_FILES.add(filepath);
        module2 = (0, _rewriteStackTrace.endHiddenCallStack)(__require)(filepath);
      } finally {
        LOADING_CJS_FILES.delete(filepath);
      }
      {
        return module2 != null && (module2.__esModule || module2[Symbol.toStringTag] === "Module") ? module2.default || (arguments[1] ? module2 : void 0) : module2;
      }
    }
    var loadMjsFromPath = (0, _rewriteStackTrace.endHiddenCallStack)(function() {
      var _loadMjsFromPath = _asyncToGenerator(function* (filepath) {
        const url2 = (0, _url().pathToFileURL)(filepath).toString() + "?import";
        {
          if (!import_) {
            throw new _configError.default("Internal error: Native ECMAScript modules aren't supported by this platform.\n", filepath);
          }
          return yield import_(url2);
        }
      });
      function loadMjsFromPath2(_x) {
        return _loadMjsFromPath.apply(this, arguments);
      }
      return loadMjsFromPath2;
    }());
    var SUPPORTED_EXTENSIONS = /* @__PURE__ */ new Set([".js", ".mjs", ".cjs", ".cts"]);
    var asyncModules = /* @__PURE__ */ new Set();
    function* loadCodeDefault(filepath, loader, esmError, tlaError) {
      var _async2;
      let async2;
      let ext2 = _path2().extname(filepath);
      if (!SUPPORTED_EXTENSIONS.has(ext2)) ext2 = ".js";
      const pattern2 = `${loader} ${ext2}`;
      switch (pattern2) {
        case "require .cjs":
        case "auto .cjs": {
          return loadCjsDefault(filepath, arguments[2]);
        }
        case "require .cts":
        case "auto .cts":
          return loadCtsDefault(filepath);
        case "auto .js":
        case "require .js":
        case "require .mjs":
          try {
            {
              return loadCjsDefault(filepath, arguments[2]);
            }
          } catch (e) {
            if (e.code === "ERR_REQUIRE_ASYNC_MODULE" || e.code === "ERR_REQUIRE_CYCLE_MODULE" && asyncModules.has(filepath)) {
              var _async;
              asyncModules.add(filepath);
              if (!((_async = async2) != null ? _async : async2 = yield* (0, _async3.isAsync)())) {
                throw new _configError.default(tlaError, filepath);
              }
            } else if (e.code === "ERR_REQUIRE_ESM" || ext2 === ".mjs") {
            } else {
              throw e;
            }
          }
        case "auto .mjs":
          if ((_async2 = async2) != null ? _async2 : async2 = yield* (0, _async3.isAsync)()) {
            return (yield* (0, _async3.waitFor)(loadMjsFromPath(filepath))).default;
          }
          throw new _configError.default(esmError, filepath);
        default:
          throw new Error("Internal Babel error: unreachable code.");
      }
    }
    function loadCtsDefault(filepath) {
      const ext2 = ".cts";
      const hasTsSupport = !!(__require.extensions[".ts"] || __require.extensions[".cts"] || __require.extensions[".mts"]);
      let handler;
      if (!hasTsSupport) {
        const opts = {
          babelrc: false,
          configFile: false,
          sourceType: "unambiguous",
          sourceMaps: "inline",
          sourceFileName: _path2().basename(filepath),
          presets: [[getTSPreset(filepath), Object.assign({
            onlyRemoveTypeImports: true,
            optimizeConstEnums: true
          }, {
            allowDeclareFields: true
          })]]
        };
        handler = function(m, filename) {
          if (handler && filename.endsWith(ext2)) {
            try {
              return m._compile((0, _transformFile.transformFileSync)(filename, Object.assign({}, opts, {
                filename
              })).code, filename);
            } catch (error) {
              if (!hasTsSupport) {
                const packageJson2 = __require("@babel/preset-typescript/package.json");
                if (_semver().lt(packageJson2.version, "7.21.4")) {
                  console.error("`.cts` configuration file failed to load, please try to update `@babel/preset-typescript`.");
                }
              }
              throw error;
            }
          }
          return __require.extensions[".js"](m, filename);
        };
        __require.extensions[ext2] = handler;
      }
      try {
        return loadCjsDefault(filepath);
      } finally {
        if (!hasTsSupport) {
          if (__require.extensions[ext2] === handler) delete __require.extensions[ext2];
          handler = void 0;
        }
      }
    }
    function getTSPreset(filepath) {
      try {
        return __require("@babel/preset-typescript");
      } catch (error) {
        if (error.code !== "MODULE_NOT_FOUND") throw error;
        let message = "You appear to be using a .cts file as Babel configuration, but the `@babel/preset-typescript` package was not found: please install it!";
        {
          if (process.versions.pnp) {
            message += `
If you are using Yarn Plug'n'Play, you may also need to add the following configuration to your .yarnrc.yml file:

packageExtensions:
	"@babel/core@*":
		peerDependencies:
			"@babel/preset-typescript": "*"
`;
          }
        }
        throw new _configError.default(message, filepath);
      }
    }
  }
});

// node_modules/@babel/core/lib/config/files/configuration.js
var require_configuration = __commonJS({
  "node_modules/@babel/core/lib/config/files/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ROOT_CONFIG_FILENAMES = void 0;
    exports2.findConfigUpwards = findConfigUpwards;
    exports2.findRelativeConfig = findRelativeConfig;
    exports2.findRootConfig = findRootConfig;
    exports2.loadConfig = loadConfig;
    exports2.resolveShowConfigPath = resolveShowConfigPath;
    function _debug2() {
      const data = require_src();
      _debug2 = function() {
        return data;
      };
      return data;
    }
    function _fs3() {
      const data = __require("fs");
      _fs3 = function() {
        return data;
      };
      return data;
    }
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    function _json() {
      const data = require_lib12();
      _json = function() {
        return data;
      };
      return data;
    }
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _caching = require_caching();
    var _configApi = require_config_api();
    var _utils = require_utils2();
    var _moduleTypes = require_module_types();
    var _patternToRegex = require_pattern_to_regex();
    var _configError = require_config_error();
    var fs6 = require_fs();
    var _rewriteStackTrace = require_rewrite_stack_trace();
    var _async = require_async();
    var debug2 = _debug2()("babel:config:loading:files:configuration");
    var ROOT_CONFIG_FILENAMES = exports2.ROOT_CONFIG_FILENAMES = ["babel.config.js", "babel.config.cjs", "babel.config.mjs", "babel.config.json", "babel.config.cts"];
    var RELATIVE_CONFIG_FILENAMES = [".babelrc", ".babelrc.js", ".babelrc.cjs", ".babelrc.mjs", ".babelrc.json", ".babelrc.cts"];
    var BABELIGNORE_FILENAME = ".babelignore";
    var runConfig = (0, _caching.makeWeakCache)(function* runConfig2(options2, cache2) {
      yield* [];
      return {
        options: (0, _rewriteStackTrace.endHiddenCallStack)(options2)((0, _configApi.makeConfigAPI)(cache2)),
        cacheNeedsConfiguration: !cache2.configured()
      };
    });
    function* readConfigCode(filepath, data) {
      if (!_fs3().existsSync(filepath)) return null;
      let options2 = yield* (0, _moduleTypes.default)(filepath, (yield* (0, _async.isAsync)()) ? "auto" : "require", "You appear to be using a native ECMAScript module configuration file, which is only supported when running Babel asynchronously or when using the Node.js `--experimental-require-module` flag.", "You appear to be using a configuration file that contains top-level await, which is only supported when running Babel asynchronously.");
      let cacheNeedsConfiguration = false;
      if (typeof options2 === "function") {
        ({
          options: options2,
          cacheNeedsConfiguration
        } = yield* runConfig(options2, data));
      }
      if (!options2 || typeof options2 !== "object" || Array.isArray(options2)) {
        throw new _configError.default(`Configuration should be an exported JavaScript object.`, filepath);
      }
      if (typeof options2.then === "function") {
        options2.catch == null || options2.catch(() => {
        });
        throw new _configError.default(`You appear to be using an async configuration, which your current version of Babel does not support. We may add support for this in the future, but if you're on the most recent version of @babel/core and still seeing this error, then you'll need to synchronously return your config.`, filepath);
      }
      if (cacheNeedsConfiguration) throwConfigError(filepath);
      return buildConfigFileObject(options2, filepath);
    }
    var cfboaf = /* @__PURE__ */ new WeakMap();
    function buildConfigFileObject(options2, filepath) {
      let configFilesByFilepath = cfboaf.get(options2);
      if (!configFilesByFilepath) {
        cfboaf.set(options2, configFilesByFilepath = /* @__PURE__ */ new Map());
      }
      let configFile = configFilesByFilepath.get(filepath);
      if (!configFile) {
        configFile = {
          filepath,
          dirname: _path2().dirname(filepath),
          options: options2
        };
        configFilesByFilepath.set(filepath, configFile);
      }
      return configFile;
    }
    var packageToBabelConfig = (0, _caching.makeWeakCacheSync)((file) => {
      const babel2 = file.options["babel"];
      if (babel2 === void 0) return null;
      if (typeof babel2 !== "object" || Array.isArray(babel2) || babel2 === null) {
        throw new _configError.default(`.babel property must be an object`, file.filepath);
      }
      return {
        filepath: file.filepath,
        dirname: file.dirname,
        options: babel2
      };
    });
    var readConfigJSON5 = (0, _utils.makeStaticFileCache)((filepath, content) => {
      let options2;
      try {
        options2 = _json().parse(content);
      } catch (err) {
        throw new _configError.default(`Error while parsing config - ${err.message}`, filepath);
      }
      if (!options2) throw new _configError.default(`No config detected`, filepath);
      if (typeof options2 !== "object") {
        throw new _configError.default(`Config returned typeof ${typeof options2}`, filepath);
      }
      if (Array.isArray(options2)) {
        throw new _configError.default(`Expected config object but found array`, filepath);
      }
      delete options2["$schema"];
      return {
        filepath,
        dirname: _path2().dirname(filepath),
        options: options2
      };
    });
    var readIgnoreConfig = (0, _utils.makeStaticFileCache)((filepath, content) => {
      const ignoreDir = _path2().dirname(filepath);
      const ignorePatterns = content.split("\n").map((line) => line.replace(/#.*$/, "").trim()).filter(Boolean);
      for (const pattern2 of ignorePatterns) {
        if (pattern2[0] === "!") {
          throw new _configError.default(`Negation of file paths is not supported.`, filepath);
        }
      }
      return {
        filepath,
        dirname: _path2().dirname(filepath),
        ignore: ignorePatterns.map((pattern2) => (0, _patternToRegex.default)(pattern2, ignoreDir))
      };
    });
    function findConfigUpwards(rootDir) {
      let dirname4 = rootDir;
      for (; ; ) {
        for (const filename of ROOT_CONFIG_FILENAMES) {
          if (_fs3().existsSync(_path2().join(dirname4, filename))) {
            return dirname4;
          }
        }
        const nextDir = _path2().dirname(dirname4);
        if (dirname4 === nextDir) break;
        dirname4 = nextDir;
      }
      return null;
    }
    function* findRelativeConfig(packageData, envName, caller) {
      let config2 = null;
      let ignore = null;
      const dirname4 = _path2().dirname(packageData.filepath);
      for (const loc of packageData.directories) {
        if (!config2) {
          var _packageData$pkg;
          config2 = yield* loadOneConfig(RELATIVE_CONFIG_FILENAMES, loc, envName, caller, ((_packageData$pkg = packageData.pkg) == null ? void 0 : _packageData$pkg.dirname) === loc ? packageToBabelConfig(packageData.pkg) : null);
        }
        if (!ignore) {
          const ignoreLoc = _path2().join(loc, BABELIGNORE_FILENAME);
          ignore = yield* readIgnoreConfig(ignoreLoc);
          if (ignore) {
            debug2("Found ignore %o from %o.", ignore.filepath, dirname4);
          }
        }
      }
      return {
        config: config2,
        ignore
      };
    }
    function findRootConfig(dirname4, envName, caller) {
      return loadOneConfig(ROOT_CONFIG_FILENAMES, dirname4, envName, caller);
    }
    function* loadOneConfig(names, dirname4, envName, caller, previousConfig = null) {
      const configs = yield* _gensync().all(names.map((filename) => readConfig(_path2().join(dirname4, filename), envName, caller)));
      const config2 = configs.reduce((previousConfig2, config3) => {
        if (config3 && previousConfig2) {
          throw new _configError.default(`Multiple configuration files found. Please remove one:
 - ${_path2().basename(previousConfig2.filepath)}
 - ${config3.filepath}
from ${dirname4}`);
        }
        return config3 || previousConfig2;
      }, previousConfig);
      if (config2) {
        debug2("Found configuration %o from %o.", config2.filepath, dirname4);
      }
      return config2;
    }
    function* loadConfig(name2, dirname4, envName, caller) {
      const filepath = (((v, w) => (v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, "8.9") ? __require.resolve : (r, {
        paths: [b]
      }, M = __require("module")) => {
        let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
        if (f) return f;
        f = new Error(`Cannot resolve module '${r}'`);
        f.code = "MODULE_NOT_FOUND";
        throw f;
      })(name2, {
        paths: [dirname4]
      });
      const conf = yield* readConfig(filepath, envName, caller);
      if (!conf) {
        throw new _configError.default(`Config file contains no configuration data`, filepath);
      }
      debug2("Loaded config %o from %o.", name2, dirname4);
      return conf;
    }
    function readConfig(filepath, envName, caller) {
      const ext2 = _path2().extname(filepath);
      switch (ext2) {
        case ".js":
        case ".cjs":
        case ".mjs":
        case ".cts":
          return readConfigCode(filepath, {
            envName,
            caller
          });
        default:
          return readConfigJSON5(filepath);
      }
    }
    function* resolveShowConfigPath(dirname4) {
      const targetPath = process.env.BABEL_SHOW_CONFIG_FOR;
      if (targetPath != null) {
        const absolutePath = _path2().resolve(dirname4, targetPath);
        const stats = yield* fs6.stat(absolutePath);
        if (!stats.isFile()) {
          throw new Error(`${absolutePath}: BABEL_SHOW_CONFIG_FOR must refer to a regular file, directories are not supported.`);
        }
        return absolutePath;
      }
      return null;
    }
    function throwConfigError(filepath) {
      throw new _configError.default(`Caching was left unconfigured. Babel's plugins, presets, and .babelrc.js files can be configured
for various types of caching, using the first param of their handler functions:

module.exports = function(api) {
  // The API exposes the following:

  // Cache the returned value forever and don't call this function again.
  api.cache(true);

  // Don't cache at all. Not recommended because it will be very slow.
  api.cache(false);

  // Cached based on the value of some function. If this function returns a value different from
  // a previously-encountered value, the plugins will re-evaluate.
  var env = api.cache(() => process.env.NODE_ENV);

  // If testing for a specific env, we recommend specifics to avoid instantiating a plugin for
  // any possible NODE_ENV value that might come up during plugin execution.
  var isProd = api.cache(() => process.env.NODE_ENV === "production");

  // .cache(fn) will perform a linear search though instances to find the matching plugin based
  // based on previous instantiated plugins. If you want to recreate the plugin and discard the
  // previous instance whenever something changes, you may use:
  var isProd = api.cache.invalidate(() => process.env.NODE_ENV === "production");

  // Note, we also expose the following more-verbose versions of the above examples:
  api.cache.forever(); // api.cache(true)
  api.cache.never();   // api.cache(false)
  api.cache.using(fn); // api.cache(fn)

  // Return the value that will be cached.
  return { };
};`, filepath);
    }
  }
});

// node_modules/@babel/core/lib/vendor/import-meta-resolve.js
var require_import_meta_resolve = __commonJS({
  "node_modules/@babel/core/lib/vendor/import-meta-resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.moduleResolve = moduleResolve;
    exports2.resolve = resolve8;
    function _assert() {
      const data = __require("assert");
      _assert = function() {
        return data;
      };
      return data;
    }
    function _fs3() {
      const data = _interopRequireWildcard(__require("fs"), true);
      _fs3 = function() {
        return data;
      };
      return data;
    }
    function _process() {
      const data = __require("process");
      _process = function() {
        return data;
      };
      return data;
    }
    function _url() {
      const data = __require("url");
      _url = function() {
        return data;
      };
      return data;
    }
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    function _module() {
      const data = __require("module");
      _module = function() {
        return data;
      };
      return data;
    }
    function _v() {
      const data = __require("v8");
      _v = function() {
        return data;
      };
      return data;
    }
    function _util() {
      const data = __require("util");
      _util = function() {
        return data;
      };
      return data;
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != typeof e && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    var own$12 = {}.hasOwnProperty;
    var classRegExp2 = /^([A-Z][a-z\d]*)+$/;
    var kTypes2 = /* @__PURE__ */ new Set(["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]);
    var codes2 = {};
    function formatList2(array2, type = "and") {
      return array2.length < 3 ? array2.join(` ${type} `) : `${array2.slice(0, -1).join(", ")}, ${type} ${array2[array2.length - 1]}`;
    }
    var messages2 = /* @__PURE__ */ new Map();
    var nodeInternalPrefix2 = "__node_internal_";
    var userStackTraceLimit2;
    codes2.ERR_INVALID_ARG_TYPE = createError3("ERR_INVALID_ARG_TYPE", (name2, expected, actual) => {
      _assert()(typeof name2 === "string", "'name' must be a string");
      if (!Array.isArray(expected)) {
        expected = [expected];
      }
      let message = "The ";
      if (name2.endsWith(" argument")) {
        message += `${name2} `;
      } else {
        const type = name2.includes(".") ? "property" : "argument";
        message += `"${name2}" ${type} `;
      }
      message += "must be ";
      const types3 = [];
      const instances = [];
      const other = [];
      for (const value2 of expected) {
        _assert()(typeof value2 === "string", "All expected entries have to be of type string");
        if (kTypes2.has(value2)) {
          types3.push(value2.toLowerCase());
        } else if (classRegExp2.exec(value2) === null) {
          _assert()(value2 !== "object", 'The value "object" should be written as "Object"');
          other.push(value2);
        } else {
          instances.push(value2);
        }
      }
      if (instances.length > 0) {
        const pos = types3.indexOf("object");
        if (pos !== -1) {
          types3.slice(pos, 1);
          instances.push("Object");
        }
      }
      if (types3.length > 0) {
        message += `${types3.length > 1 ? "one of type" : "of type"} ${formatList2(types3, "or")}`;
        if (instances.length > 0 || other.length > 0) message += " or ";
      }
      if (instances.length > 0) {
        message += `an instance of ${formatList2(instances, "or")}`;
        if (other.length > 0) message += " or ";
      }
      if (other.length > 0) {
        if (other.length > 1) {
          message += `one of ${formatList2(other, "or")}`;
        } else {
          if (other[0].toLowerCase() !== other[0]) message += "an ";
          message += `${other[0]}`;
        }
      }
      message += `. Received ${determineSpecificType2(actual)}`;
      return message;
    }, TypeError);
    codes2.ERR_INVALID_MODULE_SPECIFIER = createError3("ERR_INVALID_MODULE_SPECIFIER", (request, reason, base = void 0) => {
      return `Invalid module "${request}" ${reason}${base ? ` imported from ${base}` : ""}`;
    }, TypeError);
    codes2.ERR_INVALID_PACKAGE_CONFIG = createError3("ERR_INVALID_PACKAGE_CONFIG", (path9, base, message) => {
      return `Invalid package config ${path9}${base ? ` while importing ${base}` : ""}${message ? `. ${message}` : ""}`;
    }, Error);
    codes2.ERR_INVALID_PACKAGE_TARGET = createError3("ERR_INVALID_PACKAGE_TARGET", (packagePath, key, target, isImport = false, base = void 0) => {
      const relatedError = typeof target === "string" && !isImport && target.length > 0 && !target.startsWith("./");
      if (key === ".") {
        _assert()(isImport === false);
        return `Invalid "exports" main target ${JSON.stringify(target)} defined in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
      }
      return `Invalid "${isImport ? "imports" : "exports"}" target ${JSON.stringify(target)} defined for '${key}' in the package config ${packagePath}package.json${base ? ` imported from ${base}` : ""}${relatedError ? '; targets must start with "./"' : ""}`;
    }, Error);
    codes2.ERR_MODULE_NOT_FOUND = createError3("ERR_MODULE_NOT_FOUND", (path9, base, exactUrl = false) => {
      return `Cannot find ${exactUrl ? "module" : "package"} '${path9}' imported from ${base}`;
    }, Error);
    codes2.ERR_NETWORK_IMPORT_DISALLOWED = createError3("ERR_NETWORK_IMPORT_DISALLOWED", "import of '%s' by %s is not supported: %s", Error);
    codes2.ERR_PACKAGE_IMPORT_NOT_DEFINED = createError3("ERR_PACKAGE_IMPORT_NOT_DEFINED", (specifier, packagePath, base) => {
      return `Package import specifier "${specifier}" is not defined${packagePath ? ` in package ${packagePath}package.json` : ""} imported from ${base}`;
    }, TypeError);
    codes2.ERR_PACKAGE_PATH_NOT_EXPORTED = createError3("ERR_PACKAGE_PATH_NOT_EXPORTED", (packagePath, subpath, base = void 0) => {
      if (subpath === ".") return `No "exports" main defined in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
      return `Package subpath '${subpath}' is not defined by "exports" in ${packagePath}package.json${base ? ` imported from ${base}` : ""}`;
    }, Error);
    codes2.ERR_UNSUPPORTED_DIR_IMPORT = createError3("ERR_UNSUPPORTED_DIR_IMPORT", "Directory import '%s' is not supported resolving ES modules imported from %s", Error);
    codes2.ERR_UNSUPPORTED_RESOLVE_REQUEST = createError3("ERR_UNSUPPORTED_RESOLVE_REQUEST", 'Failed to resolve module specifier "%s" from "%s": Invalid relative URL or base scheme is not hierarchical.', TypeError);
    codes2.ERR_UNKNOWN_FILE_EXTENSION = createError3("ERR_UNKNOWN_FILE_EXTENSION", (extension2, path9) => {
      return `Unknown file extension "${extension2}" for ${path9}`;
    }, TypeError);
    codes2.ERR_INVALID_ARG_VALUE = createError3("ERR_INVALID_ARG_VALUE", (name2, value2, reason = "is invalid") => {
      let inspected = (0, _util().inspect)(value2);
      if (inspected.length > 128) {
        inspected = `${inspected.slice(0, 128)}...`;
      }
      const type = name2.includes(".") ? "property" : "argument";
      return `The ${type} '${name2}' ${reason}. Received ${inspected}`;
    }, TypeError);
    function createError3(sym, value2, constructor) {
      messages2.set(sym, value2);
      return makeNodeErrorWithCode2(constructor, sym);
    }
    function makeNodeErrorWithCode2(Base, key) {
      return NodeError;
      function NodeError(...parameters) {
        const limit = Error.stackTraceLimit;
        if (isErrorStackTraceLimitWritable2()) Error.stackTraceLimit = 0;
        const error = new Base();
        if (isErrorStackTraceLimitWritable2()) Error.stackTraceLimit = limit;
        const message = getMessage2(key, parameters, error);
        Object.defineProperties(error, {
          message: {
            value: message,
            enumerable: false,
            writable: true,
            configurable: true
          },
          toString: {
            value() {
              return `${this.name} [${key}]: ${this.message}`;
            },
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        captureLargerStackTrace2(error);
        error.code = key;
        return error;
      }
    }
    function isErrorStackTraceLimitWritable2() {
      try {
        if (_v().startupSnapshot.isBuildingSnapshot()) {
          return false;
        }
      } catch (_unused) {
      }
      const desc = Object.getOwnPropertyDescriptor(Error, "stackTraceLimit");
      if (desc === void 0) {
        return Object.isExtensible(Error);
      }
      return own$12.call(desc, "writable") && desc.writable !== void 0 ? desc.writable : desc.set !== void 0;
    }
    function hideStackFrames2(wrappedFunction) {
      const hidden = nodeInternalPrefix2 + wrappedFunction.name;
      Object.defineProperty(wrappedFunction, "name", {
        value: hidden
      });
      return wrappedFunction;
    }
    var captureLargerStackTrace2 = hideStackFrames2(function(error) {
      const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable2();
      if (stackTraceLimitIsWritable) {
        userStackTraceLimit2 = Error.stackTraceLimit;
        Error.stackTraceLimit = Number.POSITIVE_INFINITY;
      }
      Error.captureStackTrace(error);
      if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit2;
      return error;
    });
    function getMessage2(key, parameters, self2) {
      const message = messages2.get(key);
      _assert()(message !== void 0, "expected `message` to be found");
      if (typeof message === "function") {
        _assert()(message.length <= parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${message.length}).`);
        return Reflect.apply(message, self2, parameters);
      }
      const regex2 = /%[dfijoOs]/g;
      let expectedLength = 0;
      while (regex2.exec(message) !== null) expectedLength++;
      _assert()(expectedLength === parameters.length, `Code: ${key}; The provided arguments length (${parameters.length}) does not match the required ones (${expectedLength}).`);
      if (parameters.length === 0) return message;
      parameters.unshift(message);
      return Reflect.apply(_util().format, null, parameters);
    }
    function determineSpecificType2(value2) {
      if (value2 === null || value2 === void 0) {
        return String(value2);
      }
      if (typeof value2 === "function" && value2.name) {
        return `function ${value2.name}`;
      }
      if (typeof value2 === "object") {
        if (value2.constructor && value2.constructor.name) {
          return `an instance of ${value2.constructor.name}`;
        }
        return `${(0, _util().inspect)(value2, {
          depth: -1
        })}`;
      }
      let inspected = (0, _util().inspect)(value2, {
        colors: false
      });
      if (inspected.length > 28) {
        inspected = `${inspected.slice(0, 25)}...`;
      }
      return `type ${typeof value2} (${inspected})`;
    }
    var hasOwnProperty$12 = {}.hasOwnProperty;
    var {
      ERR_INVALID_PACKAGE_CONFIG: ERR_INVALID_PACKAGE_CONFIG$1
    } = codes2;
    var cache2 = /* @__PURE__ */ new Map();
    function read2(jsonPath, {
      base,
      specifier
    }) {
      const existing = cache2.get(jsonPath);
      if (existing) {
        return existing;
      }
      let string4;
      try {
        string4 = _fs3().default.readFileSync(_path2().toNamespacedPath(jsonPath), "utf8");
      } catch (error) {
        const exception = error;
        if (exception.code !== "ENOENT") {
          throw exception;
        }
      }
      const result = {
        exists: false,
        pjsonPath: jsonPath,
        main: void 0,
        name: void 0,
        type: "none",
        exports: void 0,
        imports: void 0
      };
      if (string4 !== void 0) {
        let parsed;
        try {
          parsed = JSON.parse(string4);
        } catch (error_) {
          const cause = error_;
          const error = new ERR_INVALID_PACKAGE_CONFIG$1(jsonPath, (base ? `"${specifier}" from ` : "") + (0, _url().fileURLToPath)(base || specifier), cause.message);
          error.cause = cause;
          throw error;
        }
        result.exists = true;
        if (hasOwnProperty$12.call(parsed, "name") && typeof parsed.name === "string") {
          result.name = parsed.name;
        }
        if (hasOwnProperty$12.call(parsed, "main") && typeof parsed.main === "string") {
          result.main = parsed.main;
        }
        if (hasOwnProperty$12.call(parsed, "exports")) {
          result.exports = parsed.exports;
        }
        if (hasOwnProperty$12.call(parsed, "imports")) {
          result.imports = parsed.imports;
        }
        if (hasOwnProperty$12.call(parsed, "type") && (parsed.type === "commonjs" || parsed.type === "module")) {
          result.type = parsed.type;
        }
      }
      cache2.set(jsonPath, result);
      return result;
    }
    function getPackageScopeConfig(resolved) {
      let packageJSONUrl = new URL("package.json", resolved);
      while (true) {
        const packageJSONPath2 = packageJSONUrl.pathname;
        if (packageJSONPath2.endsWith("node_modules/package.json")) {
          break;
        }
        const packageConfig = read2((0, _url().fileURLToPath)(packageJSONUrl), {
          specifier: resolved
        });
        if (packageConfig.exists) {
          return packageConfig;
        }
        const lastPackageJSONUrl = packageJSONUrl;
        packageJSONUrl = new URL("../package.json", packageJSONUrl);
        if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) {
          break;
        }
      }
      const packageJSONPath = (0, _url().fileURLToPath)(packageJSONUrl);
      return {
        pjsonPath: packageJSONPath,
        exists: false,
        type: "none"
      };
    }
    function getPackageType(url2) {
      return getPackageScopeConfig(url2).type;
    }
    var {
      ERR_UNKNOWN_FILE_EXTENSION
    } = codes2;
    var hasOwnProperty4 = {}.hasOwnProperty;
    var extensionFormatMap = {
      __proto__: null,
      ".cjs": "commonjs",
      ".js": "module",
      ".json": "json",
      ".mjs": "module"
    };
    function mimeToFormat(mime) {
      if (mime && /\s*(text|application)\/javascript\s*(;\s*charset=utf-?8\s*)?/i.test(mime)) return "module";
      if (mime === "application/json") return "json";
      return null;
    }
    var protocolHandlers = {
      __proto__: null,
      "data:": getDataProtocolModuleFormat,
      "file:": getFileProtocolModuleFormat,
      "http:": getHttpProtocolModuleFormat,
      "https:": getHttpProtocolModuleFormat,
      "node:"() {
        return "builtin";
      }
    };
    function getDataProtocolModuleFormat(parsed) {
      const {
        1: mime
      } = /^([^/]+\/[^;,]+)[^,]*?(;base64)?,/.exec(parsed.pathname) || [null, null, null];
      return mimeToFormat(mime);
    }
    function extname2(url2) {
      const pathname = url2.pathname;
      let index4 = pathname.length;
      while (index4--) {
        const code = pathname.codePointAt(index4);
        if (code === 47) {
          return "";
        }
        if (code === 46) {
          return pathname.codePointAt(index4 - 1) === 47 ? "" : pathname.slice(index4);
        }
      }
      return "";
    }
    function getFileProtocolModuleFormat(url2, _context, ignoreErrors) {
      const value2 = extname2(url2);
      if (value2 === ".js") {
        const packageType = getPackageType(url2);
        if (packageType !== "none") {
          return packageType;
        }
        return "commonjs";
      }
      if (value2 === "") {
        const packageType = getPackageType(url2);
        if (packageType === "none" || packageType === "commonjs") {
          return "commonjs";
        }
        return "module";
      }
      const format2 = extensionFormatMap[value2];
      if (format2) return format2;
      if (ignoreErrors) {
        return void 0;
      }
      const filepath = (0, _url().fileURLToPath)(url2);
      throw new ERR_UNKNOWN_FILE_EXTENSION(value2, filepath);
    }
    function getHttpProtocolModuleFormat() {
    }
    function defaultGetFormatWithoutErrors(url2, context) {
      const protocol = url2.protocol;
      if (!hasOwnProperty4.call(protocolHandlers, protocol)) {
        return null;
      }
      return protocolHandlers[protocol](url2, context, true) || null;
    }
    var {
      ERR_INVALID_ARG_VALUE
    } = codes2;
    var DEFAULT_CONDITIONS = Object.freeze(["node", "import"]);
    var DEFAULT_CONDITIONS_SET = new Set(DEFAULT_CONDITIONS);
    function getDefaultConditions() {
      return DEFAULT_CONDITIONS;
    }
    function getDefaultConditionsSet() {
      return DEFAULT_CONDITIONS_SET;
    }
    function getConditionsSet(conditions) {
      if (conditions !== void 0 && conditions !== getDefaultConditions()) {
        if (!Array.isArray(conditions)) {
          throw new ERR_INVALID_ARG_VALUE("conditions", conditions, "expected an array");
        }
        return new Set(conditions);
      }
      return getDefaultConditionsSet();
    }
    var RegExpPrototypeSymbolReplace = RegExp.prototype[Symbol.replace];
    var {
      ERR_NETWORK_IMPORT_DISALLOWED,
      ERR_INVALID_MODULE_SPECIFIER,
      ERR_INVALID_PACKAGE_CONFIG,
      ERR_INVALID_PACKAGE_TARGET,
      ERR_MODULE_NOT_FOUND,
      ERR_PACKAGE_IMPORT_NOT_DEFINED,
      ERR_PACKAGE_PATH_NOT_EXPORTED,
      ERR_UNSUPPORTED_DIR_IMPORT,
      ERR_UNSUPPORTED_RESOLVE_REQUEST
    } = codes2;
    var own = {}.hasOwnProperty;
    var invalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))?(\\|\/|$)/i;
    var deprecatedInvalidSegmentRegEx = /(^|\\|\/)((\.|%2e)(\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\|\/|$)/i;
    var invalidPackageNameRegEx = /^\.|%|\\/;
    var patternRegEx = /\*/g;
    var encodedSeparatorRegEx = /%2f|%5c/i;
    var emittedPackageWarnings = /* @__PURE__ */ new Set();
    var doubleSlashRegEx = /[/\\]{2}/;
    function emitInvalidSegmentDeprecation(target, request, match2, packageJsonUrl, internal, base, isTarget) {
      if (_process().noDeprecation) {
        return;
      }
      const pjsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
      const double = doubleSlashRegEx.exec(isTarget ? target : request) !== null;
      _process().emitWarning(`Use of deprecated ${double ? "double slash" : "leading or trailing slash matching"} resolving "${target}" for module request "${request}" ${request === match2 ? "" : `matched to "${match2}" `}in the "${internal ? "imports" : "exports"}" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}.`, "DeprecationWarning", "DEP0166");
    }
    function emitLegacyIndexDeprecation(url2, packageJsonUrl, base, main2) {
      if (_process().noDeprecation) {
        return;
      }
      const format2 = defaultGetFormatWithoutErrors(url2, {
        parentURL: base.href
      });
      if (format2 !== "module") return;
      const urlPath = (0, _url().fileURLToPath)(url2.href);
      const packagePath = (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl));
      const basePath = (0, _url().fileURLToPath)(base);
      if (!main2) {
        _process().emitWarning(`No "main" or "exports" field defined in the package.json for ${packagePath} resolving the main entry point "${urlPath.slice(packagePath.length)}", imported from ${basePath}.
Default "index" lookups for the main are deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
      } else if (_path2().resolve(packagePath, main2) !== urlPath) {
        _process().emitWarning(`Package ${packagePath} has a "main" field set to "${main2}", excluding the full filename and extension to the resolved file at "${urlPath.slice(packagePath.length)}", imported from ${basePath}.
 Automatic extension resolution of the "main" field is deprecated for ES modules.`, "DeprecationWarning", "DEP0151");
      }
    }
    function tryStatSync2(path9) {
      try {
        return (0, _fs3().statSync)(path9);
      } catch (_unused2) {
      }
    }
    function fileExists(url2) {
      const stats = (0, _fs3().statSync)(url2, {
        throwIfNoEntry: false
      });
      const isFile = stats ? stats.isFile() : void 0;
      return isFile === null || isFile === void 0 ? false : isFile;
    }
    function legacyMainResolve(packageJsonUrl, packageConfig, base) {
      let guess;
      if (packageConfig.main !== void 0) {
        guess = new (_url()).URL(packageConfig.main, packageJsonUrl);
        if (fileExists(guess)) return guess;
        const tries2 = [`./${packageConfig.main}.js`, `./${packageConfig.main}.json`, `./${packageConfig.main}.node`, `./${packageConfig.main}/index.js`, `./${packageConfig.main}/index.json`, `./${packageConfig.main}/index.node`];
        let i2 = -1;
        while (++i2 < tries2.length) {
          guess = new (_url()).URL(tries2[i2], packageJsonUrl);
          if (fileExists(guess)) break;
          guess = void 0;
        }
        if (guess) {
          emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
          return guess;
        }
      }
      const tries = ["./index.js", "./index.json", "./index.node"];
      let i = -1;
      while (++i < tries.length) {
        guess = new (_url()).URL(tries[i], packageJsonUrl);
        if (fileExists(guess)) break;
        guess = void 0;
      }
      if (guess) {
        emitLegacyIndexDeprecation(guess, packageJsonUrl, base, packageConfig.main);
        return guess;
      }
      throw new ERR_MODULE_NOT_FOUND((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), (0, _url().fileURLToPath)(base));
    }
    function finalizeResolution(resolved, base, preserveSymlinks) {
      if (encodedSeparatorRegEx.exec(resolved.pathname) !== null) {
        throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded "/" or "\\" characters', (0, _url().fileURLToPath)(base));
      }
      let filePath;
      try {
        filePath = (0, _url().fileURLToPath)(resolved);
      } catch (error) {
        const cause = error;
        Object.defineProperty(cause, "input", {
          value: String(resolved)
        });
        Object.defineProperty(cause, "module", {
          value: String(base)
        });
        throw cause;
      }
      const stats = tryStatSync2(filePath.endsWith("/") ? filePath.slice(-1) : filePath);
      if (stats && stats.isDirectory()) {
        const error = new ERR_UNSUPPORTED_DIR_IMPORT(filePath, (0, _url().fileURLToPath)(base));
        error.url = String(resolved);
        throw error;
      }
      if (!stats || !stats.isFile()) {
        const error = new ERR_MODULE_NOT_FOUND(filePath || resolved.pathname, base && (0, _url().fileURLToPath)(base), true);
        error.url = String(resolved);
        throw error;
      }
      if (!preserveSymlinks) {
        const real = (0, _fs3().realpathSync)(filePath);
        const {
          search,
          hash: hash3
        } = resolved;
        resolved = (0, _url().pathToFileURL)(real + (filePath.endsWith(_path2().sep) ? "/" : ""));
        resolved.search = search;
        resolved.hash = hash3;
      }
      return resolved;
    }
    function importNotDefined(specifier, packageJsonUrl, base) {
      return new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJsonUrl && (0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), (0, _url().fileURLToPath)(base));
    }
    function exportsNotFound(subpath, packageJsonUrl, base) {
      return new ERR_PACKAGE_PATH_NOT_EXPORTED((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, base && (0, _url().fileURLToPath)(base));
    }
    function throwInvalidSubpath(request, match2, packageJsonUrl, internal, base) {
      const reason = `request is not a valid match in pattern "${match2}" for the "${internal ? "imports" : "exports"}" resolution of ${(0, _url().fileURLToPath)(packageJsonUrl)}`;
      throw new ERR_INVALID_MODULE_SPECIFIER(request, reason, base && (0, _url().fileURLToPath)(base));
    }
    function invalidPackageTarget(subpath, target, packageJsonUrl, internal, base) {
      target = typeof target === "object" && target !== null ? JSON.stringify(target, null, "") : `${target}`;
      return new ERR_INVALID_PACKAGE_TARGET((0, _url().fileURLToPath)(new (_url()).URL(".", packageJsonUrl)), subpath, target, internal, base && (0, _url().fileURLToPath)(base));
    }
    function resolvePackageTargetString(target, subpath, match2, packageJsonUrl, base, pattern2, internal, isPathMap, conditions) {
      if (subpath !== "" && !pattern2 && target[target.length - 1] !== "/") throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
      if (!target.startsWith("./")) {
        if (internal && !target.startsWith("../") && !target.startsWith("/")) {
          let isURL3 = false;
          try {
            new (_url()).URL(target);
            isURL3 = true;
          } catch (_unused3) {
          }
          if (!isURL3) {
            const exportTarget = pattern2 ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target + subpath;
            return packageResolve(exportTarget, packageJsonUrl, conditions);
          }
        }
        throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
      }
      if (invalidSegmentRegEx.exec(target.slice(2)) !== null) {
        if (deprecatedInvalidSegmentRegEx.exec(target.slice(2)) === null) {
          if (!isPathMap) {
            const request = pattern2 ? match2.replace("*", () => subpath) : match2 + subpath;
            const resolvedTarget = pattern2 ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target;
            emitInvalidSegmentDeprecation(resolvedTarget, request, match2, packageJsonUrl, internal, base, true);
          }
        } else {
          throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
        }
      }
      const resolved = new (_url()).URL(target, packageJsonUrl);
      const resolvedPath = resolved.pathname;
      const packagePath = new (_url()).URL(".", packageJsonUrl).pathname;
      if (!resolvedPath.startsWith(packagePath)) throw invalidPackageTarget(match2, target, packageJsonUrl, internal, base);
      if (subpath === "") return resolved;
      if (invalidSegmentRegEx.exec(subpath) !== null) {
        const request = pattern2 ? match2.replace("*", () => subpath) : match2 + subpath;
        if (deprecatedInvalidSegmentRegEx.exec(subpath) === null) {
          if (!isPathMap) {
            const resolvedTarget = pattern2 ? RegExpPrototypeSymbolReplace.call(patternRegEx, target, () => subpath) : target;
            emitInvalidSegmentDeprecation(resolvedTarget, request, match2, packageJsonUrl, internal, base, false);
          }
        } else {
          throwInvalidSubpath(request, match2, packageJsonUrl, internal, base);
        }
      }
      if (pattern2) {
        return new (_url()).URL(RegExpPrototypeSymbolReplace.call(patternRegEx, resolved.href, () => subpath));
      }
      return new (_url()).URL(subpath, resolved);
    }
    function isArrayIndex(key) {
      const keyNumber = Number(key);
      if (`${keyNumber}` !== key) return false;
      return keyNumber >= 0 && keyNumber < 4294967295;
    }
    function resolvePackageTarget(packageJsonUrl, target, subpath, packageSubpath, base, pattern2, internal, isPathMap, conditions) {
      if (typeof target === "string") {
        return resolvePackageTargetString(target, subpath, packageSubpath, packageJsonUrl, base, pattern2, internal, isPathMap, conditions);
      }
      if (Array.isArray(target)) {
        const targetList = target;
        if (targetList.length === 0) return null;
        let lastException;
        let i = -1;
        while (++i < targetList.length) {
          const targetItem = targetList[i];
          let resolveResult;
          try {
            resolveResult = resolvePackageTarget(packageJsonUrl, targetItem, subpath, packageSubpath, base, pattern2, internal, isPathMap, conditions);
          } catch (error) {
            const exception = error;
            lastException = exception;
            if (exception.code === "ERR_INVALID_PACKAGE_TARGET") continue;
            throw error;
          }
          if (resolveResult === void 0) continue;
          if (resolveResult === null) {
            lastException = null;
            continue;
          }
          return resolveResult;
        }
        if (lastException === void 0 || lastException === null) {
          return null;
        }
        throw lastException;
      }
      if (typeof target === "object" && target !== null) {
        const keys = Object.getOwnPropertyNames(target);
        let i = -1;
        while (++i < keys.length) {
          const key = keys[i];
          if (isArrayIndex(key)) {
            throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, '"exports" cannot contain numeric property keys.');
          }
        }
        i = -1;
        while (++i < keys.length) {
          const key = keys[i];
          if (key === "default" || conditions && conditions.has(key)) {
            const conditionalTarget = target[key];
            const resolveResult = resolvePackageTarget(packageJsonUrl, conditionalTarget, subpath, packageSubpath, base, pattern2, internal, isPathMap, conditions);
            if (resolveResult === void 0) continue;
            return resolveResult;
          }
        }
        return null;
      }
      if (target === null) {
        return null;
      }
      throw invalidPackageTarget(packageSubpath, target, packageJsonUrl, internal, base);
    }
    function isConditionalExportsMainSugar(exports3, packageJsonUrl, base) {
      if (typeof exports3 === "string" || Array.isArray(exports3)) return true;
      if (typeof exports3 !== "object" || exports3 === null) return false;
      const keys = Object.getOwnPropertyNames(exports3);
      let isConditionalSugar = false;
      let i = 0;
      let keyIndex = -1;
      while (++keyIndex < keys.length) {
        const key = keys[keyIndex];
        const currentIsConditionalSugar = key === "" || key[0] !== ".";
        if (i++ === 0) {
          isConditionalSugar = currentIsConditionalSugar;
        } else if (isConditionalSugar !== currentIsConditionalSugar) {
          throw new ERR_INVALID_PACKAGE_CONFIG((0, _url().fileURLToPath)(packageJsonUrl), base, `"exports" cannot contain some keys starting with '.' and some not. The exports object must either be an object of package subpath keys or an object of main entry condition name keys only.`);
        }
      }
      return isConditionalSugar;
    }
    function emitTrailingSlashPatternDeprecation(match2, pjsonUrl, base) {
      if (_process().noDeprecation) {
        return;
      }
      const pjsonPath = (0, _url().fileURLToPath)(pjsonUrl);
      if (emittedPackageWarnings.has(pjsonPath + "|" + match2)) return;
      emittedPackageWarnings.add(pjsonPath + "|" + match2);
      _process().emitWarning(`Use of deprecated trailing slash pattern mapping "${match2}" in the "exports" field module resolution of the package at ${pjsonPath}${base ? ` imported from ${(0, _url().fileURLToPath)(base)}` : ""}. Mapping specifiers ending in "/" is no longer supported.`, "DeprecationWarning", "DEP0155");
    }
    function packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig, base, conditions) {
      let exports3 = packageConfig.exports;
      if (isConditionalExportsMainSugar(exports3, packageJsonUrl, base)) {
        exports3 = {
          ".": exports3
        };
      }
      if (own.call(exports3, packageSubpath) && !packageSubpath.includes("*") && !packageSubpath.endsWith("/")) {
        const target = exports3[packageSubpath];
        const resolveResult = resolvePackageTarget(packageJsonUrl, target, "", packageSubpath, base, false, false, false, conditions);
        if (resolveResult === null || resolveResult === void 0) {
          throw exportsNotFound(packageSubpath, packageJsonUrl, base);
        }
        return resolveResult;
      }
      let bestMatch = "";
      let bestMatchSubpath = "";
      const keys = Object.getOwnPropertyNames(exports3);
      let i = -1;
      while (++i < keys.length) {
        const key = keys[i];
        const patternIndex = key.indexOf("*");
        if (patternIndex !== -1 && packageSubpath.startsWith(key.slice(0, patternIndex))) {
          if (packageSubpath.endsWith("/")) {
            emitTrailingSlashPatternDeprecation(packageSubpath, packageJsonUrl, base);
          }
          const patternTrailer = key.slice(patternIndex + 1);
          if (packageSubpath.length >= key.length && packageSubpath.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
            bestMatch = key;
            bestMatchSubpath = packageSubpath.slice(patternIndex, packageSubpath.length - patternTrailer.length);
          }
        }
      }
      if (bestMatch) {
        const target = exports3[bestMatch];
        const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, false, packageSubpath.endsWith("/"), conditions);
        if (resolveResult === null || resolveResult === void 0) {
          throw exportsNotFound(packageSubpath, packageJsonUrl, base);
        }
        return resolveResult;
      }
      throw exportsNotFound(packageSubpath, packageJsonUrl, base);
    }
    function patternKeyCompare(a, b) {
      const aPatternIndex = a.indexOf("*");
      const bPatternIndex = b.indexOf("*");
      const baseLengthA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;
      const baseLengthB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;
      if (baseLengthA > baseLengthB) return -1;
      if (baseLengthB > baseLengthA) return 1;
      if (aPatternIndex === -1) return 1;
      if (bPatternIndex === -1) return -1;
      if (a.length > b.length) return -1;
      if (b.length > a.length) return 1;
      return 0;
    }
    function packageImportsResolve(name2, base, conditions) {
      if (name2 === "#" || name2.startsWith("#/") || name2.endsWith("/")) {
        const reason = "is not a valid internal imports specifier name";
        throw new ERR_INVALID_MODULE_SPECIFIER(name2, reason, (0, _url().fileURLToPath)(base));
      }
      let packageJsonUrl;
      const packageConfig = getPackageScopeConfig(base);
      if (packageConfig.exists) {
        packageJsonUrl = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
        const imports = packageConfig.imports;
        if (imports) {
          if (own.call(imports, name2) && !name2.includes("*")) {
            const resolveResult = resolvePackageTarget(packageJsonUrl, imports[name2], "", name2, base, false, true, false, conditions);
            if (resolveResult !== null && resolveResult !== void 0) {
              return resolveResult;
            }
          } else {
            let bestMatch = "";
            let bestMatchSubpath = "";
            const keys = Object.getOwnPropertyNames(imports);
            let i = -1;
            while (++i < keys.length) {
              const key = keys[i];
              const patternIndex = key.indexOf("*");
              if (patternIndex !== -1 && name2.startsWith(key.slice(0, -1))) {
                const patternTrailer = key.slice(patternIndex + 1);
                if (name2.length >= key.length && name2.endsWith(patternTrailer) && patternKeyCompare(bestMatch, key) === 1 && key.lastIndexOf("*") === patternIndex) {
                  bestMatch = key;
                  bestMatchSubpath = name2.slice(patternIndex, name2.length - patternTrailer.length);
                }
              }
            }
            if (bestMatch) {
              const target = imports[bestMatch];
              const resolveResult = resolvePackageTarget(packageJsonUrl, target, bestMatchSubpath, bestMatch, base, true, true, false, conditions);
              if (resolveResult !== null && resolveResult !== void 0) {
                return resolveResult;
              }
            }
          }
        }
      }
      throw importNotDefined(name2, packageJsonUrl, base);
    }
    function parsePackageName(specifier, base) {
      let separatorIndex = specifier.indexOf("/");
      let validPackageName = true;
      let isScoped = false;
      if (specifier[0] === "@") {
        isScoped = true;
        if (separatorIndex === -1 || specifier.length === 0) {
          validPackageName = false;
        } else {
          separatorIndex = specifier.indexOf("/", separatorIndex + 1);
        }
      }
      const packageName2 = separatorIndex === -1 ? specifier : specifier.slice(0, separatorIndex);
      if (invalidPackageNameRegEx.exec(packageName2) !== null) {
        validPackageName = false;
      }
      if (!validPackageName) {
        throw new ERR_INVALID_MODULE_SPECIFIER(specifier, "is not a valid package name", (0, _url().fileURLToPath)(base));
      }
      const packageSubpath = "." + (separatorIndex === -1 ? "" : specifier.slice(separatorIndex));
      return {
        packageName: packageName2,
        packageSubpath,
        isScoped
      };
    }
    function packageResolve(specifier, base, conditions) {
      if (_module().builtinModules.includes(specifier)) {
        return new (_url()).URL("node:" + specifier);
      }
      const {
        packageName: packageName2,
        packageSubpath,
        isScoped
      } = parsePackageName(specifier, base);
      const packageConfig = getPackageScopeConfig(base);
      if (packageConfig.exists) {
        const packageJsonUrl2 = (0, _url().pathToFileURL)(packageConfig.pjsonPath);
        if (packageConfig.name === packageName2 && packageConfig.exports !== void 0 && packageConfig.exports !== null) {
          return packageExportsResolve(packageJsonUrl2, packageSubpath, packageConfig, base, conditions);
        }
      }
      let packageJsonUrl = new (_url()).URL("./node_modules/" + packageName2 + "/package.json", base);
      let packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
      let lastPath;
      do {
        const stat3 = tryStatSync2(packageJsonPath.slice(0, -13));
        if (!stat3 || !stat3.isDirectory()) {
          lastPath = packageJsonPath;
          packageJsonUrl = new (_url()).URL((isScoped ? "../../../../node_modules/" : "../../../node_modules/") + packageName2 + "/package.json", packageJsonUrl);
          packageJsonPath = (0, _url().fileURLToPath)(packageJsonUrl);
          continue;
        }
        const packageConfig2 = read2(packageJsonPath, {
          base,
          specifier
        });
        if (packageConfig2.exports !== void 0 && packageConfig2.exports !== null) {
          return packageExportsResolve(packageJsonUrl, packageSubpath, packageConfig2, base, conditions);
        }
        if (packageSubpath === ".") {
          return legacyMainResolve(packageJsonUrl, packageConfig2, base);
        }
        return new (_url()).URL(packageSubpath, packageJsonUrl);
      } while (packageJsonPath.length !== lastPath.length);
      throw new ERR_MODULE_NOT_FOUND(packageName2, (0, _url().fileURLToPath)(base), false);
    }
    function isRelativeSpecifier(specifier) {
      if (specifier[0] === ".") {
        if (specifier.length === 1 || specifier[1] === "/") return true;
        if (specifier[1] === "." && (specifier.length === 2 || specifier[2] === "/")) {
          return true;
        }
      }
      return false;
    }
    function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {
      if (specifier === "") return false;
      if (specifier[0] === "/") return true;
      return isRelativeSpecifier(specifier);
    }
    function moduleResolve(specifier, base, conditions, preserveSymlinks) {
      const protocol = base.protocol;
      const isData = protocol === "data:";
      const isRemote = isData || protocol === "http:" || protocol === "https:";
      let resolved;
      if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
        try {
          resolved = new (_url()).URL(specifier, base);
        } catch (error_) {
          const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
          error.cause = error_;
          throw error;
        }
      } else if (protocol === "file:" && specifier[0] === "#") {
        resolved = packageImportsResolve(specifier, base, conditions);
      } else {
        try {
          resolved = new (_url()).URL(specifier);
        } catch (error_) {
          if (isRemote && !_module().builtinModules.includes(specifier)) {
            const error = new ERR_UNSUPPORTED_RESOLVE_REQUEST(specifier, base);
            error.cause = error_;
            throw error;
          }
          resolved = packageResolve(specifier, base, conditions);
        }
      }
      _assert()(resolved !== void 0, "expected to be defined");
      if (resolved.protocol !== "file:") {
        return resolved;
      }
      return finalizeResolution(resolved, base, preserveSymlinks);
    }
    function checkIfDisallowedImport(specifier, parsed, parsedParentURL) {
      if (parsedParentURL) {
        const parentProtocol = parsedParentURL.protocol;
        if (parentProtocol === "http:" || parentProtocol === "https:") {
          if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {
            const parsedProtocol = parsed == null ? void 0 : parsed.protocol;
            if (parsedProtocol && parsedProtocol !== "https:" && parsedProtocol !== "http:") {
              throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "remote imports cannot import from a local location.");
            }
            return {
              url: (parsed == null ? void 0 : parsed.href) || ""
            };
          }
          if (_module().builtinModules.includes(specifier)) {
            throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "remote imports cannot import from a local location.");
          }
          throw new ERR_NETWORK_IMPORT_DISALLOWED(specifier, parsedParentURL, "only relative and absolute specifiers are supported.");
        }
      }
    }
    function isURL2(self2) {
      return Boolean(self2 && typeof self2 === "object" && "href" in self2 && typeof self2.href === "string" && "protocol" in self2 && typeof self2.protocol === "string" && self2.href && self2.protocol);
    }
    function throwIfInvalidParentURL(parentURL) {
      if (parentURL === void 0) {
        return;
      }
      if (typeof parentURL !== "string" && !isURL2(parentURL)) {
        throw new codes2.ERR_INVALID_ARG_TYPE("parentURL", ["string", "URL"], parentURL);
      }
    }
    function defaultResolve(specifier, context = {}) {
      const {
        parentURL
      } = context;
      _assert()(parentURL !== void 0, "expected `parentURL` to be defined");
      throwIfInvalidParentURL(parentURL);
      let parsedParentURL;
      if (parentURL) {
        try {
          parsedParentURL = new (_url()).URL(parentURL);
        } catch (_unused4) {
        }
      }
      let parsed;
      let protocol;
      try {
        parsed = shouldBeTreatedAsRelativeOrAbsolutePath(specifier) ? new (_url()).URL(specifier, parsedParentURL) : new (_url()).URL(specifier);
        protocol = parsed.protocol;
        if (protocol === "data:") {
          return {
            url: parsed.href,
            format: null
          };
        }
      } catch (_unused5) {
      }
      const maybeReturn = checkIfDisallowedImport(specifier, parsed, parsedParentURL);
      if (maybeReturn) return maybeReturn;
      if (protocol === void 0 && parsed) {
        protocol = parsed.protocol;
      }
      if (protocol === "node:") {
        return {
          url: specifier
        };
      }
      if (parsed && parsed.protocol === "node:") return {
        url: specifier
      };
      const conditions = getConditionsSet(context.conditions);
      const url2 = moduleResolve(specifier, new (_url()).URL(parentURL), conditions, false);
      return {
        url: url2.href,
        format: defaultGetFormatWithoutErrors(url2, {
          parentURL
        })
      };
    }
    function resolve8(specifier, parent) {
      if (!parent) {
        throw new Error("Please pass `parent`: `import-meta-resolve` cannot ponyfill that");
      }
      try {
        return defaultResolve(specifier, {
          parentURL: parent
        }).url;
      } catch (error) {
        const exception = error;
        if ((exception.code === "ERR_UNSUPPORTED_DIR_IMPORT" || exception.code === "ERR_MODULE_NOT_FOUND") && typeof exception.url === "string") {
          return exception.url;
        }
        throw error;
      }
    }
  }
});

// node_modules/@babel/core/lib/config/files/plugins.js
var require_plugins4 = __commonJS({
  "node_modules/@babel/core/lib/config/files/plugins.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.loadPlugin = loadPlugin2;
    exports2.loadPreset = loadPreset;
    exports2.resolvePreset = exports2.resolvePlugin = void 0;
    function _debug2() {
      const data = require_src();
      _debug2 = function() {
        return data;
      };
      return data;
    }
    function _path2() {
      const data = __require("path");
      _path2 = function() {
        return data;
      };
      return data;
    }
    var _async = require_async();
    var _moduleTypes = require_module_types();
    function _url() {
      const data = __require("url");
      _url = function() {
        return data;
      };
      return data;
    }
    var _importMetaResolve = require_import_meta_resolve();
    function _fs3() {
      const data = __require("fs");
      _fs3 = function() {
        return data;
      };
      return data;
    }
    var debug2 = _debug2()("babel:config:loading:files:plugins");
    var EXACT_RE = /^module:/;
    var BABEL_PLUGIN_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-plugin-)/;
    var BABEL_PRESET_PREFIX_RE = /^(?!@|module:|[^/]+\/|babel-preset-)/;
    var BABEL_PLUGIN_ORG_RE = /^(@babel\/)(?!plugin-|[^/]+\/)/;
    var BABEL_PRESET_ORG_RE = /^(@babel\/)(?!preset-|[^/]+\/)/;
    var OTHER_PLUGIN_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-plugin(?:-|\/|$)|[^/]+\/)/;
    var OTHER_PRESET_ORG_RE = /^(@(?!babel\/)[^/]+\/)(?![^/]*babel-preset(?:-|\/|$)|[^/]+\/)/;
    var OTHER_ORG_DEFAULT_RE = /^(@(?!babel$)[^/]+)$/;
    var resolvePlugin = exports2.resolvePlugin = resolveStandardizedName.bind(null, "plugin");
    var resolvePreset = exports2.resolvePreset = resolveStandardizedName.bind(null, "preset");
    function* loadPlugin2(name2, dirname4) {
      const {
        filepath,
        loader
      } = resolvePlugin(name2, dirname4, yield* (0, _async.isAsync)());
      const value2 = yield* requireModule("plugin", loader, filepath);
      debug2("Loaded plugin %o from %o.", name2, dirname4);
      return {
        filepath,
        value: value2
      };
    }
    function* loadPreset(name2, dirname4) {
      const {
        filepath,
        loader
      } = resolvePreset(name2, dirname4, yield* (0, _async.isAsync)());
      const value2 = yield* requireModule("preset", loader, filepath);
      debug2("Loaded preset %o from %o.", name2, dirname4);
      return {
        filepath,
        value: value2
      };
    }
    function standardizeName(type, name2) {
      if (_path2().isAbsolute(name2)) return name2;
      const isPreset = type === "preset";
      return name2.replace(isPreset ? BABEL_PRESET_PREFIX_RE : BABEL_PLUGIN_PREFIX_RE, `babel-${type}-`).replace(isPreset ? BABEL_PRESET_ORG_RE : BABEL_PLUGIN_ORG_RE, `$1${type}-`).replace(isPreset ? OTHER_PRESET_ORG_RE : OTHER_PLUGIN_ORG_RE, `$1babel-${type}-`).replace(OTHER_ORG_DEFAULT_RE, `$1/babel-${type}`).replace(EXACT_RE, "");
    }
    function* resolveAlternativesHelper(type, name2) {
      const standardizedName = standardizeName(type, name2);
      const {
        error,
        value: value2
      } = yield standardizedName;
      if (!error) return value2;
      if (error.code !== "MODULE_NOT_FOUND") throw error;
      if (standardizedName !== name2 && !(yield name2).error) {
        error.message += `
- If you want to resolve "${name2}", use "module:${name2}"`;
      }
      if (!(yield standardizeName(type, "@babel/" + name2)).error) {
        error.message += `
- Did you mean "@babel/${name2}"?`;
      }
      const oppositeType = type === "preset" ? "plugin" : "preset";
      if (!(yield standardizeName(oppositeType, name2)).error) {
        error.message += `
- Did you accidentally pass a ${oppositeType} as a ${type}?`;
      }
      if (type === "plugin") {
        const transformName = standardizedName.replace("-proposal-", "-transform-");
        if (transformName !== standardizedName && !(yield transformName).error) {
          error.message += `
- Did you mean "${transformName}"?`;
        }
      }
      error.message += `

Make sure that all the Babel plugins and presets you are using
are defined as dependencies or devDependencies in your package.json
file. It's possible that the missing plugin is loaded by a preset
you are using that forgot to add the plugin to its dependencies: you
can workaround this problem by explicitly adding the missing package
to your top-level package.json.
`;
      throw error;
    }
    function tryRequireResolve(id3, dirname4) {
      try {
        if (dirname4) {
          return {
            error: null,
            value: (((v, w) => (v = v.split("."), w = w.split("."), +v[0] > +w[0] || v[0] == w[0] && +v[1] >= +w[1]))(process.versions.node, "8.9") ? __require.resolve : (r, {
              paths: [b]
            }, M = __require("module")) => {
              let f = M._findPath(r, M._nodeModulePaths(b).concat(b));
              if (f) return f;
              f = new Error(`Cannot resolve module '${r}'`);
              f.code = "MODULE_NOT_FOUND";
              throw f;
            })(id3, {
              paths: [dirname4]
            })
          };
        } else {
          return {
            error: null,
            value: __require.resolve(id3)
          };
        }
      } catch (error) {
        return {
          error,
          value: null
        };
      }
    }
    function tryImportMetaResolve(id3, options2) {
      try {
        return {
          error: null,
          value: (0, _importMetaResolve.resolve)(id3, options2)
        };
      } catch (error) {
        return {
          error,
          value: null
        };
      }
    }
    function resolveStandardizedNameForRequire(type, name2, dirname4) {
      const it = resolveAlternativesHelper(type, name2);
      let res = it.next();
      while (!res.done) {
        res = it.next(tryRequireResolve(res.value, dirname4));
      }
      return {
        loader: "require",
        filepath: res.value
      };
    }
    function resolveStandardizedNameForImport(type, name2, dirname4) {
      const parentUrl = (0, _url().pathToFileURL)(_path2().join(dirname4, "./babel-virtual-resolve-base.js")).href;
      const it = resolveAlternativesHelper(type, name2);
      let res = it.next();
      while (!res.done) {
        res = it.next(tryImportMetaResolve(res.value, parentUrl));
      }
      return {
        loader: "auto",
        filepath: (0, _url().fileURLToPath)(res.value)
      };
    }
    function resolveStandardizedName(type, name2, dirname4, allowAsync) {
      if (!_moduleTypes.supportsESM || !allowAsync) {
        return resolveStandardizedNameForRequire(type, name2, dirname4);
      }
      try {
        const resolved = resolveStandardizedNameForImport(type, name2, dirname4);
        if (!(0, _fs3().existsSync)(resolved.filepath)) {
          throw Object.assign(new Error(`Could not resolve "${name2}" in file ${dirname4}.`), {
            type: "MODULE_NOT_FOUND"
          });
        }
        return resolved;
      } catch (e) {
        try {
          return resolveStandardizedNameForRequire(type, name2, dirname4);
        } catch (e2) {
          if (e.type === "MODULE_NOT_FOUND") throw e;
          if (e2.type === "MODULE_NOT_FOUND") throw e2;
          throw e;
        }
      }
    }
    {
      LOADING_MODULES = /* @__PURE__ */ new Set();
    }
    var LOADING_MODULES;
    function* requireModule(type, loader, name2) {
      {
        if (!(yield* (0, _async.isAsync)()) && LOADING_MODULES.has(name2)) {
          throw new Error(`Reentrant ${type} detected trying to load "${name2}". This module is not ignored and is trying to load itself while compiling itself, leading to a dependency cycle. We recommend adding it to your "ignore" list in your babelrc, or to a .babelignore.`);
        }
      }
      try {
        {
          LOADING_MODULES.add(name2);
        }
        {
          return yield* (0, _moduleTypes.default)(name2, loader, `You appear to be using a native ECMAScript module ${type}, which is only supported when running Babel asynchronously or when using the Node.js \`--experimental-require-module\` flag.`, `You appear to be using a ${type} that contains top-level await, which is only supported when running Babel asynchronously.`, true);
        }
      } catch (err) {
        err.message = `[BABEL]: ${err.message} (While processing: ${name2})`;
        throw err;
      } finally {
        {
          LOADING_MODULES.delete(name2);
        }
      }
    }
  }
});

// node_modules/@babel/core/lib/config/files/index.js
var require_files = __commonJS({
  "node_modules/@babel/core/lib/config/files/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ROOT_CONFIG_FILENAMES", {
      enumerable: true,
      get: function() {
        return _configuration.ROOT_CONFIG_FILENAMES;
      }
    });
    Object.defineProperty(exports2, "findConfigUpwards", {
      enumerable: true,
      get: function() {
        return _configuration.findConfigUpwards;
      }
    });
    Object.defineProperty(exports2, "findPackageData", {
      enumerable: true,
      get: function() {
        return _package.findPackageData;
      }
    });
    Object.defineProperty(exports2, "findRelativeConfig", {
      enumerable: true,
      get: function() {
        return _configuration.findRelativeConfig;
      }
    });
    Object.defineProperty(exports2, "findRootConfig", {
      enumerable: true,
      get: function() {
        return _configuration.findRootConfig;
      }
    });
    Object.defineProperty(exports2, "loadConfig", {
      enumerable: true,
      get: function() {
        return _configuration.loadConfig;
      }
    });
    Object.defineProperty(exports2, "loadPlugin", {
      enumerable: true,
      get: function() {
        return _plugins.loadPlugin;
      }
    });
    Object.defineProperty(exports2, "loadPreset", {
      enumerable: true,
      get: function() {
        return _plugins.loadPreset;
      }
    });
    Object.defineProperty(exports2, "resolvePlugin", {
      enumerable: true,
      get: function() {
        return _plugins.resolvePlugin;
      }
    });
    Object.defineProperty(exports2, "resolvePreset", {
      enumerable: true,
      get: function() {
        return _plugins.resolvePreset;
      }
    });
    Object.defineProperty(exports2, "resolveShowConfigPath", {
      enumerable: true,
      get: function() {
        return _configuration.resolveShowConfigPath;
      }
    });
    var _package = require_package();
    var _configuration = require_configuration();
    var _plugins = require_plugins4();
  }
});

// node_modules/@babel/core/lib/transform.js
var require_transform = __commonJS({
  "node_modules/@babel/core/lib/transform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.transform = void 0;
    exports2.transformAsync = transformAsync;
    exports2.transformSync = transformSync;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _index = require_config();
    var _index2 = require_transformation();
    var _rewriteStackTrace = require_rewrite_stack_trace();
    var transformRunner = _gensync()(function* transform4(code, opts) {
      const config2 = yield* (0, _index.default)(opts);
      if (config2 === null) return null;
      return yield* (0, _index2.run)(config2, code);
    });
    var transform3 = exports2.transform = function transform4(code, optsOrCallback, maybeCallback) {
      let opts;
      let callback;
      if (typeof optsOrCallback === "function") {
        callback = optsOrCallback;
        opts = void 0;
      } else {
        opts = optsOrCallback;
        callback = maybeCallback;
      }
      if (callback === void 0) {
        {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(code, opts);
        }
      }
      (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.errback)(code, opts, callback);
    };
    function transformSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.sync)(...args);
    }
    function transformAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformRunner.async)(...args);
    }
  }
});

// node_modules/@babel/core/lib/transform-ast.js
var require_transform_ast = __commonJS({
  "node_modules/@babel/core/lib/transform-ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.transformFromAst = void 0;
    exports2.transformFromAstAsync = transformFromAstAsync;
    exports2.transformFromAstSync = transformFromAstSync;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _index = require_config();
    var _index2 = require_transformation();
    var _rewriteStackTrace = require_rewrite_stack_trace();
    var transformFromAstRunner = _gensync()(function* (ast, code, opts) {
      const config2 = yield* (0, _index.default)(opts);
      if (config2 === null) return null;
      if (!ast) throw new Error("No AST given");
      return yield* (0, _index2.run)(config2, code, ast);
    });
    var transformFromAst = exports2.transformFromAst = function transformFromAst2(ast, code, optsOrCallback, maybeCallback) {
      let opts;
      let callback;
      if (typeof optsOrCallback === "function") {
        callback = optsOrCallback;
        opts = void 0;
      } else {
        opts = optsOrCallback;
        callback = maybeCallback;
      }
      if (callback === void 0) {
        {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(ast, code, opts);
        }
      }
      (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.errback)(ast, code, opts, callback);
    };
    function transformFromAstSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.sync)(...args);
    }
    function transformFromAstAsync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(transformFromAstRunner.async)(...args);
    }
  }
});

// node_modules/@babel/core/lib/parse.js
var require_parse5 = __commonJS({
  "node_modules/@babel/core/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parse = void 0;
    exports2.parseAsync = parseAsync2;
    exports2.parseSync = parseSync;
    function _gensync() {
      const data = require_gensync();
      _gensync = function() {
        return data;
      };
      return data;
    }
    var _index = require_config();
    var _index2 = require_parser2();
    var _normalizeOpts = require_normalize_opts();
    var _rewriteStackTrace = require_rewrite_stack_trace();
    var parseRunner = _gensync()(function* parse7(code, opts) {
      const config2 = yield* (0, _index.default)(opts);
      if (config2 === null) {
        return null;
      }
      return yield* (0, _index2.default)(config2.passes, (0, _normalizeOpts.default)(config2), code);
    });
    var parse6 = exports2.parse = function parse7(code, opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = void 0;
      }
      if (callback === void 0) {
        {
          return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(code, opts);
        }
      }
      (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.errback)(code, opts, callback);
    };
    function parseSync(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.sync)(...args);
    }
    function parseAsync2(...args) {
      return (0, _rewriteStackTrace.beginHiddenCallStack)(parseRunner.async)(...args);
    }
  }
});

// node_modules/@babel/core/lib/index.js
var require_lib15 = __commonJS({
  "node_modules/@babel/core/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DEFAULT_EXTENSIONS = void 0;
    Object.defineProperty(exports2, "File", {
      enumerable: true,
      get: function() {
        return _file.default;
      }
    });
    Object.defineProperty(exports2, "buildExternalHelpers", {
      enumerable: true,
      get: function() {
        return _buildExternalHelpers.default;
      }
    });
    Object.defineProperty(exports2, "createConfigItem", {
      enumerable: true,
      get: function() {
        return _index2.createConfigItem;
      }
    });
    Object.defineProperty(exports2, "createConfigItemAsync", {
      enumerable: true,
      get: function() {
        return _index2.createConfigItemAsync;
      }
    });
    Object.defineProperty(exports2, "createConfigItemSync", {
      enumerable: true,
      get: function() {
        return _index2.createConfigItemSync;
      }
    });
    Object.defineProperty(exports2, "getEnv", {
      enumerable: true,
      get: function() {
        return _environment.getEnv;
      }
    });
    Object.defineProperty(exports2, "loadOptions", {
      enumerable: true,
      get: function() {
        return _index2.loadOptions;
      }
    });
    Object.defineProperty(exports2, "loadOptionsAsync", {
      enumerable: true,
      get: function() {
        return _index2.loadOptionsAsync;
      }
    });
    Object.defineProperty(exports2, "loadOptionsSync", {
      enumerable: true,
      get: function() {
        return _index2.loadOptionsSync;
      }
    });
    Object.defineProperty(exports2, "loadPartialConfig", {
      enumerable: true,
      get: function() {
        return _index2.loadPartialConfig;
      }
    });
    Object.defineProperty(exports2, "loadPartialConfigAsync", {
      enumerable: true,
      get: function() {
        return _index2.loadPartialConfigAsync;
      }
    });
    Object.defineProperty(exports2, "loadPartialConfigSync", {
      enumerable: true,
      get: function() {
        return _index2.loadPartialConfigSync;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse.parse;
      }
    });
    Object.defineProperty(exports2, "parseAsync", {
      enumerable: true,
      get: function() {
        return _parse.parseAsync;
      }
    });
    Object.defineProperty(exports2, "parseSync", {
      enumerable: true,
      get: function() {
        return _parse.parseSync;
      }
    });
    exports2.resolvePreset = exports2.resolvePlugin = void 0;
    Object.defineProperty((0, exports2), "template", {
      enumerable: true,
      get: function() {
        return _template().default;
      }
    });
    Object.defineProperty((0, exports2), "tokTypes", {
      enumerable: true,
      get: function() {
        return _parser().tokTypes;
      }
    });
    Object.defineProperty(exports2, "transform", {
      enumerable: true,
      get: function() {
        return _transform.transform;
      }
    });
    Object.defineProperty(exports2, "transformAsync", {
      enumerable: true,
      get: function() {
        return _transform.transformAsync;
      }
    });
    Object.defineProperty(exports2, "transformFile", {
      enumerable: true,
      get: function() {
        return _transformFile.transformFile;
      }
    });
    Object.defineProperty(exports2, "transformFileAsync", {
      enumerable: true,
      get: function() {
        return _transformFile.transformFileAsync;
      }
    });
    Object.defineProperty(exports2, "transformFileSync", {
      enumerable: true,
      get: function() {
        return _transformFile.transformFileSync;
      }
    });
    Object.defineProperty(exports2, "transformFromAst", {
      enumerable: true,
      get: function() {
        return _transformAst.transformFromAst;
      }
    });
    Object.defineProperty(exports2, "transformFromAstAsync", {
      enumerable: true,
      get: function() {
        return _transformAst.transformFromAstAsync;
      }
    });
    Object.defineProperty(exports2, "transformFromAstSync", {
      enumerable: true,
      get: function() {
        return _transformAst.transformFromAstSync;
      }
    });
    Object.defineProperty(exports2, "transformSync", {
      enumerable: true,
      get: function() {
        return _transform.transformSync;
      }
    });
    Object.defineProperty((0, exports2), "traverse", {
      enumerable: true,
      get: function() {
        return _traverse().default;
      }
    });
    exports2.version = exports2.types = void 0;
    var _file = require_file();
    var _buildExternalHelpers = require_build_external_helpers();
    var resolvers = require_files();
    var _environment = require_environment();
    function _types2() {
      const data = require_lib3();
      _types2 = function() {
        return data;
      };
      return data;
    }
    Object.defineProperty((0, exports2), "types", {
      enumerable: true,
      get: function() {
        return _types2();
      }
    });
    function _parser() {
      const data = require_lib4();
      _parser = function() {
        return data;
      };
      return data;
    }
    function _traverse() {
      const data = require_lib9();
      _traverse = function() {
        return data;
      };
      return data;
    }
    function _template() {
      const data = require_lib6();
      _template = function() {
        return data;
      };
      return data;
    }
    var _index2 = require_config();
    var _transform = require_transform();
    var _transformFile = require_transform_file();
    var _transformAst = require_transform_ast();
    var _parse = require_parse5();
    var thisFile = require_lib15();
    var version4 = exports2.version = "7.26.0";
    var resolvePlugin = (name2, dirname4) => resolvers.resolvePlugin(name2, dirname4, false).filepath;
    exports2.resolvePlugin = resolvePlugin;
    var resolvePreset = (name2, dirname4) => resolvers.resolvePreset(name2, dirname4, false).filepath;
    exports2.resolvePreset = resolvePreset;
    var DEFAULT_EXTENSIONS2 = exports2.DEFAULT_EXTENSIONS = Object.freeze([".js", ".jsx", ".es6", ".es", ".mjs", ".cjs"]);
    {
      exports2.OptionManager = class OptionManager {
        init(opts) {
          return (0, _index2.loadOptionsSync)(opts);
        }
      };
      exports2.Plugin = function Plugin(alias) {
        throw new Error(`The (${alias}) Babel 5 plugin is being run with an unsupported Babel version.`);
      };
    }
  }
});

// server/index.ts
import express2 from "express";

// server/storage.ts
var MemStorage = class {
  users;
  contacts;
  currentUserId;
  currentContactId;
  constructor() {
    this.users = /* @__PURE__ */ new Map();
    this.contacts = /* @__PURE__ */ new Map();
    this.currentUserId = 1;
    this.currentContactId = 1;
  }
  async getUser(id3) {
    return this.users.get(id3);
  }
  async getUserByUsername(username) {
    return Array.from(this.users.values()).find(
      (user) => user.username === username
    );
  }
  async createUser(insertUser) {
    const id3 = this.currentUserId++;
    const user = { ...insertUser, id: id3 };
    this.users.set(id3, user);
    return user;
  }
  async createContactSubmission(insertContact) {
    const id3 = this.currentContactId++;
    const contact = {
      ...insertContact,
      interest: insertContact.interest || null,
      message: insertContact.message || null,
      id: id3,
      createdAt: /* @__PURE__ */ new Date()
    };
    this.contacts.set(id3, contact);
    return contact;
  }
  async getContactSubmissions() {
    return Array.from(this.contacts.values()).sort(
      (a, b) => b.createdAt.getTime() - a.createdAt.getTime()
    );
  }
};
var storage = new MemStorage();

// shared/schema.ts
import { pgTable, text, serial, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull()
});
var contactSubmissions = pgTable("contact_submissions", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  phone: text("phone").notNull(),
  email: text("email").notNull(),
  interest: text("interest"),
  message: text("message"),
  createdAt: timestamp("created_at").defaultNow().notNull()
});
var insertUserSchema = createInsertSchema(users).pick({
  username: true,
  password: true
});
var insertContactSchema = createInsertSchema(contactSubmissions).omit({
  id: true,
  createdAt: true
});

// server/routes.ts
import { z } from "zod";
function registerRoutes(app2) {
  app2.post("/api/contact", async (req2, res) => {
    try {
      const validatedData = insertContactSchema.parse(req2.body);
      const contact = await storage.createContactSubmission(validatedData);
      res.json({ success: true, message: "Thank you for your message! We will contact you soon.", contact });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({
          success: false,
          message: "Please fill in all required fields correctly.",
          errors: error.errors
        });
      } else {
        res.status(500).json({
          success: false,
          message: "Something went wrong. Please try again later."
        });
      }
    }
  });
  app2.get("/api/contacts", async (req2, res) => {
    try {
      const contacts = await storage.getContactSubmissions();
      res.json(contacts);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch contacts" });
    }
  });
}

// server/vite.ts
import express from "express";
import fs5 from "fs";
import { dirname as dirname3, resolve as resolve7 } from "path";
import { fileURLToPath as fileURLToPath4 } from "url";

// node_modules/vite/dist/node/index.js
init_parseAst2();
init_dep_C6uTJdX2();
init_dep_C6uTJdX2();
init_constants();
var import_esbuild2 = __toESM(require_main(), 1);

// node_modules/vite/dist/node/runtime.js
var SOURCEMAPPING_URL2 = "sourceMa";
SOURCEMAPPING_URL2 += "ppingURL";
var isWindows2 = typeof process < "u" && process.platform === "win32";
var AsyncFunction2 = async function() {
}.constructor;
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar2 = new Uint8Array(64);
var charToInt2 = new Uint8Array(128);
for (let i = 0; i < chars2.length; i++) {
  const c = chars2.charCodeAt(i);
  intToChar2[i] = c, charToInt2[c] = i;
}
var VITE_RUNTIME_SOURCEMAPPING_REGEXP = new RegExp(
  `//# ${SOURCEMAPPING_URL2}=data:application/json;base64,(.+)`
);
var retrieveFileHandlers = /* @__PURE__ */ new Set();
var retrieveSourceMapHandlers = /* @__PURE__ */ new Set();
var createExecHandlers = (handlers) => (...args) => {
  for (const handler of handlers) {
    const result = handler(...args);
    if (result) return result;
  }
  return null;
};
var retrieveFileFromHandlers = createExecHandlers(retrieveFileHandlers);
var retrieveSourceMapFromHandlers = createExecHandlers(
  retrieveSourceMapHandlers
);
var originalPrepare = Error.prepareStackTrace;

// node_modules/@vitejs/plugin-react/dist/index.mjs
import fs4 from "node:fs";
import path5 from "node:path";
import { createRequire as createRequire2 } from "node:module";
var runtimePublicPath = "/@react-refresh";
var _require2 = createRequire2(import.meta.url);
var reactRefreshDir = path5.dirname(
  _require2.resolve("react-refresh/package.json")
);
var runtimeFilePath = path5.join(
  reactRefreshDir,
  "cjs/react-refresh-runtime.development.js"
);
var runtimeCode = `
const exports = {}
${fs4.readFileSync(runtimeFilePath, "utf-8")}
${fs4.readFileSync(_require2.resolve("./refreshUtils.js"), "utf-8")}
export default exports
`;
var preambleCode = `
import RefreshRuntime from "__BASE__${runtimePublicPath.slice(1)}"
RefreshRuntime.injectIntoGlobalHook(window)
window.$RefreshReg$ = () => {}
window.$RefreshSig$ = () => (type) => type
window.__vite_plugin_react_preamble_installed__ = true
`;
var sharedHeader = `
import RefreshRuntime from "${runtimePublicPath}";

const inWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope;
`.replace(/\n+/g, "");
var functionHeader = `
let prevRefreshReg;
let prevRefreshSig;

if (import.meta.hot && !inWebWorker) {
  if (!window.__vite_plugin_react_preamble_installed__) {
    throw new Error(
      "@vitejs/plugin-react can't detect preamble. Something is wrong. " +
      "See https://github.com/vitejs/vite-plugin-react/pull/11#discussion_r430879201"
    );
  }

  prevRefreshReg = window.$RefreshReg$;
  prevRefreshSig = window.$RefreshSig$;
  window.$RefreshReg$ = (type, id) => {
    RefreshRuntime.register(type, __SOURCE__ + " " + id)
  };
  window.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
}`.replace(/\n+/g, "");
var functionFooter = `
if (import.meta.hot && !inWebWorker) {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}`;
var sharedFooter = (id3) => `
if (import.meta.hot && !inWebWorker) {
  RefreshRuntime.__hmr_import(import.meta.url).then((currentExports) => {
    RefreshRuntime.registerExportsForReactRefresh(${JSON.stringify(
  id3
)}, currentExports);
    import.meta.hot.accept((nextExports) => {
      if (!nextExports) return;
      const invalidateMessage = RefreshRuntime.validateRefreshBoundaryAndEnqueueUpdate(${JSON.stringify(
  id3
)}, currentExports, nextExports);
      if (invalidateMessage) import.meta.hot.invalidate(invalidateMessage);
    });
  });
}`;
function addRefreshWrapper(code, id3) {
  return sharedHeader + functionHeader.replace("__SOURCE__", JSON.stringify(id3)) + code + functionFooter + sharedFooter(id3);
}
function addClassComponentRefreshWrapper(code, id3) {
  return sharedHeader + code + sharedFooter(id3);
}
var babel;
async function loadBabel() {
  if (!babel) {
    babel = await Promise.resolve().then(() => __toESM(require_lib15(), 1));
  }
  return babel;
}
var reactCompRE = /extends\s+(?:React\.)?(?:Pure)?Component/;
var refreshContentRE = /\$Refresh(?:Reg|Sig)\$\(/;
var defaultIncludeRE = /\.[tj]sx?$/;
var tsRE = /\.tsx?$/;
function viteReact(opts = {}) {
  let devBase = "/";
  const filter2 = createFilter2(opts.include ?? defaultIncludeRE, opts.exclude);
  const jsxImportSource = opts.jsxImportSource ?? "react";
  const jsxImportRuntime = `${jsxImportSource}/jsx-runtime`;
  const jsxImportDevRuntime = `${jsxImportSource}/jsx-dev-runtime`;
  let isProduction = true;
  let projectRoot = process.cwd();
  let skipFastRefresh = false;
  let runPluginOverrides;
  let staticBabelOptions;
  const importReactRE = /\bimport\s+(?:\*\s+as\s+)?React\b/;
  const viteBabel = {
    name: "vite:react-babel",
    enforce: "pre",
    config() {
      if (opts.jsxRuntime === "classic") {
        return {
          esbuild: {
            jsx: "transform"
          }
        };
      } else {
        return {
          esbuild: {
            jsx: "automatic",
            jsxImportSource: opts.jsxImportSource
          },
          optimizeDeps: { esbuildOptions: { jsx: "automatic" } }
        };
      }
    },
    configResolved(config2) {
      devBase = config2.base;
      projectRoot = config2.root;
      isProduction = config2.isProduction;
      skipFastRefresh = isProduction || config2.command === "build" || config2.server.hmr === false;
      if ("jsxPure" in opts) {
        config2.logger.warnOnce(
          "[@vitejs/plugin-react] jsxPure was removed. You can configure esbuild.jsxSideEffects directly."
        );
      }
      const hooks = config2.plugins.map((plugin3) => plugin3.api?.reactBabel).filter(defined);
      if (hooks.length > 0) {
        runPluginOverrides = (babelOptions, context) => {
          hooks.forEach((hook) => hook(babelOptions, context, config2));
        };
      } else if (typeof opts.babel !== "function") {
        staticBabelOptions = createBabelOptions(opts.babel);
      }
    },
    async transform(code, id3, options2) {
      if (id3.includes("/node_modules/"))
        return;
      const [filepath] = id3.split("?");
      if (!filter2(filepath))
        return;
      const ssr = options2?.ssr === true;
      const babelOptions = (() => {
        if (staticBabelOptions)
          return staticBabelOptions;
        const newBabelOptions = createBabelOptions(
          typeof opts.babel === "function" ? opts.babel(id3, { ssr }) : opts.babel
        );
        runPluginOverrides?.(newBabelOptions, { id: id3, ssr });
        return newBabelOptions;
      })();
      const plugins2 = [...babelOptions.plugins];
      const isJSX = filepath.endsWith("x");
      const useFastRefresh = !skipFastRefresh && !ssr && (isJSX || (opts.jsxRuntime === "classic" ? importReactRE.test(code) : code.includes(jsxImportDevRuntime) || code.includes(jsxImportRuntime)));
      if (useFastRefresh) {
        plugins2.push([
          await loadPlugin("react-refresh/babel"),
          { skipEnvCheck: true }
        ]);
      }
      if (opts.jsxRuntime === "classic" && isJSX) {
        if (!isProduction) {
          plugins2.push(
            await loadPlugin("@babel/plugin-transform-react-jsx-self"),
            await loadPlugin("@babel/plugin-transform-react-jsx-source")
          );
        }
      }
      if (!plugins2.length && !babelOptions.presets.length && !babelOptions.configFile && !babelOptions.babelrc) {
        return;
      }
      const parserPlugins = [...babelOptions.parserOpts.plugins];
      if (!filepath.endsWith(".ts")) {
        parserPlugins.push("jsx");
      }
      if (tsRE.test(filepath)) {
        parserPlugins.push("typescript");
      }
      const babel2 = await loadBabel();
      const result = await babel2.transformAsync(code, {
        ...babelOptions,
        root: projectRoot,
        filename: id3,
        sourceFileName: filepath,
        // Required for esbuild.jsxDev to provide correct line numbers
        // This crates issues the react compiler because the re-order is too important
        // People should use @babel/plugin-transform-react-jsx-development to get back good line numbers
        retainLines: getReactCompilerPlugin(plugins2) != null ? false : !isProduction && isJSX && opts.jsxRuntime !== "classic",
        parserOpts: {
          ...babelOptions.parserOpts,
          sourceType: "module",
          allowAwaitOutsideFunction: true,
          plugins: parserPlugins
        },
        generatorOpts: {
          ...babelOptions.generatorOpts,
          decoratorsBeforeExport: true
        },
        plugins: plugins2,
        sourceMaps: true
      });
      if (result) {
        let code2 = result.code;
        if (useFastRefresh) {
          if (refreshContentRE.test(code2)) {
            code2 = addRefreshWrapper(code2, id3);
          } else if (reactCompRE.test(code2)) {
            code2 = addClassComponentRefreshWrapper(code2, id3);
          }
        }
        return { code: code2, map: result.map };
      }
    }
  };
  const dependencies = [
    "react",
    "react-dom",
    jsxImportDevRuntime,
    jsxImportRuntime
  ];
  const staticBabelPlugins = typeof opts.babel === "object" ? opts.babel?.plugins ?? [] : [];
  const reactCompilerPlugin = getReactCompilerPlugin(staticBabelPlugins);
  if (reactCompilerPlugin != null) {
    const reactCompilerRuntimeModule = getReactCompilerRuntimeModule(reactCompilerPlugin);
    dependencies.push(reactCompilerRuntimeModule);
  }
  const viteReactRefresh = {
    name: "vite:react-refresh",
    enforce: "pre",
    config: (userConfig) => ({
      build: silenceUseClientWarning(userConfig),
      optimizeDeps: {
        include: dependencies
      },
      resolve: {
        dedupe: ["react", "react-dom"]
      }
    }),
    resolveId(id3) {
      if (id3 === runtimePublicPath) {
        return id3;
      }
    },
    load(id3) {
      if (id3 === runtimePublicPath) {
        return runtimeCode;
      }
    },
    transformIndexHtml() {
      if (!skipFastRefresh)
        return [
          {
            tag: "script",
            attrs: { type: "module" },
            children: preambleCode.replace(`__BASE__`, devBase)
          }
        ];
    }
  };
  return [viteBabel, viteReactRefresh];
}
viteReact.preambleCode = preambleCode;
var silenceUseClientWarning = (userConfig) => ({
  rollupOptions: {
    onwarn(warning, defaultHandler) {
      if (warning.code === "MODULE_LEVEL_DIRECTIVE" && warning.message.includes("use client")) {
        return;
      }
      if (warning.code === "SOURCEMAP_ERROR" && warning.message.includes("resolve original location") && warning.pos === 0) {
        return;
      }
      if (userConfig.build?.rollupOptions?.onwarn) {
        userConfig.build.rollupOptions.onwarn(warning, defaultHandler);
      } else {
        defaultHandler(warning);
      }
    }
  }
});
var loadedPlugin = /* @__PURE__ */ new Map();
function loadPlugin(path9) {
  const cached = loadedPlugin.get(path9);
  if (cached)
    return cached;
  const promise2 = import(path9).then((module) => {
    const value2 = module.default || module;
    loadedPlugin.set(path9, value2);
    return value2;
  });
  loadedPlugin.set(path9, promise2);
  return promise2;
}
function createBabelOptions(rawOptions) {
  var _a;
  const babelOptions = {
    babelrc: false,
    configFile: false,
    ...rawOptions
  };
  babelOptions.plugins || (babelOptions.plugins = []);
  babelOptions.presets || (babelOptions.presets = []);
  babelOptions.overrides || (babelOptions.overrides = []);
  babelOptions.parserOpts || (babelOptions.parserOpts = {});
  (_a = babelOptions.parserOpts).plugins || (_a.plugins = []);
  return babelOptions;
}
function defined(value2) {
  return value2 !== void 0;
}
function getReactCompilerPlugin(plugins2) {
  return plugins2.find(
    (p) => p === "babel-plugin-react-compiler" || Array.isArray(p) && p[0] === "babel-plugin-react-compiler"
  );
}
function getReactCompilerRuntimeModule(plugin3) {
  let moduleName = "react/compiler-runtime";
  if (Array.isArray(plugin3)) {
    if (plugin3[1]?.target === "17" || plugin3[1]?.target === "18") {
      moduleName = "react-compiler-runtime";
    } else if (typeof plugin3[1]?.runtimeModule === "string") {
      moduleName = plugin3[1]?.runtimeModule;
    }
  }
  return moduleName;
}

// vite.config.ts
import { dirname as dirname2, resolve as resolve6 } from "path";

// node_modules/@replit/vite-plugin-runtime-error-modal/dist/index.mjs
import { readFileSync as readFileSync3 } from "node:fs";

// node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma4 = ",".charCodeAt(0);
var semicolon3 = ";".charCodeAt(0);
var chars3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar3 = new Uint8Array(64);
var charToInt3 = new Uint8Array(128);
for (let i = 0; i < chars3.length; i++) {
  const c = chars3.charCodeAt(i);
  intToChar3[i] = c;
  charToInt3[c] = i;
}
function decodeInteger(reader2, relative2) {
  let value2 = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = reader2.next();
    integer = charToInt3[c];
    value2 |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value2 & 1;
  value2 >>>= 1;
  if (shouldNegate) {
    value2 = -2147483648 | -value2;
  }
  return relative2 + value2;
}
function hasMoreVlq(reader2, max) {
  if (reader2.pos >= max)
    return false;
  return reader2.peek() !== comma4;
}
var bufLength2 = 1024 * 16;
var StringReader = class {
  constructor(buffer) {
    this.pos = 0;
    this.buffer = buffer;
  }
  next() {
    return this.buffer.charCodeAt(this.pos++);
  }
  peek() {
    return this.buffer.charCodeAt(this.pos);
  }
  indexOf(char) {
    const { buffer, pos } = this;
    const idx = buffer.indexOf(char, pos);
    return idx === -1 ? buffer.length : idx;
  }
};
function decode(mappings) {
  const { length } = mappings;
  const reader2 = new StringReader(mappings);
  const decoded = [];
  let genColumn = 0;
  let sourcesIndex = 0;
  let sourceLine = 0;
  let sourceColumn = 0;
  let namesIndex = 0;
  do {
    const semi = reader2.indexOf(";");
    const line = [];
    let sorted = true;
    let lastCol = 0;
    genColumn = 0;
    while (reader2.pos < semi) {
      let seg;
      genColumn = decodeInteger(reader2, genColumn);
      if (genColumn < lastCol)
        sorted = false;
      lastCol = genColumn;
      if (hasMoreVlq(reader2, semi)) {
        sourcesIndex = decodeInteger(reader2, sourcesIndex);
        sourceLine = decodeInteger(reader2, sourceLine);
        sourceColumn = decodeInteger(reader2, sourceColumn);
        if (hasMoreVlq(reader2, semi)) {
          namesIndex = decodeInteger(reader2, namesIndex);
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];
        } else {
          seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];
        }
      } else {
        seg = [genColumn];
      }
      line.push(seg);
      reader2.pos++;
    }
    if (!sorted)
      sort(line);
    decoded.push(line);
    reader2.pos = semi + 1;
  } while (reader2.pos <= length);
  return decoded;
}
function sort(line) {
  line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[0] - b[0];
}

// node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/;
var fileRegex = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith("//");
}
function isAbsolutePath(input) {
  return input.startsWith("/");
}
function isFileUrl(input) {
  return input.startsWith("file:");
}
function isRelative(input) {
  return /^[.?#]/.test(input);
}
function parseAbsoluteUrl(input) {
  const match2 = urlRegex.exec(input);
  return makeUrl(match2[1], match2[2] || "", match2[3], match2[4] || "", match2[5] || "/", match2[6] || "", match2[7] || "");
}
function parseFileUrl(input) {
  const match2 = fileRegex.exec(input);
  const path9 = match2[2];
  return makeUrl("file:", "", match2[1] || "", "", isAbsolutePath(path9) ? path9 : "/" + path9, match2[3] || "", match2[4] || "");
}
function makeUrl(scheme, user, host, port, path9, query, hash3) {
  return {
    scheme,
    user,
    host,
    port,
    path: path9,
    query,
    hash: hash3,
    type: 7
  };
}
function parseUrl2(input) {
  if (isSchemeRelativeUrl(input)) {
    const url3 = parseAbsoluteUrl("http:" + input);
    url3.scheme = "";
    url3.type = 6;
    return url3;
  }
  if (isAbsolutePath(input)) {
    const url3 = parseAbsoluteUrl("http://foo.com" + input);
    url3.scheme = "";
    url3.host = "";
    url3.type = 5;
    return url3;
  }
  if (isFileUrl(input))
    return parseFileUrl(input);
  if (isAbsoluteUrl(input))
    return parseAbsoluteUrl(input);
  const url2 = parseAbsoluteUrl("http://foo.com/" + input);
  url2.scheme = "";
  url2.host = "";
  url2.type = input ? input.startsWith("?") ? 3 : input.startsWith("#") ? 2 : 4 : 1;
  return url2;
}
function stripPathFilename(path9) {
  if (path9.endsWith("/.."))
    return path9;
  const index4 = path9.lastIndexOf("/");
  return path9.slice(0, index4 + 1);
}
function mergePaths(url2, base) {
  normalizePath3(base, base.type);
  if (url2.path === "/") {
    url2.path = base.path;
  } else {
    url2.path = stripPathFilename(base.path) + url2.path;
  }
}
function normalizePath3(url2, type) {
  const rel = type <= 4;
  const pieces = url2.path.split("/");
  let pointer = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i = 1; i < pieces.length; i++) {
    const piece = pieces[i];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (rel) {
        pieces[pointer++] = piece;
      }
      continue;
    }
    pieces[pointer++] = piece;
    positive++;
  }
  let path9 = "";
  for (let i = 1; i < pointer; i++) {
    path9 += "/" + pieces[i];
  }
  if (!path9 || addTrailingSlash && !path9.endsWith("/..")) {
    path9 += "/";
  }
  url2.path = path9;
}
function resolve4(input, base) {
  if (!input && !base)
    return "";
  const url2 = parseUrl2(input);
  let inputType = url2.type;
  if (base && inputType !== 7) {
    const baseUrl = parseUrl2(base);
    const baseType = baseUrl.type;
    switch (inputType) {
      case 1:
        url2.hash = baseUrl.hash;
      // fall through
      case 2:
        url2.query = baseUrl.query;
      // fall through
      case 3:
      case 4:
        mergePaths(url2, baseUrl);
      // fall through
      case 5:
        url2.user = baseUrl.user;
        url2.host = baseUrl.host;
        url2.port = baseUrl.port;
      // fall through
      case 6:
        url2.scheme = baseUrl.scheme;
    }
    if (baseType > inputType)
      inputType = baseType;
  }
  normalizePath3(url2, inputType);
  const queryHash = url2.query + url2.hash;
  switch (inputType) {
    // This is impossible, because of the empty checks at the start of the function.
    // case UrlType.Empty:
    case 2:
    case 3:
      return queryHash;
    case 4: {
      const path9 = url2.path.slice(1);
      if (!path9)
        return queryHash || ".";
      if (isRelative(base || input) && !isRelative(path9)) {
        return "./" + path9 + queryHash;
      }
      return path9 + queryHash;
    }
    case 5:
      return url2.path + queryHash;
    default:
      return url2.scheme + "//" + url2.user + url2.host + url2.port + url2.path + queryHash;
  }
}

// node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
function resolve5(input, base) {
  if (base && !base.endsWith("/"))
    base += "/";
  return resolve4(input, base);
}
function stripFilename(path9) {
  if (!path9)
    return "";
  const index4 = path9.lastIndexOf("/");
  return path9.slice(0, index4 + 1);
}
var COLUMN = 0;
var SOURCES_INDEX = 1;
var SOURCE_LINE = 2;
var SOURCE_COLUMN = 3;
var NAMES_INDEX = 4;
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length)
    return mappings;
  if (!owned)
    mappings = mappings.slice();
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i = start; i < mappings.length; i++) {
    if (!isSorted(mappings[i]))
      return i;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][COLUMN] < line[j - 1][COLUMN]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned)
    line = line.slice();
  return line.sort(sortComparator2);
}
function sortComparator2(a, b) {
  return a[COLUMN] - b[COLUMN];
}
var found = false;
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][COLUMN] - needle;
    if (cmp === 0) {
      found = true;
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  found = false;
  return low - 1;
}
function upperBound(haystack, needle, index4) {
  for (let i = index4 + 1; i < haystack.length; index4 = i++) {
    if (haystack[i][COLUMN] !== needle)
      break;
  }
  return index4;
}
function lowerBound(haystack, needle, index4) {
  for (let i = index4 - 1; i >= 0; index4 = i--) {
    if (haystack[i][COLUMN] !== needle)
      break;
  }
  return index4;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = lastIndex === -1 ? 0 : lastIndex;
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
var LINE_GTR_ZERO = "`line` must be greater than 0 (lines start at line 1)";
var COL_GTR_EQ_ZERO = "`column` must be greater than or equal to 0 (columns start at column 0)";
var LEAST_UPPER_BOUND = -1;
var GREATEST_LOWER_BOUND = 1;
var TraceMap = class {
  constructor(map, mapUrl) {
    const isString3 = typeof map === "string";
    if (!isString3 && map._decodedMemo)
      return map;
    const parsed = isString3 ? JSON.parse(map) : map;
    const { version: version4, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version4;
    this.file = file;
    this.names = names || [];
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || void 0;
    const from = resolve5(sourceRoot || "", stripFilename(mapUrl));
    this.resolvedSources = sources.map((s) => resolve5(s || "", from));
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = void 0;
    } else {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString3);
    }
    this._decodedMemo = memoizedState();
    this._bySources = void 0;
    this._bySourceMemos = void 0;
  }
};
function cast(map) {
  return map;
}
function decodedMappings(map) {
  var _a;
  return (_a = cast(map))._decoded || (_a._decoded = decode(cast(map)._encoded));
}
function originalPositionFor(map, needle) {
  let { line, column, bias } = needle;
  line--;
  if (line < 0)
    throw new Error(LINE_GTR_ZERO);
  if (column < 0)
    throw new Error(COL_GTR_EQ_ZERO);
  const decoded = decodedMappings(map);
  if (line >= decoded.length)
    return OMapping(null, null, null, null);
  const segments = decoded[line];
  const index4 = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);
  if (index4 === -1)
    return OMapping(null, null, null, null);
  const segment = segments[index4];
  if (segment.length === 1)
    return OMapping(null, null, null, null);
  const { names, resolvedSources } = map;
  return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);
}
function OMapping(source, line, column, name2) {
  return { source, line, column, name: name2 };
}
function traceSegmentInternal(segments, memo, line, column, bias) {
  let index4 = memoizedBinarySearch(segments, column, memo, line);
  if (found) {
    index4 = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index4);
  } else if (bias === LEAST_UPPER_BOUND)
    index4++;
  if (index4 === -1 || index4 === segments.length)
    return -1;
  return index4;
}

// node_modules/@replit/vite-plugin-runtime-error-modal/dist/index.mjs
var packageName = "runtime-error-plugin";
function viteRuntimeErrorOverlayPlugin(options2) {
  return {
    name: packageName,
    apply(config2, env2) {
      return env2.command === "serve" && !config2.ssr;
    },
    transformIndexHtml() {
      return [
        {
          tag: "script",
          attrs: { type: "module" },
          children: CLIENT_SCRIPT
        }
      ];
    },
    configureServer(server) {
      server.ws.on(MESSAGE_TYPE, (data, client) => {
        const error = Object.assign(new Error(), data);
        if (!error.stack) {
          return;
        }
        if (options2?.filter && !options2.filter(error)) {
          return;
        }
        const { stack, loc } = rewriteStacktrace(
          error.stack,
          server.moduleGraph
        );
        const err = {
          name: error.name,
          message: error.message,
          stack,
          loc,
          plugin: packageName
        };
        if (loc?.file) {
          err.id = loc?.file;
          const source = readFileSync3(loc.file, "utf-8");
          err.frame = generateCodeFrame(source, {
            line: loc.line,
            column: loc.column - 1
          });
        }
        client.send({
          type: "error",
          err
        });
      });
    }
  };
}
var MESSAGE_TYPE = `${packageName}:error`;
var CLIENT_SCRIPT = `
import { createHotContext } from "/@vite/client";
const hot = createHotContext("/__dummy__${packageName}");

function sendError(error) {
  if (!(error instanceof Error)) {
    error = new Error("(unknown runtime error)");
  }
  const serialized = {
    message: error.message,
    stack: error.stack,
  };
  hot.send("${MESSAGE_TYPE}", serialized);
}

window.addEventListener("error", (evt) => {
  sendError(evt.error);
});

window.addEventListener("unhandledrejection", (evt) => {
  sendError(evt.reason);
});
`;
function cleanStack(stack) {
  return stack.split(/\n/g).filter((l) => /^\s*at/.test(l)).join("\n");
}
function rewriteStacktrace(stack, moduleGraph) {
  let loc = void 0;
  const rewrittenStack = cleanStack(stack).split("\n").map((line) => {
    return line.replace(
      /^ {4}at (?:(\S+?) )?\(?(?:https|http):\/\/[^\/]+(\/[^\s?]+).*:(\d+):(\d+)\)?$/,
      (input, varName, url2, line2, column) => {
        if (!url2) {
          return input;
        }
        const module = moduleGraph.urlToModuleMap.get(url2);
        if (!module) {
          return "";
        }
        const rawSourceMap = module?.transformResult?.map;
        if (rawSourceMap) {
          const traced = new TraceMap(rawSourceMap);
          const pos = originalPositionFor(traced, {
            line: Number(line2),
            // stacktrace's column is 1-indexed, but sourcemap's one is 0-indexed
            column: Number(column) - 1
          });
          if (pos.source && pos.line >= 0 && pos.column >= 0) {
            line2 = pos.line;
            column = pos.column + 1;
          }
        }
        const trimmedVarName = varName?.trim();
        const sourceFile = module.file;
        const source = `${module.file}:${line2}:${column}`;
        if (sourceFile) {
          loc ??= {
            line: Number(line2),
            column: Number(column),
            file: sourceFile
          };
        }
        if (!trimmedVarName || trimmedVarName === "eval") {
          return `    at ${source}`;
        } else {
          return `    at ${trimmedVarName} ${source}`;
        }
      }
    );
  }).join("\n");
  return {
    stack: rewrittenStack,
    loc
  };
}
var splitRE = /\r?\n/g;
var range = 2;
function posToNumber(source, pos) {
  if (typeof pos === "number") {
    return pos;
  }
  const lines = source.split(splitRE);
  const { line, column } = pos;
  let start = 0;
  for (let i = 0; i < line - 1 && i < lines.length; i++) {
    start += lines[i].length + 1;
  }
  return start + column;
}
function generateCodeFrame(source, start = 0, end) {
  start = Math.max(posToNumber(source, start), 0);
  end = Math.min(
    end !== void 0 ? posToNumber(source, end) : start,
    source.length
  );
  const lines = source.split(splitRE);
  let count = 0;
  const res = [];
  for (let i = 0; i < lines.length; i++) {
    count += lines[i].length;
    if (count >= start) {
      for (let j = i - range; j <= i + range || end > count; j++) {
        if (j < 0 || j >= lines.length) {
          continue;
        }
        const line = j + 1;
        res.push(
          `${line}${" ".repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`
        );
        const lineLength = lines[j].length;
        if (j === i) {
          const pad2 = Math.max(start - (count - lineLength), 0);
          const length = Math.max(
            1,
            end > count ? lineLength - pad2 : end - start
          );
          res.push(`   |  ` + " ".repeat(pad2) + "^".repeat(length));
        } else if (j > i) {
          if (end > count) {
            const length = Math.max(Math.min(end - count, lineLength), 1);
            res.push(`   |  ` + "^".repeat(length));
          }
          count += lineLength + 1;
        }
      }
      break;
    }
    count++;
  }
  return res.join("\n");
}

// vite.config.ts
import { fileURLToPath as fileURLToPath3 } from "url";
var __filename6 = fileURLToPath3(import.meta.url);
var __dirname6 = dirname2(__filename6);
var vite_config_default = defineConfig({
  plugins: [
    viteReact(),
    viteRuntimeErrorOverlayPlugin()
    // The following is only for Replit, safe to remove/comment for Vercel
    // ...(process.env.NODE_ENV !== "production" &&
    // process.env.REPL_ID !== undefined
    //   ? [
    //       await import("@replit/vite-plugin-cartographer").then((m) =>
    //         m.cartographer(),
    //       ),
    //     ]
    //   : []),
  ],
  resolve: {
    alias: {
      "@": resolve6(__dirname6, "client", "src"),
      "@shared": resolve6(__dirname6, "shared"),
      "@assets": resolve6(__dirname6, "attached_assets")
    }
  },
  root: resolve6(__dirname6, "client"),
  build: {
    outDir: resolve6(__dirname6, "dist"),
    // CHANGED: from "dist/public" to "dist"
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
var __filename7 = fileURLToPath4(import.meta.url);
var __dirname7 = dirname3(__filename7);
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
function serveStatic(app2) {
  const distPath = resolve7(__dirname7, "..", "dist");
  if (!fs5.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(resolve7(distPath, "index.html"));
  });
}

// server/index.ts
import path8 from "path";
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req2, res, next) => {
  const start = Date.now();
  const path9 = req2.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path9.startsWith("/api")) {
      let logLine = `${req2.method} ${path9} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
registerRoutes(app);
app.get("/favicon.ico", (req2, res) => {
  const faviconPath = path8.resolve(process.cwd(), "dist", "favicon.ico");
  res.sendFile(faviconPath, (err) => {
    if (err) res.status(204).end();
  });
});
app.use((err, req2, res, next) => {
  const status2 = err.status || err.statusCode || 500;
  const message = err.message || "Internal Server Error";
  res.status(status2).json({ message });
});
serveStatic(app);
var index_default = app;
export {
  index_default as default
};
/*! Bundled license information:

rollup/dist/es/shared/parseAst.js:
  (*
    @license
  	Rollup.js v4.24.4
  	Mon, 04 Nov 2024 08:46:36 GMT - commit cdf34ab5411aac6ac3f6cd21b10d2e58427e88ec
  
  	https://github.com/rollup/rollup
  
  	Released under the MIT License.
  *)

rollup/dist/es/parseAst.js:
  (*
    @license
  	Rollup.js v4.24.4
  	Mon, 04 Nov 2024 08:46:36 GMT - commit cdf34ab5411aac6ac3f6cd21b10d2e58427e88ec
  
  	https://github.com/rollup/rollup
  
  	Released under the MIT License.
  *)

vite/dist/node/chunks/dep-CEGXe0Sr.js:
  (*! https://mths.be/cssesc v3.0.0 by @mathias *)

vite/dist/node/chunks/dep-C6uTJdX2.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
   * Autoload Config for PostCSS
   *
   * @author Michael Ciniawsky @michael-ciniawsky <michael.ciniawsky@gmail.com>
   * @license MIT
   *
   * @module postcss-load-config
   * @version 2.1.0
   *
   * @requires comsiconfig
   * @requires ./options
   * @requires ./plugins
   *)
  (*!
   * encodeurl
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)
  (*!
   * ee-first
   * Copyright(c) 2014 Jonathan Ong
   * MIT Licensed
   *)
  (*!
   * on-finished
   * Copyright(c) 2013 Jonathan Ong
   * Copyright(c) 2014 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * parseurl
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * statuses
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * unpipe
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * finalhandler
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * connect
   * Copyright(c) 2010 Sencha Inc.
   * Copyright(c) 2011 TJ Holowaychuk
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
  (*!
   * vary
   * Copyright(c) 2014-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)
  (*!
   * etag
   * Copyright(c) 2014-2016 Douglas Christopher Wilson
   * MIT Licensed
   *)
  (*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, res, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   *)
  (*!
   * Array of passes.
   *
   * A `pass` is just a function that is executed on `req, socket, options`
   * so that you can easily add new checks while still keeping the base
   * flexible.
   *)
  (*!
   * Caron dimonio, con occhi di bragia
   * loro accennando, tutte le raccoglie;
   * batte col remo qualunque s’adagia 
   *
   * Charon the demon, with the eyes of glede,
   * Beckoning to them, collects them all together,
   * Beats with his oar whoever lags behind
   *          
   *          Dante - The Divine Comedy (Canto III)
   *)
*/
